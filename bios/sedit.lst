1802 -> Native
2 Classes read.
186 Patterns read.
    1 0000:             ; *******************************************************************
    2 0000:             ; *** This software is copyright 2005 by Michael H Riley          ***
    3 0000:             ; *** You have permission to use, modify, copy, and distribute    ***
    4 0000:             ; *** this software so long as this copyright notice is retained. ***
    5 0000:             ; *** This software may not be used in commercial applications    ***
    6 0000:             ; *** without express written permission from the author.         ***
    7 0000:             ; *******************************************************************
    8 0000:             
            #ifdef STGROM
   10 0000:             include config.inc
   11 0000:             ; DO NOT EDIT THIS FILE - EDIT CONFIG. INSTEAD!!
            #define BOOTS	 08000H
            #define WARMB	 (08000H+3)
            #define HELP	 0A000H
            #define RAMPAGE	 07F00H
            #define BIOS	 0FF00H
            #define EBIOS	 0F800H
            #define VIDEO	 09800H
            #define INIT75	 (09800H)
            #define VTPUTC	 (09800H+3)
            #define SCREEN	 (07F00H-2048)
            #define PIXIE	                  
            #define SEDIT	 0A900H
            #define EDTASM	 0B000H
            #define BASIC	 0D000H
            #define VISUAL	 0BF00H
            #define XMODEM	 0AC00H
   28 0000:             	org	SEDIT
            #endif
   32 a900:             include    bios.inc
   33 a900:             ; *******************************************************************
   34 a900:             ; *** This software is copyright 2006 by Michael H Riley          ***
   35 a900:             ; *** You have permission to use, modify, copy, and distribute    ***
   36 a900:             ; *** this software so long as this copyright notice is retained. ***
   37 a900:             ; *** This software may not be used in commercial applications    ***
   38 a900:             ; *** without express written permission from the author.         ***
   39 a900:             ; *******************************************************************
   40 a900:             
            #endif
   44 a900:             
   45 a900:             ; Define address for standard BIOS vectors
            #endif
   49 a900:             
   50 a900:             ; Define address for extended BIOS vectors
            #endif
   54 a900:             
            #ifndef TASM
   56 a900:             scall:      equ  r4                    ; register for SCALL
   57 a900:             sret:       equ  r5                    ; register for SRET
   58 a900:             
   59 a900:             call:       equ  0ffe0h                ; depricated
   60 a900:             ret:        equ  0fff1h                ; depricated
            #endif
   62 a900:             
   63 a900:             f_boot:     equ  (BIOS+00h)            ; boot from ide device
   64 a900:             f_type:     equ  (BIOS+03h)            ; type 1 character to console
   65 a900:             f_read:     equ  (BIOS+06h)            ; read 1 character from console
   66 a900:             f_msg:      equ  (BIOS+09h)            ; type asciiz string to console
   67 a900:             f_typex:    equ  (BIOS+0ch)            ; depricated, just returns now
   68 a900:             f_input:    equ  (BIOS+0fh)            ; read asciiz from console
   69 a900:             f_strcmp:   equ  (BIOS+12h)            ; compare 2 strings
   70 a900:             f_ltrim:    equ  (BIOS+15h)            ; trim leading spaces
   71 a900:             f_strcpy:   equ  (BIOS+18h)            ; copy an asciiz string
   72 a900:             f_memcpy:   equ  (BIOS+1bh)            ; copy memory
   73 a900:             f_wrtsec:   equ  (BIOS+1eh)            ; write floppy sector (depricated)
   74 a900:             f_rdsec:    equ  (BIOS+21h)            ; read floppy sector (depricated)
   75 a900:             f_seek0:    equ  (BIOS+24h)            ; floppy seek to track 0 (depricated)
   76 a900:             f_seek:     equ  (BIOS+27h)            ; floopy track seek (depricated)
   77 a900:             f_drive:    equ  (BIOS+2ah)            ; select floppy drive (depricated)
   78 a900:             f_setbd:    equ  (BIOS+2dh)            ; set console baud rate
   79 a900:             f_mul16:    equ  (BIOS+30h)            ; 16-bit multiply
   80 a900:             f_div16:    equ  (BIOS+33h)            ; 16-bit division
   81 a900:             f_idereset: equ  (BIOS+36h)            ; reset ide device
   82 a900:             f_idewrite: equ  (BIOS+39h)            ; write ide sector
   83 a900:             f_ideread:  equ  (BIOS+3ch)            ; read ide sector
   84 a900:             f_initcall: equ  (BIOS+3fh)            ; initialize R4 and R5
   85 a900:             f_bootide:  equ  (BIOS+42h)            ; boot from ide device
   86 a900:             f_hexin:    equ  (BIOS+45h)            ; convert ascii number to hex
   87 a900:             f_hexout2:  equ  (BIOS+48h)            ; convert hex to 2-digit ascii
   88 a900:             f_hexout4:  equ  (BIOS+4bh)            ; convert hex to 4-digit ascii
   89 a900:             f_tty:      equ  (BIOS+4eh)            ; type character to console
   90 a900:             f_mover:    equ  (BIOS+51h)            ; program relocator
   91 a900:             f_minimon:  equ  (BIOS+54h)            ; mini monitor
   92 a900:             f_freemem:  equ  (BIOS+57h)            ; determine memory size
   93 a900:             F_isnum:    equ  (BIOS+5ah)            ; determine if D is numeric
   94 a900:             f_atoi:     equ  (BIOS+5dh)            ; convert ascii to integer
   95 a900:             f_uintout:  equ  (BIOS+60h)            ; convert unsigned integer to ascii
   96 a900:             f_intout:   equ  (BIOS+63h)            ; convert signed integer to ascii
   97 a900:             f_inmsg:    equ  (BIOS+66h)            ; type in-line message
   98 a900:             f_inputl:   equ  (BIOS+69h)            ; read limited line from console
   99 a900:             f_brktest:  equ  (BIOS+6ch)            ; check for serial break
  100 a900:             f_findtkn:  equ  (BIOS+6fh)            ; find token in a token table
  101 a900:             f_isalpha:  equ  (BIOS+72h)            ; determine if D is alphabetic
  102 a900:             f_ishex:    equ  (BIOS+75h)            ; determine if D is hexadecimal
  103 a900:             f_isalnum:  equ  (BIOS+78h)            ; determine if D is alpha or numeric
  104 a900:             f_idnum:    equ  (BIOS+7bh)            ; determine type of ascii number
  105 a900:             f_isterm:   equ  (BIOS+7eh)            ; determine if D is a termination char
  106 a900:             f_getdev:   equ  (BIOS+81h)            ; get supported devices
  107 a900:             
  108 a900:             f_version:  equ  (BIOS+0f9h)           ; 3 bytes holding bios version number
  109 a900:             
  110 a900:             ; "Extended" BIOS vectors
  111 a900:             
  112 a900:             f_bread     equ  (EBIOS+00h)        ; read from onboard serial port
  113 a900:             f_btype     equ  (EBIOS+03h)        ; write to onboard serial port
  114 a900:             f_btest     equ  (EBIOS+06h)        ; test onboard serial port
  115 a900:             f_utype     equ  (EBIOS+09h)        ; write to disk board UART
  116 a900:             f_uread     equ  (EBIOS+0ch)        ; read from disk board UART
  117 a900:             f_utest     equ  (EBIOS+0fh)        ; test disk board UART
  118 a900:             f_usetbd    equ  (EBIOS+12h)        ; set disk board UART baud rate and format
  119 a900:             f_gettod    equ  (EBIOS+15h)        ; read time of day clock
  120 a900:             f_settod    equ  (EBIOS+18h)        ; set time of day clock
  121 a900:             f_rdnvr     equ  (EBIOS+1bh)        ; read non volatile RAM
  122 a900:             f_wrnvr     equ  (EBIOS+1eh)        ; write non volatile RAM
  123 a900:             f_idesize   equ  (EBIOS+21h)        ; return size of attached IDE drive(s)
  124 a900:             f_ideid     equ  (EBIOS+24h)        ; return device data for IDE drive(s)
  125 a900:             f_tmtoas    equ  (EBIOS+2ah)        ; time to ASCII string
  126 a900:             f_dttoas    equ  (EBIOS+27h)        ; date to ASCII string
  127 a900:             f_rtctest   equ  (EBIOS+2dh)        ; test size and presence of RTC/NVR
  128 a900:             f_astodt    equ  (EBIOS+30h)        ; convert ASCII string to date
  129 a900:             f_astotm    equ  (EBIOS+33h)        ; convert ASCII string to time
  130 a900:             f_nvrcchk   equ  (EBIOS+36h)	    ; [RLA] compute NVR checksum
  131 a900:             
  132 a900:             
  133 a900:             
  134 a900:             
  135 a900:             ;           ldi     0
  136 a900:             ;           phi     r2
  137 a900:             ;           ldi     0ffh
  138 a900:             ;           plo     r2
  139 a900:             ;           sex     r2
  140 a900: f8 a9                  ldi     high start
  141 a902: b6                     phi     r6
  142 a903: f8 09                  ldi     low start
  143 a905: a6                     plo     r6
  144 a906: c0 ff 3f               lbr     f_initcall
  145 a909:             
  146 a909:             
  147 a909: f8 01       start:     ldi     high sector         ; point to base page
  148 a90b: bb                     phi     rb
  149 a90c: f8 00                  ldi     low sector          ; need to indicate invalid sector
  150 a90e: ab                     plo     rb
  151 a90f: f8 ff                  ldi     0ffh                ; indicate no sector loaded
  152 a911: 5b                     str     rb                  ; write to pointer
  153 a912: 1b                     inc     rb
  154 a913: 5b                     str     rb
  155 a914: f8 00                  ldi     0                   ; reset drive
  156 a916: ad                     plo     rd
  157 a917: d4                     sep     scall
  158 a918: ff 36                  dw      f_idereset
  159 a91a:             
  160 a91a:             
  161 a91a: f8 ab       mainlp:    ldi     high prompt         ; get address of prompt
  162 a91c: bf                     phi     rf
  163 a91d: f8 87                  ldi     low prompt
  164 a91f: af                     plo     rf
  165 a920: d4                     sep     scall               ; display prompt
  166 a921: ff 09                  dw      f_msg
  167 a923: d4                     sep     scall
  168 a924: ab 48                  dw      loadbuf
  169 a926: d4                     sep     scall               ; get input from user
  170 a927: ff 0f                  dw      f_input
  171 a929: d4                     sep     scall
  172 a92a: ab 4f                  dw      docrlf
  173 a92c: d4                     sep     scall
  174 a92d: ab 48                  dw      loadbuf
  175 a92f: 4f                     lda     rf                  ; get command byte
  176 a930: ae                     plo     re                  ; keep a copy
  177 a931: ff 4c                  smi     'L'                 ; check for display Low command
  178 a933: c2 a9 86               lbz     disp_lo             ; jump if so
  179 a936: 8e                     glo     re                  ; recover command
  180 a937: ff 48                  smi     'H'                 ; check for display high command
  181 a939: c2 a9 76               lbz     disp_hi             ; jump if so
  182 a93c: 8e                     glo     re                  ; recover command
  183 a93d: ff 52                  smi     'R'                 ; check for read sector command
  184 a93f: c2 aa 35               lbz     rd_sec              ; jump if so
  185 a942: 8e                     glo     re                  ; recover command
  186 a943: ff 4e                  smi     'N'                 ; check for next sector command
  187 a945: c2 aa a8               lbz     nxt_sec             ; jump if so
  188 a948: 8e                     glo     re                  ; recover command
  189 a949: ff 50                  smi     'P'                 ; check for previous sector command
  190 a94b: c2 aa b3               lbz     prv_sec             ; jump if so
  191 a94e: 8e                     glo     re                  ; recover command
  192 a94f: ff 44                  smi     'D'                 ; check for display current sector
  193 a951: c2 aa be               lbz     dsp_sec             ; jump if so
  194 a954: 8e                     glo     re                  ; recover command
  195 a955: ff 45                  smi     'E'                 ; check for enter bytes command
  196 a957: c2 aa e3               lbz     enter               ; jump if so
  197 a95a: 8e                     glo     re                  ; recover command
  198 a95b: ff 57                  smi     'W'                 ; check for write sector command
  199 a95d: c2 aa 59               lbz     write               ; jump if so
  200 a960: 8e                     glo     re                  ; recover command
  201 a961: ff 51                  smi     'Q'                 ; check for quit command
  202 a963: c2 a9 75               lbz     quit                ; jump if so
  203 a966: 8e                     glo     re                  ; recover command
  204 a967: ff 41                  smi     'A'                 ; check for read AU command
  205 a969: c2 aa 21               lbz     rd_au               ; jump if so
  206 a96c: 8e                     glo     re                  ; recover command
  207 a96d: ff 43                  smi     'C'                 ; check for read AU chain command
  208 a96f: c2 aa fe               lbz     chain               ; jump if so
  209 a972:             
  210 a972: c0 a9 1a               lbr     mainlp
  211 a975:             
  212 a975: d5          quit:      sep     sret                ; return to Elf/OS
  213 a976:             
  214 a976: f8 00       disp_hi:   ldi     0                   ; setup address
  215 a978: a9                     plo     r9
  216 a979: ac                     plo     rc                  ; setup counter
  217 a97a: f8 01                  ldi     1
  218 a97c: b9                     phi     r9
  219 a97d: f8 03                  ldi     high (secbuf+256)   ; point to sector buffer
  220 a97f: ba                     phi     ra
  221 a980: f8 a2                  ldi     low (secbuf+256)
  222 a982: aa                     plo     ra
  223 a983: c0 a9 91               lbr     disp_ct             ; process display
  224 a986: f8 00       disp_lo:   ldi     0                   ; setup address
  225 a988: b9                     phi     r9
  226 a989: a9                     plo     r9
  227 a98a: ac                     plo     rc                  ; setup counter
  228 a98b: f8 02                  ldi     high secbuf         ; point to sector buffer
  229 a98d: ba                     phi     ra
  230 a98e: f8 a2                  ldi     low secbuf
  231 a990: aa                     plo     ra
  232 a991: f8 02       disp_ct:   ldi     high outbuf         ; point to output buffer
  233 a993: bf                     phi     rf
  234 a994: f8 52                  ldi     low outbuf
  235 a996: af                     plo     rf
  236 a997: f8 02                  ldi     high ascbuf         ; point to ascii buffer
  237 a999: b7                     phi     r7
  238 a99a: f8 02                  ldi     low ascbuf
  239 a99c: a7                     plo     r7
  240 a99d: f8 00                  ldi     0                   ; initial line is empty
  241 a99f: 5f                     str     rf
  242 a9a0: 57                     str     r7
  243 a9a1: 8c          disp_lp:   glo     rc                  ; get count
  244 a9a2: fa 0f                  ani     0fh                 ; need to see if on 16 byte boundary
  245 a9a4: ca a9 e3               lbnz    disp_ln             ; jump to display line
  246 a9a7: f8 00                  ldi     0                   ; place terminator
  247 a9a9: 5f                     str     rf
  248 a9aa: 57                     str     r7
  249 a9ab: f8 02                  ldi     high outbuf         ; point to output buffer
  250 a9ad: bf                     phi     rf
  251 a9ae: f8 52                  ldi     low outbuf
  252 a9b0: af                     plo     rf
  253 a9b1: d4                     sep     scall               ; output the last line
  254 a9b2: ff 09                  dw      f_msg
  255 a9b4: f8 02                  ldi     high ascbuf         ; point to ascii buffer
  256 a9b6: bf                     phi     rf
  257 a9b7: f8 02                  ldi     low ascbuf
  258 a9b9: af                     plo     rf
  259 a9ba: d4                     sep     scall               ; output the last line
  260 a9bb: ff 09                  dw      f_msg
  261 a9bd: d4                     sep     scall
  262 a9be: ab 4f                  dw      docrlf
  263 a9c0: f8 02                  ldi     high outbuf         ; point to output buffer
  264 a9c2: bf                     phi     rf
  265 a9c3: f8 52                  ldi     low outbuf
  266 a9c5: af                     plo     rf
  267 a9c6: f8 02                  ldi     high ascbuf         ; point to ascii buffer
  268 a9c8: b7                     phi     r7
  269 a9c9: f8 02                  ldi     low ascbuf
  270 a9cb: a7                     plo     r7
  271 a9cc: 99                     ghi     r9                  ; get address
  272 a9cd: bd                     phi     rd                  ; and get for hexout
  273 a9ce: 89                     glo     r9
  274 a9cf: ad                     plo     rd
  275 a9d0: d4                     sep     scall               ; output the address
  276 a9d1: ff 4b                  dw      f_hexout4
  277 a9d3: f8 3a                  ldi     ':'                 ; colon following address
  278 a9d5: 5f                     str     rf
  279 a9d6: 1f                     inc     rf
  280 a9d7: f8 20                  ldi     ' '                 ; and a space
  281 a9d9: 5f                     str     rf
  282 a9da: 1f                     inc     rf
  283 a9db: 89                     glo     r9                  ; increment address
  284 a9dc: fc 10                  adi     16
  285 a9de: a9                     plo     r9
  286 a9df: 99                     ghi     r9
  287 a9e0: 7c 00                  adci    0
  288 a9e2: b9                     phi     r9
  289 a9e3: 4a          disp_ln:   lda     ra                  ; get next byte
  290 a9e4: ae                     plo     re                  ; keep a copy
  291 a9e5: fa e0                  ani     0e0h                ; check for values below 32
  292 a9e7: c2 a9 f3               lbz     dsp_dot             ; display a dot
  293 a9ea: fa 80                  ani     080h                ; check for high values
  294 a9ec: ca a9 f3               lbnz    dsp_dot
  295 a9ef: 8e                     glo     re                  ; recover original character
  296 a9f0: c0 a9 f5               lbr     asc_go              ; and continue
  297 a9f3: f8 2e       dsp_dot:   ldi     '.'                 ; place dot into ascii buffer
  298 a9f5: 57          asc_go:    str     r7                  ; store into buffer
  299 a9f6: 17                     inc     r7                  ; and increment
  300 a9f7: 8e                     glo     re                  ; recover value
  301 a9f8: ad                     plo     rd                  ; setup for output
  302 a9f9: d4                     sep     scall               ; convert it
  303 a9fa: ff 48                  dw      f_hexout2
  304 a9fc: f8 20                  ldi     ' '                 ; space after number
  305 a9fe: 5f                     str     rf
  306 a9ff: 1f                     inc     rf
  307 aa00: 2c                     dec     rc                  ; decrement count
  308 aa01: 8c                     glo     rc                  ; get count
  309 aa02: ca a9 a1               lbnz    disp_lp             ; loop back if more to go
  310 aa05: f8 00                  ldi     0                   ; place terminator
  311 aa07: 5f                     str     rf
  312 aa08: 57                     str     r7
  313 aa09: f8 02                  ldi     high outbuf         ; point to output buffer
  314 aa0b: bf                     phi     rf
  315 aa0c: f8 52                  ldi     low outbuf
  316 aa0e: af                     plo     rf
  317 aa0f: d4                     sep     scall               ; output the last line
  318 aa10: ff 09                  dw      f_msg
  319 aa12: f8 02                  ldi     high ascbuf         ; point to ascii buffer
  320 aa14: bf                     phi     rf
  321 aa15: f8 02                  ldi     low ascbuf
  322 aa17: af                     plo     rf
  323 aa18: d4                     sep     scall               ; output the last line
  324 aa19: ff 09                  dw      f_msg
  325 aa1b: d4                     sep     scall
  326 aa1c: ab 4f                  dw      docrlf
  327 aa1e: c0 a9 1a               lbr     mainlp              ; back to main loop
  328 aa21:             
  329 aa21: d4          rd_au:     sep     scall               ; convert au number
  330 aa22: ff 45                  dw      f_hexin
  331 aa24: f8 03                  ldi     3                   ; need to shift by 3
  332 aa26: ac                     plo     rc
  333 aa27: 8d          au_lp:     glo     rd                  ; multiply by 2
  334 aa28: fe                     shl
  335 aa29: ad                     plo     rd
  336 aa2a: 9d                     ghi     rd
  337 aa2b: 7e                     shlc
  338 aa2c: bd                     phi     rd
  339 aa2d: 2c                     dec     rc                  ; decrement count
  340 aa2e: 8c                     glo     rc                  ; see if done
  341 aa2f: ca aa 27               lbnz    au_lp               ; loop back if not
  342 aa32: c0 aa 38               lbr     readit              ; read first sector of au
  343 aa35: d4          rd_sec:    sep     scall               ; convert sector number
  344 aa36: ff 45                  dw      f_hexin
  345 aa38: f8 00       readit:    ldi     low sector          ; point to sector number
  346 aa3a: ab                     plo     rb
  347 aa3b: 9d                     ghi     rd                  ; and write sector address
  348 aa3c: 5b                     str     rb
  349 aa3d: 1b                     inc     rb
  350 aa3e: 8d                     glo     rd
  351 aa3f: 5b                     str     rb
  352 aa40: 9d                     ghi     rd                  ; prepare for sector read
  353 aa41: b7                     phi     r7
  354 aa42: 8d                     glo     rd
  355 aa43: a7                     plo     r7
  356 aa44: f8 00                  ldi     0
  357 aa46: a8                     plo     r8
  358 aa47: f8 e0                  ldi     0e0h                ; in lba mode
  359 aa49: b8                     phi     r8
  360 aa4a: f8 02                  ldi     high secbuf         ; point to sector buffer
  361 aa4c: bf                     phi     rf
  362 aa4d: f8 a2                  ldi     low secbuf
  363 aa4f: af                     plo     rf
  364 aa50: d4                     sep     scall               ; read the sector
  365 aa51: ff 3c                  dw      f_ideread
  366 aa53: c3 aa 72               lbdf    ide_error
  367 aa56: c0 aa be               lbr     dsp_sec
  368 aa59:             
  369 aa59: f8 00       write:     ldi     low sector          ; point to sector number
  370 aa5b: ab                     plo     rb
  371 aa5c: 4b                     lda     rb                  ; and read it
  372 aa5d: b7                     phi     r7
  373 aa5e: 4b                     lda     rb
  374 aa5f: a7                     plo     r7
  375 aa60: f8 00                  ldi     0
  376 aa62: a8                     plo     r8
  377 aa63: f8 e0                  ldi     0e0h                ; in lba mode
  378 aa65: b8                     phi     r8
  379 aa66: f8 02                  ldi     high secbuf         ; point to sector buffer
  380 aa68: bf                     phi     rf
  381 aa69: f8 a2                  ldi     low secbuf
  382 aa6b: af                     plo     rf
  383 aa6c: d4                     sep     scall               ; write the sector
  384 aa6d: ff 39                  dw      f_idewrite
  385 aa6f: cb aa be               lbnf    dsp_sec             ; jump if no error occurred
  386 aa72: 73          ide_error: stxd                        ; save error code
  387 aa73: d4                     sep     scall               ; display error message
  388 aa74: ff 66                  dw      f_inmsg
  389 aa76: 45 72 72 6f 
            72 20 6f 6e 
            20 64 72 69 
            76 65 3a 20 
            00                     db      'Error on drive: ',0
  390 aa87: f8 01                  ldi     high buffer         ; point to buffer
  391 aa89: bf                     phi     rf
  392 aa8a: f8 02                  ldi     low buffer
  393 aa8c: af                     plo     rf
  394 aa8d: 60                     irx                         ; recover error code
  395 aa8e: f0                     ldx
  396 aa8f: ad                     plo     rd
  397 aa90: d4                     sep     scall               ; display it
  398 aa91: ff 48                  dw      f_hexout2
  399 aa93: f8 00                  ldi     0                   ; terminate value
  400 aa95: 5f                     str     rf
  401 aa96: f8 01                  ldi     high buffer         ; point to buffer
  402 aa98: bf                     phi     rf
  403 aa99: f8 02                  ldi     low buffer
  404 aa9b: af                     plo     rf
  405 aa9c: d4                     sep     scall               ; display code
  406 aa9d: ff 09                  dw      f_msg
  407 aa9f: d4                     sep     scall
  408 aaa0: ff 66                  dw      f_inmsg
  409 aaa2: 0a 0d 00               db      10,13,0
  410 aaa5: c0 a9 1a               lbr     mainlp              ; then back to main loop
  411 aaa8:              
  412 aaa8: f8 00       nxt_sec:   ldi     low sector          ; point to current sector number
  413 aaaa: ab                     plo     rb
  414 aaab: 4b                     lda     rb                  ; and read it
  415 aaac: bd                     phi     rd
  416 aaad: 4b                     lda     rb
  417 aaae: ad                     plo     rd
  418 aaaf: 1d                     inc     rd                  ; increment sector number
  419 aab0: c0 aa 38               lbr     readit              ; and read new physical sector
  420 aab3:             
  421 aab3: f8 00       prv_sec:   ldi     low sector          ; point to current sector number
  422 aab5: ab                     plo     rb
  423 aab6: 4b                     lda     rb                  ; and read it
  424 aab7: bd                     phi     rd
  425 aab8: 4b                     lda     rb
  426 aab9: ad                     plo     rd
  427 aaba: 2d                     dec     rd                  ; decrement sector number
  428 aabb: c0 aa 38               lbr     readit              ; and read new physical sector
  429 aabe:             
  430 aabe: f8 ab       dsp_sec:   ldi     high sec_msg        ; display message
  431 aac0: bf                     phi     rf
  432 aac1: f8 91                  ldi     low sec_msg
  433 aac3: af                     plo     rf
  434 aac4: d4                     sep     scall               ; and display it
  435 aac5: ff 09                  dw      f_msg
  436 aac7: f8 00                  ldi     low sector          ; get current sector number
  437 aac9: ab                     plo     rb
  438 aaca: 4b                     lda     rb                  ; and retrieve it
  439 aacb: bd                     phi     rd
  440 aacc: 4b                     lda     rb
  441 aacd: ad                     plo     rd
  442 aace: d4                     sep     scall               ; point to buffer
  443 aacf: ab 48                  dw      loadbuf
  444 aad1: d4                     sep     scall               ; convert sector number
  445 aad2: ff 4b                  dw      f_hexout4
  446 aad4: f8 00                  ldi     0                   ; write terminator
  447 aad6: 5f                     str     rf
  448 aad7: d4                     sep     scall               ; point to buffer
  449 aad8: ab 48                  dw      loadbuf
  450 aada: d4                     sep     scall               ; and display it
  451 aadb: ff 09                  dw      f_msg
  452 aadd: d4                     sep     scall               ; carriage return
  453 aade: ab 4f                  dw      docrlf
  454 aae0: c0 a9 1a               lbr     mainlp              ; back to main loop
  455 aae3:             
  456 aae3: d4          enter:     sep     scall               ; convert address
  457 aae4: ff 45                  dw      f_hexin
  458 aae6: 8d                     glo     rd                  ; transfer address
  459 aae7: fc a2                  adi     low secbuf          ; add in sector buffer offset
  460 aae9: aa                     plo     ra
  461 aaea: 9d                     ghi     rd
  462 aaeb: 7c 02                  adci    high secbuf
  463 aaed: ba                     phi     ra
  464 aaee: d4          enter_lp:  sep     scall               ; move past whitespace
  465 aaef: ff 15                  dw      f_ltrim
  466 aaf1: 0f                     ldn     rf                  ; see if at terminator
  467 aaf2: c2 a9 1a               lbz     mainlp              ; jump if done
  468 aaf5: d4                     sep     scall               ; otherwise convert number
  469 aaf6: ff 45                  dw      f_hexin
  470 aaf8: 8d                     glo     rd                  ; get number
  471 aaf9: 5a                     str     ra                  ; write into sector
  472 aafa: 1a                     inc     ra                  ; point to next position
  473 aafb: c0 aa ee               lbr     enter_lp            ; and look for more
  474 aafe:             
  475 aafe: d4          chain:     sep     scall               ; convert address
  476 aaff: ff 45                  dw      f_hexin
  477 ab01: 9d                     ghi     rd                  ; transfer address
  478 ab02: ba                     phi     ra
  479 ab03: 8d                     glo     rd
  480 ab04: aa                     plo     ra
  481 ab05: d4          chain_lp:  sep     scall               ; read specified lump
  482 ab06: ab 6e                  dw      readlump
  483 ab08: 9a                     ghi     ra                  ; transfer for display
  484 ab09: bd                     phi     rd
  485 ab0a: 8a                     glo     ra
  486 ab0b: ad                     plo     rd
  487 ab0c: d4                     sep     scall               ; setup buffer
  488 ab0d: ab 48                  dw      loadbuf
  489 ab0f: d4                     sep     scall               ; convert number
  490 ab10: ff 4b                  dw      f_hexout4
  491 ab12: f8 20                  ldi     ' '                 ; need a space
  492 ab14: 5f                     str     rf
  493 ab15: 1f                     inc     rf
  494 ab16: f8 00                  ldi     0                   ; and terminator
  495 ab18: 5f                     str     rf
  496 ab19: d4                     sep     scall               ; setup buffer
  497 ab1a: ab 48                  dw      loadbuf
  498 ab1c: d4                     sep     scall               ; display it
  499 ab1d: ff 09                  dw      f_msg
  500 ab1f: 8a                     glo     ra                  ; check for nonzero entry
  501 ab20: ca ab 2d               lbnz    chain_nz            ; jump if not
  502 ab23: 9a                     ghi     ra
  503 ab24: ca ab 2d               lbnz    chain_nz
  504 ab27: d4          chain_dn:  sep     scall               ; display a CR/LF
  505 ab28: ab 4f                  dw      docrlf
  506 ab2a: c0 a9 1a               lbr     mainlp              ; and back to main loop
  507 ab2d: 8a          chain_nz:  glo     ra                  ; check for end of chain code
  508 ab2e: ff fe                  smi     0feh
  509 ab30: ca ab 39               lbnz    chain_ne            ; jump if not end
  510 ab33: 9a                     ghi     ra
  511 ab34: ff fe                  smi     0feh
  512 ab36: c2 ab 27               lbz     chain_dn            ; jump if end of chain
  513 ab39: 8a          chain_ne:  glo     ra                  ; check for invalid entry
  514 ab3a: fb ff                  xri     0ffh
  515 ab3c: ca ab 05               lbnz    chain_lp            ; jump if not
  516 ab3f: 9a                     ghi     ra
  517 ab40: fb ff                  xri     0ffh
  518 ab42: ca ab 05               lbnz    chain_lp
  519 ab45: c0 ab 27               lbr     chain_dn
  520 ab48: f8 01       loadbuf:   ldi     high buffer
  521 ab4a: bf                     phi     rf
  522 ab4b: f8 02                  ldi     low buffer
  523 ab4d: af                     plo     rf
  524 ab4e: d5                     sep     sret
  525 ab4f:             
  526 ab4f: f8 ab       docrlf:    ldi     high crlf
  527 ab51: bf                     phi     rf
  528 ab52: f8 8e                  ldi     low crlf
  529 ab54: af                     plo     rf
  530 ab55: d4                     sep     scall
  531 ab56: ff 09                  dw      f_msg
  532 ab58: d5                     sep     sret
  533 ab59:             
  534 ab59: 8a          lmpsecofs: glo     ra                  ; get low byte of lump
  535 ab5a: fe                     shl                         ; multiply by 2
  536 ab5b: a9                     plo     r9                  ; put into offset
  537 ab5c: f8 00                  ldi     0
  538 ab5e: 7e                     shlc                        ; propagate carry
  539 ab5f: b9                     phi     r9                  ; R9 now has lat offset
  540 ab60: 9a                     ghi     ra                  ; get high byte of lump
  541 ab61: fc 11                  adi     17                  ; add in base of lat table
  542 ab63: a7                     plo     r7                  ; place into r7
  543 ab64: f8 00                  ldi     0
  544 ab66: 7c 00                  adci    0                   ; propagate the carry
  545 ab68: b7                     phi     r7
  546 ab69: f8 00                  ldi     0                   ; need to zero R8
  547 ab6b: b8                     phi     r8
  548 ab6c: a8                     plo     r8
  549 ab6d: d5                     sep     sret                ; return to caller
  550 ab6e:             
  551 ab6e: d4          readlump:  sep     scall               ; convert lump to sector:offset
  552 ab6f: ab 59                  dw      lmpsecofs
  553 ab71: f8 04                  ldi     high secbuf2        ; point to buffer
  554 ab73: bf                     phi     rf
  555 ab74: f8 a2                  ldi     low secbuf2
  556 ab76: af                     plo     rf
  557 ab77: d4                     sep     scall               ; read the sector
  558 ab78: ff 3c                  dw      f_ideread
  559 ab7a: 89                     glo     r9                  ; point to entry
  560 ab7b: fc a2                  adi     low secbuf2
  561 ab7d: af                     plo     rf
  562 ab7e: 99                     ghi     r9
  563 ab7f: 7c 04                  adci    high secbuf2
  564 ab81: bf                     phi     rf
  565 ab82: 4f                     lda     rf                  ; and retrieve entry
  566 ab83: ba                     phi     ra
  567 ab84: 4f                     lda     rf
  568 ab85: aa                     plo     ra
  569 ab86: d5                     sep     sret                ; and return
  570 ab87:             
  571 ab87:             ; [RLA]   You have to write out the "SEDIT>" prompt in this rather awkward way
  572 ab87:             ; [RLA] because rc/asm will do macro subsitutions inside of literal strings.
  573 ab87:             ; [RLA] Since the STGROM defines "SEDIT" as the address for this program, you'll
  574 ab87:             ; [RLA] with a prompt that looks like "CD00>"!  Not good...
  575 ab87: 53 45 44 49 
            54 3e 00    prompt:    db      'S','E','D','I','T','>',0
  576 ab8e: 0a 0d 00    crlf:      db      10,13,0
  577 ab91: 43 75 72 72 
            65 6e 74 20 
            73 65 63 74 
            6f 72 3a 20 
            00          sec_msg:   db      'Current sector: ',0
  578 aba2:             
  579 aba2:             
  580 aba2:                        org     0100h
  581 0100:             sector:    ds      2
  582 0102:             buffer:    ds      256
  583 0202:             ascbuf:    ds      80
  584 0252:             outbuf:    ds      80
  585 02a2:             secbuf:    ds      512
  586 04a2:             secbuf2:   ds      512

0202h: ASCBUF           - <   583>    236    238    255    257    267    269 
          319    321 
a9f5h: ASC_GO           - <   298>    296 
aa27h: AU_LP            - <   333>    341 
0102h: BUFFER           - <   582>    390    392    401    403    520    522 
ffe0h: CALL             - <    59> 
aafeh: CHAIN            - <   475>    208 
ab27h: CHAIN_DN         - <   504>    512    519 
ab05h: CHAIN_LP         - <   481>    515    518 
ab39h: CHAIN_NE         - <   513>    509 
ab2dh: CHAIN_NZ         - <   507>    501    503 
ab8eh: CRLF             - <   576>    526    528 
a991h: DISP_CT          - <   232>    223 
a976h: DISP_HI          - <   214>    181 
a9e3h: DISP_LN          - <   289>    245 
a986h: DISP_LO          - <   224>    178 
a9a1h: DISP_LP          - <   243>    309 
ab4fh: DOCRLF           - <   526>    172    262    326    453    505 
a9f3h: DSP_DOT          - <   297>    292    294 
aabeh: DSP_SEC          - <   430>    193    367    385 
aae3h: ENTER            - <   456>    196 
aaeeh: ENTER_LP         - <   464>    473 
f830h: F_ASTODT         - <   128> 
f833h: F_ASTOTM         - <   129> 
ff5dh: F_ATOI           - <    94> 
ff00h: F_BOOT           - <    63> 
ff42h: F_BOOTIDE        - <    85> 
f800h: F_BREAD          - <   112> 
ff6ch: F_BRKTEST        - <    99> 
f806h: F_BTEST          - <   114> 
f803h: F_BTYPE          - <   113> 
ff33h: F_DIV16          - <    80> 
ff2ah: F_DRIVE          - <    77> 
f827h: F_DTTOAS         - <   126> 
ff6fh: F_FINDTKN        - <   100> 
ff57h: F_FREEMEM        - <    92> 
ff81h: F_GETDEV         - <   106> 
f815h: F_GETTOD         - <   119> 
ff45h: F_HEXIN          - <    86>    330    344    457    469    476 
ff48h: F_HEXOUT2        - <    87>    303    398 
ff4bh: F_HEXOUT4        - <    88>    276    445    490 
f824h: F_IDEID          - <   124> 
ff3ch: F_IDEREAD        - <    83>    365    558 
ff36h: F_IDERESET       - <    81>    158 
f821h: F_IDESIZE        - <   123> 
ff39h: F_IDEWRITE       - <    82>    384 
ff7bh: F_IDNUM          - <   104> 
ff3fh: F_INITCALL       - <    84>    144 
ff66h: F_INMSG          - <    97>    388    408 
ff0fh: F_INPUT          - <    68>    170 
ff69h: F_INPUTL         - <    98> 
ff63h: F_INTOUT         - <    96> 
ff78h: F_ISALNUM        - <   103> 
ff72h: F_ISALPHA        - <   101> 
ff75h: F_ISHEX          - <   102> 
ff5ah: F_ISNUM          - <    93> 
ff7eh: F_ISTERM         - <   105> 
ff15h: F_LTRIM          - <    70>    465 
ff1bh: F_MEMCPY         - <    72> 
ff54h: F_MINIMON        - <    91> 
ff51h: F_MOVER          - <    90> 
ff09h: F_MSG            - <    66>    166    254    260    318    324    406 
          435    451    499    531 
ff30h: F_MUL16          - <    79> 
f836h: F_NVRCCHK        - <   130> 
f81bh: F_RDNVR          - <   121> 
ff21h: F_RDSEC          - <    74> 
ff06h: F_READ           - <    65> 
f82dh: F_RTCTEST        - <   127> 
ff27h: F_SEEK           - <    76> 
ff24h: F_SEEK0          - <    75> 
ff2dh: F_SETBD          - <    78> 
f818h: F_SETTOD         - <   120> 
ff12h: F_STRCMP         - <    69> 
ff18h: F_STRCPY         - <    71> 
f82ah: F_TMTOAS         - <   125> 
ff4eh: F_TTY            - <    89> 
ff03h: F_TYPE           - <    64> 
ff0ch: F_TYPEX          - <    67> 
ff60h: F_UINTOUT        - <    95> 
f80ch: F_UREAD          - <   116> 
f812h: F_USETBD         - <   118> 
f80fh: F_UTEST          - <   117> 
f809h: F_UTYPE          - <   115> 
fff9h: F_VERSION        - <   108> 
f81eh: F_WRNVR          - <   122> 
ff1eh: F_WRTSEC         - <    73> 
aa72h: IDE_ERROR        - <   386>    366 
ab59h: LMPSECOFS        - <   534>    552 
ab48h: LOADBUF          - <   520>    168    174    443    449    488    497 
a91ah: MAINLP           - <   161>    210    327    410    454    467    506 
aaa8h: NXT_SEC          - <   412>    187 
0252h: OUTBUF           - <   584>    232    234    249    251    263    265 
          313    315 
ab87h: PROMPT           - <   575>    161    163 
aab3h: PRV_SEC          - <   421>    190 
a975h: QUIT             - <   212>    202 
aa21h: RD_AU            - <   329>    205 
aa35h: RD_SEC           - <   343>    184 
aa38h: READIT           - <   345>    342    419    428 
ab6eh: READLUMP         - <   551>    482 
fff1h: RET              - <    60> 
0004h: SCALL            - <    56>    157    165    167    169    171    173 
          253    259    261    275    302    317    323    325    329    343 
          364    383    387    397    405    407    434    442    444    448 
          450    452    456    464    468    475    481    487    489    496 
          498    504    530    551    557 
02a2h: SECBUF           - <   585>    219    221    228    230    360    362 
          379    381    459    462 
04a2h: SECBUF2          - <   586>    553    555    560    563 
0100h: SECTOR           - <   581>    147    149    345    369    412    421 
          436 
ab91h: SEC_MSG          - <   577>    430    432 
0005h: SRET             - <    57>    212    524    532    549    569    569 
a909h: START            - <   147>    140    142 
aa59h: WRITE            - <   369>    199 

586 Lines assembled
0 Errors
107 Labels
Object Code:674 bytes

