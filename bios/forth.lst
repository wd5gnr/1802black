[00001]                   ; NOTE THIS NOW USES ASM/02 instead of RC/ASM
[00002]                   ; These are backward because there are places in the code where this is the order things are pushed (low first, then high)
[00003]                   ; And either the macros are not used or something is meddling with the items on the stack
[00004]                   ; SCRT does it the other way. I may go clean up the code to reverse it which would require push and pop to flip order but for now...
[00005]                   .op "push", "N", "8$1 73 9$1 73"
[00006]                   .op "pop","N","60 72 B$1 F0 A$1"
[00007]                   .op "call","W","D4 H1 L1"
[00008]                   .op "rtn","","D5"
[00009]                   .op "mov","NR","8$2 A$1 9$2 B$1"
[00010]                   .op "mov","NW","F8 L2 A$1 F8 H2 B$1"
[00011]                   
[00012]                   
[00013]                   ; *******************************************************************
[00014]                   ; *** This software is copyright 2006 by Michael H Riley          ***
[00015]                   ; *** You have permission to use, modify, copy, and distribute    ***
[00016]                   ; *** this software so long as this copyright notice is retained. ***
[00017]                   ; *** This software may not be used in commercial applications    ***
[00018]                   ; *** without express written permission from the author.         ***
[00019]                   ; *******************************************************************
[00020]                   ;[RLA] These are defined on the rcasm command line!
[00021]                   ;[RLA] #define ELFOS            ; build the version that runs under Elf/OS
[00022]                   ;[RLA] #define STGROM           ; build the STG EPROM version
[00023]                   ;[RLA] #define PICOROM          ; define for Mike's PIcoElf version
[00024]                   ;[RLA]   rcasm doesn't have any way to do a logical "OR" of assembly
[00025]                   ;[RLA} options, so define a master "ANYROM" option that's true for
[00026]                   ;[RLA} any of the ROM conditions...
[00027]                                 ; [gnr] Bug fixes, assembler fixes,and the Exec word
[00028]                                 ; A few notes as I've gone through the code (GNR)
[00029]                                 ; This isn't done like a conventional Forth
[00030]                                 ; Everything is parsed on processing the input line
[00031]                                 ; First, it checks for core words. If it finds one, it tokenizes it >0x80
[00032]                                 ; Then it checks for a number and, if found marks it with FF
[00033]                                 ; Anything else must be a string, so it gets marked with an FE and terminated with a zero.
[00034]                                 ; The tokenized string is already in the free storage so a VARIABLE or : just bumps up
[00035]                                 ; the pointer to the end of the string (or just past, for a variable)
[00036]                                 ; Note: This is no longer true if using USE_CBUFFER
[00037]                                 ; This reserved 256 bytes and your input gets compiled there
[00038]                                 ; This makes : and VARIABLE and ALLOT easier and safer
[00039]                                 ; because it isn't trying to overwrite your input
[00040]                                 ;
[00041]                                 ; The colon operator just grabs the name, and copies everything else. So core words
[00042]                                 ; are tokenized, but variables and user words are not.
[00043]                                 ;
[00044]                                 ; The upside is you don't have a forward ref problem of what to do with words you
[00045]                                 ; don't know yet
[00046]                                 ;
[00047]                                 ; The downside is you can't override the system words. If you did (e.g., search
[00048]                                 ; user space first) you'd have a problem with words compiled before the override
[00049]                                 ; example: 5 2 + 1+ parses out as:
[00050]                                 ; <NUM> 0005 <NUM> 0002 <+> <STR>1+<0>
[00051]                                 ; And
[00052]                                 ;
[00053]                                 ; Parses out as:
[00054]                                 ; <len><colon>example<0><NUM>0005<NUM>0002<+><STR>1+<SEMICOLON><0>
[00055]                                 ;
[00056]                                 ; You can define a word more than once, but only the first one gets used
[00057]                                 ; You can't define words over multiple lines (seems easy to fix)
[00058]                                 ;
[00059]                                 ; Although the semicolon doesn't really do anything, omitting it in a definition will crash
[00060]                                 ; and burn the system (should fix) since you just copy a bunch of stuff over (fixed)
[00061]                                 ;
[00062]                                 ; VARIABLE can't have anything following it
[00063]                                 ; e.g. VARIABLE X X 0 ! -- does not work (now throws an error)
[00064]                                 ; on a word def is ignored also  (now throws an error)
[00065]                                 ; These no longer throw errors and it ks now allowed
[00066]                                 ;
[00067]                                 ; To catch all these we now define T_EOS 0xFD. The tokenizer marks the end of string with it
[00068]                                 ; and most things ignore it. But colon and varible use it to make sure the string is
[00069]                                 ; complete and doesn't have too much stuff in it, also. As an extra feature, we now
[00070]                                 ; zero out new variables (but not the allot part)s
[00071]                   
[00072]                                 ; The old style BLOAD was binary and wipes out your variables (removed)
[00073]                                 ; The new style BLOAD (EXTLOAD) takes text strings (more space) but doesn't wipe out variables
[00074]                                 ; Of course, you can reduce space on text by easily removing definitions you
[00075]                                 ; don't want or need which is harder to do with the binary BLOAD
[00076]                                 ; Doesn't need to change based on RAM addresses
[00077]                                 ; And let's your run things not just define words/variables
[00078]                                 ; Pick one or the other here. Or define NO_BLOAD to make BLOAD act like LOAD
[00079]                                 ; (that is, XMODEM load)
[00080]                                 ; DO NOT DEFINE BLOAD_TEXT and BLOAD_BIN!
[00081]                                 ; BLOAD_AUTO, if defined, makes us run BLOAD at startup (turn off if using NO_BLOAD)
[00082]                                 ; Unless you define NO_TOKEN_COMPRESSION then
[00083]                                 ; The parser will take anything >=80h as a token directly
[00084]                                 ; This allows you to make files (or BLOAD data) that use tokenized or ASCII core words
[00085]                                 ; Example:
[00086]                                 ;   db  FCOLON,'ABC ',FSWAP,FDROP,FSEMI,0
[00087]                                 ;
[00088]                                 ; You don't HAVE to use the tokens, and you can mix and match
[00089]                                 ; However, if you wanted to put these in the data stream
[00090]                                 ; You'd need to set NO_TOKEN_COMPRESSION to allow that data to pass through
[00091]                                 ; Not sure what the use case for that would be, however.
[00092]                                 ; NOTE: The BIN format is highly dependent on the memory layout
[00093]                                 ; If you turn it back on, you will lose many extended words and you may
[00094]                                 ; have to redo the hex code blocks to work with the current memory layout
[00095]                   
<00000>                   #include forthconfig.inc
<00001>                   ; Configuration items
<00002>                   
<00003>                   ; pick EXACTLY one of the next two
<00004>                   #ifndef NO_BLOAD
<00005>                   #ifndef BLOAD_TEXT
<00006>                   ;#define NO_BLOAD
<00007>                   #define BLOAD_TEXT
<00008>                   #endif
<00009>                   #endif
<00010>                   
<00011>                   ; If you want the entire EXTLOAD/BLOAD words to load on first start up, define this:
<00012>                   #define BLOAD_AUTO
<00013>                   ; core words always load
<00014>                   
<00015>                   
<00016>                   ; if you want to compile to a separate "compile buffer" define this
<00017>                   #ifndef NO_USE_CBUFFER
<00018>                   #define USE_CBUFFER
<00019>                   #endif
<00020>                   ; If you turn off CBUFFER and use BLOAD_TEXT, you'll need to uncomment some code in cbload...
<00021>                   ; Several newer features REQUIRE CBUFFER
<00022>                   
<00023>                   ; if you want to find the last of a multiply-defined user word instead of the first one...
<00024>                   ; FIND_LAST is "better" Forth behavior but very inefficient
<00025>                   ; Fixing that would require a reorg of the entire dictionary structure
<00026>                   ; Note that you MUST define this to use option 2 below
<00027>                   ; which allows you to pick find first OR find last, so you really should
<00028>                   ; never undef this under normal circumstances
<00029>                   #ifndef NO_FIND_LAST
<00030>                   #define FIND_LAST
<00031>                   #endif
<00032>                   
<00033>                   
<00034>                   ; option bits
<00035>                   ; 1 - Set to supress spaces after output number
<00036>                   ; 2 - Set to search dictionary for first def instead of last def
<00037>                   ; 4 - Set to output 4 digit hex numbers always
<00038>                   ; 32 - SEE/LIST do not dump variable data if set
<00039>                   ; 64 - Turn of debugging
<00040>                   ; 128 - Turn on debugging
<00041>                   #ifndef DEF_OPTION
<00042> 0000:             DEF_OPTION:    equ 0
<00043>                   #endif
<00044>                   
<00045>                   
<00046>                   ; You can choose to only load core ext words into ROM by defining LEAN_EXTENDED
<00047>                   ; If you don't do this, you get two bloads where 0 BLOAD loads the core external and 1 BLOAD loads the extended
<00048>                   ; On startup, both are loaded
<00049>                   ;#define LEAN_EXTENDED
<00050>                   
<00051>                   ; It makes a smaller footprint to use the testop subroutine but because it is used heavily, it makes us slower
<00052>                   ; So if you comment this out, it will go back to inline all the ones that can be inlined
<00053>                   ; save one or two for performance or other reasons (e.g, we save the option at the same time or something)
<00054>                   #define OPT_BY_CALL
<00055>                   
<00056>                   ; If defined, selectively inline GETVAR for the same reason -- better performance, larger ROM
<00057>                   ;#define INLINE_GETVAR
[00097]                   
[00098]                   
[00099]                   
[00100]                   ; For a RAM build you need to set all this up yourself
[00101]                   ; you do need BIOS somewhere and if you don't have XMODEM then don't use those commands!
[00102]                   ; we assume you have BIOS.INC (since you have a BIOS) and that it is correct
[00122]                   #endif
[00134]                   #endif
[00146]                   #endif
[00147]                   ; [GDJ] build: asm02 -i -L -DSTGROM forth.asm
[00148]                   #ifdef        STGROM
[00149]                   #define       ANYROM        1
<00000>                   #include       config.inc
<00001>                   ; DO NOT EDIT THIS FILE - EDIT CONFIG. INSTEAD!!
<00002>                   #define BOOTS	 08000H
<00003>                   #define WARMB	 (08000H+3)
<00004>                   #define HELP	 09400H
<00005>                   #define RAMPAGE	 07F00H
<00006>                   #define BIOS	 0FF00H
<00007>                   #define EBIOS	 0F800H
<00008>                   #define FORTH	 0D700H
<00009>                   #define EDTASM	 09C00H
<00010>                   #define BASIC	 0BA00H
<00011>                   #define VISUAL	 0A900H
<00012>                   #define XMODEM	 0D400H
[00151]                   #define       RAMBASE       00000h
[00152]                                 ; [gnr] The UART is used in inkey so when using bitbang, no inkey!
[00153]                   #define       UART_SELECT   6                    ; UART register select I/O port
[00154]                   #define       UART_DATA     7                    ; UART data I/O port
[00155]                   ;[RLA] XMODEM entry vectors for the STG EPROM ...
[00156] 0000:             xopenw:       equ           XMODEM + 0*3
[00157] 0000:             xopenr:       equ           XMODEM + 1*3
[00158] 0000:             xread:        equ           XMODEM + 2*3
[00159] 0000:             xwrite:       equ           XMODEM + 3*3
[00160] 0000:             xclosew:      equ           XMODEM + 4*3
[00161] 0000:             xcloser:      equ           XMODEM + 5*3
[00162] 0000:             exitaddr:     equ           08003h
[00163]                   #endif
[00168]                   #else
[00169] 0000:             buffer:       equ           RAMBASE+0200h
[00170]                   #ifdef USE_CBUFFER
[00171] 0000:             cbuffer:      equ           RAMBASE+0300h
[00172] 0000:             himem:        equ           RAMBASE+0400h
[00175]                   #endif
[00176] 0000:             rstack:       equ           himem+2
[00177] 0000:             tos:          equ           rstack+2
[00178] 0000:             freemem:      equ           tos+2
[00179] 0000:             fstack:       equ           freemem+2
[00180] 0000:             jump:         equ           fstack+2
[00181] 0000:             rseed:        equ           jump+3
[00182] 0000:             basev:        equ           rseed+4
[00183] 0000:             basen:        equ           basev+1              ; byte access
[00184] 0000:             option:       equ           basev+2
[00185] 0000:             storage:      equ           option+2
[00186] 0000:             stack:        equ           RAMBASE+01ffh
[00187]                   #endif
<00000>                   #include       bios.inc
<00001>                   ; *******************************************************************
<00002>                   ; *** This software is copyright 2006 by Michael H Riley          ***
<00003>                   ; *** You have permission to use, modify, copy, and distribute    ***
<00004>                   ; *** this software so long as this copyright notice is retained. ***
<00005>                   ; *** This software may not be used in commercial applications    ***
<00006>                   ; *** without express written permission from the author.         ***
<00007>                   ; *******************************************************************
<00008>                   
<00011>                   #endif
<00012>                   
<00013>                   ; Define address for standard BIOS vectors
<00016>                   #endif
<00017>                   
<00018>                   ; Define address for extended BIOS vectors
<00021>                   #endif
<00022>                   
<00023>                   #ifndef TASM
<00024> 0000:             scall:      equ  r4                    ; register for SCALL
<00025> 0000:             sret:       equ  r5                    ; register for SRET
<00026>                   
<00027> 0000:             call:       equ  0ffe0h                ; depricated
<00028> 0000:             ret:        equ  0fff1h                ; depricated
<00029>                   #endif
<00030>                   
<00031> 0000:             f_boot:     equ  (BIOS+00h)            ; boot from ide device
<00032> 0000:             f_type:     equ  (BIOS+03h)            ; type 1 character to console
<00033> 0000:             f_read:     equ  (BIOS+06h)            ; read 1 character from console
<00034> 0000:             f_msg:      equ  (BIOS+09h)            ; type asciiz string to console
<00035> 0000:             f_typex:    equ  (BIOS+0ch)            ; depricated, just returns now
<00036> 0000:             f_input:    equ  (BIOS+0fh)            ; read asciiz from console
<00037> 0000:             f_strcmp:   equ  (BIOS+12h)            ; compare 2 strings
<00038> 0000:             f_ltrim:    equ  (BIOS+15h)            ; trim leading spaces
<00039> 0000:             f_strcpy:   equ  (BIOS+18h)            ; copy an asciiz string
<00040> 0000:             f_memcpy:   equ  (BIOS+1bh)            ; copy memory
<00041> 0000:             f_wrtsec:   equ  (BIOS+1eh)            ; write floppy sector (depricated)
<00042> 0000:             f_rdsec:    equ  (BIOS+21h)            ; read floppy sector (depricated)
<00043> 0000:             f_seek0:    equ  (BIOS+24h)            ; floppy seek to track 0 (depricated)
<00044> 0000:             f_seek:     equ  (BIOS+27h)            ; floopy track seek (depricated)
<00045> 0000:             f_drive:    equ  (BIOS+2ah)            ; select floppy drive (depricated)
<00046> 0000:             f_setbd:    equ  (BIOS+2dh)            ; set console baud rate
<00047> 0000:             f_mul16:    equ  (BIOS+30h)            ; 16-bit multiply
<00048> 0000:             f_div16:    equ  (BIOS+33h)            ; 16-bit division
<00049> 0000:             f_idereset: equ  (BIOS+36h)            ; reset ide device
<00050> 0000:             f_idewrite: equ  (BIOS+39h)            ; write ide sector
<00051> 0000:             f_ideread:  equ  (BIOS+3ch)            ; read ide sector
<00052> 0000:             f_initcall: equ  (BIOS+3fh)            ; initialize R4 and R5
<00053> 0000:             f_bootide:  equ  (BIOS+42h)            ; boot from ide device
<00054> 0000:             f_hexin:    equ  (BIOS+45h)            ; convert ascii number to hex
<00055> 0000:             f_hexout2:  equ  (BIOS+48h)            ; convert hex to 2-digit ascii
<00056> 0000:             f_hexout4:  equ  (BIOS+4bh)            ; convert hex to 4-digit ascii
<00057> 0000:             f_tty:      equ  (BIOS+4eh)            ; type character to console
<00058> 0000:             f_mover:    equ  (BIOS+51h)            ; program relocator
<00059> 0000:             f_minimon:  equ  (BIOS+54h)            ; mini monitor
<00060> 0000:             f_freemem:  equ  (BIOS+57h)            ; determine memory size
<00061> 0000:             F_isnum:    equ  (BIOS+5ah)            ; determine if D is numeric
<00062> 0000:             f_atoi:     equ  (BIOS+5dh)            ; convert ascii to integer
<00063> 0000:             f_uintout:  equ  (BIOS+60h)            ; convert unsigned integer to ascii
<00064> 0000:             f_intout:   equ  (BIOS+63h)            ; convert signed integer to ascii
<00065> 0000:             f_inmsg:    equ  (BIOS+66h)            ; type in-line message
<00066> 0000:             f_inputl:   equ  (BIOS+69h)            ; read limited line from console
<00067> 0000:             f_brktest:  equ  (BIOS+6ch)            ; check for serial break
<00068> 0000:             f_findtkn:  equ  (BIOS+6fh)            ; find token in a token table
<00069> 0000:             f_isalpha:  equ  (BIOS+72h)            ; determine if D is alphabetic
<00070> 0000:             f_ishex:    equ  (BIOS+75h)            ; determine if D is hexadecimal
<00071> 0000:             f_isalnum:  equ  (BIOS+78h)            ; determine if D is alpha or numeric
<00072> 0000:             f_idnum:    equ  (BIOS+7bh)            ; determine type of ascii number
<00073> 0000:             f_isterm:   equ  (BIOS+7eh)            ; determine if D is a termination char
<00074> 0000:             f_getdev:   equ  (BIOS+81h)            ; get supported devices
<00075>                   
<00076> 0000:             f_version:  equ  (BIOS+0f9h)           ; 3 bytes holding bios version number
<00077>                   
<00078>                   ; "Extended" BIOS vectors
<00079>                   
<00080> 0000:             f_bread:     equ  (EBIOS+00h)        ; read from onboard serial port
<00081> 0000:             f_btype:     equ  (EBIOS+03h)        ; write to onboard serial port
<00082> 0000:             f_btest:     equ  (EBIOS+06h)        ; test onboard serial port
<00083> 0000:             f_utype:     equ  (EBIOS+09h)        ; write to disk board UART
<00084> 0000:             f_uread:     equ  (EBIOS+0ch)        ; read from disk board UART
<00085> 0000:             f_utest:     equ  (EBIOS+0fh)        ; test disk board UART
<00086> 0000:             f_usetbd:    equ  (EBIOS+12h)        ; set disk board UART baud rate and format
<00087> 0000:             f_gettod:    equ  (EBIOS+15h)        ; read time of day clock
<00088> 0000:             f_settod:    equ  (EBIOS+18h)        ; set time of day clock
<00089> 0000:             f_rdnvr:     equ  (EBIOS+1bh)        ; read non volatile RAM
<00090> 0000:             f_wrnvr:     equ  (EBIOS+1eh)        ; write non volatile RAM
<00091> 0000:             f_idesize:   equ  (EBIOS+21h)        ; return size of attached IDE drive(s)
<00092> 0000:             f_ideid:     equ  (EBIOS+24h)        ; return device data for IDE drive(s)
<00093> 0000:             f_tmtoas:    equ  (EBIOS+2ah)        ; time to ASCII string
<00094> 0000:             f_dttoas:    equ  (EBIOS+27h)        ; date to ASCII string
<00095> 0000:             f_rtctest:   equ  (EBIOS+2dh)        ; test size and presence of RTC/NVR
<00096> 0000:             f_astodt:    equ  (EBIOS+30h)        ; convert ASCII string to date
<00097> 0000:             f_astotm:    equ  (EBIOS+33h)        ; convert ASCII string to time
<00098> 0000:             f_nvrcchk:   equ  (EBIOS+36h)	    ; [RLA] compute NVR checksum
<00099>                   
<00100>                   
[00200]                   #endif
[00201]                   ;  R2   - program stack
[00202]                   ;  R3   - Main PC
[00203]                   ;  R4   - standard call
[00204]                   ;  R5   - standard ret
[00205]                   ;  R6   - used by Scall/Sret linkage
[00206]                   ;  R7   - general and command table pointer
[00207]                   ;  R9   - Data segment (variable access)
[00208]                   ;  RA   - Used to access data in stack frames
[00209]                   ;  RB   - general SCRT return usage and token stream pointer
[00210]                   
[00211]                   ; These tokens are the order of the tokens in the tables at the bottom
[00212]                   ; A few are used in the code, but you can use them as compressed tokens
[00213]                   ; in extended.inc and/or custom.inc
[00214] 0000:             FWHILE:       equ           81h
[00215] 0000:             FREPEAT:      equ           FWHILE+1
[00216] 0000:             FIF:          equ           FREPEAT+1
[00217] 0000:             FELSE:        equ           FIF+1
[00218] 0000:             FTHEN:        equ           FELSE+1
[00219] 0000:             FVARIABLE:    equ           FTHEN+1
[00220] 0000:             FCOLON:       equ           FVARIABLE+1
[00221] 0000:             FSEMI:        equ           FCOLON+1
[00222] 0000:             FDUP:         equ           FSEMI+1
[00223] 0000:             FDROP:        equ           FDUP+1
[00224] 0000:             FSWAP:        equ           FDROP+1
[00225] 0000:             FPLUS:        equ           FSWAP+1
[00226] 0000:             FMINUS:       equ           FPLUS+1
[00227] 0000:             FMUL:         equ           FMINUS+1
[00228] 0000:             FDIV:         equ           FMUL+1
[00229] 0000:             FDOT:         equ           FDIV+1               ; 90h
[00230] 0000:             FUDOT:        equ           FDOT+1
[00231] 0000:             FI:           equ           FUDOT+1
[00232] 0000:             FAND:         equ           FI+1
[00233] 0000:             FOR:          equ           FAND+1
[00234] 0000:             FXOR:         equ           FOR+1
[00235] 0000:             FCR:          equ           FXOR+1
[00236] 0000:             FMEM:         equ           FCR+1
[00237] 0000:             FDO:          equ           FMEM+1
[00238] 0000:             FLOOP:        equ           FDO+1
[00239] 0000:             FPLOOP:       equ           FLOOP+1
[00240] 0000:             FEQUAL:       equ           FPLOOP+1
[00241] 0000:             FUNEQUAL:     equ           FEQUAL+1
[00242] 0000:             FLESS:        equ           FUNEQUAL+1           ; [GDJ]
[00243] 0000:             FULESS:       equ           FLESS+1              ; [GDJ]
[00244] 0000:             FBEGIN:       equ           FULESS+1
[00245] 0000:             FUNTIL:       equ           FBEGIN+1             ; a0h
[00246] 0000:             FRGT:         equ           FUNTIL+1
[00247] 0000:             FGTR:         equ           FRGT+1
[00248] 0000:             FRAT:         equ           FGTR+1               ; [GDJ]
[00249] 0000:             FWORDS:       equ           FRAT+1
[00250] 0000:             FEMIT:        equ           FWORDS+1
[00251] 0000:             FEMITP:       equ           FEMIT+1              ; [GDJ]
[00252] 0000:             FDEPTH:       equ           FEMITP+1
[00253] 0000:             FROT:         equ           FDEPTH+1
[00254] 0000:             FMROT:        equ           FROT+1
[00255] 0000:             FOVER:        equ           FMROT+1
[00256] 0000:             FAT:          equ           FOVER+1
[00257] 0000:             FEXCL:        equ           FAT+1
[00258] 0000:             FCAT:         equ           FEXCL+1
[00259] 0000:             FCEXCL:       equ           FCAT+1
[00260] 0000:             FCMOVE:       equ           FCEXCL+1             ; [GDJ]
[00261] 0000:             FDOTQT:       equ           FCMOVE+1             ; b0h
[00262] 0000:             FKEY:         equ           FDOTQT+1
[00263] 0000:             FKEYQ:        equ           FKEY+1               ; [GDJ]
[00264] 0000:             FALLOT:       equ           FKEYQ+1
[00265] 0000:             FERROR:       equ           FALLOT+1
[00266] 0000:             FSEE:         equ           FERROR+1
[00267] 0000:             FFORGET:      equ           FSEE+1
[00268] 0000:             FOUT:         equ           FFORGET+1
[00269] 0000:             FINP:         equ           FOUT+1
[00270] 0000:             FEF:          equ           FINP+1
[00271] 0000:             FSETQ:        equ           FEF+1
[00272] 0000:             FSAVE:        equ           FSETQ+1
[00273] 0000:             FLOAD:        equ           FSAVE+1
[00274] 0000:             FBYE:         equ           FLOAD+1
[00275] 0000:             FSPAT:        equ           FBYE+1
[00276] 0000:             FLTLT:        equ           FSPAT+1
[00277] 0000:             FGTGT:        equ           FLTLT+1
[00278] 0000:             FDELAY:       equ           FGTGT+1
[00279] 0000:             FBLOAD:       equ           FDELAY+1
[00280] 0000:             FRAND:        equ           FBLOAD+1
[00281] 0000:             FEXEC:        equ           FRAND+1
[00282] 0000:             FLIST:        equ           FEXEC+1
[00283] 0000:             FDOTX:        equ           FLIST+1
[00284] 0000:             FNEW:         equ           FDOTX+1
[00285] 0000:             FHERE:        equ           FNEW+1
[00286] 0000:             FTOHERE:      equ           FHERE+1
[00287] 0000:             FBASE:        equ           FTOHERE+1
[00288] 0000:             FENDIF:       equ           FBASE+1
[00289] 0000:             FRSEED:       equ           FENDIF+1
[00290] 0000:             FRPAT:        equ           FRSEED+1
[00291] 0000:             FOPAREN:      equ           FRPAT+1
[00292] 0000:             FOPT:         equ           FOPAREN+1
[00293] 0000:             FDOTTOK:      equ           FOPT+1
[00294] 0000:             FRPEXCL:      equ           FDOTTOK+1
[00295] 0000:             FRP0:         equ           FRPEXCL+1
[00296] 0000:             FSP0:         equ           FRP0+1
[00297] 0000:             FSPEXCL:      equ           FSP0+1
[00298] 0000:             FAPOS:        equ           FSPEXCL+1
[00299] 0000:             FEXECUTE:     equ           FAPOS+1
[00300] 0000:             FTIB:         equ           FEXECUTE+1
[00301] 0000:             FQUERY:       equ           FTIB+1
[00302] 0000:             FEXIT:        equ           FQUERY+1
[00303] 0000:             FAGAIN:       equ           FEXIT+1
[00304] 0000:             FQUIT:        equ           FAGAIN+1
[00305] 0000:             FCREATE:      equ           FQUIT+1
[00306] 0000:             FBRKQ:        equ           FCREATE+1
[00307]                   ; End of list, if adding, update LAST_TOK, below
[00308] 0000:             LAST_TOK:    equ            FBRKQ         ; don't forget to change this when adding more tokens
[00309]                   ; special tokens
[00310] 0000:             T_EOS:        equ           253                  ; end of command line
[00311] 0000:             T_NUM:        equ           255
[00312] 0000:             T_ASCII:      equ           254
[00313]                   
[00314]                   ; THIS IS THE MAIN PROGRAM (with header if using ELFOS)
[00315] 0000:                           org           FORTH
[00321]                   #endif
[00322]                   
[00323]                   
[00324]                   
[00325]                   ; MAIN ENTRY POINT FOR ROMs
[00326]                   #ifdef        ANYROM
[00327] d700: c0 d7 13                  lbr           new                  ; ROM cold entry point
[00328]                   notnew:
[00329] d703: f8 b3 a6 f8               mov           r6, old              ; ROM warm entry point
              d7 b6 
[00330]                   newornot:
[00331] d709: f8 ff a2 f8               mov           r2,stack
              01 b2 
[00332] d70f: e2                        sex           r2
[00333] d710: c0 ff 3f                  lbr           f_initcall
[00334] d713: f8 1b a6 f8 new:          mov           r6,start
              d7 b6 
[00335] d719: 30 09                     br            newornot             ; common code for warm or cold start
[00336]                   #endif
[00337]                   ; Cold start comes here after initcall
[00338] d71b: f8 04       start:        ldi           high himem           ; get page of data segment
[00339] d71d: b9                        phi           r9                   ; place into r9
[00340]                   #ifdef        ANYROM
[00341] d71e: f8 0c                     ldi           0ch                  ; form feed to clear screen
[00344]                   #else
[00345] d720: d4 ff 03                  call          f_type
[00346]                   #endif
[00347]                   #endif
[00348] d723: f8 5e af f8               mov           rf, hello            ; address of signon message
              e9 bf 
[00351]                   #else
[00352] d729: d4 ff 09                  call          f_msg                ; function to display a message
[00353]                   #endif
[00354] d72c: d4 d8 2f                  call          crlfout
[00355]                   ; ************************************************
[00356]                   ; **** Determine how much memory is installed ****
[00357]                   ; ************************************************
[00364]                   #endif
[00365]                   #ifndef       ELFOS
[00366] d72f: d4 ff 57                  call          f_freemem            ; ask BIOS for memory size
[00367] d732: 8f ab 9f bb               mov           rb,rf
[00368]                   #endif
[00369]                   ; If you want to override free memory (for example, to hide yourself in upper RAM) set this
[00372]                   #endif
[00373] d736: f8 00                     ldi           low himem
[00374] d738: a9                        plo           r9
[00375] d739: 9b                        ghi           rb
[00376] d73a: 59                        str           r9
[00377] d73b: b2                        phi           r2
[00378] d73c: 19                        inc           r9
[00379] d73d: 8b                        glo           rb
[00380] d73e: 59                        str           r9
[00381] d73f: a2                        plo           r2
[00382] d740: d4 d7 8e                  call          fresh
[00383] d743: d4 d7 56                  call          xnew
[00384]                   ; always load core external words
[00385] d746: d4 e6 b5                  call          cbloadcore
[00386]                   #ifdef        BLOAD_AUTO
[00387] d749: d4 e6 ad                  call          cbloadengext
[00388]                   #endif
[00389] d74c: 30 c2                     br            mainlp
[00390]                   
[00391]                   
[00392]                   ; the NEW word
[00393] d74e: d4 d7 56    cnew:         call          xnew                 ; user wants to start over. Do not BLOAD except core
[00394] d751: d4 e6 b5                  call          cbloadcore
[00395] d754: 30 c2                     br            mainlp
[00396]                   
[00397]                   ; Common stuff between NEW and startup
[00398]                   xnew:
[00399] d756: f8 06                     ldi           low freemem          ; set R9 to free memory
[00400] d758: a9                        plo           r9
[00401] d759: f8 04                     ldi           high storage         ; point to storage
[00402] d75b: 59                        str           r9
[00403] d75c: 19                        inc           r9
[00404] d75d: bf                        phi           rf
[00405] d75e: f8 15                     ldi           low storage
[00406] d760: 59                        str           r9
[00407] d761: af                        plo           rf
[00408] d762: f8 00                     ldi           0
[00409] d764: 5f                        str           rf                   ; write zeroes as storage terminator
[00410] d765: 1f                        inc           rf
[00411] d766: 5f                        str           rf
[00412]                   ; assume all variables are on the same page (they are)
[00413] d767: f8 11                     ldi           low basev
[00414] d769: af                        plo           rf
[00415] d76a: f8 00                     ldi           0
[00416] d76c: 5f                        str           rf
[00417] d76d: 1f                        inc           rf
[00418] d76e: f8 0a                     ldi           10
[00419] d770: 5f                        str           rf
[00420] d771: f8 13                     ldi           low option
[00421] d773: af                        plo           rf
[00422] d774: f8 00                     ldi           high DEF_OPTION
[00423] d776: 5f                        str           rf
[00424] d777: 1f                        inc           rf
[00425] d778: f8 00                     ldi           low DEF_OPTION
[00426] d77a: 5f                        str           rf
[00427]                                 ; init 32 bit rng seed
[00428]                    ;             mov           r7, 012A6h
[00429]                    ;             mov           rf, rseed
[00430] d77b: f8 0d                     ldi            low rseed
[00431] d77d: af                        plo           rf
[00432] d77e: f8 12                     ldi           12h
[00433] d780: 5f                        str           rf
[00434] d781: 1f                        inc           rf
[00435] d782: f8 a6                     ldi           0a6h
[00436] d784: 5f                        str           rf
[00437] d785: 1f                        inc           rf
[00438]                   ;              mov           r7, 0DC40h
[00439] d786: f8 dc                     ldi           0dch
[00440] d788: 5f                        str           rf
[00441] d789: 1f                        inc           rf
[00442] d78a: f8 40                     ldi           40h
[00443] d78c: 5f                        str           rf
[00444] d78d: d5                        rtn
[00445]                   ; shared code between new and old
[00446]                   fresh:
[00447] d78e: f8 0a                     ldi           low jump
[00448] d790: a9                        plo           r9
[00449] d791: f8 c0                     ldi           0c0h
[00450] d793: 59                        str           r9                   ; we use JUMP as a flag. C0 is normal
[00451] d794: f8 02                     ldi           low rstack           ; get return stack address
[00452] d796: a9                        plo           r9                   ; select in data segment
[00453] d797: 9b                        ghi           rb                   ; get hi memory
[00454] d798: ff 01                     smi           1                    ; 1 page lower for forth stack
[00455] d79a: 59                        str           r9                   ; write to pointer
[00456] d79b: 19                        inc           r9                   ; point to low byte
[00457] d79c: 8b                        glo           rb                   ; get low byte
[00458] d79d: 59                        str           r9                   ; and store
[00459] d79e: f8 04                     ldi           low tos              ; get stack address
[00460] d7a0: a9                        plo           r9                   ; select in data segment
[00461] d7a1: 9b                        ghi           rb                   ; get hi memory
[00462] d7a2: ff 02                     smi           2                    ; 2 page lower for forth stack
[00463] d7a4: 59                        str           r9                   ; write to pointer
[00464] d7a5: 19                        inc           r9                   ; point to low byte
[00465] d7a6: 8b                        glo           rb                   ; get low byte
[00466] d7a7: 59                        str           r9                   ; and store
[00467] d7a8: f8 08                     ldi           low fstack           ; get stack address
[00468] d7aa: a9                        plo           r9                   ; select in data segment
[00469] d7ab: 9b                        ghi           rb                   ; get hi memory
[00470] d7ac: ff 02                     smi           2                    ; 2 page lower for forth stack
[00471] d7ae: 59                        str           r9                   ; write to pointer
[00472] d7af: 19                        inc           r9                   ; point to low byte
[00473] d7b0: 8b                        glo           rb                   ; get low byte
[00474] d7b1: 59                        str           r9                   ; and store
[00475] d7b2: d5                        rtn
[00476]                   ; OLD entry point for warm start (after init)
[00477] d7b3: f8 00 a9 f8 old:          mov           r9,himem             ; load whole thing since this is an entry point
              04 b9 
[00478] d7b9: 49                        lda           r9                   ; retreive high memory
[00479] d7ba: bb                        phi           rb
[00480] d7bb: b2                        phi           r2                   ; and to machine stack
[00481] d7bc: 49                        lda           r9
[00482] d7bd: ab                        plo           rb
[00483] d7be: a2                        plo           r2
[00484] d7bf: d4 d7 8e                  call          fresh
[00485]                   ; fall through to main loop
[00486]                   ; *************************
[00487]                   ; *** Main program loop ***
[00488]                   ; *************************
[00489]                   mainlp:
[00490] d7c2: f8 6d af f8               mov           rf, prompt
              e9 bf 
[00491] d7c8: d4 e5 38                  call          ismulti
[00492] d7cb: 32 ce                     bz            mainprompt
[00493] d7cd: 2f                        dec           rf                   ; select alternate prompt
[00494]                   mainprompt:
[00497]                   #else
[00498] d7ce: d4 ff 09                  call          f_msg                ; function to display a message
[00499]                   #endif
[00500]                   cquit:
[00501] d7d1: d4 e5 14                  call          getvar
[00502] d7d4: 00                        db            low himem
[00503] d7d5: f8 02                     ldi           low rstack           ; reset rstack for naughty programs
[00504] d7d7: a9                        plo           r9
[00505] d7d8: 9a                        ghi           ra
[00506] d7d9: ff 01                     smi           1
[00507] d7db: 59                        str           r9
[00508] d7dc: 19                        inc           r9
[00509] d7dd: 8a                        glo           ra
[00510] d7de: 59                        str           r9
[00511] d7df: f8 00 af f8               mov           rf, buffer
              02 bf 
[00514]                   #else
[00515] d7e5: d4 ff 0f                  call          f_input              ; function to read a line
[00516]                   #endif
[00517] d7e8: cb d8 0b                  lbnf          mainent              ; jump if no ^C
[00518] d7eb: d4 ff 66                  call          f_inmsg
[00519] d7ee: 5e 43 0a 0d               db            '^C',10,13,0
              00 
[00520] d7f3: d4 e5 38                  call          ismulti
[00521] d7f6: 32 c2                     bz            mainlp               ; nope! Keep going
[00522] d7f8: f8 c0                     ldi           0C0h                 ; yes, turn it off and restore freemem
[00523] d7fa: 59                        str           r9
[00524] d7fb: 19                        inc           r9
[00525] d7fc: 49                        lda           r9
[00526] d7fd: af                        plo           rf
[00527] d7fe: 09                        ldn           r9
[00528] d7ff: bf                        phi           rf
[00529] d800: f8 06                     ldi           low freemem
[00530] d802: a9                        plo           r9
[00531] d803: 9f                        ghi           rf
[00532] d804: 59                        str           r9
[00533] d805: 19                        inc           r9
[00534] d806: 8f                        glo           rf
[00535] d807: 59                        str           r9
[00536] d808: c0 d7 c2                  lbr           mainlp
[00537]                   mainent:
[00538] d80b: d4 d8 2f                  call          crlfout
[00539] d80e: f8 00 af f8               mov           rf,buffer            ; convert to uppercase
              02 bf 
[00540] d814: d4 e7 87                  call          touc
[00541] d817: d4 da 1b                  call          tknizer
[00542]                   #ifdef USE_CBUFFER
[00543] d81a: f8 00 ab f8               mov           rb,cbuffer
              03 bb 
[00555]                   #endif
[00556] d820: 8b                        glo           rb
[00557] d821: 73                        stxd
[00558] d822: 9b                        ghi           rb
[00559] d823: 73                        stxd
[00560] d824: d4 dc 29                  call          exec
[00561]                   mainexec:
[00562] d827: 60 72 bb f0               pop           rb  ; order doesn't matter
              ab 
[00563] d82c: c0 d7 c2                  lbr           mainlp               ; return to beginning of main loop
[00564]                   crlfout:
[00565] d82f: d4 ff 66                  call          f_inmsg
[00566] d832: 0a 0d 00                  db            10,13,0
[00567] d835: d5                        rtn
[00568]                   ; **************************************
[00569]                   ; *** Display a space
[00570]                   ; **************************************
[00571] d836: f8 20       dispsp:       ldi           ' '
[00572] d838: 30 3b                     br            disp
[00573]                   ; **************************************
[00574]                   ; *** Display a character, char db after call
[00575]                   ; **************************************
[00576]                   dispf:
[00577] d83a: 46                        lda           r6                   ; get immediate character
[00578]                                 ;  fall through
[00579]                   ; **************************************
[00580]                   ; *** Display a character, char in D ***
[00581]                   ; **************************************
[00582]                   disp:
[00585]                   #else
[00586] d83b: c0 ff 03                  lbr           f_type
[00587]                   #endif
[00588]                   ; ********************************
[00589]                   ; *** Read a key, returns in D ***
[00590]                   ; ********************************
[00591]                   getkey:
[00594]                   #else
[00595] d83e: c0 ff 06                  lbr           f_read
[00596]                   #endif
[00597]                   ; There seems to be an assumption throughout that R9.1 is always the same
[00598]                   ; This is because it is only used to access the variables like freemem and jump
[00599]                   ; so it is assumed they are always on the same page, div16, for example, destroys
[00600]                   ; R9 and the caller has to preserve it
[00601]                   ; ***************************************************
[00602]                   ; *** Function to retrieve value from forth stack ***
[00603]                   ; *** Returns R[B] = value                        ***
[00604]                   ; ***         DF=0 no error, DF=1 error           ***
[00605]                   ; ***************************************************
[00606]                   pop:
[00614]                   #else
[00615] d841: d4 e5 14                  call          getvar
[00616] d844: 08                        db            low fstack
[00617]                   #endif
[00618] d845: f8 04                     ldi           low tos              ; pointer to maximum stack value
[00619] d847: a9                        plo           r9                   ; put into data frame
[00620] d848: 49                        lda           r9                   ; get high value
[00621] d849: 52                        str           r2                   ; place into memory
[00622] d84a: 9a                        ghi           ra                   ; get high byte of forth stack
[00623] d84b: f7                        sm                                 ; check if same
[00624] d84c: 3a 58                     bnz           stackok              ; jump if ok
[00625] d84e: 09                        ldn           r9                   ; get low byte of tos
[00626] d84f: 52                        str           r2
[00627] d850: 8a                        glo           ra                   ; check low byte of stack pointer
[00628] d851: f7                        sm
[00629] d852: 3a 58                     bnz           stackok              ; jump if ok
[00630] d854: f8 01                     ldi           1                    ; signal error
[00631] d856: f6          popret:       shr                                ; shift status into DF
[00632] d857: d5                        rtn                                ; return to caller
[00633] d858: 1a          stackok:      inc           ra                   ; point to high byte
[00634] d859: 4a                        lda           ra                   ; get it
[00635] d85a: bb                        phi           rb                   ; put into register
[00636] d85b: 0a                        ldn           ra                   ; get low byte
[00637] d85c: ab                        plo           rb
[00638] d85d: f8 08                     ldi           low fstack
[00639] d85f: a9                        plo           r9
[00640] d860: 9a                        ghi           ra
[00641] d861: 59                        str           r9
[00642] d862: 19                        inc           r9
[00643] d863: 8a                        glo           ra
[00644] d864: 59                        str           r9
[00645] d865: f8 00       noserr:       ldi           0                    ; signal no error
[00646] d867: 30 56                     br            popret               ; and return to caller
[00647]                   ; ********************************************************
[00648]                   ; *** Function to push value onto stack, value in R[B] ***
[00649]                   ; ********************************************************
[00650]                   push:
[00658]                   #else
[00659] d869: d4 e5 14                  call          getvar
[00660] d86c: 08                        db            low fstack
[00661]                   #endif
[00662] d86d: 8b                        glo           rb                   ; get low byte of value
[00663] d86e: 5a                        str           ra                   ; store on forth stack
[00664] d86f: 2a                        dec           ra                   ; point to next byte
[00665] d870: 9b                        ghi           rb                   ; get high value
[00666] d871: 5a                        str           ra                   ; store on forth stack
[00667] d872: 2a                        dec           ra                   ; point to next byte
[00668] d873: 8a                        glo           ra
[00669] d874: 59                        str           r9
[00670] d875: 29                        dec           r9
[00671] d876: 9a                        ghi           ra
[00672] d877: 59                        str           r9
[00673] d878: d5                        rtn                                ; return to caller
[00674]                   ; ****************************************************
[00675]                   ; *** Function to retrieve value from return stack ***
[00676]                   ; *** Returns R[B] = value                         ***
[00677]                   ; ***         D=0 no error, D=1 error              ***
[00678]                   ; ****************************************************
[00679]                   rpop:
[00687]                   #else
[00688] d879: d4 e5 14                   call          getvar
[00689] d87c: 02                        db            low rstack
[00690]                   #endif
[00691] d87d: 1a                        inc           ra                   ; point to high byte
[00692] d87e: 4a                        lda           ra                   ; get it
[00693] d87f: bb                        phi           rb                   ; put into r6
[00694] d880: 0a                        ldn           ra                   ; get low byte
[00695] d881: ab                        plo           rb
[00696] d882: 8a                        glo           ra
[00697] d883: 59                        str           r9
[00698] d884: 29                        dec           r9
[00699] d885: 9a                        ghi           ra
[00700] d886: 59                        str           r9
[00701] d887: 30 65                     br            noserr                       ; and return
[00702]                   ; ***************************************************************
[00703]                   ; *** Function to push value onto return stack, value in R[B] ***
[00704]                   ; ***************************************************************
[00705]                   rpush:
[00713]                   #else
[00714] d889: d4 e5 14                  call          getvar
[00715] d88c: 02                        db            low rstack
[00716]                   #endif
[00717] d88d: 8b                        glo           rb                   ; get low byte of value
[00718] d88e: 5a                        str           ra                   ; store on forth stack
[00719] d88f: 2a                        dec           ra                   ; point to next byte
[00720] d890: 9b                        ghi           rb                   ; get high value
[00721] d891: 5a                        str           ra                   ; store on forth stack
[00722] d892: 2a                        dec           ra                   ; point to next byte
[00723] d893: 8a                        glo           ra
[00724] d894: 59                        str           r9
[00725] d895: 29                        dec           r9
[00726] d896: 9a                        ghi           ra
[00727] d897: 59                        str           r9
[00728] d898: d5                        rtn                                ; return to caller
[00729]                   
[00730]                   ; ********************************************
[00731]                   ; *** Function to find stored name address ***
[00732]                   ; ***  Needs: name to search in R[8]       ***
[00733]                   ; ***  returns: R[B] first byte in data    ***
[00734]                   ; ***           R[7] Address of descriptor ***
[00735]                   ; ***           R[8] first addr after name ***
[00736]                   ; ***           DF = 1 if not found        ***
[00737]                   ; ********************************************
[00738]                   ; Experimental find last instead of first
[00739]                   ; Performance is bad but reversing the link list would be terrible
[00740]                   ; One idea is to make a parallel linked list external
[00741]                   ; or to extend the words to have front and back pointers but lots of work no matter what
[00742] d899: 8f 73 9f 73 findname:     push          rf                   ; we will clobber RF
[00743] d89d: 8a 73 9a 73               push          ra
[00744] d8a1: f8 00                     ldi           0
[00745] d8a3: aa                        plo           ra                   ; not found at all
[00746] d8a4: f8 15 ab f8               mov           rb, storage
              04 bb 
[00747] d8aa: 8b a7 9b b7 findlp:       mov           r7,rb
[00748] d8ae: 4b                        lda           rb                   ; get link address
[00749] d8af: 3a c6                     bnz           findgo               ; jump if nonzero
[00750] d8b1: 0b                        ldn           rb                   ; get low byte
[00751] d8b2: 3a c6                     bnz           findgo               ; more to search
[00752]                                 ; here when we have been through the whole list
[00753] d8b4: 8a                        glo           ra                   ; really not found?
[00754] d8b5: ca d9 05                  lbnz           findsuccess          ; oh yeah, we found it earlier
[00755] d8b8: f8 01                     ldi           1                    ; not found
[00756] d8ba: f6          findret:      shr                                ; set DF
[00757] d8bb: 60 72 ba f0               pop           ra
              aa 
[00758] d8c0: 60 72 bf f0               pop           rf                   ; restore caller's RF
              af 
[00759] d8c5: d5                        rtn                                ; and return to caller
[00760] d8c6: 1b          findgo:       inc           rb                   ; pointing now at type
[00761] d8c7: 1b                        inc           rb                   ; pointing at ascii indicator
[00762] d8c8: 1b                        inc           rb                   ; first byte of name
[00763] d8c9: 88 73 98 73               push          r8                   ; save requested name
[00764] d8cd: 08          findchk:      ldn           r8                   ; get byte from requested name
[00765] d8ce: 52                        str           r2                   ; place into memory
[00766] d8cf: 0b                        ldn           rb                   ; get byte from descriptor
[00767] d8d0: f7                        sm                                 ; compare equality
[00768] d8d1: ca d9 1b                  lbnz           findnext            ; jump if not found
[00769] d8d4: 08                        ldn           r8                   ; get byte
[00770] d8d5: 32 db                     bz            findfound            ; entry is found
[00771] d8d7: 18                        inc           r8                   ; increment positions
[00772] d8d8: 1b                        inc           rb
[00773] d8d9: 30 cd                     br            findchk              ; and keep looking
[00774]                   findfound:
[00775] d8db: 60 72 bf f0               pop           rf                   ; get old word pointer
              af 
[00776] d8e0: 8a                        glo           ra
[00777] d8e1: 32 e9                     bz            findfirst
[00778]                                 ; not our first
[00779] d8e3: 60                        irx                                ; yank previous result
[00780] d8e4: 60                        irx
[00781] d8e5: 60                        irx
[00782] d8e6: 60                        irx
[00783] d8e7: 60                        irx
[00784] d8e8: 60                        irx
[00785] d8e9: f8 01       findfirst:    ldi          1                     ; remember we found something
[00786] d8eb: aa                        plo          ra
[00787] d8ec: 87 73 97 73               push         r7
[00788] d8f0: 88 73 98 73               push         r8
[00789] d8f4: 8b 73 9b 73               push         rb
[00790]                   #ifdef OPT_BY_CALL
[00791] d8f8: d4 e5 2e                  call         testopt
[00792] d8fb: 02                        db           2                     ; find first or last?
[00798]                   #endif
[00799] d8fc: ca d9 05                  lbnz          findsuccess           ; find first instead of last so done!
[00800] d8ff: 8f 73 9f 73               push         rf                    ; old word pointer
[00801] d903: 30 1b                     br          findnext
[00802]                   
[00803]                   findsuccess:
[00804] d905: 60 72 bb f0               pop           rb
              ab 
[00805] d90a: 60 72 b8 f0               pop           r8
              a8 
[00806] d90f: 60 72 b7 f0               pop           r7
              a7 
[00807] d914: 1b                        inc           rb                   ; rb now points to data
[00808] d915: 18                        inc           r8                   ; move past terminator in name
[00809] d916: f8 00                     ldi           0                    ; signal success
[00810] d918: c0 d8 ba                  lbr           findret              ; and return to caller
[00811] d91b: 60 72 b8 f0 findnext:     pop           r8
              a8 
[00812] d920: 47                        lda           r7                   ; get next link address
[00813] d921: bb                        phi           rb
[00814] d922: 07                        ldn           r7
[00815] d923: ab                        plo           rb
[00816] d924: c0 d8 aa                  lbr            findlp               ; and check next entry
[00817]                   
[00818]                   
[00819]                   
[00820]                   ; *********************************************
[00821]                   ; *** Function to multiply 2 16 bit numbers *** rc,r8 = r7 * rb (moves answer to RB at end)
[00822]                   ; *********************************************
[00823] d927: f8 00       mul16:        ldi           0                    ; zero out total
[00824] d929: b8                        phi           r8                   ; R8=RC=0
[00825] d92a: a8                        plo           r8
[00826] d92b: bc                        phi           rc
[00827] d92c: ac                        plo           rc
[00828] d92d: 87          mulloop:      glo           r7                   ; get low of multiplier
[00829] d92e: 3a 38                     bnz           mulcont              ; continue multiplying if nonzero
[00830] d930: 97                        ghi           r7                   ; check hi byte as well
[00831] d931: 3a 38                     bnz           mulcont
[00832] d933: 88 ab 98 bb               mov           rb,r8
[00833] d937: d5                        rtn                                ; return to caller
[00834] d938: 97          mulcont:      ghi           r7                   ; shift multiplier
[00835] d939: f6                        shr
[00836] d93a: b7                        phi           r7
[00837] d93b: 87                        glo           r7
[00838] d93c: 76                        shrc
[00839] d93d: a7                        plo           r7
[00840] d93e: 3b 52                     bnf           mulcont2             ; loop if no addition needed
[00841] d940: 8b                        glo           rb                   ; add r8=rb+r8
[00842] d941: 52                        str           r2
[00843] d942: 88                        glo           r8
[00844] d943: f4                        add
[00845] d944: a8                        plo           r8
[00846] d945: 9b                        ghi           rb
[00847] d946: 52                        str           r2
[00848] d947: 98                        ghi           r8
[00849] d948: 74                        adc
[00850] d949: b8                        phi           r8
[00851] d94a: 8c                        glo           rc                   ; carry into high word (rc)
[00852] d94b: 7c 00                     adci          0
[00853] d94d: ac                        plo           rc
[00854] d94e: 9c                        ghi           rc
[00855] d94f: 7c 00                     adci          0
[00856] d951: bc                        phi           rc
[00857] d952: 8b          mulcont2:     glo           rb                   ; shift first number
[00858] d953: fe                        shl
[00859] d954: ab                        plo           rb
[00860] d955: 9b                        ghi           rb
[00861] d956: 7e                        shlc
[00862] d957: bb                        phi           rb
[00863] d958: 30 2d                     br           mulloop              ; loop until done
[00864]                   ; ************************************
[00865]                   ; *** make both arguments positive ***
[00866]                   ; *** Arg1 RB                      ***
[00867]                   ; *** Arg2 R7                      ***
[00868]                   ; *** Returns D=0 - signs same     ***
[00869]                   ; ***         D=1 - signs difer    ***
[00870]                   ; ************************************
[00871] d95a: 9b          mdnorm:       ghi           rb                   ; get high byte of divisor
[00872] d95b: 52                        str           r2                   ; store for sign check
[00873] d95c: 97                        ghi           r7                   ; get high byte of dividend
[00874] d95d: f3                        xor                                ; compare
[00875] d95e: fe                        shl                                ; shift into df
[00876] d95f: f8 00                     ldi           0                    ; convert to 0 or 1
[00877] d961: 7e                        shlc                               ; shift into D
[00878] d962: ae                        plo           re                   ; store into sign flag
[00879] d963: 9b                        ghi           rb                   ; need to see if RB is negative
[00880] d964: fe                        shl                                ; shift high byte to df
[00881] d965: 3b 70                     bnf           mdnorm2              ; jump if not
[00882] d967: 9b                        ghi           rb                   ; 2s compliment on RB
[00883] d968: fb ff                     xri           0ffh
[00884] d96a: bb                        phi           rb
[00885] d96b: 8b                        glo           rb
[00886] d96c: fb ff                     xri           0ffh
[00887] d96e: ab                        plo           rb
[00888] d96f: 1b                        inc           rb
[00889] d970: 97          mdnorm2:      ghi           r7                   ; now check r7 for negative
[00890] d971: fe                        shl                                ; shift sign bit into df
[00891] d972: 3b 7d                     bnf           mdnorm3              ; jump if not
[00892] d974: 97                        ghi           r7                   ; 2 compliment on R7
[00893] d975: fb ff                     xri           0ffh
[00894] d977: b7                        phi           r7
[00895] d978: 87                        glo           r7
[00896] d979: fb ff                     xri           0ffh
[00897] d97b: a7                        plo           r7
[00898] d97c: 17                        inc           r7
[00899] d97d: 8e          mdnorm3:      glo           re                   ; recover sign flag
[00900] d97e: d5                        rtn                                ; and return to caller
[00901]                   ; *** RC = RB/R7
[00902]                   ; *** R9 = remainder (the original doc says remainder but it isn't)
[00903]                   ; *** uses R8 and R9 (which is bad since we assume R9.1 stays the same all the time!)
[00904]                   ; the caller saves R9 though (only called in cdiv)
[00905] d97f: d4 d9 5a    div16:        call          mdnorm               ; normalize numbers
[00906] d982: ae                        plo           re                   ; save sign comparison
[00907] d983: f8 00                     ldi           0                    ; clear answer
[00908] d985: bc                        phi           rc
[00909] d986: ac                        plo           rc
[00910] d987: b8                        phi           r8                   ; set additive
[00911] d988: a8                        plo           r8
[00912] d989: 18                        inc           r8
[00913] d98a: 87                        glo           r7                   ; check for divide by 0
[00914] d98b: 3a 95                     bnz           d16lp1
[00915] d98d: 97                        ghi           r7
[00916] d98e: 3a 95                     bnz           d16lp1
[00917] d990: f8 ff                     ldi           0ffh                 ; return 0ffffh as div/0 error
[00918] d992: bc                        phi           rc
[00919] d993: ac                        plo           rc
[00920] d994: d5                        rtn                                ; return to caller
[00921] d995: 97          d16lp1:       ghi           r7                   ; get high byte from r7
[00922] d996: fa 80                     ani           080h                  ; check high bit
[00923] d998: 3a a8                     bnz           divst                ; jump if set
[00924] d99a: 87                        glo           r7                   ; lo byte of divisor
[00925] d99b: fe                        shl                                ; multiply by 2
[00926] d99c: a7                        plo           r7                   ; and put back
[00927] d99d: 97                        ghi           r7                   ; get high byte of divisor
[00928] d99e: 7e                        shlc                               ; continue multiply by 2
[00929] d99f: b7                        phi           r7                   ; and put back
[00930] d9a0: 88                        glo           r8                   ; multiply additive by 2
[00931] d9a1: fe                        shl
[00932] d9a2: a8                        plo           r8
[00933] d9a3: 98                        ghi           r8
[00934] d9a4: 7e                        shlc
[00935] d9a5: b8                        phi           r8
[00936] d9a6: 30 95                     br            d16lp1               ; loop until high bit set in divisor
[00937] d9a8: 87          divst:        glo           r7                   ; get low of divisor
[00938] d9a9: 3a bc                     bnz           divgo                ; jump if still nonzero
[00939] d9ab: 97                        ghi           r7                   ; check hi byte too
[00940] d9ac: 3a bc                     bnz           divgo
[00941] d9ae: 8e                        glo           re                   ; get sign flag
[00942] d9af: f6                        shr                                ; move to df
[00943] d9b0: 3b bb                     bnf           divret               ; jump if signs were the same
[00944] d9b2: 9c                        ghi           rc                   ; perform 2s compliment on answer
[00945] d9b3: fb ff                     xri           0ffh
[00946] d9b5: bc                        phi           rc
[00947] d9b6: 8c                        glo           rc
[00948] d9b7: fb ff                     xri           0ffh
[00949] d9b9: ac                        plo           rc
[00950] d9ba: 1c                        inc           rc
[00951] d9bb: d5          divret:       rtn                                ; jump if done
[00952] d9bc: 8b a9 9b b9 divgo:        mov           r9,rb
[00953] d9c0: 87                        glo           r7                   ; get lo of divisor
[00954] d9c1: 73                        stxd                               ; place into memory
[00955] d9c2: 60                        irx                                ; point to memory
[00956] d9c3: 8b                        glo           rb                   ; get low byte of dividend
[00957] d9c4: f7                        sm                                 ; subtract
[00958] d9c5: ab                        plo           rb                   ; put back into r6
[00959] d9c6: 97                        ghi           r7                   ; get hi of divisor
[00960] d9c7: 73                        stxd                               ; place into memory
[00961] d9c8: 60                        irx                                ; point to byte
[00962] d9c9: 9b                        ghi           rb                   ; get hi of dividend
[00963] d9ca: 77                        smb                                ; subtract
[00964] d9cb: bb                        phi           rb                   ; and put back
[00965] d9cc: 33 d4                     bdf           divyes               ; branch if no borrow happened
[00966] d9ce: 89 ab 99 bb               mov           rb,r9                ; recover copy
[00967] d9d2: 30 e0                     br            divno                ; jump to next iteration
[00968] d9d4: 88          divyes:       glo           r8                   ; get lo of additive
[00969] d9d5: 73                        stxd                               ; place in memory
[00970] d9d6: 60                        irx                                ; point to byte
[00971] d9d7: 8c                        glo           rc                   ; get lo of answer
[00972] d9d8: f4                        add                                ; and add
[00973] d9d9: ac                        plo           rc                   ; put back
[00974] d9da: 98                        ghi           r8                   ; get hi of additive
[00975] d9db: 73                        stxd                               ; place into memory
[00976] d9dc: 60                        irx                                ; point to byte
[00977] d9dd: 9c                        ghi           rc                   ; get hi byte of answer
[00978] d9de: 74                        adc                                ; and continue addition
[00979] d9df: bc                        phi           rc                   ; put back
[00980] d9e0: 97          divno:        ghi           r7                   ; get hi of divisor
[00981] d9e1: f6                        shr                                ; divide by 2
[00982] d9e2: b7                        phi           r7                   ; put back
[00983] d9e3: 87                        glo           r7                   ; get lo of divisor
[00984] d9e4: 76                        shrc                               ; continue divide by 2
[00985] d9e5: a7                        plo           r7
[00986] d9e6: 98                        ghi           r8                   ; get hi of divisor
[00987] d9e7: f6                        shr                                ; divide by 2
[00988] d9e8: b8                        phi           r8                   ; put back
[00989] d9e9: 88                        glo           r8                   ; get lo of divisor
[00990] d9ea: 76                        shrc                               ; continue divide by 2
[00991] d9eb: a8                        plo           r8
[00992] d9ec: 30 a8                     br            divst                ; next iteration
[00993]                   
[00994]                   
[00995]                   cquery:
[00996] d9ee: d4 d8 41                call            pop
[00997] d9f1: c3 dd 2d                lbdf            error
[00998] d9f4: 8b af 9b bf             mov             rf,rb
[00999] d9f8: d4 d8 41                call            pop
[01000] d9fb: c3 dd 2d                lbdf            error
[01001] d9fe: 8b ac 9b bc             mov             rc,rb     ; count
[01002] da02: 8f 73 9f 73             push            rf
[01003] da06: d4 ff 69                call            f_inputl
[01004] da09: 60 72 bf f0             pop             rf
              af 
[01005] da0e: cb dd 2a                lbnf            good
[01006] da11: f8 03                   ldi            3
[01007] da13: 5f                      str            rf
[01008] da14: 1f                      inc            rf
[01009] da15: f8 00                   ldi            0
[01010] da17: 5f                      str            rf
[01011] da18: c0 dd 2a    qgood:      lbr             good
[01012]                   
[01013]                   ; ***************************
[01014]                   ; *** Setup for tokenizer ***
[01015]                   ; ***************************
[01016] da1b: f8 00 ab f8 tknizer:      mov           rb, buffer
              02 bb 
[01017]                   tknizerb:
[01018]                   #ifdef USE_CBUFFER
[01019] da21: f8 00 af f8               mov           rf,cbuffer
              03 bf 
[01032]                   #endif
[01033]                   ; ******************************
[01034]                   ; *** Now the tokenizer loop ***
[01035]                   ; ******************************
[01036] da27: 0b          tokenlp:      ldn           rb                   ; get byte from buffer
[01037] da28: c2 dc 21                  lbz           tokendn              ; jump if found terminator
[01038] da2b: ff 21                     smi           (' '+1)              ; check for whitespace
[01039] da2d: 33 32                     bdf           nonwhite             ; jump if not whitespace
[01040] da2f: 1b                        inc           rb                   ; move past white space
[01041] da30: 30 27                     br            tokenlp              ; and keep looking
[01042]                   ; ********************************************
[01043]                   ; *** Prepare to check against token table ***
[01044]                   ; ********************************************
[01045]                   nonwhite:
[01046] da32: 0b                        ldn           rb
[01047]                   #ifndef NO_TOKEN_COMPRESSION
[01048] da33: ff ff                     smi           T_NUM                 ; check for T_NUM
[01049] da35: 3a 42                     bnz           tkstrck
[01050] da37: 4b                        lda           rb                   ; load tokenized number
[01051] da38: 5f                        str           rf
[01052] da39: 1f                        inc           rf
[01053] da3a: 4b                        lda           rb
[01054] da3b: 5f                        str           rf
[01055] da3c: 1f                        inc           rf
[01056] da3d: 4b                        lda           rb
[01057]                   copytoken:
[01058] da3e: 5f                        str           rf
[01059] da3f: 1f                        inc           rf
[01060] da40: 30 27                      br            tokenlp              ; go get more
[01061]                   
[01062]                   tkstrck:                                        ; test for string token
[01063] da42: 0b                        ldn           rb
[01064] da43: ff fe                     smi           T_ASCII
[01065] da45: 3a 4e                     bnz           tkcompck
[01066]                   tkstrcpy:
[01067] da47: 4b                        lda           rb                  ; found a string
[01068] da48: 5f                        str           rf
[01069] da49: 1f                        inc           rf
[01070] da4a: 3a 47                     bnz           tkstrcpy
[01071] da4c: 30 27                     br            tokenlp
[01072]                   
[01073]                   
[01074]                   tkcompck:
[01075] da4e: 0b                        ldn           rb
[01076] da4f: ff 7f                     smi           07fh
[01077] da51: 4b                        lda           rb
[01078] da52: 33 ac                     bdf           copycmdtk           ; will handle ." but needs a space after: db FDOTQT,20h,T_ASCII,'foo"',...
[01079] da54: 2b                        dec           rb
[01080] da55: 0b                        ldn           rb
[01081]                   #endif
[01082] da56: ff 5c                     smi           '\'                  ; possible comment
[01083] da58: 3a 67                     bnz           noncom
[01084] da5a: 1b                        inc           rb
[01085] da5b: 0b                        ldn           rb
[01086] da5c: 2b                        dec           rb
[01087] da5d: ff 21                     smi           (' '+1)
[01088] da5f: 33 32                     bdf           nonwhite             ; nope, not a comment, just something that starts with \
[01089] da61: f8 00                     ldi           0
[01090] da63: 5b                        str           rb
[01091] da64: c0 dc 21                  lbr           tokendn              ; zero it and ignore all else
[01092]                   noncom:
[01093] da67: f8 8e a7 f8               mov           r7,cmdTable
              e9 b7 
[01094] da6d: f8 01                     ldi           1                    ; first command number
[01095] da6f: a8                        plo           r8                   ; r8 will keep track of command number
[01096]                   ; **************************
[01097]                   ; *** Command check loop ***
[01098]                   ; **************************
[01099] da70: 8b ac 9b bc cmdloop:      mov           rc,rb                ; save buffer address
[01100]                   ; ************************
[01101]                   ; *** Check next token ***
[01102]                   ; ************************
[01103] da74: 07          tokloop:      ldn           r7                   ; get byte from token table
[01104] da75: fa 80                     ani           080h                  ; check if last byte of token
[01105] da77: 3a 96                     bnz           cmdend               ; jump if last byte
[01106] da79: 07                        ldn           r7                   ; reget token byte
[01107] da7a: 52                        str           r2                   ; store to stack
[01108] da7b: 0b                        ldn           rb                   ; get byte from buffer
[01109] da7c: f7                        sm                                 ; do bytes match?
[01110] da7d: 3a 83                     bnz           toknomtch            ; jump if no match
[01111] da7f: 17                        inc           r7                   ; incrment token pointer
[01112] da80: 1b                        inc           rb                   ; increment buffer pointer
[01113] da81: 30 74                     br            tokloop              ; and keep looking
[01114]                   ; *********************************************************
[01115]                   ; *** Token failed match, move to next and reset buffer ***
[01116]                   ; *********************************************************
[01117] da83: 8c ab 9c bb toknomtch:    mov           rb,rc                ; recover saved address
[01118] da87: 07          nomtch1:      ldn           r7                   ; get byte from token
[01119] da88: fa 80                     ani           080h                  ; looking for last byte of token
[01120] da8a: 3a 8f                     bnz           nomtch2              ; jump if found
[01121] da8c: 17                        inc           r7                   ; point to next byte
[01122] da8d: 30 87                     br            nomtch1              ; and keep looking
[01123] da8f: 17          nomtch2:      inc           r7                   ; point to next token
[01124] da90: 18                        inc           r8                   ; increment command number
[01125] da91: 07                        ldn           r7                   ; get next token byte
[01126] da92: 3a 70                     bnz          cmdloop              ; jump if more tokens to check
[01127] da94: 30 dd                     br            notoken              ; jump if no token found
[01128]                   ; ***********************************************************
[01129]                   ; *** Made it to last byte of token, check remaining byte ***
[01130]                   ; ***********************************************************
[01131] da96: 07          cmdend:       ldn           r7                   ; get byte fro token
[01132] da97: fa 7f                     ani           07fh                 ; strip off end code
[01133] da99: 52                        str           r2                   ; save to stack
[01134] da9a: 0b                        ldn           rb                   ; get byte from buffer
[01135] da9b: f7                        sm                                 ; do they match
[01136] da9c: 3a 83                     bnz           toknomtch            ; jump if not
[01137] da9e: 1b                        inc           rb                   ; point to next byte
[01138] da9f: 0b                        ldn           rb                   ; get it
[01139]                   #ifndef NO_TOKEN_COMPRESSION
[01140] daa0: fa 80                     ani           080h
[01141] daa2: 3a a9                     bnz           tmatch               ; treat a compressed token as end of string just like white space
[01142] daa4: 0b                        ldn           rb
[01143]                   #endif
[01144] daa5: ff 21                     smi           (' '+1)              ; it must be whitespace
[01145] daa7: 33 83                     bdf           toknomtch            ; otherwise no match
[01146]                   ; *************************************************************
[01147]                   ; *** Match found, store command number into command buffer ***
[01148]                   ; *************************************************************
[01149]                   tmatch:
[01150] daa9: 88                        glo           r8                   ; get command number
[01151] daaa: f9 80                     ori           080h                  ; set high bit
[01152] daac: a8          copycmdtk:    plo           r8                   ; redundant UNLESS we jump to copycmdtk from elsewhere
[01153] daad: ff ce                     smi          FOPAREN
[01154] daaf: 3a c3                     bnz          tksto
[01155]                   tkcomloop:
[01156] dab1: 4b                        lda          rb
[01157] dab2: ff 21                     smi          (' '+1)
[01158] dab4: 33 b1                     bdf          tkcomloop             ; must be <space>)<space> to close
[01159] dab6: 4b                        lda          rb
[01160] dab7: fd 29                     sdi          ')'
[01161] dab9: 3a b1                     bnz          tkcomloop
[01162] dabb: 4b                        lda          rb
[01163] dabc: ff 21                     smi           (' '+1)              ; check for whitespace
[01164] dabe: 33 b1                     bdf          tkcomloop
[01165] dac0: 2b                        dec          rb                    ; let tokenizer swallow the space (might be the last one)
[01166] dac1: 30 27                     br          tokenlp
[01167]                   tksto:
[01168] dac3: 88                        glo           r8
[01169] dac4: 5f                        str           rf                   ; write to command buffer
[01170]                   
[01182]                   #endif
[01183]                   copycmdckq:
[01184] dac5: 1f                        inc           rf
[01185] dac6: 88                        glo           r8
[01186] dac7: ff b0                     smi           FDOTQT               ; check for ." function
[01187] dac9: 3a 27                     bnz          tokenlp              ; jump if not
[01188] dacb: 1b                        inc           rb                   ; move past first space
[01189] dacc: f8 fe                     ldi           T_ASCII              ; need an ascii token
[01190] dace: 5f          tdotqtlp:     str           rf                   ; write to command buffer
[01191] dacf: 1f                        inc           rf
[01192] dad0: ff 22                     smi           022h                 ; read to quote
[01193] dad2: 32 d7                     bz            tdotqtdn             ; jump if found
[01194] dad4: 4b                        lda           rb                   ; transfer character to code
[01195] dad5: 30 ce                     br            tdotqtlp             ; and keep looking
[01196] dad7: f8 00       tdotqtdn:     ldi           0                    ; need string terminator
[01197] dad9: 5f                        str           rf
[01198] dada: 1f                        inc           rf
[01199] dadb: 30 27                     br           tokenlp              ; then continue tokenizing
[01200]                   ; ------------------------------------------------------------------------
[01201]                   ;     DECIMAL handler  if not valid decimal then proceed to ascii        ;
[01202]                   ; ------------------------------------------------------------------------
[01203]                   notoken:                                         ; get number BASE [GDJ]
[01204] dadd: 8b ac 9b bc               mov           rc,rb
[01205] dae1: 0b                        ldn           rb
[01206] dae2: ff 22                     smi           22h                  ; single quote
[01207] dae4: ca db 09                  lbnz           nocconst
[01208] dae7: 1b                        inc           rb
[01209] dae8: 1b                        inc           rb
[01210] dae9: 4b                        lda           rb
[01211] daea: ff 22                     smi           22h
[01212] daec: ca db 05                  lbnz           nocconstpop
[01213] daef: 0b                        ldn           rb
[01214] daf0: fa 80                     ani           080h
[01215] daf2: 3a fa                     bnz           cconstdn
[01216] daf4: 0b                        ldn           rb
[01217] daf5: ff 21                     smi           (' '+1)              ; check for whitespace
[01218] daf7: c3 db 05                  lbdf           nocconstpop
[01219]                   cconstdn:
[01220] dafa: 2b                        dec           rb
[01221] dafb: 2b                        dec           rb
[01222] dafc: f8 00                     ldi           0
[01223] dafe: b7                        phi           r7
[01224] daff: 4b                        lda           rb
[01225] db00: a7                        plo           r7
[01226] db01: 1b                        inc           rb
[01227] db02: c0 db 9f                  lbr           numberdn1
[01228]                   
[01229]                   
[01230]                   
[01231] db05: 8c ab 9c bb nocconstpop:  mov           rb,rc
[01232]                   nocconst:
[01233] db09: 0b                        ldn           rb
[01234] db0a: ff 30                     smi           '0'
[01235] db0c: ca db 24                  lbnz           notokenbase          ; if no leading 0 can't be 0x or 0#
[01236] db0f: 1b                        inc           rb
[01237] db10: 0b                        ldn           rb
[01238] db11: ff 58                     smi           'X'
[01239] db13: c2 db 1b                  lbz            notoken_0            ; 0xHexNumber
[01240] db16: 0b                        ldn           rb
[01241] db17: ff 23                     smi           '#'
[01242] db19: 3a 23                     bnz           notokenbaseadj       ; 0#DecNumber
[01243]                   notoken_0:
[01244] db1b: 0b                        ldn           rb
[01245] db1c: 1b                        inc           rb
[01246] db1d: ff 58                     smi           'X'
[01247] db1f: 32 ac                     bz            hexnum
[01248] db21: 30 2c                     br            decnum
[01249] db23: 2b          notokenbaseadj: dec           rb                   ; point back at 0
[01250]                   notokenbase:
[01251]                   ;              mov           rd, basen
[01252]                   ;              ldn           rd
[01253] db24: f8 12                     ldi            low basen
[01254] db26: a9                        plo            r9
[01255] db27: 09                        ldn            r9
[01256] db28: ff 0a                     smi           10
[01257] db2a: 3a ac                     bnz           hexnum
[01258]                   decnum:
[01259] db2c: 8b ac 9b bc               mov           rc,rb                ; save pointer in case of bad number
[01260] db30: f8 00                     ldi           0
[01261] db32: bd                        phi           rd
[01262] db33: ad                        plo           rd
[01263] db34: ae                        plo           re
[01264] db35: 0b                        ldn           rb                   ; get byte
[01265] db36: ff 2d                     smi           '-'                  ; is it negative
[01266] db38: 3a 3f                     bnz           notoken1             ; jump if not
[01267] db3a: 1b                        inc           rb                   ; move past negative
[01268] db3b: f8 01                     ldi           1                    ; set negative flag
[01269] db3d: ae                        plo           re
[01270] db3e: ad                        plo           rd
[01271] db3f: 0b          notoken1:     ldn           rb                   ; get byte
[01272] db40: ff 30                     smi           '0'                  ; check for below numbers
[01273] db42: 3b f8                     bnf          nonnumber            ; jump if not a number
[01274] db44: 0b                        ldn           rb
[01275] db45: ff 3a                     smi           ('9'+1)
[01276] db47: 33 f8                     bdf          nonnumber
[01277]                   ; **********************
[01278]                   ; *** Found a number ***
[01279]                   ; **********************
[01280] db49: f8 00       isnumber:     ldi           0                    ; number starts out as zero
[01281] db4b: b7                        phi           r7                   ; use r7 to compile number
[01282] db4c: a7                        plo           r7
[01283] db4d: 97          numberlp:     ghi           r7                   ; copy number to temp (don't use MOV because we need to know LOW was last)
[01284] db4e: b8                        phi           r8
[01285] db4f: 87                        glo           r7
[01286] db50: a8                        plo           r8
[01287]                                 ; already loaded r7
[01288]                   ;      glo     r7		;mulitply by 2
[01289] db51: fe                        shl
[01290] db52: a7                        plo           r7
[01291] db53: 97                        ghi           r7
[01292] db54: 7e                        shlc
[01293] db55: b7                        phi           r7
[01294] db56: 87                        glo           r7                   ; mulitply by 4
[01295] db57: fe                        shl
[01296] db58: a7                        plo           r7
[01297] db59: 97                        ghi           r7
[01298] db5a: 7e                        shlc
[01299] db5b: b7                        phi           r7
[01300] db5c: 88                        glo           r8                   ; multiply by 5
[01301] db5d: 52                        str           r2
[01302] db5e: 87                        glo           r7
[01303] db5f: f4                        add
[01304] db60: a7                        plo           r7
[01305] db61: 98                        ghi           r8
[01306] db62: 52                        str           r2
[01307] db63: 97                        ghi           r7
[01308] db64: 74                        adc
[01309] db65: b7                        phi           r7
[01310] db66: 87                        glo           r7                   ; mulitply by 10
[01311] db67: fe                        shl
[01312] db68: a7                        plo           r7
[01313] db69: 97                        ghi           r7
[01314] db6a: 7e                        shlc
[01315] db6b: b7                        phi           r7
[01316] db6c: 4b                        lda           rb                   ; get byte from buffer
[01317] db6d: ff 30                     smi           '0'                  ; convert to numeric
[01318] db6f: 52                        str           r2                   ; store it
[01319] db70: 87                        glo           r7                   ; add to number
[01320] db71: f4                        add
[01321] db72: a7                        plo           r7
[01322] db73: 97                        ghi           r7                   ; propagate through high byte
[01323] db74: 7c 00                     adci          0
[01324] db76: b7                        phi           r7
[01325] db77: 0b                        ldn           rb                   ; get byte
[01326]                   #ifndef NO_TOKEN_COMPRESSION
[01327] db78: fa 80                     ani           080h
[01328] db7a: 3a 93                     bnz           numberdn
[01329] db7c: 0b                        ldn           rb
[01330]                   #endif                             ;
[01331] db7d: ff 21                     smi           (' '+1)              ; check for space
[01332] db7f: 3b 93                     bnf           numberdn             ; number also done
[01333] db81: 0b                        ldn           rb
[01334] db82: ff 30                     smi           '0'                  ; check for below numbers
[01335] db84: 3b 8d                     bnf           numbererr            ; jump if not a number
[01336] db86: 0b                        ldn           rb
[01337] db87: ff 3a                     smi           ('9'+1)
[01338] db89: 33 8d                     bdf           numbererr
[01339] db8b: 30 4d                     br            numberlp             ; get rest of number
[01340] db8d: 8c ab 9c bb numbererr:    mov           rb,rc                ; recover address
[01341] db91: 30 f8                     br           nonnumber
[01342] db93: 8e          numberdn:     glo           re                   ; get negative flag
[01343] db94: 32 9f                     bz            numberdn1            ; jump if positive number
[01344] db96: 97                        ghi           r7                   ; negative, so 2s compliment number
[01345] db97: fb ff                     xri           0ffh
[01346] db99: b7                        phi           r7
[01347] db9a: 87                        glo           r7
[01348] db9b: fb ff                     xri           0ffh
[01349] db9d: a7                        plo           r7
[01350] db9e: 17                        inc           r7
[01351] db9f: f8 ff       numberdn1:    ldi           T_NUM                ; code to signify a number
[01352] dba1: 5f                        str           rf                   ; write to code buffer
[01353] dba2: 1f                        inc           rf                   ; point to next position
[01354] dba3: 97                        ghi           r7                   ; get high byte of number
[01355] dba4: 5f                        str           rf                   ; write to code buffer
[01356] dba5: 1f                        inc           rf                   ; point to next position
[01357] dba6: 87                        glo           r7                   ; get lo byte of numbr
[01358] dba7: 5f                        str           rf                   ; write to code buffer
[01359] dba8: 1f                        inc           rf                   ; point to next position
[01360] dba9: c0 da 27                  lbr           tokenlp              ; continue reading tokens
[01361]                   ; ------------------------------------------------------------------------
[01362]                   ;       HEX handler  if not valid decimal then proceed to ascii          ;
[01363]                   ; ------------------------------------------------------------------------
[01364]                                 ; [GDJ]
[01365] dbac: f8 00       hexnum:       ldi           0h                   ; clear return value
[01366] dbae: a7                        plo           r7
[01367] dbaf: b7                        phi           r7
[01368] dbb0: 8b ac 9b bc               mov           rc,rb                ; save pointer in case of bad number
[01369]                                 ; for first pass we reject non hex chars
[01370]                                 ; in next pass this check has already been done but we
[01371]                                 ; have to deal with the different offsets here for ascii to binary
[01372]                                 ; Note: all strings have been converted to upper case previously
[01373] dbb4: 0b          tohexlp:      ldn           rb                   ; get next byte
[01374] dbb5: ff 30                     smi           '0'                  ; check for bottom of range
[01375] dbb7: 3b f8                     bnf           nonnumber            ; jump if non-numeric
[01376] dbb9: 0b                        ldn           rb                   ; recover byte
[01377] dbba: ff 3a                     smi           '9'+1                ; upper range of digits
[01378] dbbc: 3b ca                     bnf           tohexd               ; jump if digit
[01379] dbbe: 0b                        ldn           rb                   ; recover character
[01380] dbbf: ff 41                     smi           'A'                  ; check below uc A
[01381] dbc1: 3b f8                     bnf           nonnumber            ; jump if not hex character
[01382] dbc3: 0b                        ldn           rb                   ; recover character
[01383] dbc4: ff 47                     smi           'F'+1                ; check for above uc F
[01384] dbc6: 33 f8                     bdf           nonnumber            ; jump if not hex character
[01385] dbc8: 30 cf                     br            tohex
[01386] dbca: 0b          tohexd:       ldn           rb                   ; recover character 0..9
[01387] dbcb: ff 30                     smi           '0'                  ; convert to binary
[01388] dbcd: 30 d2                     br            tohexad
[01389] dbcf: 0b          tohex:        ldn           rb                   ; recover character A..F
[01390] dbd0: ff 37                     smi           55                   ; convert to binary ('A'-10)
[01391] dbd2: 52          tohexad:      str           r2                   ; store value to add
[01392] dbd3: f8 04                     ldi           4                    ; need to shift 4 times
[01393] dbd5: ae                        plo           re
[01394] dbd6: 87          tohexal:      glo           r7
[01395] dbd7: fe                        shl
[01396] dbd8: a7                        plo           r7
[01397] dbd9: 97                        ghi           r7
[01398] dbda: 7e                        shlc
[01399] dbdb: b7                        phi           r7
[01400] dbdc: 2e                        dec           re                   ; decrement count
[01401] dbdd: 8e                        glo           re                   ; get count
[01402] dbde: 3a d6                     bnz           tohexal              ; loop until done
[01403] dbe0: 87                        glo           r7                   ; now add in new value
[01404] dbe1: f1                        or                                 ; or with stored byte
[01405] dbe2: a7                        plo           r7
[01406] dbe3: 1b                        inc           rb
[01407] dbe4: 0b                        ldn           rb
[01408]                   #ifndef NO_TOKEN_COMPRESSION
[01409] dbe5: fa 80                     ani           080h
[01410] dbe7: 3a 9f                     bnz          numberdn1
[01411] dbe9: 0b                        ldn           rb
[01412]                   #endif
[01413] dbea: ff 21                     smi           (' '+1)              ; check for space
[01414] dbec: 3b 9f                     bnf          numberdn1            ; number is complete
[01415]                                 ; words that begin with valid hex chars but have
[01416]                                 ; embedded non hex characters get filtered out here
[01417] dbee: 0b                        ldn           rb
[01418] dbef: d4 e8 32                  call          ishex                ; check for hex character
[01419] dbf2: 33 b4                     bdf           tohexlp              ; loop back if so else
[01420]                                 ; we dont have a hex char
[01421]                                 ; we got here since this was not a valid hex number
[01422] dbf4: 8c ab 9c bb nothexnum:    mov           rb,rc                ; retrieve pointer
[01423]                   ; *************************************************************
[01424]                   ; *** Neither token or number found, insert as ascii string ***
[01425]                   ; *************************************************************
[01426] dbf8: 2b          nonnumber:    dec           rb                   ; account for first increment
[01427] dbf9: f8 12                     ldi           low basen
[01428] dbfb: a9                        plo           r9
[01429] dbfc: 09                        ldn           r9
[01430] dbfd: ff 0a                     smi           10
[01431] dbff: 3a 05                     bnz           nonnumber1
[01432] dc01: 8d                        glo           rd
[01433] dc02: 32 05                     bz            nonnumber1
[01434] dc04: 2b                        dec           rb                   ; account for previous minus sign in DECIMAL mode
[01435]                   nonnumber1:
[01436] dc05: f8 fe                     ldi           T_ASCII              ; indicate ascii to follow
[01437] dc07: 5f          notokenlp:    str           rf                   ; write to buffer
[01438] dc08: 1f                        inc           rf                   ; advance to next position
[01439] dc09: 1b                        inc           rb                   ; point to next position
[01440] dc0a: 0b                        ldn           rb                   ; get next byte
[01441]                   #ifndef NO_TOKEN_COMPRESSION
[01442] dc0b: fa 80                     ani          080h                  ; treat a compressed token as whitespace
[01443] dc0d: ca dc 1a                  lbnz          notokwht
[01444] dc10: 0b                        ldn          rb
[01445]                   #endif
[01446] dc11: ff 21                     smi           (' '+1)              ; check for whitespace
[01447] dc13: cb dc 1a                  lbnf           notokwht             ; found whitespace
[01448] dc16: 0b                        ldn           rb                   ; get byte
[01449] dc17: c0 dc 07                  lbr            notokenlp            ; get characters til whitespace
[01450] dc1a: f8 00       notokwht:     ldi           0                    ; need ascii terminator
[01451] dc1c: 5f                        str           rf                   ; store into buffer
[01452] dc1d: 1f                        inc           rf                   ; point to next position
[01453] dc1e: c0 da 27                  lbr           tokenlp              ; and keep looking
[01454] dc21: f8 fd       tokendn:      ldi           T_EOS
[01455] dc23: 5f                        str           rf
[01456] dc24: 1f                        inc           rf
[01457] dc25: f8 00                     ldi           0                    ; need to terminate command string
[01458] dc27: 5f                        str           rf                   ; write to buffer
[01459] dc28: d5                        rtn                                ; return to caller
[01460]                   
[01461]                   
[01462]                   ; ****************************************************
[01463]                   ; *** Execute forth byte codes, RB points to codes ***
[01464]                   ; ****************************************************
[01465]                   exec:
[01466]                   #ifdef OPT_BY_CALL
[01467] dc29: d4 e5 2e                  call            testopt           ; debug on?
[01468] dc2c: 80                        db              080h
[01474]                   #endif
[01475] dc2d: 32 75                     bz            nodebug
[01476] dc2f: 8b 73 9b 73               push          rb
[01477] dc33: 8b af 9b bf               mov           rf,rb
[01478] dc37: f8 85 a8 f8               mov           r8,debug_hook
              e9 b8 
[01479] dc3d: d4 d8 99                  call          findname
[01480] dc40: 33 70                     bdf          nodebugpop
[01481]                   #ifdef OPT_BY_CALL
[01482] dc42: d4 e5 2e                  call          testopt              ; clear debug flag while calling debug hook
[01483] dc45: 7f                        db            07fh
[01489]                   #endif
[01490] dc46: 59                        str           r9                   ; already points to low
[01491] dc47: 17                        inc           r7
[01492] dc48: 17                        inc           r7
[01493] dc49: 88                        glo           r8                  ; PUSH R8 (backwards from SCRT order)
[01494] dc4a: 73                        stxd
[01495] dc4b: 98                        ghi           r8
[01496] dc4c: 73                        stxd
[01497] dc4d: 8b a8 9b b8               mov           r8,rb
[01498] dc51: 8f ab 9f bb               mov           rb,rf
[01499] dc55: d4 d8 69                  call          push                ; push RB for exec then reload RB
[01500] dc58: 88 ab 98 bb               mov           rb,r8
[01501] dc5c: d4 dc 29                  call          exec
[01502] dc5f: 60                        irx                               ; remove old RB
[01503] dc60: 60                        irx
[01504]                   #ifdef OPT_BY_CALL
[01505] dc61: d4 e5 2e                  call         testopt
[01506] dc64: 40                        db           40h                  ; request to turn off debugging?
[01512]                   #endif
[01513]                   
[01514] dc65: 32 6c                     bz           dbgresume
[01515] dc67: 09                        ldn          r9
[01516] dc68: fa 3f                     ani          03fh
[01517] dc6a: 30 6f                     br           dbgreset
[01518]                   dbgresume:
[01519] dc6c: 09                        ldn          r9                   ; put debug back on
[01520] dc6d: f9 80                     ori          80h
[01521]                   dbgreset:
[01522] dc6f: 59                        str          r9
[01523] dc70: 60 72 bb f0 nodebugpop:   pop          rb                     ; restore RB from old R8
              ab 
[01524]                   nodebug:
[01525] dc75: 0b                        ldn           rb                   ; get byte from codestream
[01526] dc76: c2 e3 75                  lbz           execdn               ; jump if at end of stream
[01527] dc79: ff fd                     smi           T_EOS
[01528] dc7b: c2 e3 75                  lbz           execdn
[01529] dc7e: d4 e5 38                  call          ismulti
[01530] dc81: 32 8e                     bz            execnorm
[01531] dc83: 8b 73 9b 73               push          rb
[01532] dc87: 8b                        glo           rb                   ; save rb (backwards from SCRT order)
[01533] dc88: 73                        stxd
[01534] dc89: 9b                        ghi           rb
[01535] dc8a: 73                        stxd
[01536] dc8b: c0 e1 6f                  lbr           ccolon
[01537]                   execnorm:
[01538] dc8e: 0b                        ldn           rb
[01539] dc8f: ff ff                     smi           T_NUM                ; check for numbers
[01540] dc91: 32 d4                     bz            execnum              ; code is numeric
[01541] dc93: 0b                        ldn           rb                   ; recover byte
[01542] dc94: ff fe                     smi           T_ASCII              ; check for ascii data
[01543] dc96: 32 e6                     bz            execascii            ; jump if ascii
[01544] dc98: f8 0a a8 f8               mov           r8, jump             ; point to jump address
              04 b8 
[01545] dc9e: f8 c0                     ldi           0c0h                 ; need LBR
[01546] dca0: 58                        str           r8                   ; store it
[01547] dca1: 18                        inc           r8
[01548] dca2: 0b                        ldn           rb                   ; recover byte
[01549] dca3: fa 7f                     ani           07fh                 ; strip high bit
[01550] dca5: ff 01                     smi           1                    ; reset to origin
[01551] dca7: fe                        shl                                ; addresses are two bytes
[01552] dca8: 52                        str           r2                   ; write offset for addtion
[01553] dca9: f8 c7                     ldi           low cmdvecs
[01554] dcab: f4                        add                                ; add offset
[01555] dcac: a7                        plo           r7
[01556] dcad: f8 ea                     ldi           high cmdvecs         ; high address of command vectors
[01557] dcaf: 7c 00                     adci          0                    ; propagate carry
[01558] dcb1: b7                        phi           r7                   ; r[7] now points to command vector
[01559] dcb2: 47                        lda           r7                   ; get high byte of vector
[01560] dcb3: 58                        str           r8
[01561] dcb4: 18                        inc           r8
[01562] dcb5: 47                        lda           r7                   ; get low byte of vector
[01563] dcb6: 58                        str           r8
[01564] dcb7: 1b                        inc           rb                   ; point rb to next command
[01565] dcb8: 8b                        glo           rb                   ; save rb (backward from SCRT order)
[01566] dcb9: 73                        stxd
[01567] dcba: 9b                        ghi           rb
[01568] dcbb: 73                        stxd
[01569] dcbc: c0 04 0a                  lbr           jump
[01570]                   
[01571]                   cexit:
[01572]                   	;;  This is hard to get right and is fragile depending on how exec is called
[01573]                   	;;  WHen you make a CALL to anything you get the return address in R6 and the previous return address
[01574]                   	;;  on the top of the stack.
[01575]                   	;;  However, exec pushes the old RB on the stack so when we get here
[01576]                   	;; the stack looks like [RB], old ret address
[01577] dcbf: 60          	irx     ; pop old RB
[01578] dcc0: 60          	irx
[01579] dcc1: d5          	rtn     ; return to my caller
[01580]                   
[01581]                   
[01582]                   
[01583]                   execret:
[01584] dcc2: a7                        plo           r7                   ; save return code
[01585] dcc3: 60                        irx                                ; recover rb
[01586] dcc4: 42                        lda           r2
[01587] dcc5: bb                        phi           rb
[01588] dcc6: 02                        ldn           r2
[01589] dcc7: ab                        plo           rb
[01590] dcc8: 87                        glo           r7                   ; get result code
[01591] dcc9: 32 29                     bz            exec                 ; jump if no error
[01592] dccb: f8 71 af f8               mov           rf, msempty
              e9 bf 
[01593]                   execrmsg:
[01596]                   #else
[01597] dcd1: c0 ff 09                  lbr           f_msg                ; and return
[01598]                   #endif
[01599] dcd4: 1b          execnum:      inc           rb                   ; point to number
[01600] dcd5: 8b a7 9b b7               mov           r7,rb
[01601] dcd9: 47                        lda           r7
[01602] dcda: bb                        phi           rb
[01603] dcdb: 47                        lda           r7
[01604] dcdc: ab                        plo           rb
[01605] dcdd: d4 d8 69                  call          push
[01606] dce0: 87 ab 97 bb               mov           rb,r7
[01607] dce4: 30 29                     br            exec                 ; execute next code
[01608] dce6: 1b          execascii:    inc           rb                   ; move past ascii code
[01609] dce7: 8b a8 9b b8               mov           r8,rb                ; xfer name to R8
[01610] dceb: d4 d8 99                  call          findname             ; find entry
[01611] dcee: 3b f8                     bnf           ascnoerr             ; jump if name was found
[01612] dcf0: f8 7f af f8 ascerr:       mov           rf, msgerr           ; error message
              e9 bf 
[01613] dcf6: 30 d1                     br            execrmsg
[01614] dcf8: 17          ascnoerr:     inc           r7                   ; point to type
[01615] dcf9: 17                        inc           r7
[01616] dcfa: 07                        ldn           r7                   ; get type
[01617] dcfb: ff 86                     smi           FVARIABLE            ; check for variable
[01618] dcfd: c2 dd 15                  lbz           execvar              ; jump if so
[01619] dd00: 07                        ldn           r7                   ; get type
[01620] dd01: ff 87                     smi           FCOLON               ; check for function
[01621] dd03: ca dc f0                  lbnz           ascerr               ; jump if not
[01622] dd06: 88                        glo           r8                   ; save position
[01623] dd07: 73                        stxd                               ; and store on stack (backwards from SCRT order)
[01624] dd08: 98                        ghi           r8
[01625] dd09: 73                        stxd
[01626] dd0a: d4 dc 29                  call          exec                 ; call exec to execute stored program
[01627] dd0d: 60                        irx                                ; recover pointer
[01628] dd0e: 72                        ldxa
[01629] dd0f: bb                        phi           rb
[01630] dd10: f0                        ldx
[01631] dd11: ab                        plo           rb
[01632] dd12: c0 dc 29                  lbr           exec                 ; and continue execution
[01633] dd15: d4 d8 69    execvar:      call          push                 ; push var address to stack
[01634] dd18: 88 ab 98 bb               mov           rb,r8                ; address back to RB
[01635] dd1c: c0 dc 29                  lbr           exec                 ; execute next code
[01636]                   ; helper return calls to save space:
[01637]                   ; goodpush - push RB, indicate no error, continue exec
[01638]                   ; good - indicate no error, continue exec
[01639]                   ; error - indicate error, continue exec
[01640]                   ; goodpushb - D->RB.1, goodpush
[01641]                   ; goodpushb0 - D->RB.0, goodpush
[01642]                   ; typegoode - D->RE.0, call typenum, goto good
[01643]                   ; typegood - call typenum, goto good
[01644]                   ; goodrpush - rpush rb, good
[01645]                   ; goodrpush78b - r8->rb rpush r7->rb, rpush, good
[01646]                   ; goodrpush0 - D->RB.0 rpush
[01647]                   ; gooddf - DF->RB, push
[01648]                   ; goodisp - call disp, good
[01649]                   ; goodpushb8b - D->RB.0, push r8->rb, goodpushb0
[01650]                   ;
[01651]                   ;          org     600h
[01652] dd1f: d4 d8 41    cdup:         call          pop                  ; pop value from forth stack
[01653] dd22: 33 2d                     bdf           error                ; jump if stack was empty
[01654] dd24: d4 d8 69                  call          push                 ; push back twice
[01655]                   goodpush:                                        ; other things come here to push once
[01656] dd27: d4 d8 69                  call          push
[01657] dd2a: f8 00       good:         ldi           0                    ; indicate success
[01658] dd2c: c8                        lskp
[01659] dd2d: f8 01       error:        ldi           1
[01660] dd2f: c0 dc c2                  lbr           execret              ; return to caller
[01661] dd32: d4 d8 41    cdrop:        call          pop                  ; pop value from stack
[01662] dd35: 33 2d                     bdf           error                ; jump if stack was empty
[01663] dd37: 30 2a                     br            good                 ; return
[01664]                   cplus:        ;call          pop                  ; get value from stack
[01665]                                 ;bdf           lbdferr0                ; jump if stack was empty
[01666]                                 ;mov           r7,rb
[01667]                                 ;call          pop                  ; next number
[01668] dd39: d4 e5 08                  call          pop2
[01669] dd3c: 33 2d                     bdf           error                ; jump if stack was empty
[01670] dd3e: 87                        glo           r7                   ; perform addition
[01671] dd3f: 52                        str           r2
[01672] dd40: 8b                        glo           rb
[01673] dd41: f4                        add
[01674] dd42: ab                        plo           rb
[01675] dd43: 97                        ghi           r7
[01676] dd44: 52                        str           r2
[01677] dd45: 9b                        ghi           rb
[01678] dd46: 74                        adc
[01679]                   goodpushb:
[01680] dd47: bb                        phi           rb
[01681] dd48: 30 27                     br            goodpush
[01682]                   cminus:       ;call          pop                  ; get value from stack
[01683] dd4a: d4 e5 08                  call          pop2
[01684] dd4d: 33 2d                     bdf          error                ; jump if stack was empty
[01685] dd4f: 87                        glo           r7                   ; perform addition
[01686] dd50: 52                        str           r2
[01687] dd51: 8b                        glo           rb
[01688] dd52: f7                        sm
[01689] dd53: ab                        plo           rb
[01690] dd54: 97                        ghi           r7
[01691] dd55: 52                        str           r2
[01692] dd56: 9b                        ghi           rb
[01693] dd57: 77                        smb
[01694] dd58: 30 47                     br            goodpushb
[01695] dd5a: d4 d8 41    cdot:         call          pop                  ; get value from stack
[01696] dd5d: 33 2d       cdoterr:      bdf           error                ; jump if stack was empty
[01697] dd5f: f8 01                     ldi           1
[01698]                   typegoode:
[01699] dd61: ae                        plo           re                   ; signal signed int (put in e incase SCRT doesn't do it)
[01700]                   typegood:
[01701] dd62: d4 e7 c5                  call          typenum              ; RE was in D so this call won't wipe it
[01702] dd65: 30 2a                     br            good                 ; return
[01703]                   
[01704] dd67: d4 d8 41    cudot:        call          pop
[01705] dd6a: 33 5d                     bdf           cdoterr              ; jump if stack was empty
[01706] dd6c: f8 00                     ldi           0
[01707] dd6e: 30 61                     br            typegoode
[01708]                   cdotx:
[01709] dd70: d4 d8 41                  call          pop
[01710] dd73: 33 2d                     bdf           error
[01711] dd75: d4 e7 a8                  call          typenumind
[01712] dd78: 30 2a                     br            good
[01713] dd7a: d4 e5 08    cand:         call           pop2
[01714] dd7d: 33 2d                     bdf           error              ; jump if stack was empty
[01715] dd7f: 87                        glo           r7                   ; perform and
[01716] dd80: 52                        str           r2
[01717] dd81: 8b                        glo           rb
[01718] dd82: f2                        and
[01719] dd83: ab                        plo           rb
[01720] dd84: 97                        ghi           r7
[01721] dd85: 52                        str           r2
[01722] dd86: 9b                        ghi           rb
[01723] dd87: f2                        and
[01724] dd88: 30 47                     br            goodpushb
[01725] dd8a: d4 e5 08    cor:          call          pop2
[01726] dd8d: 33 2d                     bdf           error              ; jump if stack was empty
[01727] dd8f: 87                        glo           r7                   ; perform and
[01728] dd90: 52                        str           r2
[01729] dd91: 8b                        glo           rb
[01730] dd92: f1                        or
[01731] dd93: ab                        plo           rb
[01732] dd94: 97                        ghi           r7
[01733] dd95: 52                        str           r2
[01734] dd96: 9b                        ghi           rb
[01735] dd97: f1                        or
[01736] dd98: 30 47                     br            goodpushb
[01737] dd9a: d4 e5 08    cxor:         call          pop2
[01738] dd9d: 33 2d                     bdf          error              ; jump if stack was empty
[01739] dd9f: 87                        glo           r7                   ; perform and
[01740] dda0: 52                        str           r2
[01741] dda1: 8b                        glo           rb
[01742] dda2: f3                        xor
[01743] dda3: ab                        plo           rb
[01744] dda4: 97                        ghi           r7
[01745] dda5: 52                        str           r2
[01746] dda6: 9b                        ghi           rb
[01747] dda7: f3                        xor
[01748] dda8: 30 47                     br            goodpushb
[01749] ddaa: d4 d8 2f    ccr:          call          crlfout
[01750] ddad: 30 2a                     br            good                 ; return
[01751] ddaf: d4 e5 08    cswap:        call          pop2
[01752] ddb2: 33 2d                     bdf           error                ; jump if stack was empty
[01753] ddb4: 8b a8 9b b8               mov           r8,rb                ; move number
[01754] ddb8: 87 ab 97 bb               mov           rb,r7                ; restore first number
[01755] ddbc: d4 d8 69                  call          push                 ; put answer back on stack
[01756] ddbf: 98                        ghi           r8                   ; move number
[01757] ddc0: bb                        phi           rb
[01758] ddc1: 88                        glo           r8
[01759]                   goodpushb0:
[01760] ddc2: ab                        plo           rb
[01761] ddc3: 30 27                     br            goodpush
[01762]                   crat:
[01763] ddc5: d4 d8 79    ci:           call          rpop                 ; get value from return stack
[01764] ddc8: d4 d8 89                  call          rpush                ; put it back
[01765] ddcb: 30 27                     br            goodpush
[01766]                   cmem:
[01767] ddcd: f8 06                     ldi           low freemem          ; set R9 to free memory
[01768] ddcf: a9                        plo           r9
[01769] ddd0: 49                        lda           r9                   ; get high byte of free memory pointer
[01770] ddd1: 73                        stxd                               ; store on stack
[01771] ddd2: 49                        lda           r9                   ; get low byte
[01772] ddd3: 52                        str           r2                   ; store on stack
[01773] ddd4: f8 08                     ldi           low fstack           ; get pointer to stack
[01774] ddd6: a9                        plo           r9                   ; set into data frame
[01775] ddd7: 19                        inc           r9                   ; point to lo byte
[01776] ddd8: 09                        ldn           r9                   ; get it
[01777] ddd9: f7                        sm                                 ; perform subtract
[01778] ddda: ab                        plo           rb                   ; put into result
[01779] dddb: 29                        dec           r9                   ; high byte of stack pointer
[01780] dddc: 60                        irx                                ; point to high byte os free mem
[01781] dddd: 09                        ldn           r9                   ; get high byte of stack
[01782] ddde: 77                        smb                                ; continue subtraction
[01783] dddf: 30 47                     br           goodpushb
[01784] dde1: d4 e5 08    cdo:          call          pop2
[01785] dde4: 33 2d                     bdf          error               ; jump if stack was empty
[01786] dde6: 8b a8 9b b8               mov           r8,rb
[01787] ddea: d4 e8 ab                  call          getstream
[01788] dded: d4 d8 89                  call          rpush                ; store inst point on return stack
[01789]                   goodrpush78b:
[01790] ddf0: 88 ab 98 bb               mov           rb,r8                ; termination to rb
[01791] ddf4: d4 d8 89                  call          rpush                ; store termination on return stack
[01792] ddf7: 97                        ghi           r7                   ; transfer count to rb
[01793] ddf8: bb                        phi           rb
[01794] ddf9: 87                        glo           r7
[01795]                   goodrpushb0:
[01796] ddfa: ab                        plo           rb
[01797]                   goodrpush:
[01798] ddfb: d4 d8 89                  call          rpush
[01799] ddfe: 30 2a                     br           good
[01800] de00: d4 d8 79    cloop:        call          rpop
[01801] de03: 1b                        inc           rb                   ; add 1 to it
[01802] de04: 8b a7 9b b7 loopcnt:      mov           r7,rb
[01803] de08: d4 d8 79                  call          rpop                 ; get termination
[01804] de0b: 8b                        glo           rb                   ; get lo of termination
[01805] de0c: 52                        str           r2                   ; place into memory
[01806] de0d: 87                        glo           r7                   ; get count
[01807] de0e: f7                        sm                                 ; perform subtract
[01808] de0f: 9b                        ghi           rb                   ; get hi of termination
[01809] de10: 52                        str           r2                   ; place into memory
[01810] de11: 97                        ghi           r7                   ; get high of count
[01811] de12: 77                        smb                                ; continue subtract
[01812] de13: c3 de 2d                  lbdf           cloopdn              ; jump if loop complete
[01813] de16: 8b a8 9b b8               mov           r8,rb
[01814] de1a: d4 d8 79                  call          rpop                 ; get loop address
[01815] de1d: d4 d8 89                  call          rpush                ; keep on stack as well
[01816] de20: 82 aa 92 ba               mov           ra,r2
[01817] de24: 1a                        inc           ra                   ; pointing at ra value high
[01818] de25: 9b                        ghi           rb
[01819] de26: 5a                        str           ra                   ; and write it
[01820] de27: 1a                        inc           ra
[01821] de28: 8b                        glo           rb                   ; get rb lo value
[01822] de29: 5a                        str           ra                   ; and write it
[01823] de2a: c0 dd f0                  lbr            goodrpush78b
[01824] de2d: d4 d8 79    cloopdn:      call          rpop                 ; pop off start of loop address
[01825] de30: c0 dd 2a                  lbr           good                 ; and return
[01826] de33: d4 d8 79    cploop:       call          rpop                 ; get top or return stack
[01827] de36: 9b                        ghi           rb                   ; put count into memory
[01828] de37: 73                        stxd
[01829] de38: 8b                        glo           rb
[01830] de39: 73                        stxd
[01831] de3a: d4 d8 41                  call          pop                  ; get word from data stack
[01832] de3d: c3 dd 2d    errorl0:      lbdf          error
[01833] de40: 60                        irx
[01834] de41: 8b                        glo           rb                   ; add to count
[01835] de42: f4                        add
[01836] de43: ab                        plo           rb
[01837] de44: 9b                        ghi           rb
[01838] de45: 60                        irx
[01839] de46: 74                        adc
[01840] de47: bb                        phi           rb
[01841] de48: c0 de 04                  lbr            loopcnt              ; then standard loop code
[01842] de4b: d4 e8 ab    cbegin:       call           getstream
[01843] de4e: 2b                        dec            rb
[01844]                   ; we need to put 3x on stack to be compatible with DO etc.
[01845] de4f: d4 d8 89                  call           rpush
[01846] de52: d4 d8 89                  call           rpush
[01847] de55: c0 dd fb                  lbr            goodrpush
[01848]                   ; [GDJ] corrected logic - BEGIN/UNTIL loop should repeat if flag preceding UNTIL is FALSE
[01849] de58: d4 d8 41    cuntil:       call          pop                  ; get top of stack
[01850] de5b: 33 3d                     bdf           errorl0               ; jump if stack was empty
[01851] de5d: 8b                        glo           rb                   ; [GDJ] check flag LSB - if true were done
[01852] de5e: 3a 63                     bnz           untilno              ; [GDJ]
[01853] de60: 9b                        ghi           rb                   ; [GDJ] check flag MSB
[01854] de61: 32 6f                     bz            untilyes
[01855] de63: d4 d8 79    untilno:      call          rpop                 ; pop off begin address
[01856] de66: d4 d8 79                  call          rpop
[01857] de69: d4 d8 79                  call          rpop
[01858] de6c: c0 dd 2a                  lbr           good                 ; we are done, just return
[01859] de6f: d4 d8 79    untilyes:     call          rpop                 ; get return address - continue looping
[01860] de72: d4 d8 79                  call          rpop
[01861] de75: d4 d8 79                  call          rpop
[01862] de78: 82 aa 92 ba               mov           ra,r2
[01863] de7c: 1a                        inc           ra                   ; pointing at ra value high
[01864] de7d: 9b                        ghi           rb
[01865] de7e: 5a                        str           ra                   ; and write it
[01866] de7f: 1a                        inc           ra
[01867] de80: 8b                        glo           rb                   ; get rb lo value
[01868] de81: 5a                        str           ra                   ; and write it
[01869] de82: c0 dd 2a                  lbr           good                 ; now return
[01870] de85: d4 d8 79    crgt:         call          rpop                 ; get value from return stack
[01871] de88: c0 dd 27                  lbr           goodpush
[01872] de8b: d4 d8 41    cgtr:         call          pop
[01873] de8e: 33 3d                     bdf          errorl0                ; jump if stack was empty
[01874] de90: c0 dd fb                  lbr            goodrpush
[01875]                   cunequal:    ; call          pop
[01876]                   ;              bdf           cunerr               ; jump if stack was empty
[01877]                   ;              mov           r7,rb
[01878] de93: d4 e5 08                  call          pop2
[01879] de96: 33 3d       cunerr:       bdf          errorl0                ; jump if stack was empty
[01880] de98: 87                        glo           r7                   ; perform and
[01881] de99: 52                        str           r2
[01882] de9a: 8b                        glo           rb
[01883] de9b: f3                        xor
[01884] de9c: 3a a8                     bnz           unequal              ; jump if not equal
[01885] de9e: 97                        ghi           r7
[01886] de9f: 52                        str           r2
[01887] dea0: 9b                        ghi           rb
[01888] dea1: f3                        xor
[01889] dea2: 3a a8                     bnz           unequal              ; jump if not equal
[01890] dea4: ab                        plo           rb
[01891] dea5: c0 dd 47                  lbr           goodpushb
[01892] dea8: f8 00       unequal:      ldi           0                    ; set return result
[01893] deaa: bb                        phi           rb
[01894] deab: ab                        plo           rb
[01895] deac: 1b                        inc           rb                   ; it is now 1
[01896] dead: c0 dd 27    lgoodpush:    lbr           goodpush
[01897]                   ; [GDJ]
[01898]                   ; determine if NOS < TOS
[01899] deb0: d4 d8 41    cless:        call          pop
[01900] deb3: 33 3d                     bdf          errorl0                ; jump if stack was empty
[01901] deb5: 8b a8 9b b8               mov           r8,rb
[01902] deb9: d4 d8 41                  call          pop
[01903] debc: 33 3d                     bdf          errorl0               ; jump if stack was empty
[01904] debe: 8b a7 9b b7               mov           r7,rb
[01905]                                 ; bias numbers for comparison
[01906] dec2: 97                        ghi           r7
[01907] dec3: fb 80                     xri           080h                 ; bias upwards
[01908] dec5: b7                        phi           r7
[01909] dec6: 98                        ghi           r8
[01910] dec7: fb 80                     xri           080h                 ; bias upwards
[01911] dec9: b8                        phi           r8
[01912] deca: 87                        glo           7                    ; subtract them
[01913] decb: 52                        str           r2
[01914] decc: 88                        glo           r8
[01915] decd: f5                        sd
[01916] dece: a7                        plo           r7
[01917] decf: 97                        ghi           r7
[01918] ded0: 52                        str           r2
[01919] ded1: 98                        ghi           r8
[01920] ded2: 75                        sdb
[01921] ded3: b7                        phi           r7
[01922]                   gooddf:
[01923] ded4: f8 00                     ldi           0
[01924] ded6: bb                        phi           rb                   ; no matter what
[01925] ded7: cf                        lsdf
[01926] ded8: f8 01                     ldi           1                    ; now D=0 if DF=0 or 1 if DF=1
[01927] deda: ab                        plo           rb
[01928] dedb: 30 ad                     br           lgoodpush
[01929]                   ; [GDJ]
[01930]                   culess:      ; call          pop
[01931]                                ; lbdf          error                ; jump if stack was empty
[01932]                                ; mov           r7,rb
[01933] dedd: d4 e5 08                  call          pop2
[01934] dee0: 33 3d                     bdf          errorl0               ; jump if stack was empty
[01935] dee2: 8b a8 9b b8               mov           r8,rb
[01936]                                 ; perform subtraction r8-r7  (NOS-TOS) to check for borrow
[01937] dee6: 88                        glo           r8
[01938] dee7: 52                        str           r2
[01939] dee8: 87                        glo           r7
[01940] dee9: f5                        sd
[01941] deea: a8                        plo           r8
[01942] deeb: 98                        ghi           r8
[01943] deec: 52                        str           r2
[01944] deed: 97                        ghi           r7
[01945] deee: 75                        sdb                                ; subtract with borrow
[01946] deef: 30 d4                     br            gooddf
[01947] def1: d4 ff 66    cwords:       call          f_inmsg
[01948] def4: 43 4f 52 45               db            'CORE:',10,13,0
              3a 0a 0d 00 
[01949] defc: f8 8e a7 f8               mov           r7, cmdtable
              e9 b7 
[01950] df02: f8 00                     ldi           0
[01951] df04: bd                        phi           rd
[01952] df05: ad                        plo           rd
[01953] df06: 47          cwordslp:     lda           r7                   ; get byte
[01954] df07: c2 df 30                  lbz            cwordsdn             ; jump if done
[01955] df0a: ab                        plo           rb                   ; save it
[01956] df0b: fa 80                     ani           128                  ; check for final of token
[01957] df0d: 3a 16                     bnz           cwordsf              ; jump if so
[01958] df0f: 8b                        glo           rb                   ; get byte
[01959] df10: d4 d8 3b                  call          disp
[01960] df13: c0 df 06                  lbr            cwordslp             ; and loop back
[01961] df16: 8b          cwordsf:      glo           rb                   ; get byte
[01962] df17: fa 7f                     ani           07fh                 ; strip high bit
[01963] df19: d4 d8 3b                  call          disp
[01964] df1c: d4 d8 36                  call          dispsp
[01965] df1f: 1d                        inc           rd
[01966] df20: 8d                        glo           rd
[01967] df21: ff 0c                     smi           12                   ; items per line
[01968] df23: ca df 06                  lbnz           cwordslp
[01969] df26: f8 00                     ldi           0
[01970] df28: bd                        phi           rd
[01971] df29: ad                        plo           rd
[01972] df2a: d4 d8 2f                  call          crlfout
[01973] df2d: c0 df 06                  lbr            cwordslp             ; and loop back
[01974] df30: d4 ff 66    cwordsdn:     call          f_inmsg
[01975] df33: 0a 0d 55 53               db            10,13,'USER:',10,13,0
              45 52 3a 0a 
              0d 00 
[01976] df3d: f8 15 a7 f8               mov           r7,storage
              04 b7 
[01977] df43: f8 00                     ldi           0
[01978] df45: bd                        phi           rd
[01979] df46: ad                        plo           rd
[01980] df47: 47          cwordslp2:    lda           r7                   ; get pointer to next entry
[01981] df48: b8                        phi           r8                   ; put into r8
[01982] df49: 47                        lda           r7                   ; now pointing at type indicator
[01983] df4a: a8                        plo           r8                   ; save low of link
[01984] df4b: 3a 53                     bnz           cwordsnot            ; jump if not link terminator
[01985] df4d: 98                        ghi           r8                   ; check high byte too
[01986] df4e: 3a 53                     bnz           cwordsnot
[01987] df50: c0 dd aa    cwordsdn1:    lbr           ccr                  ; CR and done
[01988] df53: 17          cwordsnot:    inc           r7                   ; now pointing at ascii indicator
[01989] df54: 17                        inc           r7                   ; first character of name
[01990] df55: 47          wordsnotl:    lda           r7                   ; get byte from string
[01991] df56: 32 5d                     bz            wordsnxt             ; jump if end of string
[01992] df58: d4 d8 3b                  call          disp
[01993] df5b: 30 55                     br            wordsnotl            ; keep going
[01994] df5d: d4 d8 36    wordsnxt:     call          dispsp
[01995] df60: 88 a7 98 b7               mov           r7,r8                ; r7=next word address
[01996] df64: 1d                        inc           rd
[01997] df65: 8d                        glo           rd
[01998] df66: ff 08                     smi           8
[01999] df68: 3a 47                     bnz           cwordslp2
[02000] df6a: f8 00                     ldi           0
[02001] df6c: bd                        phi           rd
[02002] df6d: ad                        plo           rd
[02003] df6e: d4 d8 2f                  call          crlfout
[02004] df71: 30 47                     br            cwordslp2            ; and check next word
[02005] df73: d4 d8 41    cemit:        call          pop
[02006] df76: c3 dd 2d                  lbdf          error                ; jump if error
[02007] df79: 8b                        glo           rb                   ; get low of return value
[02008]                   gooddisp:
[02009] df7a: d4 d8 3b                  call          disp
[02010] df7d: c0 dd 2a                  lbr           good                 ; return to caller
[02011]                   ; [GDJ]
[02012] df80: d4 d8 41    cemitp:       call          pop
[02013] df83: c3 dd 2d                  lbdf          error                ; jump if error
[02014] df86: 8b                        glo           rb                   ; get low of return value
[02015] df87: ff 20                     smi           32                   ; check for below space
[02016] df89: 3b 91                     bnf           notprint             ; jump if not printable
[02017] df8b: 8b                        glo           rb
[02018] df8c: ff 7f                     smi           127                  ; check for above tilde ~
[02019] df8e: cf                        lsdf                               ; jump if not printable (skip 2)
[02020] df8f: 8b                        glo           rb
[02021] df90: c8                        lskp                               ; ok printable so skip ldi .
[02022] df91: f8 2e       notprint:     ldi           '.'
[02023] df93: 30 7a       emitpout:     br            gooddisp
[02024] df95: d4 d8 41    cwhile:       call          pop
[02025] df98: c3 dd 2d                  lbdf          error                ; jump if error
[02026] df9b: 8b                        glo           rb                   ; need to check for zero
[02027] df9c: 3a c4                     bnz           whileno              ; jump if not zero
[02028] df9e: 9b                        ghi           rb                   ; check high byte
[02029] df9f: 3a c4                     bnz           whileno
[02030] dfa1: d4 e8 ab                  call          getstream
[02031] dfa4: f8 00                     ldi           0                    ; set while count to zero
[02032] dfa6: a7                        plo           r7
[02033] dfa7: 0b          findrep:      ldn           rb                   ; get byte from stream
[02034] dfa8: ff 81                     smi           FWHILE               ; was a while found
[02035] dfaa: 3a b0                     bnz           notwhile             ; jump if not
[02036] dfac: 17                        inc           r7                   ; increment while count
[02037] dfad: 1b          notrep:       inc           rb                   ; point to next byte
[02038] dfae: 30 a7                     br            findrep              ; and keep looking
[02039] dfb0: 0b          notwhile:     ldn           rb                   ; retrieve byte
[02040] dfb1: ff 82                     smi           FREPEAT              ; is it a repeat
[02041] dfb3: 3a ad                     bnz           notrep               ; jump if not
[02042] dfb5: 87                        glo           r7                   ; get while count
[02043] dfb6: 32 bb                     bz            fndrep               ; jump if not zero
[02044] dfb8: 27                        dec           r7                   ; decrement count
[02045] dfb9: 30 ad                     br            notrep               ; and keep looking
[02046] dfbb: 1b          fndrep:       inc           rb                   ; move past the while
[02047] dfbc: 8b                        glo           rb                   ; now put back into R[6]
[02048] dfbd: 5a                        str           ra
[02049] dfbe: 2a                        dec           ra
[02050] dfbf: 9b                        ghi           rb
[02051] dfc0: 5a                        str           ra
[02052] dfc1: c0 dd 2a                  lbr           good                 ; then return to caller
[02053] dfc4: d4 e8 ab    whileno:      call          getstream
[02054] dfc7: 2b                        dec           rb                   ; point back to while command
[02055]                   ; we need to put in two dummy stack items so unloop can work with do/while/begin
[02056] dfc8: d4 d8 89                  call          rpush
[02057] dfcb: d4 d8 89                  call          rpush
[02058] dfce: c0 dd fb                  lbr           goodrpush
[02059]                   cagain:
[02060] dfd1: d4 d8 79    crepeat:      call          rpop                 ; get address on return stack
[02061] dfd4: d4 d8 79                  call          rpop
[02062] dfd7: d4 d8 79                  call          rpop                 ; all 3 the same for a while/repeat
[02063] dfda: 82 aa 92 ba               mov           ra,r2
[02064] dfde: 1a                        inc           ra                   ; now pointing at high byte of R[6]
[02065] dfdf: 9b                        ghi           rb                   ; get while address
[02066] dfe0: 5a                        str           ra                   ; and place into R[6]
[02067] dfe1: 1a                        inc           ra
[02068] dfe2: 8b                        glo           rb
[02069] dfe3: 5a                        str           ra
[02070] dfe4: c0 dd 2a                  lbr           good                 ; then return
[02071] dfe7: d4 d8 41    cif:          call          pop
[02072] dfea: c3 dd 2d                  lbdf          error                ; jump if error
[02073] dfed: 8b                        glo           rb                   ; check for zero
[02074] dfee: ca dd 2a                  lbnz          good                 ; jump if not zero
[02075] dff1: 9b                        ghi           rb                   ; check hi byte too
[02076] dff2: ca dd 2a                  lbnz          good                 ; jump if not zero
[02077] dff5: d4 e8 ab                  call          getstream
[02078] dff8: f8 00                     ldi           0                    ; set IF count
[02079] dffa: a7                        plo           r7                   ; put into counter
[02080] dffb: 0b          iflp1:        ldn           rb                   ; get next byte
[02081] dffc: ff 83                     smi           FIF                  ; check for IF
[02082] dffe: ca e0 06                  lbnz           ifnotif              ; jump if not
[02083] e001: 17                        inc           r7                   ; increment if count
[02084] e002: 1b          ifcnt:        inc           rb                   ; point to next byte
[02085] e003: c0 df fb                  lbr            iflp1                ; keep looking
[02086] e006: 0b          ifnotif:      ldn           rb                   ; retrieve byte
[02087] e007: ff 84                     smi           FELSE                ; check for ELSE
[02088] e009: 3a 18                     bnz           ifnotelse            ; jump if not
[02089] e00b: 87                        glo           r7                   ; get IF count
[02090] e00c: ca e0 02                  lbnz           ifcnt                ; jump if it is not zero
[02091] e00f: 1b                        inc           rb                   ; move past the else
[02092] e010: 8b          ifsave:       glo           rb                   ; store back into instruction pointer
[02093] e011: 5a                        str           ra
[02094] e012: 2a                        dec           ra
[02095] e013: 9b                        ghi           rb
[02096] e014: 5a                        str           ra
[02097] e015: c0 dd 2a                  lbr           good                 ; and return
[02098] e018: 0b          ifnotelse:    ldn           rb                   ; retrieve byte
[02099] e019: ff 85                     smi           FTHEN                ; check for THEN
[02100] e01b: ca e0 02                  lbnz           ifcnt                ; jump if not
[02101] e01e: 87                        glo           r7                   ; get if count
[02102] e01f: 27                        dec           r7                   ; decrement if count
[02103] e020: ca e0 02                  lbnz           ifcnt                ; jump if not zero
[02104] e023: c0 e0 10                  lbr            ifsave               ; otherwise found
[02105] e026: d4 e8 ab    celse:        call          getstream
[02106] e029: f8 00                     ldi           0                    ; count of IFs
[02107] e02b: a7                        plo           r7                   ; put into R7
[02108] e02c: 0b          elselp1:      ldn           rb                   ; get next byte from stream
[02109] e02d: ff 83                     smi           FIF                  ; check for IF
[02110] e02f: 3a 35                     bnz           elsenif              ; jump if not if
[02111] e031: 17                        inc           r7                   ; increment IF count
[02112] e032: 1b          elsecnt:      inc           rb                   ; point to next byte
[02113] e033: 30 2c                     br            elselp1              ; keep looking
[02114] e035: 0b          elsenif:      ldn           rb                   ; retrieve byte
[02115] e036: ff 85                     smi           FTHEN                ; is it THEN
[02116] e038: 3a 32                     bnz           elsecnt              ; jump if not
[02117] e03a: 87                        glo           r7                   ; get IF count
[02118] e03b: 27                        dec           r7                   ; minus 1 IF
[02119] e03c: 3a 32                     bnz           elsecnt              ; jump if not 0
[02120] e03e: 8b                        glo           rb                   ; put into instruction pointer
[02121] e03f: 5a                        str           ra
[02122] e040: 2a                        dec           ra
[02123] e041: 9b                        ghi           rb
[02124] e042: 5a                        str           ra
[02125] e043: c0 dd 2a                  lbr           good                 ; now pointing at a then
[02126]                   cequal:       ;call          pop
[02127]                                 ;lbdf          error                ; jump if stack was empty
[02128]                                 ;mov           r7,rb
[02129] e046: d4 e5 08                  call          pop2
[02130] e049: c3 dd 2d                  lbdf          error                ; jump if stack was empty
[02131] e04c: 87                        glo           r7                   ; perform and
[02132] e04d: 52                        str           r2
[02133] e04e: 8b                        glo           rb
[02134] e04f: f3                        xor
[02135] e050: 3a 5e                     bnz           unequal2             ; jump if not equal
[02136] e052: 97                        ghi           r7
[02137] e053: 52                        str           r2
[02138] e054: 9b                        ghi           rb
[02139] e055: f3                        xor
[02140] e056: 3a 5e                     bnz           unequal2             ; jump if not equal
[02141] e058: bb                        phi           rb                   ; set return result
[02142] e059: ab                        plo           rb
[02143] e05a: 1b                        inc           rb
[02144] e05b: c0 dd 27                  lbr           goodpush
[02145] e05e: f8 00       unequal2:     ldi           0
[02146] e060: ab                        plo           rb
[02147] e061: c0 dd 47                  lbr           goodpushb
[02148]                   cdepth:
[02149] e064: f8 08                     ldi           low fstack           ; point to free memory pointer
[02150] e066: a9                        plo           r9                   ; place into data frame
[02151] e067: 49                        lda           r9                   ; get high byte of free memory pointer
[02152] e068: 73                        stxd                               ; store on stack
[02153] e069: 49                        lda           r9                   ; get low byte
[02154] e06a: 52                        str           r2                   ; store on stack
[02155] e06b: f8 04                     ldi           low tos              ; get pointer to stack
[02156] e06d: a9                        plo           r9                   ; set into data frame
[02157] e06e: 19                        inc           r9                   ; point to lo byte
[02158] e06f: 09                        ldn           r9                   ; get it
[02159] e070: f7                        sm                                 ; perform subtract
[02160] e071: ab                        plo           rb                   ; put into result
[02161] e072: 29                        dec           r9                   ; high byte of stack pointer
[02162] e073: 60                        irx                                ; point to high byte os free mem
[02163] e074: 09                        ldn           r9                   ; get high byte of stack
[02164] e075: 77                        smb                                ; continue subtraction
[02165] e076: f6                        shr                                ; divide by 2
[02166] e077: bb                        phi           rb                   ; store answer
[02167] e078: 8b                        glo           rb                   ; propagate the shift
[02168] e079: 76                        shrc
[02169] e07a: c0 dd c2                  lbr           goodpushb0
[02170]                   crot:         ;call          pop                  ; get C
[02171]                                 ;lbdf          error                ; jump if error
[02172]                                 ;mov           r7,rb
[02173] e07d: d4 e5 08                  call          pop2                  ; get B
[02174] e080: c3 dd 2d                  lbdf          error                ; jump if error
[02175] e083: 8b a8 9b b8               mov           r8,rb
[02176] e087: d4 d8 41                  call          pop                  ; get A
[02177] e08a: c3 dd 2d                  lbdf          error                ; jump if error
[02178] e08d: 8b ac 9b bc               mov           rc,rb
[02179]                                 ;  load and push B
[02180] e091: 88 ab 98 bb               mov           rb,r8
[02181] e095: d4 d8 69                  call          push
[02182]                                 ;  and C
[02183] e098: 87 ab 97 bb               mov           rb,r7
[02184] e09c: d4 d8 69                  call          push
[02185] e09f: 9c                        ghi           rc                   ; get A
[02186] e0a0: bb                        phi           rb
[02187] e0a1: 8c                        glo           rc
[02188] e0a2: c0 dd c2                  lbr           goodpushb0
[02189]                   cmrot:        ;call          pop                  ; get C
[02190]                                 ;lbdf          error                ; jump if error
[02191]                                 ;mov           r7,rb
[02192] e0a5: d4 e5 08                  call          pop2                  ; get B
[02193] e0a8: c3 dd 2d                  lbdf          error                ; jump if error
[02194] e0ab: 8b a8 9b b8               mov           r8,rb
[02195] e0af: d4 d8 41                  call          pop                  ; get A
[02196] e0b2: c3 dd 2d                  lbdf          error                ; jump if error
[02197] e0b5: 8b ac 9b bc               mov           rc,rb
[02198] e0b9: 87 ab 97 bb               mov           rb,r7                ; C
[02199] e0bd: d4 d8 69                  call          push
[02200] e0c0: 9c                        ghi           rc                   ; get A
[02201] e0c1: bb                        phi           rb
[02202] e0c2: 8c                        glo           rc
[02203]                   goodpushb8b:
[02204] e0c3: ab                        plo           rb
[02205] e0c4: d4 d8 69                  call          push
[02206] e0c7: 98                        ghi           r8                   ; get B
[02207] e0c8: bb                        phi           rb
[02208] e0c9: 88                        glo           r8
[02209] e0ca: c0 dd c2                  lbr           goodpushb0
[02210]                   cover:        ;call          pop                  ; get B
[02211]                                 ;lbdf          error                ; jump if error
[02212]                                 ;mov           r7,rb
[02213] e0cd: d4 e5 08                  call          pop2                  ; get A
[02214] e0d0: c3 dd 2d                  lbdf          error                ; jump if error
[02215] e0d3: 8b a8 9b b8               mov           r8,rb
[02216] e0d7: d4 d8 69                  call          push                 ; put onto stack
[02217] e0da: 97                        ghi           r7                   ; get B
[02218] e0db: bb                        phi           rb
[02219] e0dc: 87                        glo           r7
[02220] e0dd: 30 c3                     br            goodpushb8b
[02221] e0df: d4 d8 41    cat:          call          pop
[02222] e0e2: c3 dd 2d                  lbdf          error                ; jump on error
[02223] e0e5: 8b a7 9b b7               mov           r7,rb
[02224] e0e9: 47                        lda           r7                   ; get word at address
[02225]                   catcomm:
[02226] e0ea: bb                        phi           rb
[02227] e0eb: 07                        ldn           r7
[02228] e0ec: c0 dd c2                  lbr           goodpushb0
[02229] e0ef: d4 d8 41    cexcl:        call          pop
[02230] e0f2: c3 dd 2d                  lbdf          error                ; jump on error
[02231] e0f5: 8b a7 9b b7               mov           r7,rb
[02232] e0f9: d4 d8 41                  call          pop                  ; date data word from stack
[02233] e0fc: c3 dd 2d                  lbdf          error                ; jump on error
[02234] e0ff: 9b                        ghi           rb                   ; write word to memory
[02235] e100: 57                        str           r7
[02236] e101: 17                        inc           r7
[02237]                   goodexcl:
[02238] e102: 8b                        glo           rb
[02239] e103: 57                        str           r7
[02240] e104: c0 dd 2a                  lbr           good                 ; and return
[02241] e107: d4 d8 41    ccat:         call          pop                  ; get address from stack
[02242] e10a: c3 e1 19                  lbdf           ccerr                ; jump on error
[02243] e10d: 8b a7 9b b7               mov           r7,rb
[02244] e111: f8 00                     ldi           0                    ; high byte is zero
[02245] e113: c0 e0 ea                  lbr            catcomm
[02246]                   ccexcl:      ; call          pop
[02247]                   ;ccerr:        lbdf          error                ; jump on error
[02248]                                ; mov           r7,rb
[02249] e116: d4 e5 08                  call          pop2                  ; date data word from stack
[02250] e119: c3 dd 2d    ccerr:        lbdf          error                ; jump on error
[02251] e11c: c0 e1 02                  lbr            goodexcl
[02252]                   ccreate:  ; like variable but with no allocation: CBUFFER only!
[02253] e11f: f8 86                    ldi           FVARIABLE
[02254] e121: c8                       lskp                   ; skip into cvariable
[02255]                   
[02256]                   ; ************** WARNING: FALL THOUGH HERE
[02257]                   cvariable:
[02258]                   #ifdef USE_CBUFFER
[02259]                   ; easier.. we just copy the FVARIABLE FASCII String and then bump up two bytes and go
[02260] e122: f8 00                     ldi           0
[02261] e124: af                        plo           rf                   ; mark that we are a variable (1=create)
[02262] e125: d4 e8 ab                  call          getstream
[02263] e128: 0b                        ldn           rb                   ; get next byte
[02264] e129: ff fe                     smi           T_ASCII              ; it must be an ascii mark
[02265] e12b: ca dd 2d                  lbnz          error                ; jump if not
[02266] e12e: 2b                        dec           rb                   ; point back to FVARIABLE
[02267] e12f: f8 06                     ldi           low freemem          ; set R9 to free memory
[02268] e131: a9                        plo           r9
[02269] e132: 49                        lda           r9                   ; get current pointer
[02270] e133: b7                        phi           r7                   ; place here
[02271] e134: 09                        ldn           r9                   ; get low byte
[02272] e135: a7                        plo           r7                   ; R7=start of variable
[02273] e136: 17                        inc           r7
[02274] e137: 17                        inc           r7                   ; make room for link
[02275] e138: 8f                        glo           rf
[02276] e139: 32 3e                     bz            cvarlp
[02277] e13b: 57                        str           r7
[02278] e13c: 1b                        inc           rb
[02279] e13d: 17                        inc           r7                   ; replace FCREATE with FVARIABLE
[02280]                   cvarlp:
[02281] e13e: 4b                        lda           rb                   ; copy from cbuffer to working memory
[02282] e13f: 57                        str           r7
[02283] e140: 17                        inc           r7
[02284] e141: 3a 3e                     bnz           cvarlp
[02285] e143: 8b 73 9b 73               push          rb                   ; RB (on stack)= next input token
[02286]                                                                    ; R7 = area for variable
[02287] e147: 8f                        glo           rf
[02288] e148: 3a 50                     bnz           cvarnospace
[02289] e14a: f8 00                     ldi           0
[02290] e14c: 57                        str           r7                   ; make sure variable is set to zero (extra feature!)
[02291] e14d: 17                        inc           r7
[02292] e14e: 57                        str           r7
[02293] e14f: 17                        inc           r7                   ; R7 now new free pointer
[02294]                   cvarnospace:
[02295]                   
[02296] e150: 09                        ldn           r9                   ; R9 = low byte of freemem
[02297] e151: af                        plo           rf
[02298] e152: 29                        dec           r9
[02299] e153: 09                        ldn           r9
[02300] e154: bf                        phi           rf
[02301] e155: 97                        ghi           r7                  ; get memory pointer
[02302] e156: 5f                        str           rf
[02303] e157: 59                        str           r9
[02304] e158: 19                        inc           r9
[02305] e159: 1f                        inc           rf
[02306] e15a: 87                        glo           r7
[02307] e15b: 5f                        str           rf
[02308] e15c: 59                        str           r9
[02309]                   
[02310] e15d: f8 00                     ldi           0                    ; need zero at end of list
[02311] e15f: 57                        str           r7                   ; store it
[02312] e160: 17                        inc           r7
[02313] e161: 57                        str           r7
[02314] e162: 60 72 bb f0               pop           rb
              ab 
[02315] e167: 8b                        glo           rb                   ; write back to instruction pointer
[02316] e168: 5a                        str           ra
[02317] e169: 2a                        dec           ra
[02318] e16a: 9b                        ghi           rb
[02319] e16b: 5a                        str           ra
[02320] e16c: c0 dd 2a                  lbr           good                 ; return
[02398]                   #endif
[02399]                   ccolon:
[02400]                   #ifdef USE_CBUFFER
[02401]                   ; almost the same excep we copy cbuffer to free mem and we have to update within cbuffer not within
[02402] e16f: d4 e8 ab                  call         getstream
[02403]                   ; we have to copy from CBUFFER to  either FSEMI or T_EOS NOTE: T_NUM MIGHT HAVE A T_EOS or FSEMI in it!
[02404] e172: f8 06                     ldi          low freemem
[02405] e174: a9                        plo          r9
[02406] e175: 49                        lda          r9
[02407] e176: bf                        phi          rf
[02408] e177: 09                        ldn          r9
[02409] e178: af                        plo          rf
[02410] e179: d4 e5 38                  call         ismulti
[02411] e17c: 3a 81                     bnz          ccmulti               ; don't skip link for lines 2-n, only line 1
[02412] e17e: 1f                        inc          rf                    ; skip link
[02413] e17f: 1f                        inc          rf
[02414] e180: 2b                        dec          rb                    ; point back at FCOLON
[02415]                   ccmulti:
[02416] e181: 8f 73 9f 73               push         rf                    ; we will pop back to RB
[02417]                   
[02418]                   
[02419] e185: 4b          ccolcpy:      lda          rb
[02420] e186: 5f                        str          rf
[02421] e187: 1f                        inc          rf
[02422] e188: ae                        plo          re                     ; hold temp
[02423] e189: ff ff                     smi          T_NUM                  ; if T_NUM we must copy two more bytes no matter what
[02424] e18b: 3a 95                     bnz          cccpyck
[02425] e18d: 4b                        lda          rb
[02426] e18e: 5f                        str          rf
[02427] e18f: 1f                        inc          rf
[02428] e190: 4b                        lda          rb
[02429] e191: 5f                        str          rf
[02430] e192: 1f                        inc          rf
[02431] e193: 30 85                     br          ccolcpy
[02432] e195: 8e          cccpyck:      glo          re
[02433] e196: ff 88                     smi          FSEMI
[02434] e198: 32 9f                     bz           ccolcpydn
[02435] e19a: 8e                        glo          re
[02436] e19b: ff fd                     smi          T_EOS
[02437] e19d: 3a 85                     bnz          ccolcpy
[02438]                   ccolcpydn:
[02439] e19f: 8b                        glo          rb
[02440] e1a0: 5a                        str          ra
[02441] e1a1: 2a                        dec          ra
[02442] e1a2: 9b                        ghi          rb
[02443] e1a3: 5a                        str          ra       ; set up exec to go after the semi or whatever
[02444] e1a4: 60 72 bb f0               pop          rb       ; this was RF but now points to free mem area
              ab 
[02445] e1a9: 1b                        inc          rb       ; skip FCOLON
[02446]                   ; after that it is almost normal
[02447] e1aa: d4 e5 38                  call          ismulti
[02448] e1ad: 19                        inc           r9
[02449] e1ae: 3a c2                     bnz           colonlp1             ; multiline, just keep it going
[02450]                    ; if first line, assume it MIGHT be multline
[02451] e1b0: 2b                        dec           rb                    ; go back after all
[02452] e1b1: 2b                        dec           rb
[02453] e1b2: 2b                        dec           rb
[02454] e1b3: 8b                        glo           rb
[02455] e1b4: 59                        str           r9
[02456] e1b5: 19                        inc           r9
[02457] e1b6: 9b                        ghi           rb                   ; yes this is backward for "historical" reasons
[02458] e1b7: 59                        str           r9
[02459] e1b8: 1b                        inc           rb
[02460] e1b9: 1b                        inc           rb
[02461] e1ba: 1b                        inc           rb                   ; put it back
[02462]                   
[02463] e1bb: 0b                        ldn           rb                   ; get next byte
[02464] e1bc: ff fe                     smi           T_ASCII              ; it must be an ascii mark
[02465] e1be: ca dd 2d                  lbnz          error                ; jump if not
[02466] e1c1: 1b                        inc           rb                   ; move into string
[02467]                   colonlp1:                                        ; here for both cases
[02468] e1c2: 0b                        ldn           rb
[02469] e1c3: ff ff                     smi           T_NUM                ; a number could have T_EOS or F_SEMI in it!
[02470] e1c5: 3a cc                     bnz           colonckend
[02471] e1c7: 1b                        inc           rb
[02472] e1c8: 1b                        inc           rb
[02473] e1c9: 1b                        inc           rb
[02474] e1ca: 30 c2                     br            colonlp1
[02475]                   colonckend:
[02476] e1cc: 0b                        ldn           rb
[02477] e1cd: ff fd                     smi           T_EOS
[02478] e1cf: c2 e2 1a                  lbz           colonmark
[02479] e1d2: 4b                        lda           rb
[02480] e1d3: ff 88                     smi           FSEMI                ; look for the ;
[02481] e1d5: 3a c2                     bnz           colonlp1             ; jump if terminator not found
[02482] e1d7: f8 00                     ldi           0                    ; want a command terminator
[02483] e1d9: 5b                        str           rb                   ; write it
[02484] e1da: 1b                        inc           rb                   ; new value for freemem
[02485] e1db: d4 e5 38                  call         ismulti
[02486] e1de: 32 f0                     bz           colonpreline         ; single line
[02487]                   ; end of multiline
[02488] e1e0: f8 02                     ldi           02
[02489] e1e2: 59                        str           r9                  ; end of multi marker ([JUMP]==2)
[02490] e1e3: 19                        inc           r9
[02491] e1e4: 49                        lda           r9
[02492] e1e5: 73                        stxd
[02493] e1e6: 09                        ldn           r9
[02494] e1e7: 52                        str           r2
[02495] e1e8: f8 06                     ldi           low freemem
[02496] e1ea: a9                        plo           r9
[02497] e1eb: 42                        lda           r2
[02498] e1ec: 59                        str           r9
[02499] e1ed: 19                        inc           r9
[02500] e1ee: 02                        ldn           r2
[02501] e1ef: 59                        str           r9
[02502]                   ; now the freemem is back to the beginning of the multiline (or we jumped here on a single line)
[02503]                   colonpreline:
[02504] e1f0: f8 06                     ldi           low freemem          ; set R9 to free memory
[02505] e1f2: a9                        plo           r9
[02506] e1f3: 49                        lda           r9                   ; get current pointer
[02507] e1f4: b7                        phi           r7                   ; place here
[02508] e1f5: 09                        ldn           r9                   ; get low byte
[02509] e1f6: a7                        plo           r7
[02510] e1f7: 9b                        ghi           rb                   ; get memory pointer
[02511] e1f8: 57                        str           r7                   ; and store into link list
[02512] e1f9: 17                        inc           r7
[02513] e1fa: 8b                        glo           rb
[02514] e1fb: 57                        str           r7
[02515]                   ccolonpmult:                                     ; come here to only update freemem
[02516] e1fc: 8b                        glo           rb                   ; store new freemem value
[02517] e1fd: 59                        str           r9
[02518] e1fe: 29                        dec           r9
[02519] e1ff: 9b                        ghi           rb
[02520] e200: 59                        str           r9
[02521] e201: f8 0a                     ldi           low jump
[02522] e203: a9                        plo           r9
[02523] e204: 09                        ldn           r9
[02524] e205: fb 01                     xri           1
[02525] e207: c2 e2 0f                  lbz            colonnend
[02526] e20a: f8 00                     ldi           0                    ; need zero at end of list (only if finished)
[02527] e20c: 5b                        str           rb                   ; store it
[02528] e20d: 1b                        inc           rb
[02529] e20e: 5b                        str           rb
[02530]                   colonnend:
[02531]                   ;           ldi     low jump    ; already loaded!
[02532]                   ;           plo     r9
[02533] e20f: 09                        ldn           r9
[02534] e210: fb 02                     xri           2                    ; end of multiline
[02535] e212: 3a 17                     bnz           csemi
[02536] e214: f8 c0                     ldi           0c0h
[02537] e216: 59                        str           r9                   ; mark back to normal
[02619]                   #endif
[02620]                   cthen:
[02621]                   csemi:
[02622] e217: c0 dd 2a                  lbr           good                 ; return
[02623]                   colonmark:
[02624] e21a: f8 00                     ldi           0
[02625] e21c: 5b                        str           rb
[02626] e21d: 1b                        inc           rb
[02627] e21e: 5b                        str           rb                   ; temporary end mark
[02628] e21f: 2b                        dec           rb
[02629] e220: d4 e5 38                  call          ismulti
[02630] e223: 3a 28                     bnz           colonmcont           ; already marked
[02631] e225: f8 01                     ldi           1
[02632] e227: 59                        str           r9
[02643]                   #endif
[02644]                   colonmcont:
[02645] e228: f8 07                     ldi           low freemem+1
[02646] e22a: a9                        plo           r9                   ; set up for main code
[02647] e22b: c0 e1 fc                  lbr            ccolonpmult
[02648]                   
[02649]                   
[02650]                   
[02651] e22e: f8 15 a7 f8 clist:        mov           r7,storage
              04 b7 
[02652]                   clist0:
[02653] e234: 87 73 97 73               push          r7
[02654] e238: 07                        ldn           r7
[02655] e239: 3a 47                     bnz           clist1
[02656] e23b: 17                        inc           r7
[02657] e23c: 07                        ldn           r7
[02658] e23d: 3a 47                     bnz           clist1
[02659] e23f: 60 72 b7 f0               pop           r7
              a7 
[02660] e244: c0 dd 2a                  lbr           good
[02661]                   clist1:
[02662] e247: 60 72 b7 f0               pop           r7
              a7 
[02663] e24c: 87 73 97 73               push          r7
[02664] e250: f8 14                     ldi           low option+1   ; can't call testopt because we push value
[02665] e252: a9                        plo           r9
[02666] e253: 09                        ldn           r9
[02667] e254: 73                        stxd
[02668] e255: fa fe                     ani           0feh   ; turn on spaces (but save to restore)
[02669] e257: 59                        str           r9
[02670] e258: d4 e2 9e                  call          csee_sub0
[02671] e25b: f8 14                     ldi           low option+1
[02672] e25d: a9                        plo           r9
[02673] e25e: 60                        irx
[02674] e25f: 02                        ldn           r2
[02675] e260: 59                        str           r9    ; restore option byte
[02676] e261: 60 72 b7 f0               pop           r7
              a7 
[02677] e266: 07                        ldn           r7
[02678] e267: bb                        phi           rb
[02679] e268: 17                        inc           r7
[02680] e269: 07                        ldn           r7
[02681] e26a: a7                        plo           r7
[02682] e26b: 9b                        ghi           rb
[02683] e26c: b7                        phi           r7
[02684] e26d: 30 34                     br            clist0
[02685] e26f: 82 aa 92 ba csee:         mov           ra,r2
[02686] e273: 1a                        inc           ra                   ; point to R[6]
[02687] e274: 4a                        lda           ra                   ; and retrieve it
[02688] e275: b8                        phi           r8
[02689] e276: 0a                        ldn           ra
[02690] e277: a8                        plo           r8
[02691] e278: 08                        ldn           r8                   ; get next byte
[02692] e279: ff fe                     smi           T_ASCII              ; it must be an ascii mark
[02693] e27b: ca dd 2d                  lbnz          error                ; jump if not
[02694] e27e: 18                        inc           r8                   ; move into string
[02695] e27f: d4 d8 99                  call          findname             ; find the name
[02696] e282: c3 dd 2d                  lbdf          error                ; jump if not found
[02697] e285: 88                        glo           r8                   ; put new address into inst pointer
[02698] e286: 5a                        str           ra
[02699] e287: 2a                        dec           ra
[02700] e288: 98                        ghi           r8
[02701] e289: 5a                        str           ra
[02702] e28a: f8 14                     ldi           low option+1          ; don't call testopt here (pushes value)
[02703] e28c: a9                        plo           r9
[02704] e28d: 09                        ldn           r9
[02705] e28e: 73                        stxd
[02706] e28f: fa fe                     ani           0feh
[02707] e291: 59                        str           r9
[02708] e292: d4 e2 a8                  call          csee_sub
[02709] e295: f8 14                     ldi           low option+1
[02710] e297: a9                        plo           r9
[02711] e298: 60                        irx
[02712] e299: 02                        ldn           r2
[02713] e29a: 59                        str           r9
[02714] e29b: c0 dd 2a                  lbr           good                 ; otherwise good
[02715]                                 ;  make see callable so we can use it from inside Forth words
[02716]                                 ; points to next address)
[02717]                                 ;  rb = first byte in data
[02718]                                 ;  user callable csee_sub0 only requires r7. If r7 and rb are set call csee_sub
[02719]                   csee_sub0:
[02720] e29e: 87 ab 97 bb               mov           rb,r7
[02721] e2a2: 1b                        inc           rb
[02722] e2a3: 1b                        inc           rb
[02723] e2a4: 0b          csub0:        ldn           rb                   ; set up rb to point correctly
[02724] e2a5: 1b                        inc           rb
[02725] e2a6: 3a a4                     bnz           csub0
[02726]                   csee_sub:
[02727] e2a8: 47                        lda           r7                   ; move past next address  (store next in in RF for later)
[02728] e2a9: bf                        phi           rf
[02729] e2aa: 47                        lda           r7
[02730] e2ab: af                        plo           rf
[02731] e2ac: 07                        ldn           r7                   ; get type byte
[02732] e2ad: ff 86                     smi           86h                  ; check for variable
[02733] e2af: ca e3 96                  lbnz          cseefunc             ; jump if not
[02734] e2b2: d4 ff 66                  call          f_inmsg
[02735] e2b5: 43 52 45 41               db            'CREATE ',0
              54 45 20 00 
[02736] e2bd: 17                        inc           r7                   ; skip variable mark
[02737] e2be: 87 73 97 73               push          r7
[02738]                   seevname:
[02739] e2c2: 17                        inc           r7                   ; point to name
[02740] e2c3: 07                        ldn           r7
[02741] e2c4: 32 cb                     bz            seeveq
[02742] e2c6: d4 d8 3b                  call          disp
[02743] e2c9: 30 c2                     br            seevname
[02744]                   seeveq:
[02745] e2cb: d4 d8 2f                  call          crlfout
[02746]                                 ;  need to see if we need an allot here
[02747]                                 ; if [next]-2 == rb then we do not need it
[02748]                                 ; since we allow CREATE and always use it now we nearly always need an allot
[02749] e2ce: 8f                        glo           rf
[02750] e2cf: 52                        str           r2
[02751] e2d0: 8b                        glo           rb                   ; (next-2)-dataaddress
[02752] e2d1: f5                        sd
[02753] e2d2: af                        plo           rf
[02754] e2d3: 9f                        ghi           rf
[02755] e2d4: 52                        str           r2
[02756] e2d5: 9b                        ghi           rb
[02757] e2d6: 75                        sdb
[02758] e2d7: bf                        phi           rf                   ; now RF is the offset
[02759] e2d8: 52                        str           r2
[02760] e2d9: 8f                        glo           rf
[02761] e2da: f1                        or
[02762]                   ;              bz           seevnoa              ; was equal, jump
[02763]                   ; with create, if we don't need allot then we are done
[02764] e2db: c2 e3 70                  lbz            seedone
[02765]                   seevallot:
[02766]                                 ; ok we need to do the allot here
[02767] e2de: 8b 73 9b 73               push          rb
[02768] e2e2: 9f                        ghi           rf
[02771]                   #endif
[02772] e2e3: bb                        phi           rb
[02773] e2e4: 8f                        glo           rf
[02776]                   #endif
[02777] e2e5: ab                        plo           rb
[02778] e2e6: d4 e7 a8                  call          typenumind           ; type count
[02779] e2e9: d4 ff 66                  call          f_inmsg
[02780] e2ec: 41 4c 4c 4f               db            'ALLOT',10,13,0
              54 0a 0d 00 
[02781]                                 ;   dump all words (rf has byte count which needs +2 for the original word)
[02782]                   ;              inc           rf
[02783]                   ;              inc           rf
[02784]                   ; we should check if the length is odd. If so, we do one C! at the start and the rest we do !
[02785]                   ; with full words to minimize the amount of data we spit out
[02786] e2f4: 60 72 bb f0               pop           rb                   ; start address
              ab 
[02787]                   #ifdef OPT_BY_CALL
[02788] e2f9: d4 e5 2e                  call          testopt
[02789] e2fc: 20                        db            20h    ; option 20h - don't dump data for variables
[02796]                   #endif
[02797] e2fd: ca e3 70                  lbnz           seedone
[02798]                   
[02799] e300: f8 00                     ldi           0
[02800] e302: bc                        phi           rc
[02801] e303: ac                        plo           rc
[02802]                   seesto:
[02803] e304: 8b 73 9b 73               push          rb                   ; save for addr disp
[02804] e308: 4b                        lda           rb
[02805] e309: ae                        plo           re
[02806]                   ; check for odd count
[02807] e30a: 8f                        glo           rf
[02808] e30b: fa 01                     ani           1
[02809] e30d: 32 16                     bz            seeeven
[02810] e30f: 8e                        glo           re
[02811] e310: ab                        plo           rb                   ; move for
[02812] e311: f8 00                     ldi           0                    ; byte only
[02813] e313: bb                        phi           rb
[02814] e314: 30 1a                     br            seeodd
[02815]                   seeeven:
[02816] e316: 4b                        lda           rb
[02817] e317: ab                        plo           rb
[02818] e318: 8e                        glo           re
[02819] e319: bb                        phi           rb
[02820]                   seeodd:
[02821] e31a: d4 e7 a8                  call          typenumind           ; print data
[02822] e31d: 60 72 bb f0               pop           rb
              ab 
[02823] e322: 60 72 b7 f0               pop           r7
              a7 
[02824] e327: 87 73 97 73               push          r7
[02825] e32b: 8b 73 9b 73               push          rb
[02826]                   seevnamea:
[02827] e32f: 17                        inc           r7                   ; point to name
[02828] e330: 07                        ldn           r7
[02829] e331: 32 38                     bz            seevdata
[02830] e333: d4 d8 3b                  call          disp
[02831] e336: 30 2f                     br            seevnamea
[02832]                   seevdata:
[02833] e338: d4 d8 36                  call          dispsp
[02834] e33b: 8c ab 9c bb               mov           rb,rc
[02835] e33f: d4 e7 a8                  call          typenumind
[02836] e342: 60 72 bb f0               pop           rb                   ; print n
              ab 
[02837] e347: d4 ff 66                  call          f_inmsg
[02838] e34a: 2b 20 00                  db            '+ ',0
[02839] e34d: 8f                        glo           rf
[02840] e34e: fa 01                     ani           1
[02841] e350: 32 5b                     bz            seeeven1
[02842] e352: 2f                        dec           rf                   ; now it is even
[02843] e353: d4 d8 3a                  call          dispf
[02844] e356: 43                        db            'C'
[02845] e357: 1c                        inc           rc                   ; increase count
[02846] e358: 1b                        inc           rb
[02847] e359: 30 61                     br            seecont
[02848]                   seeeven1:
[02849] e35b: 1c                        inc           rc
[02850] e35c: 1c                        inc           rc
[02851] e35d: 1b                        inc           rb
[02852] e35e: 1b                        inc           rb
[02853] e35f: 2f                        dec           rf
[02854] e360: 2f                        dec           rf
[02855]                   seecont:
[02856] e361: d4 ff 66                  call          f_inmsg
[02857] e364: 21 0a 0d 00               db            '!',10,13,0
[02858]                                 ;  stop when rf is zero (assumes rf was even or made even)
[02859] e368: 8f                        glo           rf
[02860] e369: ca e3 04                  lbnz           seesto
[02861] e36c: 9f                        ghi           rf
[02862] e36d: ca e3 04                  lbnz           seesto
[02863]                   seedone:
[02864] e370: 60 72 b7 f0               pop           r7
              a7 
[02865] e375: d5          execdn:       rtn                                ; final CRLF already in place
[02866]                   seevnoa:
[02867] e376: 4b                        lda           rb                   ; get value
[02868] e377: b7                        phi           r7
[02869] e378: 4b                        lda           rb
[02870] e379: ab                        plo           rb
[02871] e37a: 97                        ghi           r7
[02872] e37b: bb                        phi           rb
[02873] e37c: d4 e7 a8                  call          typenumind
[02874] e37f: 60 72 b7 f0               pop           r7
              a7 
[02875]                   seevname1:
[02876] e384: 17                        inc           r7
[02877] e385: 07                        ldn           r7
[02878] e386: 32 8d                     bz            seeveq1
[02879] e388: d4 d8 3b                  call          disp
[02880] e38b: 30 84                      br            seevname1
[02881]                   seeveq1:
[02882] e38d: d4 ff 66                  call          f_inmsg
[02883] e390: 20 21 00                  db            ' !',0
[02884] e393: c0 d8 2f    seeexit:      lbr           crlfout              ; and return
[02885] e396: d4 d8 3a    cseefunc:     call          dispf
[02886] e399: 3a                        db            ':'
[02887] e39a: 17                        inc           r7                   ; move address to name
[02888] e39b: d4 d8 36    seefunclp:    call          dispsp
[02889]                   seefunclpns:
[02890] e39e: 07                        ldn           r7                   ; get next token
[02891] e39f: c2 d8 2f                  lbz            crlfout              ; jump if done
[02892] e3a2: ff fe                     smi           T_ASCII              ; check for ascii
[02893] e3a4: 3a b3                     bnz           seenota              ; jump if not ascii
[02894] e3a6: 17                        inc           r7                   ; move into string
[02895] e3a7: 07          seestrlp:     ldn           r7                   ; get next byte
[02896] e3a8: 32 b0                     bz            seenext              ; jump if done with token
[02897] e3aa: d4 d8 3b                  call          disp
[02898] e3ad: 17                        inc           r7                   ; point to next character
[02899] e3ae: 30 a7                     br            seestrlp             ; and continue til done
[02900] e3b0: 17          seenext:      inc           r7                   ; point to next token
[02901] e3b1: 30 9b                     br            seefunclp
[02902] e3b3: 07          seenota:      ldn           r7                   ; reget token
[02903] e3b4: ff ff                     smi           T_NUM                ; is it a number
[02904] e3b6: 3a cc                     bnz           seenotn              ; jump if not a number
[02905] e3b8: 17                        inc           r7                   ; move past token
[02906] e3b9: 47                        lda           r7                   ; get number into rb
[02907] e3ba: bb                        phi           rb
[02908] e3bb: 07                        ldn           r7
[02909] e3bc: ab                        plo           rb
[02910] e3bd: 87                        glo           r7                   ; save r7
[02911] e3be: 73                        stxd
[02912] e3bf: 97                        ghi           r7
[02913] e3c0: 73                        stxd
[02914] e3c1: d4 e7 a8                  call          typenumind           ; display the number
[02915] e3c4: 60                        irx                                ; retrieve r7
[02916] e3c5: 72                        ldxa
[02917] e3c6: b7                        phi           r7
[02918] e3c7: f0                        ldx
[02919] e3c8: a7                        plo           r7
[02920] e3c9: 17                        inc           r7
[02921] e3ca: 30 9e                     br            seefunclpns          ; next token with no space
[02922] e3cc: d4 e3 d1    seenotn:      call          dottok
[02923] e3cf: 30 b0                     br            seenext              ; jump for next token
[02924]                   
[02925]                   
[02926] e3d1: f8 8e ab f8 dottok:       mov           rb,cmdtable
              e9 bb 
[02927] e3d7: 07                        ldn           r7                   ; get token
[02928] e3d8: fa 7f                     ani           07fh                 ; strip high bit
[02929] e3da: a8                        plo           r8                   ; token counter
[02930] e3db: 28          seenotnlp:    dec           r8                   ; decrement count
[02931] e3dc: 88                        glo           r8                   ; get count
[02932] e3dd: 32 e6                     bz            seetoken             ; found the token
[02933] e3df: 4b          seelp3:       lda           rb                   ; get byte from token
[02934] e3e0: fa 80                     ani           128                  ; was it last one?
[02935] e3e2: 3a db                     bnz           seenotnlp            ; jump if it was
[02936] e3e4: 30 df                      br            seelp3               ; keep looking
[02937] e3e6: 0b          seetoken:     ldn           rb                   ; get byte from token
[02938] e3e7: fa 80                     ani           128                  ; is it last
[02939] e3e9: 3a f2                     bnz           seetklast            ; jump if so
[02940] e3eb: 0b                        ldn           rb                   ; retrieve byte
[02941] e3ec: d4 d8 3b                  call          disp
[02942] e3ef: 1b                        inc           rb                   ; point to next character
[02943] e3f0: 30 e6                     br            seetoken             ; and loop til done
[02944] e3f2: 0b          seetklast:    ldn           rb                   ; retrieve byte
[02945] e3f3: fa 7f                     ani           07fh                 ; strip high bit
[02946] e3f5: c0 d8 3b                  lbr           disp                 ; display and hidden return
[02947]                   
[02948]                   
[02949] e3f8: 82 aa 92 ba cdotqt:       mov           ra,r2
[02950] e3fc: 1a                        inc           ra                   ; point to R[6]
[02951] e3fd: 4a                        lda           ra                   ; and retrieve it
[02952] e3fe: b8                        phi           r8
[02953] e3ff: 0a                        ldn           ra
[02954] e400: a8                        plo           r8
[02955] e401: 08                        ldn           r8                   ; get next byte
[02956] e402: ff fe                     smi           T_ASCII              ; it must be an ascii mark
[02957] e404: ca dd 2d                  lbnz          error                ; jump if not
[02958] e407: 18                        inc           r8                   ; move past ascii mark
[02959] e408: 48          cdotqtlp:     lda           r8                   ; get next byte
[02960] e409: 32 18                     bz            cdotqtdn             ; jump if terinator
[02961] e40b: ff 22                     smi           34                   ; check for quote
[02962] e40d: c2 e4 08                  lbz            cdotqtlp             ; do not display quotes
[02963] e410: 28                        dec           r8
[02964] e411: 48                        lda           r8
[02965] e412: d4 d8 3b                  call          disp
[02966] e415: c0 e4 08                  lbr            cdotqtlp             ; loop back
[02967] e418: 88          cdotqtdn:     glo           r8                   ; put pointer back
[02968] e419: 5a                        str           ra
[02969] e41a: 2a                        dec           ra
[02970] e41b: 98                        ghi           r8
[02971] e41c: 5a                        str           ra
[02972] e41d: c0 dd 2a                  lbr           good                 ; and return
[02973]                   ckey:
[02974] e420: f8 00                     ldi           0                    ; zero the high byte
[02975] e422: bb                        phi           rb
[02976] e423: d4 d8 3e                  call          getkey
[02977] e426: c0 dd c2                  lbr           goodpushb0
[02978]                                 ; [GDJ]
[02979]                   ckeyq:
[02980] e429: f8 00                     ldi           0
[02981] e42b: bb                        phi           rb
[02982] e42c: d4 f8 0f                  call          f_utest
[02983] e42f: f8 00                     ldi           0
[02984] e431: c7                        lsnf
[02985] e432: f8 01                     ldi           1
[02986] e434: c0 dd c2                  lbr           goodpushb0
[02987]                   
[02988]                   #ifdef USE_CBUFFER
[02989]                   ; very simple. Make sure we are in a good place and adjust the here pointer
[02990] e437: f8 15 a7 f8 callot:       mov           r7,storage
              04 b7 
[02991] e43d: 47          callotlp1:    lda           r7                   ; get next link
[02992] e43e: b8                        phi           r8
[02993] e43f: 07                        ldn           r7
[02994] e440: a8                        plo           r8
[02995] e441: 48                        lda           r8                   ; get value at that link
[02996] e442: bb                        phi           rb
[02997] e443: 08                        ldn           r8
[02998] e444: 28                        dec           r8                   ; keep r8 pointing at link
[02999] e445: 3a 4c                     bnz           callotno             ; jump if next link is not zero
[03000] e447: 9b                        ghi           rb                   ; check high byte
[03001] e448: 3a 4c                     bnz           callotno             ; jump if not zero
[03002] e44a: 30 52                     br            callotyes
[03003] e44c: 88 a7 98 b7 callotno:     mov           r7,r8                ; r7=link
[03004] e450: 30 3d                     br            callotlp1            ; and keep looking
[03005] e452: 17          callotyes:    inc           r7                   ; point to type byte
[03006] e453: 07                        ldn           r7                   ; get it
[03007] e454: ff 86                     smi           FVARIABLE            ; it must be a variable
[03008] e456: ca dd 2d                  lbnz          error                ; jump if not
[03009] e459: d4 d8 41                  call          pop
[03010] e45c: c3 dd 2d                  lbdf          error                ; jump if error
[03011]                   ; here R8 points to the zero and R7 points to the FVARIABLE. RB has the amount to adjust
[03012] e45f: 27                        dec          r7           ; point to low part
[03013]                   
[03014] e460: f8 07                     ldi          low freemem+1
[03015] e462: a9                        plo          r9
[03016] e463: 8b                        glo          rb
[03017] e464: 52                        str          r2
[03018] e465: 88                        glo          r8
[03019] e466: f4                        add
[03020] e467: 59                        str          r9
[03021] e468: 57                        str          r7
[03022] e469: af                        plo          rf
[03023] e46a: 29                        dec          r9
[03024] e46b: 27                        dec          r7
[03025] e46c: 9b                        ghi          rb
[03026] e46d: 52                        str          r2
[03027] e46e: 98                        ghi          r8
[03028] e46f: 74                        adc
[03029] e470: 59                        str          r9
[03030] e471: 57                        str          r7
[03031] e472: bf                        phi          rf
[03032] e473: f8 00                     ldi          0
[03033] e475: 5f                        str          rf
[03034] e476: 1f                        inc          rf
[03035] e477: 5f                        str          rf
[03036] e478: c0 dd 2a                  lbr          good
[03037]                   
[03038]                   
[03090]                   #endif
[03091]                   
[03092] e47b: d4 e5 08    cmul:         call          pop2
[03093] e47e: c3 dd 2d    lerror1:      lbdf          error                ; jump on error
[03094] e481: d4 d9 27                  call          mul16
[03095] e484: c0 dd 27                  lbr           goodpush
[03096] e487: d4 e5 08    cdiv:         call          pop2
[03097] e48a: 33 7e                     bdf           lerror1                ; jump on error
[03098] e48c: 99                        ghi           r9                   ; save our data segment!
[03099] e48d: 73                        stxd
[03100] e48e: d4 d9 7f                  call          div16
[03101] e491: 60                        irx
[03102] e492: f0                        ldx
[03103] e493: b9                        phi           r9
[03104] e494: 9c          cdivr:        ghi           rc                   ; transfer answer
[03105] e495: bb                        phi           rb
[03106] e496: 8c                        glo           rc
[03107] e497: c0 dd c2                  lbr           goodpushb0
[03108]                   
[03109] e49a: 82 aa 92 ba cforget:      mov           ra,r2
[03110] e49e: 1a                        inc           ra                   ; point to ra
[03111] e49f: 4a                        lda           ra                   ; and retrieve it
[03112] e4a0: b8                        phi           r8
[03113] e4a1: 0a                        ldn           ra
[03114] e4a2: a8                        plo           r8
[03115] e4a3: 08                        ldn           r8                   ; get next byte
[03116] e4a4: ff fe                     smi           T_ASCII              ; it must be an ascii mark
[03117] e4a6: ca dd 2d                  lbnz          error                ; jump if not
[03118] e4a9: 18                        inc           r8                   ; move into string
[03119] e4aa: d4 d8 99                  call          findname
[03120] e4ad: 33 7e                     bdf           lerror1                ; jump if not found
[03121] e4af: 88                        glo           r8
[03122] e4b0: 5a                        str           ra
[03123] e4b1: 2a                        dec           ra
[03124] e4b2: 98                        ghi           r8
[03125] e4b3: 5a                        str           ra
[03126] e4b4: 47                        lda           r7                   ; get next entry
[03127] e4b5: bb                        phi           rb
[03128] e4b6: 07                        ldn           r7
[03129] e4b7: ab                        plo           rb
[03130] e4b8: 27                        dec           r7
[03131] e4b9: 87                        glo           r7                   ; find difference in pointers
[03132] e4ba: 52                        str           r2
[03133] e4bb: 8b                        glo           rb
[03134] e4bc: f7                        sm
[03135] e4bd: ac                        plo           rc
[03136] e4be: 97                        ghi           r7
[03137] e4bf: 52                        str           r2
[03138] e4c0: 9b                        ghi           rb
[03139] e4c1: 77                        smb
[03140] e4c2: bc                        phi           rc                   ; RC now has offset, RB is next descr.
[03141] e4c3: 4b          forgetlp1:    lda           rb                   ; get pointer
[03142] e4c4: ba                        phi           ra                   ; put into ra
[03143] e4c5: 52                        str           r2
[03144] e4c6: 0b                        ldn           rb
[03145] e4c7: aa                        plo           ra
[03146] e4c8: f1                        or                                 ; see if it was zero
[03147] e4c9: 32 dc                     bz            forgetd1             ; jump if it was
[03148] e4cb: 8c                        glo           rc                   ; subtract RC from RA
[03149] e4cc: 52                        str           r2
[03150] e4cd: 8a                        glo           ra
[03151] e4ce: f7                        sm
[03152] e4cf: 5b                        str           rb                   ; store back into pointer
[03153] e4d0: 2b                        dec           rb
[03154] e4d1: 9c                        ghi           rc
[03155] e4d2: 52                        str           r2
[03156] e4d3: 9a                        ghi           ra
[03157] e4d4: 77                        smb
[03158] e4d5: 5b                        str           rb
[03159] e4d6: 8a ab 9a bb               mov           rb,ra
[03160] e4da: 30 c3                     br            forgetlp1            ; loop until done
[03161] e4dc: 47          forgetd1:     lda           r7                   ; get next entry
[03162] e4dd: bb                        phi           rb
[03163] e4de: 07                        ldn           r7
[03164] e4df: ab                        plo           rb
[03165] e4e0: 27                        dec           r7
[03166] e4e1: f8 06                     ldi           low freemem          ; get end of memory pointer
[03167] e4e3: a9                        plo           r9                   ; and place into data frame
[03168] e4e4: 49                        lda           r9                   ; get free memory position
[03169] e4e5: b8                        phi           r8
[03170] e4e6: 09                        ldn           r9
[03171] e4e7: a8                        plo           r8
[03172] e4e8: 18                        inc           r8                   ; account for zero bytes at end
[03173] e4e9: 18                        inc           r8
[03174] e4ea: 8b                        glo           rb                   ; subtract RB from R8
[03175] e4eb: 52                        str           r2
[03176] e4ec: 88                        glo           r8
[03177] e4ed: f7                        sm
[03178] e4ee: a8                        plo           r8
[03179] e4ef: 9b                        ghi           rb
[03180] e4f0: 52                        str           r2
[03181] e4f1: 98                        ghi           r8
[03182] e4f2: 77                        smb
[03183] e4f3: b8                        phi           r8                   ; r8 now has number of bytes to move
[03184] e4f4: 4b          forgetlp:     lda           rb                   ; get byte from higher memory
[03185] e4f5: 57                        str           r7                   ; write to lower memory
[03186] e4f6: 17                        inc           r7                   ; point to next position
[03187] e4f7: 28                        dec           r8                   ; decrement the count
[03188] e4f8: 88                        glo           r8                   ; check for zero
[03189] e4f9: 3a f4       localfglp:    bnz           forgetlp
[03190] e4fb: 98                        ghi           r8
[03191] e4fc: 3a f4                     bnz           forgetlp
[03192] e4fe: 27                        dec           r7                   ; move back to freemem position
[03193] e4ff: 27                        dec           r7
[03194] e500: 87                        glo           r7                   ; store back into freemem pointer
[03195] e501: 59                        str           r9
[03196] e502: 29                        dec           r9
[03197] e503: 97                        ghi           r7
[03198] e504: 59                        str           r9
[03199] e505: c0 dd 2a                  lbr           good                 ; and return
[03200]                   
[03201]                   
[03202]                   
[03203]                   
[03204] e508: d4 d8 41    pop2:         call         pop
[03205] e50b: 33 1a                     bdf          pop2dn
[03206] e50d: 8b a7 9b b7               mov          r7,rb
[03207] e511: c0 d8 41                  lbr           pop                   ; hidden return
[03208]                   
[03209]                   ; call to get a variable into RA, take var offest (1 byte) after call
[03210] e514: 46          getvar:      lda            r6                    ; read variable #
[03211] e515: a9                       plo            r9
[03212] e516: 49                       lda            r9
[03213] e517: ba                       phi            ra
[03214] e518: 09                       ldn            r9
[03215] e519: aa                       plo            ra
[03216] e51a: d5          pop2dn:      rtn
[03217]                   
[03218] e51b: f8 13 ab f8 copt:         mov           rb,option
              04 bb 
[03219] e521: c0 dd 27                  lbr           goodpush
[03220]                   
[03221] e524: d4 d8 41    cerror:       call          pop
[03222] e527: c3 dd 2d                  lbdf          error                ; jump on error
[03223] e52a: 8b                        glo           rb                   ; get returned value
[03224] e52b: c0 dc c2                  lbr           execret              ; return to caller
[03225]                   
[03226]                   
[03227]                   
[03228]                   
[03229]                   #ifdef OPT_BY_CALL
[03230]                   ; test option against mask (z if true)
[03231] e52e: 46          testopt:    lda            r6
[03232] e52f: 22                      dec            r2  ; just in case
[03233] e530: 52                      str            r2
[03234] e531: f8 14                   ldi            low option+1
[03235] e533: a9                      plo            r9
[03236] e534: 09                      ldn            r9
[03237] e535: f2                      and
[03238] e536: 12                      inc            r2  ; restore sp
[03239] e537: d5                      rtn
[03240]                   #endif
[03241]                   
[03242]                   
[03243]                   
[03244]                   
[03245]                   
[03246]                   ; test to see if we are in multi line colon definition
[03247]                   ; This is a hack -- it uses JUMP which we are otherwise not using at the time
[03248]                   ; If byte 0 is C0 we are NOT in a multiline
[03249]                   ; if byte 0 is 1 or 2, we are at some point in a multiline
[03250]                   ; and then byte 1 and 2 have a pointer back to the first line's empty link
[03251]                   
[03252] e538: f8 0a       ismulti:    ldi   low jump
[03253] e53a: a9                      plo   r9
[03254] e53b: 09                      ldn   r9
[03255] e53c: fb c0                   xri   0c0h    ; returns non-zero if we ARE in multi mode
[03256] e53e: d5                      rtn
[03257]                   
[03258] e53f: d4 d8 41    crpexcl:      call          pop
[03259] e542: c3 dd 2d                  lbdf          error
[03260] e545: f8 02                     ldi           low rstack
[03261] e547: a9          pexcl:        plo           r9
[03262] e548: 9b                        ghi           rb
[03263] e549: 59                        str           r9
[03264] e54a: 19                        inc           r9
[03265] e54b: 8b                        glo           rb
[03266] e54c: 59                        str           r9
[03267] e54d: c0 dd 2a                  lbr            good
[03268]                   
[03269] e550: d4 d8 41    cspexcl:      call          pop
[03270] e553: c3 dd 2d                  lbdf          error
[03271] e556: f8 08                     ldi           low fstack
[03272] e558: 30 47                     br            pexcl
[03273]                   
[03274] e55a: d4 e5 14    crp0:         call          getvar
[03275] e55d: 00                        db            low himem
[03276] e55e: 9a                        ghi           ra
[03277] e55f: ff 01                     smi           1
[03278]                   rsp0:
[03279] e561: bb                        phi           rb
[03280] e562: 8a                        glo           ra
[03281] e563: c0 dd c2                  lbr           goodpushb0
[03282]                   
[03283] e566: d4 e5 14    csp0:         call          getvar
[03284] e569: 00                        db            low himem
[03285] e56a: 9a                        ghi           ra
[03286] e56b: ff 02                     smi           2
[03287] e56d: 30 61                     br            rsp0
[03288] e56f: f8 00 ab f8 ctib:         mov           rb,buffer
              02 bb 
[03289] e575: c0 dd 27                  lbr           goodpush
[03290]                   
[03291]                   
[03292] e578: d4 e5 14    cspat:        call          getvar
[03293] e57b: 08                        db            low fstack
[03294] e57c: 1a          addat:        inc           ra
[03295] e57d: 8a ab 9a bb goodpusha:    mov           rb,ra
[03296] e581: c0 dd 27                  lbr           goodpush
[03297] e584: d4 e5 14    crpat:        call          getvar
[03298] e587: 02                        db            low rstack
[03299] e588: 30 7c                     br            addat
[03300]                   
[03301] e58a: f8 00       cef:          ldi           0                    ; start with zero
[03302] e58c: bb                        phi           rb
[03303] e58d: 3c 91                     bn1           cef1                 ; jump if ef1 not on
[03304] e58f: f9 01                     ori           1                    ; signal ef1 is on
[03305] e591: 3d 95       cef1:         bn2           cef2                 ; jump if ef2 ot on
[03306] e593: f9 02                     ori           2                    ; signal ef2 is on
[03307] e595: 3e 99       cef2:         bn3           cef3                 ; jump if ef3 not on
[03308] e597: f9 04                     ori           4                    ; signal ef3 is on
[03309] e599: 3f 9d       cef3:         bn4           cef4                 ; jump if ef4 not on
[03310] e59b: f9 08                     ori           8
[03311]                   cef4:
[03312] e59d: c0 dd c2                  lbr           goodpushb0
[03313]                   
[03314]                   
[03315]                   
[03316]                   
[03317] e5a0: d4 e5 08    cout:         call          pop2                  ; value
[03318] e5a3: c3 dd 2d                  lbdf          error                ; jump on error
[03319] e5a6: 87                        glo           r7                   ; get value
[03320] e5a7: 52                        str           r2                   ; store into memory for out (assume X=2)
[03321] e5a8: 8b                        glo           rb                   ; get port
[03322] e5a9: fa 07                     ani           7                    ; value must be 1-7
[03323] e5ab: c2 dd 2d                  lbz           error
[03324] e5ae: ff 01                     smi           1                    ; convert to 0-6
[03325]                                 ;  using a jump table is much shorter than old code
[03326]                                 ;  we take port (0-6) *2 and add outtable
[03327]                                 ;  then we shift PC to RB which will do the work and shift back to P=3
[03328] e5b0: fe                        shl                                ; *2
[03329] e5b1: fc be                     adi           low outtable
[03330] e5b3: af                        plo           rf
[03331] e5b4: f8 e5                     ldi           high outtable
[03332] e5b6: 7c 00                     adci          0                    ; could save some code if we KNEW the table were on one page
[03333] e5b8: bf                        phi           rf
[03334] e5b9: df                        sep           rf
[03335] e5ba: 22                        dec           r2
[03336] e5bb: c0 dd 2a                  lbr           good
[03337]                   outtable:
[03338] e5be: 61                        out           1
[03339] e5bf: d3                        sep           r3
[03340] e5c0: 62                        out           2
[03341] e5c1: d3                        sep           r3
[03342] e5c2: 63                        out           3
[03343] e5c3: d3                        sep           r3
[03344] e5c4: 64                        out           4
[03345] e5c5: d3                        sep           r3
[03346] e5c6: 65                        out           5
[03347] e5c7: d3                        sep           r3
[03348] e5c8: 66                        out           6
[03349] e5c9: d3                        sep           r3
[03350] e5ca: 67                        out           7
[03351] e5cb: d3                        sep           r3
[03352] e5cc: d4 d8 41    cinp:         call          pop
[03353] e5cf: c3 dd 2d                  lbdf          error                ; jump on error
[03354] e5d2: 8b                        glo           rb                   ; get port
[03355] e5d3: fa 07                     ani           7
[03356] e5d5: c2 dd 2d                  lbz           error
[03357] e5d8: ff 01                     smi           1                    ; check port 1
[03358] e5da: fe                        shl
[03359] e5db: fc ea                     adi           low intable
[03360] e5dd: af                        plo           rf
[03361] e5de: f8 e5                     ldi           high intable
[03362] e5e0: 7c 00                     adci          0
[03363] e5e2: bf                        phi           rf
[03364] e5e3: f8 00                     ldi           0
[03365] e5e5: bb                        phi           rb
[03366] e5e6: df                        sep           rf
[03367] e5e7: c0 dd c2                  lbr           goodpushb0
[03368]                   intable:
[03369] e5ea: 69                        inp           1
[03370] e5eb: d3                        sep           r3
[03371] e5ec: 6a                        inp           2
[03372] e5ed: d3                        sep           r3
[03373] e5ee: 6b                        inp           3
[03374] e5ef: d3                        sep           r3
[03375] e5f0: 6c                        inp           4
[03376] e5f1: d3                        sep           r3
[03377] e5f2: 6d                        inp           5
[03378] e5f3: d3                        sep           r3
[03379] e5f4: 6e                        inp           6
[03380] e5f5: d3                        sep           r3
[03381] e5f6: 6f                        inp           7
[03382] e5f7: d3                        sep           r3
[03383]                   
[03384]                   ; -----------------------------------------------------------------
[03385]                   ; additions April 2022  GDJ
[03386]                   ; -----------------------------------------------------------------
[03387] e5f8: d4 e5 08    ccmove:    call    pop2
[03388] e5fb: c3 dd 2d               lbdf    error               ; jump if error
[03389]                                                          ; r7 is count of bytes
[03390] e5fe: 8b a8 9b b8            mov     r8,rb               ; r8 is destination address
[03391] e602: d4 d8 41               call    pop
[03392] e605: c3 dd 2d               lbdf     error               ; jump if error
[03393]                                                          ; rb is source address
[03394]                   
[03395]                              ; transfer data
[03396]                              ; begin check for zero byte count else tragedy could result
[03397] e608: 87          cmovelp:   glo     r7
[03398] e609: 3a 0f                  bnz    cmovestr
[03399] e60b: 97                     ghi     r7
[03400]                   
[03401] e60c: c2 dd 2a               lbz     good
[03402] e60f: 4b          cmovestr:  lda     rb
[03403] e610: 58                     str     r8
[03404] e611: 18                     inc     r8
[03405] e612: 27                     dec     r7
[03406] e613: c0 e6 08               lbr     cmovelp
[03407]                   
[03408]                   
[03409] e616: d4 d8 41    csetq:        call          pop
[03410] e619: c3 dd 2d                  lbdf          error                ; jump if error
[03411] e61c: 8b                        glo           rb                   ; get low of return value
[03412] e61d: ce                        lsz
[03413] e61e: 7b                        seq
[03414] e61f: 38                        skp
[03415] e620: 7a          qoff:         req
[03416] e621: c0 dd 2a                  lbr           good
[03417]                   
[03418] e624: d4 e8 4b    crand:        call          randbyte
[03419] e627: 98                        ghi           r8
[03420] e628: ab                        plo           rb
[03421] e629: f8 00                     ldi           0
[03422] e62b: c0 dd 47                  lbr           goodpushb
[03423]                                 ;  call f_msg but first store terminator and reset f to buffer
[03424] e62e: f8 00       f_msg_term:   ldi           0
[03425] e630: 5f                        str           rf
[03426] e631: f8 00 af f8               mov           rf, buffer
              02 bf 
[03427] e637: c0 ff 09                  lbr           f_msg
[03428]                   ; -----------------------------------------------------------------------------
[03429]                   ; 'C' style operators for bit shifting, note no range check on number of shifts
[03430]                   ; -----------------------------------------------------------------------------
[03431] e63a: d4 e5 08    clshift:   call    pop2                ; get value from stack
[03432] e63d: c3 dd 2d               lbdf    error               ; jump if stack was empty
[03433]                   
[03434] e640: 87                     glo     r7                  ; zero shift is identity
[03435] e641: 3a 45                  bnz    lshiftlp
[03436] e643: 30 4f                  br     lshiftret           ; return with no shift
[03437]                   
[03438] e645: 8b          lshiftlp:  glo     rb
[03439] e646: fe                     shl                         ; shift lo byte
[03440] e647: ab                     plo     rb
[03441] e648: 9b                     ghi     rb
[03442] e649: 7e                     shlc                        ; shift hi byte with carry
[03443] e64a: bb                     phi     rb
[03444] e64b: 27                     dec     r7
[03445] e64c: 87                     glo     r7
[03446] e64d: 3a 45                  bnz    lshiftlp
[03447]                   ; fall through
[03448]                   lshiftret:
[03449] e64f: c0 dd 27    	   lbr goodpush
[03450]                   
[03451]                   
[03452] e652: d4 e5 08    crshift:   call    pop2
[03453] e655: c3 dd 2d               lbdf    error               ; jump if stack was empty
[03454]                   
[03455] e658: 87                     glo     r7                  ; zero shift is identity
[03456] e659: 3a 5d                  bnz    rshiftlp
[03457] e65b: 30 67                  br     rshiftret           ; return with no shift
[03458]                   
[03459] e65d: 9b          rshiftlp:  ghi     rb
[03460] e65e: f6                     shr                         ; shift hi byte
[03461] e65f: bb                     phi     rb
[03462] e660: 8b                     glo     rb
[03463] e661: 76                     shrc                        ; shift lo byte with carry
[03464] e662: ab                     plo     rb
[03465] e663: 27                     dec     r7
[03466] e664: 87                     glo     r7
[03467] e665: 3a 5d                  bnz    rshiftlp
[03468]                   
[03469]                   rshiftret:
[03470] e667: c0 dd 27    	   lbr goodpush
[03471]                   
[03472]                   
[03473]                   
[03474]                   ; delay for approx 1 millisecond on 4MHz 1802
[03475] e66a: d4 d8 41    cdelay:       call          pop
[03476] e66d: c3 dd 2d                  lbdf          error                ; jump if stack was empty
[03477]                   ; 0 delay turns out to be the same as 0x10000 delay so special case it
[03478] e670: 8b                        glo           rb
[03479] e671: a7                        plo           r7
[03480] e672: 3a 78                     bnz           delaynz
[03481] e674: 9b                        ghi           rb
[03482] e675: c2 dd 2a                  lbz           good
[03483] e678: 9b          delaynz:      ghi           rb                  ; redundant unless you skipped from above
[03484] e679: b7                        phi           r7
[03485] e67a: f8 3c       delaylp1:     ldi           60
[03486] e67c: c4          delaylp2:     nop
[03487] e67d: ff 01                     smi           1
[03488] e67f: ca e6 7c                  lbnz          delaylp2
[03489] e682: 27                        dec           r7
[03490] e683: 87                        glo           r7
[03491] e684: ca e6 7a                  lbnz          delaylp1
[03492] e687: 97                        ghi           r7
[03493] e688: ca e6 7a                  lbnz          delaylp1
[03494] e68b: c0 dd 2a                  lbr           good
[03495]                   
[03496] e68e: d4 d8 41    cexec:        call          pop
[03497] e691: c3 dd 2d                  lbdf          error
[03498] e694: f8 0a                     ldi           low jump             ; point to jump address
[03499] e696: a9                        plo           r9
[03500] e697: f8 c0                     ldi           0c0h                 ; lbr
[03501] e699: 59                        str           r9                  ; store it
[03502] e69a: 19                        inc           r9
[03503] e69b: 9b                        ghi           rb
[03504] e69c: 59                        str           r9
[03505] e69d: 19                        inc           r9
[03506] e69e: 8b                        glo           rb
[03507] e69f: 59                        str           r9
[03508] e6a0: d4 e6 aa                  call          cexec0
[03509]                   ; R9.1 is so critical, we are going to force it back. Same for X
[03510] e6a3: f8 04                     ldi           high himem
[03511] e6a5: b9                        phi           r9
[03512] e6a6: e2                        sex           r2
[03513]                                 ; if we return RB is pushed on stack
[03514] e6a7: c0 dd 27                  lbr           goodpush
[03515] e6aa: c0 04 0a    cexec0:       lbr           jump                 ; transfer to user code. If it returns, it goes back to my caller
[03516]                   ; -----------------------------------------------------------------------------
[03517]                   ; Load contents of dictionary -
[03518]                   ; -----------------------------------------------------------------------------
[03519]                   
[03520]                   #ifdef BLOAD_TEXT
[03521]                   
[03522]                   
[03523]                   cbloadengext:
[03524] e6ad: f8 32 ab f8              mov           rb,loadtext
              ee bb 
[03525] e6b3: 30 bb                    br            cbload2
[03526] e6b5: f8 81 ab f8 cbloadcore:  mov           rb,loadcore
              eb bb 
[03527] e6bb: 0b          cbload2:     ldn           rb
[03528] e6bc: 32 dc                    bz           cbloaddn
[03529]                                 ;call          dispf
[03530]                                 ;db '.'  ; Just for debugging print a dot for each line loaded
[03531] e6be: d4 da 21                  call          tknizerb
[03532] e6c1: 8b 73 9b 73               push          rb
[03542]                   #else
[03543] e6c5: f8 00 ab f8               mov           rb,cbuffer
              03 bb 
[03544]                   #endif
[03545] e6cb: d4 dc 29                  call          exec
[03546] e6ce: 60 72 bb f0               pop           rb
              ab 
[03547] e6d3: 1b                        inc           rb
[03548] e6d4: 30 bb                     br            cbload2
[03549]                   
[03550]                   cbload:
[03551] e6d6: d4 e6 ad                 call          cbloadengext
[03552] e6d9: c0 d7 c2                 lbr           mainlp
[03553]                   
[03554] e6dc: d5          cbloaddn:    rtn
[03555]                   
[03556]                   #endif
[03557]                   
[03558]                   ; -----------------------------------------------------------------
[03559]                   #ifdef        ANYROM
[03560] e6dd: 8f 73 9f 73 csave:        push          rf                   ; save consumed registers
[03561] e6e1: 8c 73 9c 73               push          rc
[03562] e6e5: d4 d4 00                  call          xopenw               ; open write channel
[03563] e6e8: f8 06 af f8               mov           rf,freemem           ; need pointer to freemem
              04 bf 
[03564] e6ee: 4f                        lda           rf                   ; get high address of free memory
[03565] e6ef: ff 04                     smi           high himem
[03566] e6f1: bc                        phi           rc                   ; store into count
[03567] e6f2: 0f                        ldn           rf                   ; get low byte of free memory
[03568] e6f3: ac                        plo           rc                   ; store into count
[03569] e6f4: 1c                        inc           rc                   ; account for terminator
[03570] e6f5: 1c                        inc           rc
[03571] e6f6: f8 00 af f8               mov           rf,buffer            ; temporary storage
              02 bf 
[03572] e6fc: 9c                        ghi           rc                   ; get high byte of count
[03573] e6fd: 5f                        str           rf                   ; store it
[03574] e6fe: 1f                        inc           rf                   ; point to low byte
[03575] e6ff: 8c                        glo           rc                   ; get it
[03576] e700: 5f                        str           rf                   ; store into buffer
[03577] e701: 2f                        dec           rf                   ; move back to buffer
[03578] e702: f8 02 ac f8               mov           rc,2                 ; 2 bytes of length
              00 bc 
[03579] e708: d4 d4 09                  call          xwrite
[03580] e70b: f8 00 af f8               mov           rf,buffer            ; point to where count is
              02 bf 
[03581] e711: 8f ac 9f bc               mov           rc,rf
[03582] e715: f8 00 af f8               mov           rf,himem             ; point to forth data
              04 bf 
[03583] e71b: d4 d4 09                  call          xwrite
[03584] e71e: d4 d4 0c                  call          xclosew
[03585] e721: 60 72 bc f0               pop           rc                   ; recover consumed registers
              ac 
[03586] e726: 60 72 bf f0               pop           rf
              af 
[03587] e72b: c0 dd 2a                  lbr           good                 ; all done
[03588]                   #endif
[03636]                   #endif
[03637]                   #ifdef        ANYROM
[03638] e72e: 8f 73 9f 73 cload:        push          rf                   ; save consumed registers
[03639] e732: 8c 73 9c 73               push          rc
[03640] e736: 8e 73 9e 73               push          re                   ; [GDJ]
[03641] e73a: d4 d4 03                  call          xopenr               ; open XMODEM read channel
[03642] e73d: f8 00 af f8               mov           rf,buffer            ; point to buffer
              02 bf 
[03643] e743: f8 02 ac f8               mov           rc,2                 ; need to read 2 bytes
              00 bc 
[03644] e749: d4 d4 06                  call          xread
[03645] e74c: f8 00 af f8               mov           rf,buffer            ; point to buffer
              02 bf 
[03646] e752: 4f                        lda           rf                   ; retrieve count
[03647] e753: bc                        phi           rc                   ; into rc
[03648] e754: 0f                        ldn           rf
[03649] e755: ac                        plo           rc                   ; rc now has count of bytes to read
[03650] e756: f8 00 af f8               mov           rf,himem             ; point to forth data
              04 bf 
[03651] e75c: d4 d4 06                  call          xread
[03652] e75f: d4 d4 0f                  call          xcloser
[03653] e762: 60 72 be f0               pop           re                   ; [GDJ]
              ae 
[03654] e767: 60 72 bc f0               pop           rc                   ; recover consumed registers
              ac 
[03655] e76c: 60 72 bf f0               pop           rf
              af 
[03656] e771: c0 d7 c2                  lbr           mainlp               ; back to main loop
[03657]                   #endif
[03707]                   #endif
[03708] e774: c0 80 03    cbye:         lbr           exitaddr
[03709] e777: f8 11       cbase:        ldi           low basev
[03710] e779: ab                        plo           rb
[03711] e77a: f8 04                     ldi           high basev           ; don't use mov so we can save a byte by calling goodpushb
[03712] e77c: c0 dd 47                  lbr           goodpushb
[03713] e77f: f8 0d       crseed:       ldi           low rseed
[03714] e781: ab                        plo           rb
[03715] e782: f8 04                     ldi           high rseed           ; don't use mov so we can save a byte by calling goodpushb
[03716] e784: c0 dd 47                  lbr           goodpushb
[03730]                   #endif
[03731]                   ; **********************************************************
[03732]                   ; ***** Convert string to uppercase, honor quoted text *****
[03733]                   ; **********************************************************
[03734] e787: 0f          touc:         ldn           rf                   ; check for quote
[03735] e788: ff 22                     smi           022h
[03736] e78a: 32 9e                     bz            touc_qt              ; jump if quote
[03737] e78c: 0f                        ldn           rf                   ; get byte from string
[03738] e78d: 32 9d                     bz            touc_dn              ; jump if done
[03739] e78f: ff 61                     smi           'a'                  ; check if below lc
[03740] e791: 3b 9a                     bnf           touc_nxt             ; jump if so
[03741] e793: ff 1a                     smi           26                   ; check upper range
[03742] e795: 33 9a                     bdf           touc_nxt             ; jump if above lc
[03743] e797: fc 5b                     adi           'A'+26
[03744] e799: 5f                        str           rf
[03745] e79a: 1f          touc_nxt:     inc           rf                   ; point to next character
[03746] e79b: 30 87                     br            touc                 ; loop to check rest of string
[03747] e79d: d5          touc_dn:      rtn                                ; return to caller
[03748] e79e: 1f          touc_qt:      inc           rf                   ; move past quote
[03749] e79f: 4f          touc_qlp:     lda           rf                   ; get next character
[03750] e7a0: 32 9d                     bz            touc_dn              ; exit if terminator found
[03751] e7a2: ff 22                     smi           022h                 ; check for quote charater
[03752] e7a4: 32 87                     bz            touc                 ; back to main loop if quote
[03753] e7a6: 30 9f                     br            touc_qlp             ; otherwise keep looking
[03754]                   ; [GDJ] type out number according to selected BASE and signed/unsigned flag
[03755]                   typenumind:
[03756] e7a8: 8f 73 9f 73               push          rf                   ; save rf for tokenizer
[03757]                   typenos:
[03758] e7ac: d4 d8 3a                  call          dispf
[03759] e7af: 30                        db            '0'
[03760] e7b0: f8 12                     ldi           low basen
[03761] e7b2: a9                        plo           r9
[03762] e7b3: 09                        ldn           r9
[03763] e7b4: ff 0a                     smi           10
[03764] e7b6: 32 bb                     bz           typenuminddec
[03765] e7b8: f8 78                     ldi           'x'
[03766] e7ba: c8                        lskp
[03767]                   typenuminddec:
[03768] e7bb: f8 23                     ldi           '#'
[03769] e7bd: d4 d8 3b                  call          disp                 ; Do not use dispf here because we have an lskp above!
[03770] e7c0: f8 00                     ldi           0
[03771] e7c2: ae                        plo           re                   ; always unsigned here
[03772] e7c3: 30 c9                     br            typenumx
[03773]                   typenum:                                         ; get BASE  ; enter here for normal output
[03774] e7c5: 8f 73 9f 73               push          rf                   ; save rf for tokenizer
[03775]                   typenumx:
[03776] e7c9: f8 12                     ldi           low basen
[03777] e7cb: a9                        plo           r9
[03778] e7cc: 09                        ldn           r9
[03779] e7cd: ff 0a                     smi           10
[03780] e7cf: 3a ea                     bnz           typehex
[03781] e7d1: 8b ad 9b bd               mov           rd,rb
[03782] e7d5: f8 00 af f8               mov           rf, buffer
              02 bf 
[03783] e7db: 8e                        glo           re
[03784] e7dc: 32 e4                     bz            typenumU
[03785] e7de: d4 ff 63                  call          f_intout    ; since D=re SCRT will preserve either way
[03786] e7e1: c0 e8 0a                  lbr            typeout
[03787] e7e4: d4 ff 60    typenumU:     call          f_uintout   ; since D=re SCRT will preserve either way
[03788] e7e7: c0 e8 0a                  lbr            typeout
[03789]                   typehex:
[03790] e7ea: 8b ad 9b bd               mov           rd,rb
[03791] e7ee: f8 00 af f8               mov           rf, buffer
              02 bf 
[03792]                   ; for performance we inline testopt in two places here
[03793] e7f4: f8 14                     ldi           low option+1
[03794] e7f6: a9                        plo           r9
[03795] e7f7: 09                        ldn           r9
[03796] e7f8: fa 04                     ani           4
[03797] e7fa: ca e8 01                  lbnz           hex16            ; if option bit 2 set, always do 4 digits
[03798] e7fd: 9d                        ghi           rd
[03799] e7fe: c2 e8 07                  lbz            hexbyte          ; otherwise do 2 digits for byte, 4 digits for word
[03800] e801: 9d          hex16:        ghi           rd               ; in case we jumped in
[03801] e802: d4 ff 4b                  call          f_hexout4
[03802] e805: 30 0a                     br            typeout
[03803] e807: d4 ff 48    hexbyte:      call          f_hexout2
[03804] e80a: f8 14       typeout:      ldi           low option+1
[03805] e80c: a9                        plo           r9
[03806] e80d: 09                        ldn           r9
[03807] e80e: fa 01                     ani           1
[03808] e810: 3a 16                     bnz           nospace
[03809] e812: f8 20                     ldi           ' '                  ; add space (wish for optional way to supress)
[03810] e814: 5f                        str           rf
[03811] e815: 1f                        inc           rf
[03812]                   nospace:
[03813] e816: d4 e6 2e                  call          f_msg_term
[03814] e819: 60 72 bf f0               pop           rf
              af 
[03815] e81e: d5                        rtn                                ; return to caller
[03816]                   ; *************************************
[03817]                   ; *** Check if character is numeric ***
[03818]                   ; *** D - char to check             ***
[03819]                   ; *** Returns DF=1 if numeric       ***
[03820]                   ; ***         DF=0 if not           ***
[03821]                   ; *************************************
[03822] e81f: ae          isnum:        plo           re                   ; save a copy
[03823] e820: ff 30                     smi           '0'                  ; check for below zero
[03824] e822: 3b 2b                     bnf           fails                ; jump if below
[03825] e824: ff 0a                     smi           10                   ; see if above
[03826] e826: 33 2b                     bdf           fails                ; fails if so
[03827] e828: ff 00       passes:       smi           0                    ; signal success
[03828] e82a: c8                        lskp
[03829] e82b: fc 00       fails:        adi           0                    ; signal failure
[03830] e82d: 8e                        glo           re                   ; recover character
[03831] e82e: d5                        rtn                                ; and return
[03832] e82f: ff 00       err:          smi           0                    ; signal an error
[03833] e831: d5                        rtn                                ; and return
[03834]                   ; **********************************
[03835]                   ; *** check D if hex             ***
[03836]                   ; *** Returns DF=1 - hex         ***
[03837]                   ; ***         DF=0 - non-hex     ***
[03838]                   ; **********************************
[03839] e832: d4 e8 1f    ishex:        call          isnum
[03840] e835: ae                        plo           re                   ; keep a copy
[03841] e836: 33 28                     bdf           passes               ; jump if it is numeric
[03842] e838: ff 41                     smi           'A'                  ; check for below uppercase a
[03843] e83a: 3b 2b                     bnf           fails                ; value is not hex
[03844] e83c: ff 06                     smi           6                    ; check for less then 'G'
[03845] e83e: 3b 28                     bnf           passes               ; jump if so
[03846] e840: 8e                        glo           re                   ; recover value
[03847] e841: ff 61                     smi           'a'                  ; check for lowercase a
[03848] e843: 3b 2b                     bnf           fails                ; jump if not
[03849] e845: ff 06                     smi           6                    ; check for less than 'g'
[03850] e847: 3b 28                     bnf           passes               ; jump if so
[03851] e849: 30 2b                     br            fails
[03852]                   
[03853]                   
[03854]                   ;------------------------------------------------------------------
[03855]                   ; Generate a psuedo-random byte
[03856]                   ;
[03857]                   ; IN:       N/A
[03858]                   ; OUT:      D=psuedo-random number
[03859]                   ; TRASHED:  RA
[03860]                   ;
[03861]                   ; This PRNG was extracted from AdventureLand
[03862]                   ; Copyright (C) 2019 by Richard Goedeken, All Rights Reserved.
[03863]                   ;
[03864]                   ; modified GDJ 2021 --> return in r8.1, changed r7 to ra
[03865]                   ;
[03866]                   ; Update1: 23 Jan 2022 no period has been determined, thus
[03867]                   ; far a 320kB file has been checked - 12 minutes on the PicoElf2
[03868]                   ; gave 20479 lines of 16 samples --> 327664 bytes
[03869]                   ;
[03870]                   ; Update2: 25 Feb 2022 translated this code into 'C' and
[03871]                   ; discovered a period of P = 2020966655
[03872]                   ; after which the sequence repeats!
[03873]                   ; other init params often gave the same period, however the
[03874]                   ; initial arrays:
[03875]                   ;        {1,3,5,7} gave a period of 543537919
[03876]                   ;   {12,137,98,32} gave a period of 1080837375
[03877]                   ;------------------------------------------------------------------
[03878] e84b: f8 0d ad f8 randbyte:     mov           rd,rseed
              04 bd 
[03879] e851: ed                        sex           rd
[03880] e852: 0d                        ldn           rd                   ; D = VarX
[03881] e853: fc 01                     adi           1
[03882] e855: 5d                        str           rd
[03883] e856: 1d                        inc           rd
[03884] e857: 4d                        lda           rd                   ; D = VarA
[03885] e858: 1d                        inc           rd
[03886] e859: f3                        xor                                ; D = VarA XOR VarC
[03887] e85a: 2d                        dec           rd
[03888] e85b: 2d                        dec           rd
[03889] e85c: 2d                        dec           rd
[03890] e85d: f3                        xor                                ; D = VarA XOR VarC XOR VarX
[03891] e85e: 1d                        inc           rd
[03892] e85f: 5d                        str           rd                   ; VarA = D
[03893] e860: 1d                        inc           rd
[03894] e861: f4                        add
[03895] e862: 73                        stxd
[03896] e863: f6                        shr
[03897] e864: f3                        xor
[03898] e865: 1d                        inc           rd
[03899] e866: 1d                        inc           rd
[03900] e867: f4                        add
[03901] e868: 5d                        str           rd
[03902] e869: b8                        phi           r8                   ; added GDJ
[03903] e86a: e2                        sex           r2                   ; ...
[03904] e86b: d5                        rtn
[03905] e86c: f8 06       chere:        ldi           low freemem          ; set R9 to free memory
[03906] e86e: a9                        plo           r9
[03907] e86f: 49                        lda           r9
[03908] e870: bb                        phi           rb
[03909] e871: 09                        ldn           r9
[03910] e872: ab                        plo           rb
[03911] e873: c0 dd 27                  lbr           goodpush
[03912] e876: d4 d8 41    ctohere:      call          pop
[03913] e879: c3 dd 2d                  lbdf          error
[03914] e87c: f8 06                     ldi           low freemem          ; set R9 to free memory
[03915] e87e: a9                        plo           r9
[03916] e87f: 9b                        ghi           rb
[03917] e880: 59                        str           r9
[03918] e881: 19                        inc           r9
[03919] e882: 8b                        glo           rb
[03920] e883: 59                        str           r9
[03921] e884: c0 dd 2a                  lbr           good
[03922]                   
[03923] e887: d4 d8 41    cdottok:      call         pop
[03924] e88a: c3 dd 2d                  lbdf         error
[03925] e88d: 8b                        glo          rb
[03926] e88e: fa 80                     ani          080h
[03927] e890: c2 dd 2d                  lbz          error
[03928] e893: 8b                        glo          rb
[03929] e894: fd dd                     sdi          LAST_TOK
[03930] e896: cb dd 2d                  lbnf         error
[03931] e899: f8 00                     ldi          0
[03932] e89b: 73                        stxd
[03933] e89c: 8b                        glo          rb
[03934] e89d: 73                        stxd
[03935] e89e: 82 a7 92 b7               mov          r7,r2
[03936] e8a2: 17                        inc          r7
[03937] e8a3: d4 e3 d1                  call         dottok
[03938] e8a6: 60                        irx
[03939] e8a7: 60                        irx
[03940] e8a8: c0 dd 2a                  lbr          good
[03941]                   
[03942]                   
[03943]                   
[03944]                   
[03945]                   ; get current stream pointer into rb
[03946] e8ab: 82 aa 92 ba getstream:    mov           ra,r2
[03947] e8af: 1a                        inc           ra    ; move to top of stack
[03948] e8b0: 1a                        inc           ra    ; skip our return address (2 bytes)
[03949] e8b1: 1a                        inc           ra
[03950] e8b2: 4a                        lda           ra
[03951] e8b3: bb                        phi           rb
[03952] e8b4: 0a                        ldn           ra
[03953] e8b5: ab                        plo           rb
[03954] e8b6: d5                        rtn
[03955]                   
[03956] e8b7: d4 e8 ab    capos:        call          getstream
[03957] e8ba: 0b                        ldn           rb
[03958] e8bb: ff ff                     smi           T_NUM
[03959] e8bd: c2 dd 2d                  lbz           error
[03960] e8c0: 0b                        ldn           rb
[03961] e8c1: ff fe                     smi           T_ASCII
[03962] e8c3: 32 e8                     bz            aposstr
[03963] e8c5: 0b                        ldn           rb
[03964] e8c6: fa 80                     ani           80h
[03965] e8c8: c2 dd 2d                  lbz           error         ; what?
[03966]                   ; here we have a token
[03967] e8cb: 4b                        lda           rb
[03968] e8cc: ae                        plo           re
[03969] e8cd: 8b                        glo           rb         ; reset return address
[03970] e8ce: 5a                        str           ra
[03971] e8cf: 2a                        dec           ra
[03972] e8d0: 9b                        ghi           rb
[03973] e8d1: 5a                        str           ra          ; reset address
[03974] e8d2: f8 c7 aa f8               mov           ra,cmdvecs
              ea ba 
[03975] e8d8: 2e                        dec           re
[03976] e8d9: 8e                        glo           re
[03977] e8da: fa 7f                     ani           07fh
[03978] e8dc: fe                        shl
[03979] e8dd: 52                        str           r2
[03980] e8de: 8a                        glo           ra
[03981] e8df: f4                        add
[03982] e8e0: ab                        plo           rb
[03983] e8e1: 9a                        ghi           ra
[03984] e8e2: 7c 00                     adci          0
[03985] e8e4: bb                        phi           rb
[03986] e8e5: c0 dd 27                  lbr           goodpush
[03987]                   
[03988] e8e8: 1b          aposstr:      inc           rb
[03989] e8e9: 8b a8 9b b8               mov           r8,rb
[03990] e8ed: d4 d8 99                  call          findname
[03991] e8f0: c3 dd 2d                  lbdf          error
[03992] e8f3: d4 d8 69                  call          push
[03993] e8f6: 82 aa 92 ba               mov           ra,r2
[03994] e8fa: 1a                        inc           ra
[03995] e8fb: 98                        ghi           r8
[03996] e8fc: 5a                        str           ra
[03997] e8fd: 1a                        inc           ra
[03998] e8fe: 88                        glo           r8
[03999] e8ff: 5a                        str           ra
[04000] e900: c0 dd 2a                  lbr           good
[04001]                   
[04002] e903: d4 d8 41    cexecute:     call          pop
[04003] e906: c3 dd 2d                  lbdf          error
[04004]                                 ; if rb>himem we have a token to execute
[04005] e909: d4 e5 14                  call          getvar
[04006] e90c: 00                        db            low himem
[04007] e90d: 9a                        ghi           ra
[04008] e90e: 52                        str           r2
[04009] e90f: 9b                        ghi           rb
[04010] e910: f7                        sm
[04011] e911: 3b 43                     bnf           estring  ; if hipart of address >himem high part (usual case) must be core word
[04012]                            ; no point in checking low part so...
[04013]                                 ; exec token pointed to by RB
[04014] e913: 8b af 9b bf               mov          rf,rb
[04015] e917: f8 ea                     ldi          high cmdvecs
[04016] e919: 52                        str          r2
[04017] e91a: 9b                        ghi          rb
[04018] e91b: f7                        sm
[04019] e91c: bb                        phi          rb
[04020] e91d: f8 c7                     ldi          low cmdvecs
[04021] e91f: 52                        str          r2
[04022] e920: 8b                        glo          rb
[04023] e921: 77                        smb
[04024] e922: f6                        shr
[04025] e923: ab                        plo          rb
[04026]                   
[04027] e924: f8 00                     ldi           0
[04028] e926: 73                        stxd
[04029] e927: 8b                        glo           rb
[04030] e928: f9 80                     ori           80h
[04031] e92a: fc 01                     adi           1
[04032] e92c: 73                        stxd
[04033] e92d: 82 ab 92 bb               mov           rb,r2
[04034] e931: 1b                        inc           rb
[04035] e932: 8b                        glo          rb
[04036] e933: 73                        stxd
[04037] e934: 9b                        ghi          rb
[04038] e935: 73                        stxd
[04039] e936: d4 dc 29                  call         exec
[04040] e939: 60                        irx
[04041] e93a: 72                        ldxa
[04042] e93b: bb                        phi          rb
[04043] e93c: f0                        ldx
[04044] e93d: ab                        plo          rb
[04045]                   ; eat the token
[04046] e93e: 60                        irx
[04047] e93f: 60                        irx
[04048] e940: c0 dd 2a                  lbr          good
[04049]                   
[04050]                   estring:
[04051]                                 ; otherwise we execute a string
[04052] e943: 8b                        glo           rb
[04053] e944: 73                        stxd
[04054] e945: 9b                        ghi           rb
[04055] e946: 73                        stxd
[04056] e947: d4 dc 29                  call          exec
[04057] e94a: 60                        irx
[04058] e94b: 72                        ldxa
[04059] e94c: bb                        phi           rb
[04060] e94d: f0                        ldx
[04061] e94e: ab                        plo           rb
[04062] e94f: c0 dd 2a                  lbr           good
[04063]                   
[04064] e952: f8 00       cbrkq:        ldi           0
[04065] e954: bb                        phi           rb
[04066] e955: d4 ff 6c                  call         f_brktest
[04067] e958: f8 00                     ldi          0
[04068] e95a: 7e                        shlc
[04069] e95b: c0 dd c2                  lbr         goodpushb0
[04070]                   
[04071]                   
[04072] e95e: 52 63 2f 46 hello:        db            'Rc/Forth 0.55',0
              6f 72 74 68 
              20 30 2e 35 
              35 00 
[04073] e96c: 3a          aprompt:      db            ':'                  ; no zero, adds to prompt (must be right before prompt)
[04074] e96d: 6f 6b 20 00 prompt:       db            'ok ',0
[04075] e971: 73 74 61 63 msempty:      db            'stack empty',10,13,0
              6b 20 65 6d 
              70 74 79 0a 
              0d 00 
[04076] e97f: 65 72 72 0a msgerr:       db            'err',10,13,0
              0d 00 
[04077] e985: 44 42 47 2d debug_hook:   db            'DBG-HOOK',0
              48 4f 4f 4b 
              00 
[04078] e98e: 57 48 49 4c cmdtable:     db            'WHIL',('E'+80h)
              c5 
[04079] e993: 52 45 50 45               db            'REPEA',('T'+80h)
              41 d4 
[04080] e999: 49 c6                     db            'I',('F'+80h)
[04081] e99b: 45 4c 53 c5               db            'ELS',('E'+80h)
[04082] e99f: 54 48 45 ce               db            'THE',('N'+80h)
[04083] e9a3: 56 41 52 49               db            'VARIABL',('E'+80h)
              41 42 4c c5 
[04084] e9ab: ba                        db            (':'+80h)
[04085] e9ac: bb                        db            (';'+80h)
[04086] e9ad: 44 55 d0                  db            'DU',('P'+80h)
[04087] e9b0: 44 52 4f d0               db            'DRO',('P'+80h)
[04088] e9b4: 53 57 41 d0               db            'SWA',('P'+80h)
[04089] e9b8: ab                        db            ('+'+80h)
[04090] e9b9: ad                        db            ('-'+80h)
[04091] e9ba: aa                        db            ('*'+80h)
[04092] e9bb: af                        db            ('/'+80h)
[04093] e9bc: ae                        db            ('.'+80h)
[04094] e9bd: 55 ae                     db            'U',('.'+80h)
[04095] e9bf: c9                        db            ('I'+80h)
[04096] e9c0: 41 4e c4                  db            'AN',('D'+80h)
[04097] e9c3: 4f d2                     db            'O',('R'+80h)
[04098] e9c5: 58 4f d2                  db            'XO',('R'+80h)
[04099] e9c8: 43 d2                     db            'C',('R'+80h)
[04100] e9ca: 4d 45 cd                  db            'ME',('M'+80h)
[04101] e9cd: 44 cf                     db            'D',('O'+80h)
[04102] e9cf: 4c 4f 4f d0               db            'LOO',('P'+80h)
[04103] e9d3: 2b 4c 4f 4f               db            '+LOO',('P'+80h)
              d0 
[04104] e9d8: bd                        db            ('='+80h)
[04105] e9d9: 3c be                     db            '<',('>'+80h)
[04106] e9db: bc                        db            ('<'+80h)            ; [GDJ]
[04107] e9dc: 55 bc                     db            'U',('<'+80h)        ; [GDJ]
[04108] e9de: 42 45 47 49               db            'BEGI',('N'+80h)
              ce 
[04109] e9e3: 55 4e 54 49               db            'UNTI',('L'+80h)
              cc 
[04110] e9e8: 52 be                     db            'R',('>'+80h)
[04111] e9ea: 3e d2                     db            '>',('R'+80h)
[04112] e9ec: 52 c0                     db            'R',('@'+80h)        ; [GDJ]
[04113] e9ee: 57 4f 52 44               db            'WORD',('S'+80h)
              d3 
[04114] e9f3: 45 4d 49 d4               db            'EMI',('T'+80h)
[04115] e9f7: 45 4d 49 54               db            'EMIT',('P'+80h)     ; [GDJ]
              d0 
[04116] e9fc: 44 45 50 54               db            'DEPT',('H'+80h)
              c8 
[04117] ea01: 52 4f d4                  db            'RO',('T'+80h)
[04118] ea04: 2d 52 4f d4               db            '-RO',('T'+80h)
[04119] ea08: 4f 56 45 d2               db            'OVE',('R'+80h)
[04120] ea0c: c0                        db            ('@'+80h)
[04121] ea0d: a1                        db            ('!'+80h)
[04122] ea0e: 43 c0                     db            'C',('@'+80h)
[04123] ea10: 43 a1                     db            'C',('!'+80h)
[04124] ea12: 43 4d 4f 56               db            'CMOV',('E'+80h)     ; [GDJ]
              c5 
[04125] ea17: 2e a2                     db            '.',(34+80h)
[04126] ea19: 4b 45 d9                  db            'KE',('Y'+80h)
[04127] ea1c: 4b 45 59 bf               db            'KEY',('?'+80h)      ; [GDJ]
[04128] ea20: 41 4c 4c 4f               db            'ALLO',('T'+80h)
              d4 
[04129] ea25: 45 52 52 4f               db            'ERRO',('R'+80h)
              d2 
[04130] ea2a: 53 45 c5                  db            'SE',('E'+80h)
[04131] ea2d: 46 4f 52 47               db            'FORGE',('T'+80h)
              45 d4 
[04132] ea33: 4f 55 d4                  db            'OU',('T'+80h)
[04133] ea36: 49 4e d0                  db            'IN',('P'+80h)
[04134] ea39: 45 c6                     db            'E',('F'+80h)
[04135] ea3b: 53 45 54 d1               db            'SET',('Q'+80h)      ; [GDJ]
[04136] ea3f: 53 41 56 c5               db            'SAV',('E'+80h)
[04137] ea43: 4c 4f 41 c4               db            'LOA',('D'+80h)
[04138] ea47: 42 59 c5                  db            'BY',('E'+80h)
[04139] ea4a: 53 50 c0                  db            'SP',('@'+80h)       ; [GDJ]
[04140] ea4d: 3c bc                     db            '<',('<'+80h)        ; [GDJ]
[04141] ea4f: 3e be                     db            '>',('>'+80h)        ; [GDJ]
[04142] ea51: 44 45 4c 41               db            'DELA',('Y'+80h)     ; [GDJ]
              d9 
[04143] ea56: 45 58 54 4c               db            'EXTLOA',('D'+80h)     ; [GDJ]
              4f 41 c4 
[04144] ea5d: 52 41 4e c4               db            'RAN',('D'+80h)      ; [GDJ]
[04145] ea61: 45 58 45 c3               db            'EXE',('C'+80h)
[04146] ea65: 4c 49 53 d4               db            'LIS',('T'+80h)
[04147] ea69: 58 ae                     db            'X',('.'+80h)
[04148] ea6b: 4e 45 d7                  db            'NE',('W'+80h)
[04149] ea6e: 48 45 52 c5               db            'HER',('E'+80h)
[04150] ea72: 2d 3e 48 45               db            '->HER',('E'+80h)
              52 c5 
[04151] ea78: 42 41 53 c5               db            'BAS',('E'+80h)
[04152] ea7c: 45 4e 44 49               db            'ENDI',('F'+80h)
              c6 
[04153] ea81: 52 53 45 45               db            'RSEE',('D'+80h)
              c4 
[04154] ea86: 52 50 c0                  db            'RP',('@'+80h)
[04155] ea89: a8                        db            ('('+80h)
[04156] ea8a: 4f 50 d4                  db            'OP',(80h+'T')
[04157] ea8d: 2e 54 4f cb               db            '.TO',(80h+'K')
[04158] ea91: 52 50 a1                  db            'RP',(80h+'!')
[04159] ea94: 52 50 b0                  db            'RP',(80h+'0')
[04160] ea97: 53 50 b0                  db            'SP',(80h+'0')
[04161] ea9a: 53 50 a1                  db            'SP',(80h+'!')
[04162] ea9d: 5b 27 dd                  db            '[',27h,(80h+']')             ; ['] command
[04163] eaa0: 45 58 45 43               db            'EXECUT',(80h+'E')
              55 54 c5 
[04164] eaa7: 54 49 c2                  db            'TI',(80h+'B')
[04165] eaaa: 51 55 45 52               db            'QUER',(80h+'Y')
              d9 
[04166] eaaf: 45 58 49 d4               db            'EXI',(80h+'T')
[04167] eab3: 41 47 41 49               db            'AGAI',(80h+'N')
              ce 
[04168] eab8: 51 55 49 d4               db            'QUI',(80h+'T')
[04169] eabc: 43 52 45 41               db            'CREAT',(80h+'E')
              54 c5 
[04170] eac2: 42 52 4b bf               db            'BRK',(80h+'?')
[04171] eac6: 00                        db            0                    ; no more tokens
[04172] eac7: df 95       cmdvecs:      dw            cwhile               ; 81h
[04173] eac9: df d1                     dw            crepeat              ; 82h
[04174] eacb: df e7                     dw            cif                  ; 83h
[04175] eacd: e0 26                     dw            celse                ; 84h
[04176] eacf: e2 17                     dw            cthen                ; 85h
[04177] ead1: e1 22                     dw            cvariable            ; 86h
[04178] ead3: e1 6f                     dw            ccolon               ; 87h
[04179] ead5: e2 17                     dw            csemi                ; 88h
[04180] ead7: dd 1f                     dw            cdup                 ; 89h
[04181] ead9: dd 32                     dw            cdrop                ; 8ah
[04182] eadb: dd af                     dw            cswap                ; 8bh
[04183] eadd: dd 39                     dw            cplus                ; 8ch
[04184] eadf: dd 4a                     dw            cminus               ; 8dh
[04185] eae1: e4 7b                     dw            cmul                 ; 8eh
[04186] eae3: e4 87                     dw            cdiv                 ; 8fh
[04187] eae5: dd 5a                     dw            cdot                 ; 90h
[04188] eae7: dd 67                     dw            cudot                ; 91h
[04189] eae9: dd c5                     dw            ci                   ; 92h
[04190] eaeb: dd 7a                     dw            cand                 ; 93h
[04191] eaed: dd 8a                     dw            cor                  ; 94h
[04192] eaef: dd 9a                     dw            cxor                 ; 95h
[04193] eaf1: dd aa                     dw            ccr                  ; 96h
[04194] eaf3: dd cd                     dw            cmem                 ; 97h
[04195] eaf5: dd e1                     dw            cdo                  ; 98h
[04196] eaf7: de 00                     dw            cloop                ; 99h
[04197] eaf9: de 33                     dw            cploop               ; 9ah
[04198] eafb: e0 46                     dw            cequal               ; 9bh
[04199] eafd: de 93                     dw            cunequal             ; 9ch
[04200] eaff: de b0                     dw            cless                ; 9dh [GDJ]
[04201] eb01: de dd                     dw            culess               ; 9eh [GDJ]
[04202] eb03: de 4b                     dw            cbegin               ; 9fh
[04203] eb05: de 58                     dw            cuntil               ; a0h
[04204] eb07: de 85                     dw            crgt                 ; a1h
[04205] eb09: de 8b                     dw            cgtr                 ; a2h
[04206] eb0b: dd c5                     dw            crat                 ; a3h [GDJ]
[04207] eb0d: de f1                     dw            cwords               ; a4h
[04208] eb0f: df 73                     dw            cemit                ; a5h
[04209] eb11: df 80                     dw            cemitp               ; a6h [GDJ]
[04210] eb13: e0 64                     dw            cdepth               ; a7h
[04211] eb15: e0 7d                     dw            crot                 ; a8h
[04212] eb17: e0 a5                     dw            cmrot                ; a9h
[04213] eb19: e0 cd                     dw            cover                ; aah
[04214] eb1b: e0 df                     dw            cat                  ; abh
[04215] eb1d: e0 ef                     dw            cexcl                ; ach
[04216] eb1f: e1 07                     dw            ccat                 ; adh
[04217] eb21: e1 16                     dw            ccexcl               ; aeh
[04218] eb23: e5 f8                     dw            ccmove               ; afh [GDJ]
[04219] eb25: e3 f8                     dw            cdotqt               ; b0h
[04220] eb27: e4 20                     dw            ckey                 ; b1h
[04221] eb29: e4 29                     dw            ckeyq                ; b2h [GDJ]
[04222] eb2b: e4 37                     dw            callot               ; b3h
[04223] eb2d: e5 24                     dw            cerror               ; b4h
[04224] eb2f: e2 6f                     dw            csee                 ; b5h
[04225] eb31: e4 9a                     dw            cforget              ; b6h
[04226] eb33: e5 a0                     dw            cout                 ; b7h
[04227] eb35: e5 cc                     dw            cinp                 ; b8h
[04228] eb37: e5 8a                     dw            cef                  ; b9h
[04229] eb39: e6 16                     dw            csetq                ; bah [GDJ]
[04230] eb3b: e6 dd                     dw            csave                ; bbh
[04231] eb3d: e7 2e                     dw            cload                ; bch
[04232] eb3f: e7 74                     dw            cbye                 ; bdh
[04233] eb41: e5 78                     dw            cspat                ; beh [GDJ]
[04234] eb43: e6 3a                     dw            clshift              ; c1h [GDJ]
[04235] eb45: e6 52                     dw            crshift              ; c2h [GDJ]
[04236] eb47: e6 6a                     dw            cdelay               ; c3h [GDJ]
[04237]                   #ifndef       NO_BLOAD
[04238] eb49: e6 d6                     dw            cbload               ; c4h [GDJ]
[04241]                   #endif
[04242] eb4b: e6 24                     dw            crand                ; c6h [GDJ]
[04243] eb4d: e6 8e                     dw            cexec                ; c7h [gnr]
[04244] eb4f: e2 2e                     dw            clist                ; c8h [gnr]
[04245] eb51: dd 70                     dw            cdotx                ; c9h [gnr]
[04246] eb53: d7 4e                     dw            cnew                 ; cah [gnr]
[04247] eb55: e8 6c                     dw            chere
[04248] eb57: e8 76                     dw            ctohere
[04249] eb59: e7 77                     dw            cbase
[04250] eb5b: e2 17                     dw            cthen                ; alias ENDIF=then (as in gforth)
[04251] eb5d: e7 7f                     dw            crseed
[04252] eb5f: e5 84                     dw            crpat
[04253] eb61: 00 00                     dw            0             ; no handler for ( comment )
[04254] eb63: e5 1b                     dw            copt
[04255] eb65: e8 87                     dw            cdottok
[04256] eb67: e5 3f                     dw            crpexcl
[04257] eb69: e5 5a                     dw            crp0
[04258] eb6b: e5 66                     dw            csp0
[04259] eb6d: e5 50                     dw            cspexcl
[04260] eb6f: e8 b7                     dw            capos
[04261] eb71: e9 03                     dw            cexecute
[04262] eb73: e5 6f                     dw            ctib
[04263] eb75: d9 ee                     dw            cquery
[04264] eb77: dc bf                     dw            cexit
[04265] eb79: df d1                     dw            cagain
[04266] eb7b: d7 d1                     dw            cquit
[04267] eb7d: e1 1f                     dw            ccreate
[04268] eb7f: e9 52                     dw            cbrkq
[04269]                   
[04270]                   
[04271]                   
[04272]                   
[04273]                   #ifdef BLOAD_TEXT
[04274]                   loadcore:
<00000>                   #include extcore.inc
<00001> eb81: 2e 22 20 57   db '." Wait..."CR',0
              61 69 74 2e 
              2e 2e 22 43 
              52 00 
<00002>                   
<00003>                   ; You can put ASCII definitions/command here
<00004>                   ; But you can also use the Fxxx words for core words.
<00005>                   ; So...
<00006>                   ; db ': foo swap drop ;',0
<00007>                   ; is the same as:
<00008>                   ; db FCOLON,'foo',FSWAP,FDROP,FSEMI,0
<00009>                   ; NOTE: tokens no longer have to end in space if there is a compiled token following.
<00010>                   ; Also FDOTQT is "odd":  dw FDOTQT,' <-space not printed"100 2 + ',FDOT,FCR,0
<00011>                   ; Note the first space is "eaten" and the quote ends the string (no zero), and you do NOT need
<00012>                   ; a space after the quote (although it won't hurt if you have one)
<00013>                   ; You can also use T_NUM:  db T_NUM,0,0ffh   ; 255
<00014>                   ; or T_ASCII: db FCOLON,T_ASCII,'FOO',0,....
<00015>                   
<00016> eb8f: 87 2e 53 cf   db FCOLON,'.S',FOPT,FAT,FDUP,FGTR,'1',FOR,FOPT,FEXCL,'." <"',FDEPTH,FDOT
              ab 89 a2 31 
              94 cf ac 2e 
              22 20 3c 22 
              a7 90 
<00017> eba1: 2e 22 20 3e   db        '." > "0',FOPT,FEXCL,FDEPTH,'?DUP',FIF,FDUP,'0',FDO,FDUP,FI,FMINUS,'PICK',FDOT,FLOOP,FDROP,FTHEN,FRGT,FOPT,FEXCL,FSEMI,0
              20 22 30 cf 
              ac a7 3f 44 
              55 50 83 89 
              30 98 89 92 
              8d 50 49 43 
              4b 90 99 8a 
              85 a1 cf ac 
              88 00 
<00018> ebc3: 87 3f ab 91   db FCOLON,'?',FAT,FUDOT,FSEMI,0
              88 00 
<00019> ebc9: 87 3f 44 55   db FCOLON,'?DUP',FDUP,FIF,FDUP,FTHEN,FSEMI,0
              50 89 83 89 
              85 88 00 
<00020> ebd4: 87 42 4c 20   db FCOLON,'BL 0X20 ;',0
              30 58 32 30 
              20 3b 00 
<00021> ebdf: 87 42 53 20   db FCOLON,'BS 8',FEMIT,FSEMI,0
              38 a5 88 00 
<00022> ebe7: 87 43 45 4c   db FCOLON,'CELLS 2',FMUL,FSEMI,0
              4c 53 20 32 
              8e 88 00 
<00023> ebf2: 87 43 4c 45   db FCOLON,'CLEAR',FDEPTH,FWHILE,FDROP,FDEPTH,FREPEAT,FSEMI,0
              41 52 a7 81 
              8a a7 82 88 
              00 
<00024> ebff: 87 43 2c 20   db FCOLON,'C, 1',FALLOT,FHERE,'1-',FCEXCL,FSEMI,0
              31 b3 c8 31 
              2d ae 88 00 
<00025> ec0b: 87 43 4c 53   db FCOLON,'CLS ESC ." [2J"ESC ." [H"'
              20 45 53 43 
              20 2e 22 20 
              5b 32 4a 22 
              45 53 43 20 
              2e 22 20 5b 
              48 22 
<00026> ec25: 88 00         db FSEMI,0
<00027> ec27: 87 44 55 4d   db FCOLON,'DUMP',FOPT,FAT,FGTR,'0',FOPT,FEXCL,FCR,'5 SPACES',T_NUM,0,10h,'0',FDO,FI,FDOT,FLOOP,'0',FDO,FCR,FDUP,FDOT,T_NUM,0,10h
              50 cf ab a2 
              30 cf ac 96 
              35 20 53 50 
              41 43 45 53 
              ff 00 10 30 
              98 92 90 99 
              30 98 96 89 
              90 ff 00 10 
<00028> ec4b: 30 98 89 ad   db        '0',FDO,FDUP,FCAT,FDOT,'1+',FLOOP,FDUP,T_NUM,0,10h,FMINUS,T_NUM,0,10h,'TYPE',T_NUM,0,10h,FPLOOP,FDROP,FCR,FRGT,FOPT,FEXCL,FSEMI,0
              90 31 2b 99 
              89 ff 00 10 
              8d ff 00 10 
              54 59 50 45 
              ff 00 10 9a 
              8a 96 a1 cf 
              ac 88 00 
<00029> ec6a: 87 45 53 43   db FCOLON,'ESC 0X1B',FEMIT,FSEMI,0
              20 30 58 31 
              42 a5 88 00 
<00030> ec76: 87 46 41 4c   db FCOLON,'FALSE 0',FSEMI,0
              53 45 20 30 
              88 00 
<00031> ec80: 87 46 52 45   db FCOLON,'FREE ',FMEM,FUDOT,FCR,FSEMI,0
              45 20 97 91 
              96 88 00 
<00032> ec8b: 87 4d 4f 44   db FCOLON,'MOD',FDUP,FROT,FDUP,FROT,FDIV,FROT,FMUL,FMINUS,FSEMI,0
              89 a8 89 a8 
              8f a8 8e 8d 
              88 00 
<00033> ec99: 87 4e 49 50   db FCOLON,'NIP',FSWAP,FDROP,FSEMI,0
              8b 8a 88 00 
<00034> eca1: 87 4e 4f 54   db FCOLON,'NOT 0=',FSEMI,0
              20 30 3d 88 
              00 
<00035> ecaa: 87 50 49 43   db FCOLON,'PICK 2 * 2+',FSPAT,FPLUS,FAT,FSEMI,0
              4b 20 32 20 
              2a 20 32 2b 
              be 8c ab 88 
              00 
<00036> ecbb: 87 3e 8b 9d   db FCOLON,'>',FSWAP,FLESS,FSEMI,0
              88 00 
<00037> ecc1: 87 3e 3d 20   db FCOLON,'>= < NOT',FSEMI,0
              3c 20 4e 4f 
              54 88 00 
<00038> eccc: 87 3c 3d 20   db FCOLON,'<= > NOT',FSEMI,0
              3e 20 4e 4f 
              54 88 00 
<00039> ecd7: 87 2c 20 32   db FCOLON,', 2',FALLOT,FHERE,'2-',FEXCL,FSEMI,0
              b3 c8 32 2d 
              ac 88 00 
<00040> ece2: 87 30 3c 20   db FCOLON,'0< 0 <',FSEMI,0
              30 20 3c 88 
              00 
<00041> eceb: 87 30 3e 20   db FCOLON,'0> 0 >',FSEMI,0
              30 20 3e 88 
              00 
<00042> ecf4: 87 30 3d 20   db FCOLON,'0= 0 =',FSEMI,0
              30 20 3d 88 
              00 
<00043> ecfd: 87 31 2b 20   db FCOLON,'1+ 1 +',FSEMI,0
              31 20 2b 88 
              00 
<00044> ed06: 87 31 2d 20   db FCOLON,'1- 1 -',FSEMI,0
              31 20 2d 88 
              00 
<00045> ed0f: 87 32 2b 20   db FCOLON,'2+ 2 +',FSEMI,0
              32 20 2b 88 
              00 
<00046> ed18: 87 32 2d 20   db FCOLON,'2- 2 -',FSEMI,0
              32 20 2d 88 
              00 
<00047> ed21: 87 4e 45 47   db FCOLON,'NEG 0',FSWAP,FMINUS,FSEMI,0
              20 30 8b 8d 
              88 00 
<00048> ed2b: 87 53 50 41   db FCOLON,'SPACE',T_NUM,0,20h,FEMIT,FSEMI,0
              43 45 ff 00 
              20 a5 88 00 
<00049> ed37: 87 53 50 41   db FCOLON,'SPACES 0',FDO,T_NUM,0,20h,FEMIT,FLOOP,FSEMI,0
              43 45 53 20 
              30 98 ff 00 
              20 a5 99 88 
              00 
<00050> ed48: 87 54 52 55   db FCOLON,'TRUE 1',FSEMI,0
              45 20 31 88 
              00 
<00051> ed51: 87 54 55 43   db FCOLON,'TUCK',FSWAP,FOVER,FSEMI,0
              4b 8b aa 88 
              00 
<00052> ed5a: 87 54 59 50   db FCOLON,'TYPE',FDUP,FIF,'0',FDO,FDUP,FCAT,FEMITP,'1+',FLOOP,FELSE,FDROP,FTHEN,FDROP,FSEMI,0
              45 89 83 30 
              98 89 ad a6 
              31 2b 99 84 
              8a 85 8a 88 
              00 
<00053> ed6f: 87 55 3e 8b   db FCOLON,'U>',FSWAP,'U<',FSEMI,0
              55 3c 88 00 
<00054> ed77: 87 55 3e 3d   db FCOLON,'U>= 2DUP U> >R = R> OR',FSEMI,0
              20 32 44 55 
              50 20 55 3e 
              20 3e 52 20 
              3d 20 52 3e 
              20 4f 52 88 
              00 
<00055> ed90: 87 55 3c 3d   db FCOLON,'U<= U>= NOT',FSEMI,0
              20 55 3e 3d 
              20 4e 4f 54 
              88 00 
<00056> ed9e: 87 52 44 52   db FCOLON,'RDROP',FRGT,FDROP,FSEMI,0
              4f 50 a1 8a 
              88 00 
<00057> eda8: 87 55 4e 4c   db FCOLON,'UNLOOP',FRGT,FRGT,FRGT,FDROP,FDROP,FDROP,FSEMI,0
              4f 4f 50 a1 
              a1 a1 8a 8a 
              8a 88 00 
<00058> edb7: 87 48 45 58   db FCOLON,'HEX',T_NUM,0,10h,FBASE,FEXCL,FSEMI,0
              ff 00 10 ca 
              ac 88 00 
<00059> edc2: 87 44 45 43   db FCOLON,'DECIMAL',T_NUM,0,10,FBASE,FEXCL,FSEMI,0
              49 4d 41 4c 
              ff 00 0a ca 
              ac 88 00 
<00000>                   #include custom.inc
<00001>                   ; This file can hold definitions you don't want in the "standard" definitions
<00002> edd1: 3a 20 49 4e    db ': INIT HEX ;',0
              49 54 20 48 
              45 58 20 3b 
              00 
<00009>                   #endif
<00010>                   ; breakpoint for 1802BLACK
<00011>                   
<00012> edde: 3a 20 42 4c    db ': BLKBRK ',T_NUM, 068h, 0d5h, FSPAT, FEXEC, FDROP, FDROP, FSEMI,0
              4b 42 52 4b 
              20 ff 68 d5 
              be c4 8a 8a 
              88 00 
<00013> edf0: 3a 20 53 54    db ': STGBRK ',T_NUM,0d5h, 00h, T_NUM,079h,0d1h,FSPAT,FEXEC,FDROP,FDROP,FDROP,FSEMI,0
              47 42 52 4b 
              20 ff d5 00 
              ff 79 d1 be 
              c4 8a 8a 8a 
              88 00 
<00014> ee06: 3a 20 42 41    db ': BASE? ." 0#"BASE @ #. ',FSEMI,0
              53 45 3f 20 
              2e 22 20 30 
              23 22 42 41 
              53 45 20 40 
              20 23 2e 20 
              88 00 
<00015>                   
<00016>                   
<00017>                   ; do not put final zero here!
<00018>                   
<00019>                   
<00020>                   
<00061> ee20: 49 4e 49 54   db 'INIT',0
              00 
<00062> ee25: 46 4f 52 47   db 'FORGET INIT',0
              45 54 20 49 
              4e 49 54 00 
<00063> ee31: 00            db  0
[04276]                   loadtext:
<00000>                   #include extended.inc
<00001>                   
<00002>                   ; Define LEAN_EXTENDED if you only want what I think are
<00003>                   ; "important" extended words You can always load the rest as you see
<00004>                   ; fit at runtime
<00005>                   
<00006>                   
<00007>                   ; rules: All uppercase
<00008>                   ; no multiple line definitions
<00009>                   ; 0 Ends each string and a zero at the end
<00010>                   ; Sometimes (but not always) RC/ASM stops after a double quote
<00011>                   ; So '." foo " .',0  -- might stop after the quote. Check the listing to be sure
<00012>                   
<00013>                     ; You can put ASCII definitions/command here
<00014>                   ; But you can also use the Fxxx words for core words.
<00015>                   ; So...
<00016>                   ; db ': foo swap drop ;',0
<00017>                   ; is the same as:
<00018>                   ; db FCOLON,'foo',FSWAP,FDROP,FSEMI,0
<00019>                   ; NOTE: tokens no longer have to end in space if there is a compiled token following.
<00020>                   ; Also FDOTQT is "odd":  dw FDOTQT,' <-space not printed"100 2 + ',FDOT,FCR,0
<00021>                   ; Note the first space is "eaten" and the quote ends the string (no zero), and you do NOT need
<00022>                   ; a space after the quote (although it won't hurt if you have one)
<00023>                   ; You can also use T_NUM:  db T_NUM,0,0ffh   ; 255
<00024>                   ; or T_ASCII: db FCOLON,T_ASCII,'FOO',0,....
<00025>                   
<00026>                   
<00027>                   
<00028>                   ; of course, it is easy enough to move stuff from one list to the other
<00029>                   #ifndef LEAN_EXTENDED
<00030> ee32: 87 2b 21 20   db FCOLON,'+! TUCK',FAT,FPLUS,FSWAP,FEXCL,FSEMI,0
              54 55 43 4b 
              ab 8c 8b ac 
              88 00 
<00031> ee40: 87 2d 21 20   db FCOLON,'-! NEG +!',FSEMI,0
              4e 45 47 20 
              2b 21 88 00 
<00032> ee4c: 87 2a 21 20   db FCOLON,'*! TUCK',FAT,FMUL,FSWAP,FEXCL,FSEMI,0
              54 55 43 4b 
              ab 8e 8b ac 
              88 00 
<00033> ee5a: 87 2f 21 20   db FCOLON,'/! TUCK',FAT,FSWAP,FDIV,FSWAP,FEXCL,FSEMI,0
              54 55 43 4b 
              ab 8b 8f 8b 
              ac 88 00 
<00034> ee69: 87 2f 4d 4f   db FCOLON,'/MOD 2DUP MOD',FMROT,FDIV,FSEMI,0
              44 20 32 44 
              55 50 20 4d 
              4f 44 a9 8f 
              88 00 
<00035> ee7b: 87 40 2b 89   db FCOLON,'@+',FDUP,FAT,FSWAP,'2+ ',FSWAP,FSEMI,0
              ab 8b 32 2b 
              20 8b 88 00 
<00036> ee87: 87 32 44 55   db FCOLON,'2DUP',FOVER,FOVER,FSEMI,0
              50 aa aa 88 
              00 
<00037> ee90: 87 32 44 52   db FCOLON,'2DROP',FDROP,FDROP,FSEMI,0
              4f 50 8a 8a 
              88 00 
<00038> ee9a: 87 32 4f 56   db FCOLON,'2OVER 3 PICK 3 PICK',FSEMI,0
              45 52 20 33 
              20 50 49 43 
              4b 20 33 20 
              50 49 43 4b 
              88 00 
<00039> eeb0: 87 32 53 57   db FCOLON,'2SWAP',FGTR,FMROT,FRGT,FMROT,FSEMI,0
              41 50 a2 a9 
              a1 a9 88 00 
<00040> eebc: 87 41 42 53   db FCOLON,'ABS',FDUP,'0< ',FIF,'NEG ',FTHEN,FSEMI,0
              89 30 3c 20 
              83 4e 45 47 
              20 85 88 00 
<00041> eecc: 87 42 59 54   db FCOLON,'BYTESWAP',FDUP,'8 >>',FSWAP,'0XFF',FAND,'8 <<',FOR,FSEMI,0
              45 53 57 41 
              50 89 38 20 
              3e 3e 8b 30 
              58 46 46 93 
              38 20 3c 3c 
              94 88 00 
<00042> eee7: 87 43 2b 21   db FCOLON,'C+!',FDUP,FGTR,FCAT,FPLUS,FRGT,FCEXCL,FSEMI,0
              89 a2 ad 8c 
              a1 ae 88 00 
<00043> eef3: 87 43 2d 21   db FCOLON,'C-! NEG C+!',FSEMI,0
              20 4e 45 47 
              20 43 2b 21 
              88 00 
<00044> ef01: 87 43 4c 52   db FCOLON,'CLRBIT 1',FSWAP,' << INVERT',FAND,FSEMI,0
              42 49 54 20 
              31 8b 20 3c 
              3c 20 49 4e 
              56 45 52 54 
              93 88 00 
<00045> ef18: 87 45 52 41   db FCOLON,'ERASE 0 FILL',FSEMI,0
              53 45 20 30 
              20 46 49 4c 
              4c 88 00 
<00046> ef27: 87 46 49 4c   db FCOLON,'FILL',FSWAP,FGTR,FOVER,FCEXCL,FDUP,'1+',FRGT,'1-',FCMOVE,FSEMI,0
              4c 8b a2 aa 
              ae 89 31 2b 
              a1 31 2d af 
              88 00 
<00047> ef39: 87 47 45 54   db FCOLON,'GETBIT >> 1',FAND,FSEMI,0
              42 49 54 20 
              3e 3e 20 31 
              93 88 00 
<00048> ef48: 87 47 4f 54   db FCOLON,'GOTOXY',FBASE,FAT,FMROT,FOPT,FAT,FMROT,T_NUM,0,10,FBASE,FEXCL,'1',FOPT,FEXCL,'ESC ." [". ." ;". ." H"',FOPT,FEXCL,FBASE,FEXCL,FSEMI,0
              4f 58 59 ca 
              ab a9 cf ab 
              a9 ff 00 0a 
              ca ac 31 cf 
              ac 45 53 43 
              20 2e 22 20 
              5b 22 2e 20 
              2e 22 20 3b 
              22 2e 20 2e 
              22 20 48 22 
              cf ac ca ac 
              88 00 
<00049> ef7a: 87 4a cd 36   db FCOLON,'J',FRPAT,'6 + @',FSEMI,0
              20 2b 20 40 
              88 00 
<00050> ef84: 87 49 4e 56   db FCOLON,'INVERT',T_NUM,0ffh,0ffh,FXOR,FSEMI,0
              45 52 54 ff 
              ff ff 95 88 
              00 
<00051> ef91: 87 4c 53 48   db FCOLON,'LSHIFT',FDUP,FWHILE,FSWAP,'2',FMUL,FSWAP,'1-',FDUP,FREPEAT,FDROP,FSEMI,0
              49 46 54 89 
              81 8b 32 8e 
              8b 31 2d 89 
              82 8a 88 00 
<00052> efa5: 87 4d 41 58   db FCOLON,'MAX 2DUP < SWAP?',FDROP,FSEMI,0
              20 32 44 55 
              50 20 3c 20 
              53 57 41 50 
              3f 8a 88 00 
<00053> efb9: 87 4d 49 4e   db FCOLON,'MIN 2DUP > SWAP?',FDROP,FSEMI,0
              20 32 44 55 
              50 20 3e 20 
              53 57 41 50 
              3f 8a 88 00 
<00054> efcd: 87 52 53 48   db FCOLON,'RSHIFT',FDUP,FWHILE,FSWAP,'2',FDIV,FSWAP,'1-',FDUP,FREPEAT,FDROP,FSEMI,0
              49 46 54 89 
              81 8b 32 8f 
              8b 31 2d 89 
              82 8a 88 00 
<00055> efe1: 87 53 45 54   db FCOLON,'SETBIT 1',FSWAP,'<<',FOR,FSEMI,0
              42 49 54 20 
              31 8b 3c 3c 
              94 88 00 
<00056> eff0: 87 53 47 4e   db FCOLON,'SGN',FDUP,FIF,'0X8000',FAND,FIF,T_NUM,0ffh,0ffh,FELSE,'1',FTHEN,FTHEN,FSEMI,0
              89 83 30 58 
              38 30 30 30 
              93 83 ff ff 
              ff 84 31 85 
              85 88 00 
<00057> f007: 87 53 57 41   db FCOLON,'SWAP?',FIF,FSWAP,FTHEN,FSEMI,0
              50 3f 83 8b 
              85 88 00 
<00058> f012: 87 54 47 4c   db FCOLON,'TGLBIT 1',FSWAP,'<<',FXOR,FSEMI,0
              42 49 54 20 
              31 8b 3c 3c 
              95 88 00 
<00059> f021: 87 55 4d 49   db FCOLON,'UMIN 2DUP U> SWAP?',FDROP,FSEMI,0
              4e 20 32 44 
              55 50 20 55 
              3e 20 53 57 
              41 50 3f 8a 
              88 00 
<00060> f037: 87 55 4d 41   db FCOLON,'UMAX 2DUP U< SWAP?',FDROP,FSEMI,0
              58 20 32 44 
              55 50 20 55 
              3c 20 53 57 
              41 50 3f 8a 
              88 00 
<00061> f04d: 87 42 41 53   db FCOLON,'BASEOUT',FBASE,FAT,FMROT,FBASE,FEXCL,FDOT,FBASE,FEXCL,FSEMI,0
              45 4f 55 54 
              ca ab a9 ca 
              ac 90 ca ac 
              88 00 
<00062> f05f: 87 23 2e ff   db FCOLON,'#.',T_NUM,0,10,'BASEOUT ;',0
              00 0a 42 41 
              53 45 4f 55 
              54 20 3b 00 
<00063> f06f: 87 24 2e ff   db FCOLON,'$.',T_NUM,0,16,'BASEOUT ;',0
              00 10 42 41 
              53 45 4f 55 
              54 20 3b 00 
<00064> f07f: 87 25 2e ff   db FCOLON,'%.',T_NUM,80h,00,FBEGIN,'2DUP',FAND,FIF,T_NUM,0,31h,FELSE,T_NUM,0,30h
              80 00 9f 32 
              44 55 50 93 
              83 ff 00 31 
              84 ff 00 30 
<00065> f093: 85 a5 31 20     db         FTHEN,FEMIT,'1 ',FGTGT,FDUP,'NOT',FUNTIL,'SPACE',FDROP,FDROP,FSEMI,0
              c0 89 4e 4f 
              54 a0 53 50 
              41 43 45 8a 
              8a 88 00 
<00066> f0a6: 87 43 41 53   db FCOLON,'CASE?',FOVER,FEQUAL,FDUP,FIF,'NIP',FTHEN,FSEMI,0
              45 3f aa 9b 
              89 83 4e 49 
              50 85 88 00 
<00067>                   #endif
<00068>                   
<00069> f0b6: 00            db  0
<00070>                   
[04278]                   
[04279]                   
[04280]                   #endif
[04281]                   
[04282] f0b7:             endrom:       equ           $
[04294]                   #endif
[04295] f0b7:                           end           start
