1802 -> Native
2 Classes read.
186 Patterns read.
    1 0000:             ; *******************************************************************
    2 0000:             ; *** This software is copyright 2020 by Michael H Riley          ***
    3 0000:             ; *** You have permission to use, modify, copy, and distribute    ***
    4 0000:             ; *** this software so long as this copyright notice is retained. ***
    5 0000:             ; *** This software may not be used in commercial applications    ***
    6 0000:             ; *** without express written permission from the author.         ***
    7 0000:             ; *******************************************************************
    8 0000:             
    9 0000:             ;[RLA] These are defined on the rcasm command line!
   10 0000:             ;[RLA] #define STGROM		; build the STG EPROM version
   11 0000:             
   12 0000:             ;[RLA] The STG EPROM version is (semi) standalone ...
            #ifdef STGROM			;[RLA]
   14 0000:             include config.inc		;[RLA] STG EPROM definitions
   15 0000:             ; DO NOT EDIT THIS FILE - EDIT CONFIG. INSTEAD!!
            #define BOOTS	 08000H
            #define WARMB	 (08000H+3)
            #define HELP	 09400H
            #define RAMPAGE	 07F00H
            #define BIOS	 0FF00H
            #define EBIOS	 0F800H
            #define FORTH	 0D700H
            #define EDTASM	 09C00H
            #define BASIC	 0BA00H
            #define VISUAL	 0A900H
            #define XMODEM	 0D400H
            #endif
   28 0000:             include bios.inc
   29 0000:             ; *******************************************************************
   30 0000:             ; *** This software is copyright 2006 by Michael H Riley          ***
   31 0000:             ; *** You have permission to use, modify, copy, and distribute    ***
   32 0000:             ; *** this software so long as this copyright notice is retained. ***
   33 0000:             ; *** This software may not be used in commercial applications    ***
   34 0000:             ; *** without express written permission from the author.         ***
   35 0000:             ; *******************************************************************
   36 0000:             
            #endif
   40 0000:             
   41 0000:             ; Define address for standard BIOS vectors
            #endif
   45 0000:             
   46 0000:             ; Define address for extended BIOS vectors
            #endif
   50 0000:             
            #ifndef TASM
   52 0000:             scall:      equ  r4                    ; register for SCALL
   53 0000:             sret:       equ  r5                    ; register for SRET
   54 0000:             
   55 0000:             call:       equ  0ffe0h                ; depricated
   56 0000:             ret:        equ  0fff1h                ; depricated
            #endif
   58 0000:             
   59 0000:             f_boot:     equ  (BIOS+00h)            ; boot from ide device
   60 0000:             f_type:     equ  (BIOS+03h)            ; type 1 character to console
   61 0000:             f_read:     equ  (BIOS+06h)            ; read 1 character from console
   62 0000:             f_msg:      equ  (BIOS+09h)            ; type asciiz string to console
   63 0000:             f_typex:    equ  (BIOS+0ch)            ; depricated, just returns now
   64 0000:             f_input:    equ  (BIOS+0fh)            ; read asciiz from console
   65 0000:             f_strcmp:   equ  (BIOS+12h)            ; compare 2 strings
   66 0000:             f_ltrim:    equ  (BIOS+15h)            ; trim leading spaces
   67 0000:             f_strcpy:   equ  (BIOS+18h)            ; copy an asciiz string
   68 0000:             f_memcpy:   equ  (BIOS+1bh)            ; copy memory
   69 0000:             f_wrtsec:   equ  (BIOS+1eh)            ; write floppy sector (depricated)
   70 0000:             f_rdsec:    equ  (BIOS+21h)            ; read floppy sector (depricated)
   71 0000:             f_seek0:    equ  (BIOS+24h)            ; floppy seek to track 0 (depricated)
   72 0000:             f_seek:     equ  (BIOS+27h)            ; floopy track seek (depricated)
   73 0000:             f_drive:    equ  (BIOS+2ah)            ; select floppy drive (depricated)
   74 0000:             f_setbd:    equ  (BIOS+2dh)            ; set console baud rate
   75 0000:             f_mul16:    equ  (BIOS+30h)            ; 16-bit multiply
   76 0000:             f_div16:    equ  (BIOS+33h)            ; 16-bit division
   77 0000:             f_idereset: equ  (BIOS+36h)            ; reset ide device
   78 0000:             f_idewrite: equ  (BIOS+39h)            ; write ide sector
   79 0000:             f_ideread:  equ  (BIOS+3ch)            ; read ide sector
   80 0000:             f_initcall: equ  (BIOS+3fh)            ; initialize R4 and R5
   81 0000:             f_bootide:  equ  (BIOS+42h)            ; boot from ide device
   82 0000:             f_hexin:    equ  (BIOS+45h)            ; convert ascii number to hex
   83 0000:             f_hexout2:  equ  (BIOS+48h)            ; convert hex to 2-digit ascii
   84 0000:             f_hexout4:  equ  (BIOS+4bh)            ; convert hex to 4-digit ascii
   85 0000:             f_tty:      equ  (BIOS+4eh)            ; type character to console
   86 0000:             f_mover:    equ  (BIOS+51h)            ; program relocator
   87 0000:             f_minimon:  equ  (BIOS+54h)            ; mini monitor
   88 0000:             f_freemem:  equ  (BIOS+57h)            ; determine memory size
   89 0000:             F_isnum:    equ  (BIOS+5ah)            ; determine if D is numeric
   90 0000:             f_atoi:     equ  (BIOS+5dh)            ; convert ascii to integer
   91 0000:             f_uintout:  equ  (BIOS+60h)            ; convert unsigned integer to ascii
   92 0000:             f_intout:   equ  (BIOS+63h)            ; convert signed integer to ascii
   93 0000:             f_inmsg:    equ  (BIOS+66h)            ; type in-line message
   94 0000:             f_inputl:   equ  (BIOS+69h)            ; read limited line from console
   95 0000:             f_brktest:  equ  (BIOS+6ch)            ; check for serial break
   96 0000:             f_findtkn:  equ  (BIOS+6fh)            ; find token in a token table
   97 0000:             f_isalpha:  equ  (BIOS+72h)            ; determine if D is alphabetic
   98 0000:             f_ishex:    equ  (BIOS+75h)            ; determine if D is hexadecimal
   99 0000:             f_isalnum:  equ  (BIOS+78h)            ; determine if D is alpha or numeric
  100 0000:             f_idnum:    equ  (BIOS+7bh)            ; determine type of ascii number
  101 0000:             f_isterm:   equ  (BIOS+7eh)            ; determine if D is a termination char
  102 0000:             f_getdev:   equ  (BIOS+81h)            ; get supported devices
  103 0000:             
  104 0000:             f_version:  equ  (BIOS+0f9h)           ; 3 bytes holding bios version number
  105 0000:             
  106 0000:             ; "Extended" BIOS vectors
  107 0000:             
  108 0000:             f_bread:     equ  (EBIOS+00h)        ; read from onboard serial port
  109 0000:             f_btype:     equ  (EBIOS+03h)        ; write to onboard serial port
  110 0000:             f_btest:     equ  (EBIOS+06h)        ; test onboard serial port
  111 0000:             f_utype:     equ  (EBIOS+09h)        ; write to disk board UART
  112 0000:             f_uread:     equ  (EBIOS+0ch)        ; read from disk board UART
  113 0000:             f_utest:     equ  (EBIOS+0fh)        ; test disk board UART
  114 0000:             f_usetbd:    equ  (EBIOS+12h)        ; set disk board UART baud rate and format
  115 0000:             f_gettod:    equ  (EBIOS+15h)        ; read time of day clock
  116 0000:             f_settod:    equ  (EBIOS+18h)        ; set time of day clock
  117 0000:             f_rdnvr:     equ  (EBIOS+1bh)        ; read non volatile RAM
  118 0000:             f_wrnvr:     equ  (EBIOS+1eh)        ; write non volatile RAM
  119 0000:             f_idesize:   equ  (EBIOS+21h)        ; return size of attached IDE drive(s)
  120 0000:             f_ideid:     equ  (EBIOS+24h)        ; return device data for IDE drive(s)
  121 0000:             f_tmtoas:    equ  (EBIOS+2ah)        ; time to ASCII string
  122 0000:             f_dttoas:    equ  (EBIOS+27h)        ; date to ASCII string
  123 0000:             f_rtctest:   equ  (EBIOS+2dh)        ; test size and presence of RTC/NVR
  124 0000:             f_astodt:    equ  (EBIOS+30h)        ; convert ASCII string to date
  125 0000:             f_astotm:    equ  (EBIOS+33h)        ; convert ASCII string to time
  126 0000:             f_nvrcchk:   equ  (EBIOS+36h)	    ; [RLA] compute NVR checksum
  127 0000:             
  128 0000:             
  129 0000:             
  130 0000:             ;[RLA]   Usually the XMODEM data segment lives at the very top end of RAM, but
  131 0000:             ;[RLA] on the ELF2K or the PicoElf with the STG EPROM, the ROM monitor reserves
  132 0000:             ;[RLA] the last page of RAM and we have to squeeze in just below that.
            #ifdef STGROM
  134 0000:             base:      equ     RAMPAGE-0100h
            #endif
  138 0000:             
  139 0000:             ; XMODEM data segment
  140 0000:             baud:      equ     base+0
  141 0000:             init:      equ     base+1
  142 0000:             block:     equ     base+2            ; current block
  143 0000:             count:     equ     base+3            ; byte send/receive count
  144 0000:             xdone:     equ     base+4
  145 0000:             h1:        equ     base+5
  146 0000:             h2:        equ     base+6
  147 0000:             h3:        equ     base+7
  148 0000:             txrx:      equ     base+8            ; buffer for tx/rx
  149 0000:             temp1:     equ     base+150
  150 0000:             temp2:     equ     base+152
  151 0000:             buffer:    equ     base+154          ; address for input buffer
  152 0000:             ack:       equ     06h
  153 0000:             nak:       equ     15h
  154 0000:             soh:       equ     01h
  155 0000:             etx:       equ     03h
  156 0000:             eot:       equ     04h
  157 0000:             can:       equ     18h
  158 0000:             csub:      equ     1ah
  159 0000:             
  160 0000:             ;[RLA]   In the STG version XMODEM is an independent module and there's a table
  161 0000:             ;[RLA] of entry vectors at the start.  All the other code, including the EPROM
  162 0000:             ;[RLA] stuff like BASIC or Forth, call XMODEM via these vectors.  Needless to
  163 0000:             ;[RLA] say, these need to remain in this order and at this location!
            #ifdef STGROM
  165 0000:             	org	XMODEM	 	;[RLA] the XMODEM module lives here ...
  166 d400: c0 d4 12    	lbr	xopenw		;[RLA] open XMODEM channel for sending
  167 d403: c0 d5 38    	lbr	xopenr		;[RLA]  "    "  "   "   "   "  receiving
  168 d406: c0 d5 72    	lbr	xread		;[RLA] receive XMODEM data
  169 d409: c0 d4 3c    	lbr	xwrite		;[RLA] send     "  "   "
  170 d40c: c0 d4 ed    	lbr	xclosew		;[RLA] close XMODEM sending channel
  171 d40f: c0 d6 31    	lbr	xcloser		;[RLA]   "    "  "  receiving  "
            #endif
  173 d412:             
  174 d412:             ; *******************************************
  175 d412:             ; ***** Open XMODEM channel for writing *****
  176 d412:             ; *******************************************
  177 d412: 8f 73 9f 73 xopenw:    push    rf                ; save consumed register
  178 d416: f8 02 af f8 
            7e bf                  mov     rf,block          ; current block number
  179 d41c: f8 01                  ldi     1                 ; starts at 1
  180 d41e: 5f                     str     rf                ; store into block number
  181 d41f: 1f                     inc     rf                ; point to byte count
  182 d420: f8 00                  ldi     0                 ; set count to zero
  183 d422: 5f                     str     rf                ; store to byte count
  184 d423: f8 00 af f8 
            7e bf                  mov     rf,baud           ; place to store baud constant
  185 d429: 9e                     ghi     re                ; need to turn off echo
  186 d42a: 5f                     str     rf                ; save it
  187 d42b: fa fe                  ani     0feh
  188 d42d: be                     phi     re                ; put it back
  189 d42e: d4          xopenw1:   sep     scall             ; read a byte from the serial port
  190 d42f: ff 06                  dw      f_read
  191 d431: ff 15                  smi     nak               ; need a nak character
  192 d433: ca d4 2e               lbnz    xopenw1           ; wait until a nak is received
  193 d436: 60 72 bf f0 
            af                     pop     rf                ; recover rf
  194 d43b: d5                     sep     sret              ; and return to caller
  195 d43c:             
  196 d43c:             ; ***********************************
  197 d43c:             ; ***** Write to XMODEM channel *****
  198 d43c:             ; ***** RF - pointer to data    *****
  199 d43c:             ; ***** RC - Count of data      *****
  200 d43c:             ; ***********************************
  201 d43c: 88 73 98 73 xwrite:    push    r8                ; save consumed registers
  202 d440: 8a 73 9a 73            push    ra
  203 d444: f8 03 aa f8 
            7e ba                  mov     ra,count          ; need address of count
  204 d44a: 0a                     ldn     ra                ; get count
  205 d44b: 52                     str     r2                ; store for add
  206 d44c: a8                     plo     r8                ; put into count as well
  207 d44d: f8 08                  ldi     txrx.0            ; low byte of buffer
  208 d44f: f4                     add                       ; add current byte count
  209 d450: aa                     plo     ra                ; put into ra
  210 d451: f8 7e                  ldi     txrx.1            ; high byte of buffer
  211 d453: 7c 00                  adci    0                 ; propagate carry
  212 d455: ba                     phi     ra                ; ra now has address
  213 d456: 4f          xwrite1:   lda     rf                ; retrieve next byte to write
  214 d457: 5a                     str     ra                ; store into buffer
  215 d458: 1a                     inc     ra
  216 d459: 18                     inc     r8                ; increment buffer count
  217 d45a: 88                     glo     r8                ; get buffer count
  218 d45b: fa 80                  ani     080h              ; check for 128 bytes in buffer
  219 d45d: c2 d4 6c               lbz     xwrite2           ; jump if not
  220 d460: d4                     sep     scall             ; send current block
  221 d461: d4 88                  dw      xsend
  222 d463: f8 00                  ldi     0                 ; zero buffer count
  223 d465: a8                     plo     r8
  224 d466: f8 08 aa f8 
            7e ba                  mov     ra,txrx           ; reset buffer position
  225 d46c: 2c          xwrite2:   dec     rc                ; decrement count
  226 d46d: 8c                     glo     rc                ; see if done
  227 d46e: ca d4 56               lbnz    xwrite1           ; loop back if not
  228 d471: 9c                     ghi     rc                ; need to check high byte
  229 d472: ca d4 56               lbnz    xwrite1           ; loop back if not
  230 d475: f8 03 aa f8 
            7e ba                  mov     ra,count          ; need to write new count
  231 d47b: 88                     glo     r8                ; get the count
  232 d47c: 5a                     str     ra                ; and save it
  233 d47d: 60 72 ba f0 
            aa                     pop     ra                ; pop consumed registers
  234 d482: 60 72 b8 f0 
            a8                     pop     r8
  235 d487: d5                     sep     sret              ; and return to caller
  236 d488:             
  237 d488:             
  238 d488:             ; *******************************
  239 d488:             ; ***** Send complete block *****
  240 d488:             ; *******************************
  241 d488: 8f 73 9f 73 xsend:     push    rf                 ; save consumed registers
  242 d48c: 8c 73 9c 73            push    rc
  243 d490: f8 01       xsendnak:  ldi     soh                ; need to send soh character
  244 d492: bc                     phi     rc                 ; initial value for checksum
  245 d493: d4                     sep     scall              ; send it
  246 d494: ff 4e                  dw      f_tty
  247 d496: f8 02 af f8 
            7e bf                  mov     rf,block           ; need current block number
  248 d49c: 0f                     ldn     rf                 ; get block number
  249 d49d: 52                     str     r2                 ; save it
  250 d49e: 9c                     ghi     rc                 ; get checksum
  251 d49f: f4                     add                        ; add in new byte
  252 d4a0: bc                     phi     rc                 ; put it back
  253 d4a1: 02                     ldn     r2                 ; recover block number
  254 d4a2: d4                     sep     scall              ; and send it
  255 d4a3: ff 4e                  dw      f_tty
  256 d4a5: 0f                     ldn     rf                 ; get block number back
  257 d4a6: fd ff                  sdi     255                ; subtract from 255
  258 d4a8: 52                     str     r2                 ; save it
  259 d4a9: 9c                     ghi     rc                 ; get current checksum
  260 d4aa: f4                     add                        ; add in inverted block number
  261 d4ab: bc                     phi     rc                 ; put it back
  262 d4ac: 02                     ldn     r2                 ; recover inverted block number
  263 d4ad: d4                     sep     scall              ; send it
  264 d4ae: ff 4e                  dw      f_tty
  265 d4b0: f8 80                  ldi     128                ; 128 bytes to write
  266 d4b2: ac                     plo     rc                 ; place into counter
  267 d4b3: f8 08 af f8 
            7e bf                  mov     rf,txrx            ; point rf to data block
  268 d4b9: 4f          xsend1:    lda     rf                 ; retrieve next byte
  269 d4ba: 52                     str     r2                 ; save it
  270 d4bb: 9c                     ghi     rc                 ; get checksum
  271 d4bc: f4                     add                        ; add in new byte
  272 d4bd: bc                     phi     rc                 ; save checksum
  273 d4be: 02                     ldn     r2                 ; recover byte
  274 d4bf: d4                     sep     scall              ; and send it
  275 d4c0: ff 4e                  dw      f_tty
  276 d4c2: 2c                     dec     rc                 ; decrement byte count
  277 d4c3: 8c                     glo     rc                 ; get count
  278 d4c4: ca d4 b9               lbnz    xsend1             ; jump if more bytes to send
  279 d4c7: 9c                     ghi     rc                 ; get checksum byte
  280 d4c8: d4                     sep     scall              ; and send it
  281 d4c9: ff 4e                  dw      f_tty    
  282 d4cb: d4          xsend2:    sep     scall              ; read byte from serial port
  283 d4cc: ff 06                  dw      f_read
  284 d4ce: 52                     str     r2                 ; save it
  285 d4cf: ff 15                  smi     nak                ; was it a nak
  286 d4d1: c2 d4 90               lbz     xsendnak           ; resend block if nak
  287 d4d4: f8 02 af f8 
            7e bf                  mov     rf,block           ; point to block number
  288 d4da: 0f                     ldn     rf                 ; get block number
  289 d4db: fc 01                  adi     1                  ; increment block number
  290 d4dd: 5f                     str     rf                 ; and put it back
  291 d4de: 1f                     inc     rf                 ; point to buffer count
  292 d4df: f8 00                  ldi     0                  ; set buffer count
  293 d4e1: 5f                     str     rf
  294 d4e2: 60 72 bc f0 
            ac                     pop     rc                 ; recover registers
  295 d4e7: 60 72 bf f0 
            af                     pop     rf
  296 d4ec: d5                     sep     sret               ; and return
  297 d4ed:             
  298 d4ed:             ; **************************************
  299 d4ed:             ; ***** Close XMODEM write channel *****
  300 d4ed:             ; **************************************
  301 d4ed: 8f 73 9f 73 xclosew:   push    rf                 ; save consumed registers
  302 d4f1: 8c 73 9c 73            push    rc
  303 d4f5: f8 03 af f8 
            7e bf                  mov     rf,count           ; get count of characters unsent
  304 d4fb: 0f                     ldn     rf                 ; retrieve count
  305 d4fc: c2 d5 18               lbz     xclosewd           ; jump if no untransmitted characters
  306 d4ff: ac                     plo     rc                 ; put into count
  307 d500: 52                     str     r2                 ; save for add
  308 d501: f8 08                  ldi     txrx.0             ; low byte of buffer
  309 d503: f4                     add                        ; add characters in buffer
  310 d504: af                     plo     rf                 ; put into rf
  311 d505: f8 7e                  ldi     txrx.1             ; high byte of transmit buffer
  312 d507: 7c 00                  adci    0                  ; propagate carry
  313 d509: bf                     phi     rf                 ; rf now has position to write at
  314 d50a: f8 1a       xclosew1:  ldi     csub               ; character to put into buffer
  315 d50c: 5f                     str     rf                 ; store into transmit buffer
  316 d50d: 1f                     inc     rf                 ; point to next position
  317 d50e: 1c                     inc     rc                 ; increment byte count
  318 d50f: 8c                     glo     rc                 ; get count
  319 d510: fa 80                  ani     080h               ; need 128 bytes
  320 d512: c2 d5 0a               lbz     xclosew1           ; loop if not enough
  321 d515: d4                     sep     scall              ; send final block
  322 d516: d4 88                  dw      xsend
  323 d518: f8 04       xclosewd:  ldi     eot                ; need to send eot
  324 d51a: d4                     sep     scall              ; send it
  325 d51b: ff 4e                  dw      f_tty
  326 d51d: d4                     sep     scall              ; read a byte
  327 d51e: ff 06                  dw      f_read
  328 d520: ff 06                  smi     06h                ; needs to be an ACK
  329 d522: ca d5 18               lbnz    xclosewd           ; resend EOT if not ACK
  330 d525: f8 00 af f8 
            7e bf                  mov     rf,baud            ; need to restore baud constant
  331 d52b: 0f                     ldn     rf                 ; get it
  332 d52c: be                     phi     re                 ; put it back
  333 d52d: 60 72 bc f0 
            ac                     pop     rc                 ; recover consumed registers
  334 d532: 60 72 bf f0 
            af                     pop     rf
  335 d537: d5                     sep     sret               ; and return
  336 d538:             
  337 d538:             ; *******************************************
  338 d538:             ; ***** Open XMODEM channel for reading *****
  339 d538:             ; *******************************************
  340 d538: 8f 73 9f 73 xopenr:    push    rf                 ; save consumed registers
  341 d53c: f8 00 af f8 
            7e bf                  mov     rf,baud            ; point to baud constant
  342 d542: 9e                     ghi     re                 ; get baud constant
  343 d543: 5f                     str     rf                 ; save it
  344 d544: fa fe                  ani     0feh               ; turn off echo
  345 d546: be                     phi     re                 ; put it back
  346 d547: 1f                     inc     rf                 ; point to init block
  347 d548: f8 15                  ldi     nak                ; need to send initial nak
  348 d54a: 5f                     str     rf                 ; store it
  349 d54b: 1f                     inc     rf                 ; point to block number
  350 d54c: f8 01                  ldi     1                  ; expect 1
  351 d54e: 5f                     str     rf                 ; store it
  352 d54f: 1f                     inc     rf                 ; point to count
  353 d550: f8 80                  ldi     128                ; mark as no bytes in buffer
  354 d552: 5f                     str     rf                 ; store it
  355 d553: 1f                     inc     rf                 ; point to done
  356 d554: f8 00                  ldi     0                  ; mark as not done
  357 d556: 5f                     str     rf
  358 d557:                         
  359 d557: f8 00                  ldi 0                      ; setup inner delay loop
  360 d559: af                     plo rf
  361 d55a: bf                     phi rf
  362 d55b: f8 10                  ldi 010h                   ; setup outer delay loop
  363 d55d: ae                     plo re
  364 d55e: 2f          xopenr1:   dec     rf
  365 d55f: 8f                     glo     rf
  366 d560: ca d5 5e               lbnz    xopenr1
  367 d563: 9f                     ghi     rf
  368 d564: ca d5 5e               lbnz    xopenr1
  369 d567: 2e                     dec     re
  370 d568: 8e                     glo     re
  371 d569: ca d5 5e               lbnz    xopenr1
  372 d56c: 60 72 bf f0 
            af                     pop     rf                 ; recover consumed register
  373 d571: d5                     sep     sret               ; and return
  374 d572:             
  375 d572:             ; ************************************
  376 d572:             ; ***** Read from XMODEM channel *****
  377 d572:             ; ***** RF - pointer to data     *****
  378 d572:             ; ***** RC - Count of data       *****
  379 d572:             ; ************************************
  380 d572: 8a 73 9a 73 xread:     push    ra                 ; save consumed registers
  381 d576: 89 73 99 73            push    r9
  382 d57a: f8 03 aa f8 
            7e ba                  mov     ra,count           ; need current read count
  383 d580: 0a                     ldn     ra                 ; get read count
  384 d581: a9                     plo     r9                 ; store it here
  385 d582: 52                     str     r2                 ; store for add
  386 d583: f8 08                  ldi     txrx.0             ; low byte of buffer address
  387 d585: f4                     add                        ; add count
  388 d586: aa                     plo     ra                 ; store into ra
  389 d587: f8 7e                  ldi     txrx.01            ; high byte of buffer address
  390 d589: 7c 00                  adci    0                  ; propagate carry
  391 d58b: ba                     phi     ra                 ; ra now has address
  392 d58c: 89          xreadlp:   glo     r9                 ; get count
  393 d58d: fa 80                  ani     080h               ; need to see if bytes to read
  394 d58f: c2 d5 9e               lbz     xread1             ; jump if so
  395 d592: d4                     sep     scall              ; receive another block
  396 d593: d5 be                  dw      xrecv
  397 d595: f8 08 aa f8 
            7e ba                  mov     ra,txrx            ; back to beginning of buffer
  398 d59b: f8 00                  ldi     0                  ; zero count
  399 d59d: a9                     plo     r9
  400 d59e: 4a          xread1:    lda     ra                 ; read byte from receive buffer
  401 d59f: 5f                     str     rf                 ; store into output
  402 d5a0: 1f                     inc     rf
  403 d5a1: 19                     inc     r9                 ; increment buffer count
  404 d5a2: 2c                     dec     rc                 ; decrement read count
  405 d5a3: 8c                     glo     rc                 ; get low of count
  406 d5a4: ca d5 8c               lbnz    xreadlp            ; loop back if more to read
  407 d5a7: 9c                     ghi     rc                 ; need to check high byte
  408 d5a8: ca d5 8c               lbnz    xreadlp            ; loop back if more
  409 d5ab: f8 03 aa f8 
            7e ba                  mov     ra,count           ; need to store buffer count
  410 d5b1: 89                     glo     r9                 ; get it
  411 d5b2: 5a                     str     ra                 ; and store it
  412 d5b3: 60 72 b9 f0 
            a9                     pop     r9                 ; recover used registers
  413 d5b8: 60 72 ba f0 
            aa                     pop     ra
  414 d5bd: d5                     sep     sret               ; and return to caller
  415 d5be:             
  416 d5be:             ; ********************************
  417 d5be:             ; ***** Receive XMODEM block *****
  418 d5be:             ; ********************************
  419 d5be: 8f 73 9f 73 xrecv:     push    rf                 ; save consumed registers
  420 d5c2: 8c 73 9c 73            push    rc
  421 d5c6:             xrecvnak:
  422 d5c6: d4          xrecvlp:   sep     scall              ; receive a byte
  423 d5c7: d6 40                  dw      readblk
  424 d5c9: c3 d6 25               lbdf    xrecveot           ; jump if EOT received
  425 d5cc: f8 06 af f8 
            7e bf                  mov     rf,h2              ; point to received block number
  426 d5d2: 0f                     ldn     rf                 ; get it
  427 d5d3: 52                     str     r2                 ; store for comparison
  428 d5d4: f8 02 af f8 
            7e bf                  mov     rf,block           ; get expected block number
  429 d5da: 0f                     ldn     rf                 ; retrieve it
  430 d5db: f7                     sm                         ; check against received block number
  431 d5dc: ca d6 19               lbnz    xrecvnak1          ; jump if bad black number
  432 d5df: f8 08 af f8 
            7e bf                  mov     rf,txrx            ; point to first data byte
  433 d5e5: f8 00                  ldi     0                  ; checksum starts at zero
  434 d5e7: bc                     phi     rc
  435 d5e8: f8 80                  ldi     128                ; 128 bytes need to be added to checksum
  436 d5ea: ac                     plo     rc
  437 d5eb: 4f          xrecv1:    lda     rf                 ; next byte from buffer
  438 d5ec: 52                     str     r2                 ; store for add
  439 d5ed: 9c                     ghi     rc                 ; get checksum
  440 d5ee: f4                     add                        ; add in byte
  441 d5ef: bc                     phi     rc                 ; put checksum back
  442 d5f0: 2c                     dec     rc                 ; decrement byte count
  443 d5f1: 8c                     glo     rc                 ; see if done
  444 d5f2: ca d5 eb               lbnz    xrecv1             ; jump if more to add up
  445 d5f5: 0f                     ldn     rf                 ; get received checksum
  446 d5f6: 52                     str     r2                 ; store for comparison
  447 d5f7: 9c                     ghi     rc                 ; get computed checksum
  448 d5f8: f7                     sm                         ; and compare
  449 d5f9: ca d6 19               lbnz    xrecvnak1          ; jump if bad
  450 d5fc:             
  451 d5fc: f8 01 af f8 
            7e bf                  mov     rf,init            ; point to init number
  452 d602: f8 06                  ldi     ack                ; need to send an ack
  453 d604: 5f                     str     rf
  454 d605: 1f                     inc     rf                 ; point to block number
  455 d606: 0f                     ldn     rf                 ; get block number
  456 d607: fc 01                  adi     1                  ; increment block number
  457 d609: 5f                     str     rf                 ; put it back
  458 d60a: 1f                     inc     rf                 ; point to count
  459 d60b: f8 00                  ldi     0                  ; no bytes read from this block
  460 d60d: 5f                     str     rf
  461 d60e: 60 72 bc f0 
            ac          xrecvret:  pop     rc                 ; recover consumed registers
  462 d613: 60 72 bf f0 
            af                     pop     rf
  463 d618: d5                     sep     sret               ; return to caller
  464 d619:             
  465 d619: f8 01 af f8 
            7e bf       xrecvnak1: mov     rf,init            ; point to init byte
  466 d61f: f8 15                  ldi     nak                ; need a nak
  467 d621: 5f                     str     rf                 ; store it
  468 d622: c0 d5 c6               lbr     xrecvnak           ; need to have packet resent
  469 d625:             
  470 d625: f8 04 af f8 
            7e bf       xrecveot:  mov     rf,xdone           ; need to mark EOT received
  471 d62b: f8 01                  ldi     1
  472 d62d: 5f                     str     rf
  473 d62e: c0 d6 0e               lbr     xrecvret           ; jump to return
  474 d631:             
  475 d631:             ; *************************************
  476 d631:             ; ***** Close XMODEM read channel *****
  477 d631:             ; *************************************
  478 d631: d4          xcloser:   sep     scall              ; read next block
  479 d632: d6 40                  dw      readblk
  480 d634: cb d6 31               lbnf    xcloser            ; jump if EOT not received
  481 d637:             
  482 d637: f8 00 af f8 
            7e bf                  mov     rf,baud            ; need to restore baud constant
  483 d63d: 0f                     ldn     rf                 ; get it
  484 d63e: be                     phi     re                 ; put it back
  485 d63f: d5                     sep     sret               ; return to caller
  486 d640:             
  487 d640:             ;[RLA]   The following code needs to be on a single page, because of the bnf
  488 d640:             ;[RLA] and bnz instructions in the time sensitive loop.  Assuming this whole
  489 d640:             ;[RLA] XMODEM module started on a page boundry then there's plenty of room
  490 d640:             ;[RLA} on the current page, but if you're not so lucky then uncomment the
  491 d640:             ;[RLA] following ORG statement...
  492 d640:             ;[RLA]     org     ($+0FFh) & 0FF00h  ;[RLA] move to the start of the next page
  493 d640:             
  494 d640: 8c 73 9c 73 readblk:   push    rc                 ; save consumed registers
  495 d644: 8a 73 9a 73            push    ra
  496 d648: 8d 73 9d 73            push    rd
  497 d64c: 89 73 99 73            push    r9
  498 d650: f8 84                  ldi     132                ; 132 bytes to receive
  499 d652: aa                     plo     ra
  500 d653: f8 01                  ldi     1                  ; first character flag
  501 d655: ba                     phi     ra
  502 d656:             
  503 d656: f8 01 af f8 
            7e bf                  mov     rf,init            ; get byte to send
  504 d65c: 0f                     ldn     rf                 ; retrieve it
  505 d65d: b9                     phi     r9                 ; Place for transmit
  506 d65e: f8 05 af f8 
            7e bf                  mov     rf,h1              ; point to input buffer
  507 d664: 99                     ghi     r9                 ; get byte
  508 d665: d4                     sep     scall              ; and send it
  509 d666: ff 4e                  dw      f_tty
  510 d668: d4          readblk1:  sep     scall              ; read next byte from serial port
  511 d669: ff 06                  dw      f_read
  512 d66b: 5f                     str     rf                  ; store into buffer
  513 d66c: 1f                     inc     rf                  ; increment buffer
  514 d66d: 9a                     ghi     ra                  ; get first character flag
  515 d66e: f6                     shr                         ; shift into df
  516 d66f: ba                     phi     ra                  ; and put it back
  517 d670: 3b 81                  bnf     recvgo              ; jump if not first character
  518 d672: 8e                     glo     re                  ; [RLA] get character
  519 d673: ff 04                  smi     04h                 ; check for EOT
  520 d675: 3a 81                  bnz     recvgo              ; jump if not EOT
  521 d677: f8 06                  ldi     ack                 ; ACK the EOT
  522 d679: d4                     sep     scall
  523 d67a: ff 4e                  dw      f_tty
  524 d67c: f8 01                  ldi     1                   ; indicate EOT received
  525 d67e: c0 d6 87               lbr     recvret
  526 d681: 2a          recvgo:    dec     ra                  ; decrement receive count
  527 d682: 8a                     glo     ra                  ; see if done
  528 d683: 3a 68                  bnz    readblk1             ; jump if more bytes to read
  529 d685: f8 00                  ldi     0                   ; clear df flag for full block read
  530 d687: f6          recvret:   shr
  531 d688: 60 72 b9 f0 
            a9                     pop     r9
  532 d68d: 60 72 bd f0 
            ad                     pop     rd                  ; recover consumed registers
  533 d692: 60 72 ba f0 
            aa                     pop     ra
  534 d697: 60 72 bc f0 
            ac                     pop     rc
  535 d69c: d5                     sep     sret                ; and return to caller

0006h: ACK              - <   152>    452    521 
7e00h: BASE             - <   134>    140    141    142    143    144    145 
          146    147    148    149    150    151 
7e00h: BAUD             - <   140>    184    330    341    482 
7e02h: BLOCK            - <   142>    178    247    287    428 
7e9ah: BUFFER           - <   151> 
ffe0h: CALL             - <    55> 
0018h: CAN              - <   157> 
7e03h: COUNT            - <   143>    203    230    303    382    409 
001ah: CSUB             - <   158>    314 
0004h: EOT              - <   156>    323 
0003h: ETX              - <   155> 
f830h: F_ASTODT         - <   124> 
f833h: F_ASTOTM         - <   125> 
ff5dh: F_ATOI           - <    90> 
ff00h: F_BOOT           - <    59> 
ff42h: F_BOOTIDE        - <    81> 
f800h: F_BREAD          - <   108> 
ff6ch: F_BRKTEST        - <    95> 
f806h: F_BTEST          - <   110> 
f803h: F_BTYPE          - <   109> 
ff33h: F_DIV16          - <    76> 
ff2ah: F_DRIVE          - <    73> 
f827h: F_DTTOAS         - <   122> 
ff6fh: F_FINDTKN        - <    96> 
ff57h: F_FREEMEM        - <    88> 
ff81h: F_GETDEV         - <   102> 
f815h: F_GETTOD         - <   115> 
ff45h: F_HEXIN          - <    82> 
ff48h: F_HEXOUT2        - <    83> 
ff4bh: F_HEXOUT4        - <    84> 
f824h: F_IDEID          - <   120> 
ff3ch: F_IDEREAD        - <    79> 
ff36h: F_IDERESET       - <    77> 
f821h: F_IDESIZE        - <   119> 
ff39h: F_IDEWRITE       - <    78> 
ff7bh: F_IDNUM          - <   100> 
ff3fh: F_INITCALL       - <    80> 
ff66h: F_INMSG          - <    93> 
ff0fh: F_INPUT          - <    64> 
ff69h: F_INPUTL         - <    94> 
ff63h: F_INTOUT         - <    92> 
ff78h: F_ISALNUM        - <    99> 
ff72h: F_ISALPHA        - <    97> 
ff75h: F_ISHEX          - <    98> 
ff5ah: F_ISNUM          - <    89> 
ff7eh: F_ISTERM         - <   101> 
ff15h: F_LTRIM          - <    66> 
ff1bh: F_MEMCPY         - <    68> 
ff54h: F_MINIMON        - <    87> 
ff51h: F_MOVER          - <    86> 
ff09h: F_MSG            - <    62> 
ff30h: F_MUL16          - <    75> 
f836h: F_NVRCCHK        - <   126> 
f81bh: F_RDNVR          - <   117> 
ff21h: F_RDSEC          - <    70> 
ff06h: F_READ           - <    61>    190    283    327    511 
f82dh: F_RTCTEST        - <   123> 
ff27h: F_SEEK           - <    72> 
ff24h: F_SEEK0          - <    71> 
ff2dh: F_SETBD          - <    74> 
f818h: F_SETTOD         - <   116> 
ff12h: F_STRCMP         - <    65> 
ff18h: F_STRCPY         - <    67> 
f82ah: F_TMTOAS         - <   121> 
ff4eh: F_TTY            - <    85>    246    255    264    275    281    325 
          509    523 
ff03h: F_TYPE           - <    60> 
ff0ch: F_TYPEX          - <    63> 
ff60h: F_UINTOUT        - <    91> 
f80ch: F_UREAD          - <   112> 
f812h: F_USETBD         - <   114> 
f80fh: F_UTEST          - <   113> 
f809h: F_UTYPE          - <   111> 
fff9h: F_VERSION        - <   104> 
f81eh: F_WRNVR          - <   118> 
ff1eh: F_WRTSEC         - <    69> 
7e05h: H1               - <   145>    506 
7e06h: H2               - <   146>    425 
7e07h: H3               - <   147> 
7e01h: INIT             - <   141>    451    465    503 
0015h: NAK              - <   153>    191    285    347    466 
d640h: READBLK          - <   494>    423    479 
d668h: READBLK1         - <   510>    528 
d681h: RECVGO           - <   526>    517    520 
d687h: RECVRET          - <   530>    525 
fff1h: RET              - <    56> 
0004h: SCALL            - <    52>    189    220    245    254    263    274 
          280    282    321    324    326    395    422    478    508    510 
          522 
0001h: SOH              - <   154>    243 
0005h: SRET             - <    53>    194    235    296    335    373    414 
          463    485    535    535 
7e96h: TEMP1            - <   149> 
7e98h: TEMP2            - <   150> 
7e08h: TXRX             - <   148>    207    210    224    267    308    311 
          386    389    397    432 
d631h: XCLOSER          - <   478>    171    480 
d4edh: XCLOSEW          - <   301>    170 
d50ah: XCLOSEW1         - <   314>    320 
d518h: XCLOSEWD         - <   323>    305    329 
7e04h: XDONE            - <   144>    470 
d538h: XOPENR           - <   340>    167 
d55eh: XOPENR1          - <   364>    366    368    371 
d412h: XOPENW           - <   177>    166 
d42eh: XOPENW1          - <   189>    192 
d572h: XREAD            - <   380>    168 
d59eh: XREAD1           - <   400>    394 
d58ch: XREADLP          - <   392>    406    408 
d5beh: XRECV            - <   419>    396 
d5ebh: XRECV1           - <   437>    444 
d625h: XRECVEOT         - <   470>    424 
d5c6h: XRECVLP          - <   422> 
d5c6h: XRECVNAK         - <   421>    468 
d619h: XRECVNAK1        - <   465>    431    449 
d60eh: XRECVRET         - <   461>    473 
d488h: XSEND            - <   241>    221    322 
d4b9h: XSEND1           - <   268>    278 
d4cbh: XSEND2           - <   282> 
d490h: XSENDNAK         - <   243>    286 
d43ch: XWRITE           - <   201>    169 
d456h: XWRITE1          - <   213>    227    229 
d46ch: XWRITE2          - <   225>    219 

535 Lines assembled
0 Errors
117 Labels
Object Code:669 bytes

