1802 -> Native
2 Classes read.
186 Patterns read.
    1 0000:             ; *******************************************************************
    2 0000:             ; *** This software is copyright 2006 by Michael H Riley          ***
    3 0000:             ; *** You have permission to use, modify, copy, and distribute    ***
    4 0000:             ; *** this software so long as this copyright notice is retained. ***
    5 0000:             ; *** This software may not be used in commercial applications    ***
    6 0000:             ; *** without express written permission from the author.         ***
    7 0000:             ; *******************************************************************
    8 0000:             
    9 0000:             ;[RLA] These are defined on the rcasm command line!
   10 0000:             ;[RLA] #define ELFOS            ; build the version that runs under Elf/OS
   11 0000:             ;[RLA] #define STGROM           ; build the STG EPROM version
   12 0000:             ;[RLA] #define PICOROM          ; define for Mike's PIcoElf version
   13 0000:             
   14 0000:             ;[RLA]   rcasm doesn't have any way to do a logical "OR" of assembly
   15 0000:             ;[RLA} options, so define a master "ANYROM" option that's true for
   16 0000:             ;[RLA} any of the ROM conditions...
   17 0000:             	
   18 0000:             	;; [gnr] Bug fixes, assembler fixes,and the Exec word
   19 0000:             
            #endif
   42 0000:             
            #endif
   65 0000:             
   66 0000:             ; [GDJ] build: asm02 -i -L -DSTGROM forth.asm
            #ifdef STGROM
            #define    ANYROM 1
   69 0000:             	include config.inc
   70 0000:             ; DO NOT EDIT THIS FILE - EDIT CONFIG. INSTEAD!!
            #define BOOTS	 08000H
            #define WARMB	 (08000H+3)
            #define HELP	 09400H
            #define RAMPAGE	 07F00H
            #define BIOS	 0FF00H
            #define EBIOS	 0F800H
            #define FORTH	 09B00H
            #define EDTASM	 0B400H
            #define BASIC	 0D300H
            #define VISUAL	 0C100H
            #define XMODEM	 0ED00H
            #define CODE FORTH  		; [gnr] [GDG] says now bigger than 15 pages
   83 0000:             	; [gnr] The UART is used in inkey so when using bitbang, no inkey!
            #define    UART_SELECT   6             ; UART register select I/O port
            #define    UART_DATA     7             ; UART data I/O port
   86 0000:             
   87 0000:             
   88 0000:             ;[RLA] XMODEM entry vectors for the STG EPROM ...
   89 0000:             xopenw:    equ     XMODEM + 0*3
   90 0000:             xopenr:    equ     XMODEM + 1*3
   91 0000:             xread:     equ     XMODEM + 2*3
   92 0000:             xwrite:    equ     XMODEM + 3*3
   93 0000:             xclosew:   equ     XMODEM + 4*3
   94 0000:             xcloser:   equ     XMODEM + 5*3
   95 0000:             buffer:    equ     0200h
   96 0000:             himem:     equ     300h
   97 0000:             rstack:    equ     302h
   98 0000:             tos:       equ     304h
   99 0000:             freemem:   equ     306h
  100 0000:             fstack:    equ     308h
  101 0000:             jump:      equ     30ah
  102 0000:             storage:   equ     30dh
  103 0000:             basen:     equ     317h
  104 0000:             rseed:     equ     02f0h               ; note this limits size of buffer at 200h to 240 bytes
  105 0000:             stack:     equ     01ffh
  106 0000:             exitaddr:  equ     08003h
            #endif
  108 0000:             
            #endif
  114 0000:             
  115 0000:             include    bios.inc
  116 0000:             ; *******************************************************************
  117 0000:             ; *** This software is copyright 2006 by Michael H Riley          ***
  118 0000:             ; *** You have permission to use, modify, copy, and distribute    ***
  119 0000:             ; *** this software so long as this copyright notice is retained. ***
  120 0000:             ; *** This software may not be used in commercial applications    ***
  121 0000:             ; *** without express written permission from the author.         ***
  122 0000:             ; *******************************************************************
  123 0000:             
            #endif
  127 0000:             
  128 0000:             ; Define address for standard BIOS vectors
            #endif
  132 0000:             
  133 0000:             ; Define address for extended BIOS vectors
            #endif
  137 0000:             
            #ifndef TASM
  139 0000:             scall:      equ  r4                    ; register for SCALL
  140 0000:             sret:       equ  r5                    ; register for SRET
  141 0000:             
  142 0000:             call:       equ  0ffe0h                ; depricated
  143 0000:             ret:        equ  0fff1h                ; depricated
            #endif
  145 0000:             
  146 0000:             f_boot:     equ  (BIOS+00h)            ; boot from ide device
  147 0000:             f_type:     equ  (BIOS+03h)            ; type 1 character to console
  148 0000:             f_read:     equ  (BIOS+06h)            ; read 1 character from console
  149 0000:             f_msg:      equ  (BIOS+09h)            ; type asciiz string to console
  150 0000:             f_typex:    equ  (BIOS+0ch)            ; depricated, just returns now
  151 0000:             f_input:    equ  (BIOS+0fh)            ; read asciiz from console
  152 0000:             f_strcmp:   equ  (BIOS+12h)            ; compare 2 strings
  153 0000:             f_ltrim:    equ  (BIOS+15h)            ; trim leading spaces
  154 0000:             f_strcpy:   equ  (BIOS+18h)            ; copy an asciiz string
  155 0000:             f_memcpy:   equ  (BIOS+1bh)            ; copy memory
  156 0000:             f_wrtsec:   equ  (BIOS+1eh)            ; write floppy sector (depricated)
  157 0000:             f_rdsec:    equ  (BIOS+21h)            ; read floppy sector (depricated)
  158 0000:             f_seek0:    equ  (BIOS+24h)            ; floppy seek to track 0 (depricated)
  159 0000:             f_seek:     equ  (BIOS+27h)            ; floopy track seek (depricated)
  160 0000:             f_drive:    equ  (BIOS+2ah)            ; select floppy drive (depricated)
  161 0000:             f_setbd:    equ  (BIOS+2dh)            ; set console baud rate
  162 0000:             f_mul16:    equ  (BIOS+30h)            ; 16-bit multiply
  163 0000:             f_div16:    equ  (BIOS+33h)            ; 16-bit division
  164 0000:             f_idereset: equ  (BIOS+36h)            ; reset ide device
  165 0000:             f_idewrite: equ  (BIOS+39h)            ; write ide sector
  166 0000:             f_ideread:  equ  (BIOS+3ch)            ; read ide sector
  167 0000:             f_initcall: equ  (BIOS+3fh)            ; initialize R4 and R5
  168 0000:             f_bootide:  equ  (BIOS+42h)            ; boot from ide device
  169 0000:             f_hexin:    equ  (BIOS+45h)            ; convert ascii number to hex
  170 0000:             f_hexout2:  equ  (BIOS+48h)            ; convert hex to 2-digit ascii
  171 0000:             f_hexout4:  equ  (BIOS+4bh)            ; convert hex to 4-digit ascii
  172 0000:             f_tty:      equ  (BIOS+4eh)            ; type character to console
  173 0000:             f_mover:    equ  (BIOS+51h)            ; program relocator
  174 0000:             f_minimon:  equ  (BIOS+54h)            ; mini monitor
  175 0000:             f_freemem:  equ  (BIOS+57h)            ; determine memory size
  176 0000:             F_isnum:    equ  (BIOS+5ah)            ; determine if D is numeric
  177 0000:             f_atoi:     equ  (BIOS+5dh)            ; convert ascii to integer
  178 0000:             f_uintout:  equ  (BIOS+60h)            ; convert unsigned integer to ascii
  179 0000:             f_intout:   equ  (BIOS+63h)            ; convert signed integer to ascii
  180 0000:             f_inmsg:    equ  (BIOS+66h)            ; type in-line message
  181 0000:             f_inputl:   equ  (BIOS+69h)            ; read limited line from console
  182 0000:             f_brktest:  equ  (BIOS+6ch)            ; check for serial break
  183 0000:             f_findtkn:  equ  (BIOS+6fh)            ; find token in a token table
  184 0000:             f_isalpha:  equ  (BIOS+72h)            ; determine if D is alphabetic
  185 0000:             f_ishex:    equ  (BIOS+75h)            ; determine if D is hexadecimal
  186 0000:             f_isalnum:  equ  (BIOS+78h)            ; determine if D is alpha or numeric
  187 0000:             f_idnum:    equ  (BIOS+7bh)            ; determine type of ascii number
  188 0000:             f_isterm:   equ  (BIOS+7eh)            ; determine if D is a termination char
  189 0000:             f_getdev:   equ  (BIOS+81h)            ; get supported devices
  190 0000:             
  191 0000:             f_version:  equ  (BIOS+0f9h)           ; 3 bytes holding bios version number
  192 0000:             
  193 0000:             ; "Extended" BIOS vectors
  194 0000:             
  195 0000:             f_bread     equ  (EBIOS+00h)        ; read from onboard serial port
  196 0000:             f_btype     equ  (EBIOS+03h)        ; write to onboard serial port
  197 0000:             f_btest     equ  (EBIOS+06h)        ; test onboard serial port
  198 0000:             f_utype     equ  (EBIOS+09h)        ; write to disk board UART
  199 0000:             f_uread     equ  (EBIOS+0ch)        ; read from disk board UART
  200 0000:             f_utest     equ  (EBIOS+0fh)        ; test disk board UART
  201 0000:             f_usetbd    equ  (EBIOS+12h)        ; set disk board UART baud rate and format
  202 0000:             f_gettod    equ  (EBIOS+15h)        ; read time of day clock
  203 0000:             f_settod    equ  (EBIOS+18h)        ; set time of day clock
  204 0000:             f_rdnvr     equ  (EBIOS+1bh)        ; read non volatile RAM
  205 0000:             f_wrnvr     equ  (EBIOS+1eh)        ; write non volatile RAM
  206 0000:             f_idesize   equ  (EBIOS+21h)        ; return size of attached IDE drive(s)
  207 0000:             f_ideid     equ  (EBIOS+24h)        ; return device data for IDE drive(s)
  208 0000:             f_tmtoas    equ  (EBIOS+2ah)        ; time to ASCII string
  209 0000:             f_dttoas    equ  (EBIOS+27h)        ; date to ASCII string
  210 0000:             f_rtctest   equ  (EBIOS+2dh)        ; test size and presence of RTC/NVR
  211 0000:             f_astodt    equ  (EBIOS+30h)        ; convert ASCII string to date
  212 0000:             f_astotm    equ  (EBIOS+33h)        ; convert ASCII string to time
  213 0000:             f_nvrcchk   equ  (EBIOS+36h)	    ; [RLA] compute NVR checksum
  214 0000:             
  215 0000:             
  216 0000:             
            #endif
  229 0000:             
  230 0000:             ;  R2   - program stack
  231 0000:             ;  R3   - Main PC
  232 0000:             ;  R4   - standard call
  233 0000:             ;  R5   - standard ret
  234 0000:             ;  R6   - used by Scall/Sret linkage
  235 0000:             ;  R7   - general and command table pointer
  236 0000:             ;  R9   - Data segment
  237 0000:             ;  RB   - general SCRT return usage and token stream pointer
  238 0000:             
  239 0000:             FWHILE:    equ     81h
  240 0000:             FREPEAT:   equ     FWHILE+1
  241 0000:             FIF:       equ     FREPEAT+1
  242 0000:             FELSE:     equ     FIF+1
  243 0000:             FTHEN:     equ     FELSE+1
  244 0000:             FVARIABLE: equ     FTHEN+1
  245 0000:             FCOLON:    equ     FVARIABLE+1
  246 0000:             FSEMI:     equ     FCOLON+1
  247 0000:             FDUP:      equ     FSEMI+1
  248 0000:             FDROP:     equ     FDUP+1
  249 0000:             FSWAP:     equ     FDROP+1
  250 0000:             FPLUS:     equ     FSWAP+1
  251 0000:             FMINUS:    equ     FPLUS+1
  252 0000:             FMUL:      equ     FMINUS+1
  253 0000:             FDIV:      equ     FMUL+1
  254 0000:             FDOT:      equ     FDIV+1              ; 90h
  255 0000:             FUDOT:     equ     FDOT+1
  256 0000:             FI:        equ     FUDOT+1
  257 0000:             FAND:      equ     FI+1
  258 0000:             FOR:       equ     FAND+1
  259 0000:             FXOR:      equ     FOR+1
  260 0000:             FCR:       equ     FXOR+1
  261 0000:             FMEM:      equ     FCR+1
  262 0000:             FDO:       equ     FMEM+1
  263 0000:             FLOOP:     equ     FDO+1
  264 0000:             FPLOOP:    equ     FLOOP+1
  265 0000:             FEQUAL:    equ     FPLOOP+1
  266 0000:             FUNEQUAL:  equ     FEQUAL+1
  267 0000:             FLESS:     equ     FUNEQUAL+1          ; [GDJ]
  268 0000:             FULESS:    equ     FLESS+1             ; [GDJ]
  269 0000:             FBEGIN:    equ     FULESS+1
  270 0000:             FUNTIL:    equ     FBEGIN+1            ; a0h
  271 0000:             FRGT:      equ     FUNTIL+1
  272 0000:             FGTR:      equ     FRGT+1
  273 0000:             FRAT:      equ     FGTR+1              ; [GDJ]
  274 0000:             FWORDS:    equ     FRAT+1
  275 0000:             FEMIT:     equ     FWORDS+1
  276 0000:             FEMITP:    equ     FEMIT+1             ; [GDJ]
  277 0000:             FDEPTH:    equ     FEMITP+1
  278 0000:             FROT:      equ     FDEPTH+1
  279 0000:             FMROT:     equ     FROT+1
  280 0000:             FOVER:     equ     FMROT+1
  281 0000:             FAT:       equ     FOVER+1
  282 0000:             FEXCL:     equ     FAT+1
  283 0000:             FCAT:      equ     FEXCL+1
  284 0000:             FCEXCL:    equ     FCAT+1
  285 0000:             FCMOVE:    equ     FCEXCL+1            ; [GDJ]
  286 0000:             FDOTQT:    equ     FCMOVE+1            ; b0h
  287 0000:             FKEY:      equ     FDOTQT+1
  288 0000:             FKEYQ:     equ     FKEY+1              ; [GDJ]
  289 0000:             FALLOT:    equ     FKEYQ+1
  290 0000:             FERROR:    equ     FALLOT+1
  291 0000:             FSEE:      equ     FERROR+1
  292 0000:             FFORGET:   equ     FSEE+1
  293 0000:             FEXEC:	   equ     FFORGET+1
  294 0000:             FLIST:	   equ     FEXEC+1
  295 0000:             
  296 0000:             T_NUM:     equ     255
  297 0000:             T_ASCII:   equ     254
  298 0000:             
  299 0000:                        org     CODE
  300 9b00:             
            #endif
  307 9b00:             
            #ifdef     ANYROM
  309 9b00: c0 9b 12               lbr     new
  310 9b03:             notnew:	
  311 9b03: f8 ff a2 f8 
            01 b2                  mov     r2,stack
  312 9b09: f8 bd a6 f8 
            9b b6                  mov     r6,old
  313 9b0f: c0 ff 3f               lbr     f_initcall
  314 9b12: f8 ff a2 f8 
            01 b2       new:       mov     r2,stack
  315 9b18: f8 21 a6 f8 
            9b b6                  mov     r6,start
  316 9b1e: c0 ff 3f               lbr     f_initcall
            #endif
  318 9b21:             
  319 9b21: f8 03       start:     ldi     high himem          ; get page of data segment
  320 9b23: b9                     phi     r9                  ; place into r9
            #ifdef ANYROM
  322 9b24: f8 0c                  ldi     0ch                 ; form feed
  323 9b26: d4                     sep     scall               ; clear screen
            #else
  327 9b27: ff 03                  dw      f_type
            #endif
            #endif
  330 9b29: f8 ac                  ldi     high hello          ; address of signon message
  331 9b2b: bf                     phi     rf                  ; place into r6
  332 9b2c: f8 ff                  ldi     low hello
  333 9b2e: af                     plo     rf
  334 9b2f: d4                     sep     scall               ; call bios to display message
            #else
  338 9b30: ff 09                  dw      f_msg               ; function to display a message
            #endif
  340 9b32:             
  341 9b32:             ; ************************************************
  342 9b32:             ; **** Determine how much memory is installed ****
  343 9b32:             ; ************************************************
            #else
  351 9b32: d4                     sep     scall               ; ask BIOS for memory size
  352 9b33: ff 57                  dw      f_freemem
  353 9b35: 8f ab 9f bb            mov     rb,rf
            #endif
  355 9b39:             
  356 9b39: f8 06                  ldi     low freemem         ; free memory pointer
  357 9b3b: a9                     plo     r9                  ; place into data pointer
  358 9b3c: f8 03                  ldi     storage.1
  359 9b3e: 59                     str     r9
  360 9b3f: 19                     inc     r9
  361 9b40: f8 0d                  ldi     storage.0
  362 9b42: 59                     str     r9
  363 9b43:             
  364 9b43:             ;memlp:     ldi     0                   ; get a zero
  365 9b43:             ;           str     rb                  ; write to memory
  366 9b43:             ;           ldn     rb                  ; recover retrieved byte
  367 9b43:             ;           bnz     memdone             ; jump if not same
  368 9b43:             ;           ldi     255                 ; another value
  369 9b43:             ;           str     rb                  ; write to memory
  370 9b43:             ;           ldn     rb                  ; retrieve it
  371 9b43:             ;           smi     255                 ; compare against written
  372 9b43:             ;           bnz     memdone             ; jump if not same
  373 9b43:             ;           ghi     rb
  374 9b43:             ;           adi     1                   ; point to next page
  375 9b43:             ;           phi     rb                  ; and put it back
  376 9b43:             ;           smi     7fh                 ; prevent from going over 7f00h
  377 9b43:             ;           bnz     memlp
  378 9b43: f8 00       memdone:   ldi     low himem           ; memory pointer
  379 9b45: a9                     plo     r9                  ; place into r9
  380 9b46: 9b                     ghi     rb                  ; get high of last memory
  381 9b47: 59                     str     r9                  ; write to data
  382 9b48: b2                     phi     r2                  ; and to machine stack
  383 9b49: 19                     inc     r9                  ; point to low byte
  384 9b4a: 8b                     glo     rb                  ; get low of himem
  385 9b4b: 59                     str     r9                  ; and store
  386 9b4c: a2                     plo     r2
  387 9b4d: f8 02                  ldi     low rstack          ; get return stack address
  388 9b4f: a9                     plo     r9                  ; select in data segment
  389 9b50: 9b                     ghi     rb                  ; get hi memory
  390 9b51: ff 01                  smi     1                   ; 1 page lower for forth stack
  391 9b53: 59                     str     r9                  ; write to pointer
  392 9b54: 19                     inc     r9                  ; point to low byte
  393 9b55: 8b                     glo     rb                  ; get low byte
  394 9b56: 59                     str     r9                  ; and store
  395 9b57: f8 04                  ldi     low tos             ; get stack address
  396 9b59: a9                     plo     r9                  ; select in data segment
  397 9b5a: 9b                     ghi     rb                  ; get hi memory
  398 9b5b: ff 02                  smi     2                   ; 2 page lower for forth stack
  399 9b5d: 59                     str     r9                  ; write to pointer
  400 9b5e: 19                     inc     r9                  ; point to low byte
  401 9b5f: 8b                     glo     rb                  ; get low byte
  402 9b60: 59                     str     r9                  ; and store
  403 9b61: f8 08                  ldi     low fstack          ; get stack address
  404 9b63: a9                     plo     r9                  ; select in data segment
  405 9b64: 9b                     ghi     rb                  ; get hi memory
  406 9b65: ff 02                  smi     2                   ; 2 page lower for forth stack
  407 9b67: 59                     str     r9                  ; write to pointer
  408 9b68: 19                     inc     r9                  ; point to low byte
  409 9b69: 8b                     glo     rb                  ; get low byte
  410 9b6a: 59                     str     r9                  ; and store
  411 9b6b: f8 03                  ldi     high storage        ; point to storage
  412 9b6d: bf                     phi     rf
  413 9b6e: f8 0d                  ldi     low storage
  414 9b70: af                     plo     rf
  415 9b71: f8 00                  ldi     0
  416 9b73: 5f                     str     rf                  ; write zeroes as storage terminator
  417 9b74: 1f                     inc     rf
  418 9b75: 5f                     str     rf
  419 9b76: 1f                     inc     rf
  420 9b77: 5f                     str     rf
  421 9b78: 1f                     inc     rf
  422 9b79: 5f                     str     rf
  423 9b7a: 1f                     inc     rf
  424 9b7b:             
  425 9b7b:                        ; [GDJ] create and initialize BASE variable
  426 9b7b: f8 1a a7 f8 
            00 b7                  mov     r7, 26
  427 9b81: f8 a0 ac f8 
            ae bc                  mov     rc, basev
  428 9b87: f8 06 ad f8 
            03 bd                  mov     rd, freemem
  429 9b8d: 4c          nextbase:  lda     rc
  430 9b8e: 5d                     str     rd
  431 9b8f: 1d                     inc     rd
  432 9b90: 27                     dec     r7
  433 9b91: 87                     glo     r7
  434 9b92: ca 9b 8d               lbnz    nextbase
  435 9b95:             
            #ifdef STGROM
  437 9b95: d4 ac 7a               call    clrstacks           ; [GDJ]
            #endif
  439 9b98:             
  440 9b98:                        ; init 32 bit rng seed
  441 9b98: f8 a6 a7 f8 
            12 b7                  mov     r7, 012A6h
  442 9b9e: f8 f0 af f8 
            02 bf                  mov     rf, rseed
  443 9ba4: 97                     ghi     r7
  444 9ba5: 5f                     str     rf
  445 9ba6: 87                     glo     r7
  446 9ba7: 1f                     inc     rf
  447 9ba8: 5f                     str     rf
  448 9ba9:                        
  449 9ba9: f8 40 a7 f8 
            dc b7                  mov     r7, 0DC40h
  450 9baf: f8 f2 af f8 
            02 bf                  mov     rf, rseed+2
  451 9bb5: 97                     ghi     r7
  452 9bb6: 5f                     str     rf
  453 9bb7: 87                     glo     r7
  454 9bb8: 1f                     inc     rf
  455 9bb9: 5f                     str     rf
  456 9bba:             
  457 9bba:             
  458 9bba: c0 9b e7               lbr     mainlp
  459 9bbd:             
  460 9bbd: f8 03       old: 	   ldi     high himem	; [gnr] fix up r9 since this might be entry point
  461 9bbf: b9          	   phi     r9
  462 9bc0: f8 00       	   ldi     low himem           ; memory pointer
  463 9bc2: a9                     plo     r9                  ; place into r9
  464 9bc3: 49                     lda     r9                  ; retreive high memory
  465 9bc4: bb                     phi     rb
  466 9bc5: b2                     phi     r2                  ; and to machine stack
  467 9bc6: 49                     lda     r9
  468 9bc7: ab                     plo     rb
  469 9bc8: a2                     plo     r2
  470 9bc9: f8 02                  ldi     low rstack          ; get return stack address
  471 9bcb: a9                     plo     r9                  ; select in data segment
  472 9bcc: 9b                     ghi     rb                  ; get hi memory
  473 9bcd: ff 01                  smi     1                   ; 1 page lower for forth stack
  474 9bcf: 59                     str     r9                  ; write to pointer
  475 9bd0: 19                     inc     r9                  ; point to low byte
  476 9bd1: 8b                     glo     rb                  ; get low byte
  477 9bd2: 59                     str     r9                  ; and store
  478 9bd3: f8 04                  ldi     low tos             ; get stack address
  479 9bd5: a9                     plo     r9                  ; select in data segment
  480 9bd6: 9b                     ghi     rb                  ; get hi memory
  481 9bd7: ff 02                  smi     2                   ; 2 page lower for forth stack
  482 9bd9: 59                     str     r9                  ; write to pointer
  483 9bda: 19                     inc     r9                  ; point to low byte
  484 9bdb: 8b                     glo     rb                  ; get low byte
  485 9bdc: 59                     str     r9                  ; and store
  486 9bdd: f8 08                  ldi     low fstack          ; get stack address
  487 9bdf: a9                     plo     r9                  ; select in data segment
  488 9be0: 9b                     ghi     rb                  ; get hi memory
  489 9be1: ff 02                  smi     2                   ; 2 page lower for forth stack
  490 9be3: 59                     str     r9                  ; write to pointer
  491 9be4: 19                     inc     r9                  ; point to low byte
  492 9be5: 8b                     glo     rb                  ; get low byte
  493 9be6: 59                     str     r9                  ; and store
  494 9be7:             
  495 9be7:             ; *************************
  496 9be7:             ; *** Main program loop ***
  497 9be7:             ; *************************
  498 9be7: f8 ad       mainlp:    ldi     high prompt         ; address of prompt
  499 9be9: bf                     phi     rf                  ; place into r6
  500 9bea: f8 0e                  ldi     low prompt
  501 9bec: af                     plo     rf
  502 9bed: d4                     sep     scall               ; display prompt
            #else
  506 9bee: ff 09                  dw      f_msg               ; function to display a message
            #endif
  508 9bf0: f8 02                  ldi     high buffer         ; point to input buffer
  509 9bf2: bf                     phi     rf
  510 9bf3: f8 00                  ldi     low buffer
  511 9bf5: af                     plo     rf
  512 9bf6: d4                     sep     scall               ; read a line
            #else
  516 9bf7: ff 0f                  dw      f_input             ; function to read a line
            #endif
  518 9bf9:             
  519 9bf9: d4          	   sep     scall
  520 9bfa: 9c 17       	   dw      crlfout
  521 9bfc: f8 00 af f8 
            02 bf                  mov     rf,buffer           ; convert to uppercase
  522 9c02: d4                     sep     scall
  523 9c03: ab a4                  dw      touc
  524 9c05: d4                     sep     scall               ; call tokenizer
  525 9c06: 9d c0                  dw      tknizer
  526 9c08:             
  527 9c08: f8 06                  ldi     low freemem         ; get free memory pointer
  528 9c0a: a9                     plo     r9                  ; place into data segment
  529 9c0b: 49                     lda     r9                  ; get free memory pointer
  530 9c0c: bb                     phi     rb                  ; place into rF
  531 9c0d: 09                     ldn     r9
  532 9c0e: ab                     plo     rb
  533 9c0f: 1b                     inc     rb
  534 9c10: 1b                     inc     rb
  535 9c11: d4                     sep     scall
  536 9c12: 9f 76                  dw      exec
  537 9c14:             
  538 9c14: c0 9b e7               lbr     mainlp              ; return to beginning of main loop
  539 9c17:             
  540 9c17:             crlfout:	
  541 9c17: 8f 73 9f 73 	   push rf
  542 9c1b: f8 ad                  ldi     high crlf           ; address of CR/LF
  543 9c1d: bf                     phi     rf                  ; place into r6
  544 9c1e: f8 0b                  ldi     low crlf  
  545 9c20: af                     plo     rf
  546 9c21: d4                     sep     scall               ; call bios
            #else
  550 9c22: ff 09                  dw      f_msg               ; function to display a message
            #endif
  552 9c24: 60 72 bf f0 
            af          	  pop rf
  553 9c29: d5          	   sep sret
  554 9c2a:             
  555 9c2a:             ; **************************************
  556 9c2a:             ; *** Display a character, char in D ***
  557 9c2a:             ; **************************************
  558 9c2a: d4          disp:      sep     scall               ; call bios
            #else
  562 9c2b: ff 03                  dw      f_type              ; function to type a charactr
            #endif
  564 9c2d: d5                     sep     sret                ; return to caller
  565 9c2e:             
  566 9c2e:             ; ********************************
  567 9c2e:             ; *** Read a key, returns in D ***
  568 9c2e:             ; ********************************
  569 9c2e: d4          getkey:    sep     scall               ; call bios
            #else
  573 9c2f: ff 06                  dw      f_read              ; function to read a key
            #endif
  575 9c31: d5                     sep     sret                ; return to caller
  576 9c32:             
  577 9c32:             ; ***************************************************
  578 9c32:             ; *** Function to retrieve value from forth stack ***
  579 9c32:             ; *** Returns R[B] = value                        ***
  580 9c32:             ; ***         DF=0 no error, DF=1 error           ***
  581 9c32:             ; ***************************************************
  582 9c32: e2          pop:       sex     r2                  ; be sure x points to stack
  583 9c33: f8 08                  ldi     low fstack          ; get stack address
  584 9c35: a9                     plo     r9                  ; select in data segment
  585 9c36: 49                     lda     r9
  586 9c37: ba                     phi     ra
  587 9c38: 09                     ldn     r9
  588 9c39: aa                     plo     ra
  589 9c3a: f8 04                  ldi     low tos             ; pointer to maximum stack value
  590 9c3c: a9                     plo     r9                  ; put into data frame
  591 9c3d: 49                     lda     r9                  ; get high value
  592 9c3e: 52                     str     r2                  ; place into memory
  593 9c3f: 9a                     ghi     ra                  ; get high byte of forth stack
  594 9c40: f7                     sm                          ; check if same
  595 9c41: ca 9c 4f               lbnz    stackok             ; jump if ok
  596 9c44: 09                     ldn     r9                  ; get low byte of tos
  597 9c45: 52                     str     r2
  598 9c46: 8a                     glo     ra                  ; check low byte of stack pointer
  599 9c47: f7                     sm
  600 9c48: ca 9c 4f               lbnz    stackok             ; jump if ok
  601 9c4b: f8 01                  ldi     1                   ; signal error
  602 9c4d: f6          popret:    shr                         ; shift status into DF
  603 9c4e: d5                     sep     sret                ; return to caller
  604 9c4f: 1a          stackok:   inc     ra                  ; point to high byte
  605 9c50: 4a                     lda     ra                  ; get it
  606 9c51: bb                     phi     rb                  ; put into r6
  607 9c52: 0a                     ldn     ra                  ; get low byte
  608 9c53: ab                     plo     rb
  609 9c54: f8 08                  ldi     low fstack          ; get stack address
  610 9c56: a9                     plo     r9                  ; select in data segment
  611 9c57: 9a                     ghi     ra                  ; get hi memory
  612 9c58: 59                     str     r9                  ; write to pointer
  613 9c59: 19                     inc     r9                  ; point to low byte
  614 9c5a: 8a                     glo     ra                  ; get low byte
  615 9c5b: 59                     str     r9                  ; and store
  616 9c5c: f8 00                  ldi     0                   ; signal no error
  617 9c5e: c0 9c 4d               lbr     popret              ; and return to caller
  618 9c61:             
  619 9c61:             ; ********************************************************
  620 9c61:             ; *** Function to push value onto stack, value in R[B] ***
  621 9c61:             ; ********************************************************
  622 9c61: f8 08       push:      ldi     low fstack          ; get stack address
  623 9c63: a9                     plo     r9                  ; select in data segment
  624 9c64: 49                     lda     r9
  625 9c65: ba                     phi     ra
  626 9c66: 09                     ldn     r9
  627 9c67: aa                     plo     ra
  628 9c68: 8b                     glo     rb                  ; get low byte of value
  629 9c69: 5a                     str     ra                  ; store on forth stack
  630 9c6a: 2a                     dec     ra                  ; point to next byte
  631 9c6b: 9b                     ghi     rb                  ; get high value
  632 9c6c: 5a                     str     ra                  ; store on forth stack
  633 9c6d: 2a                     dec     ra                  ; point to next byte
  634 9c6e: f8 08                  ldi     low fstack          ; get stack address
  635 9c70: a9                     plo     r9                  ; select in data segment
  636 9c71: 9a                     ghi     ra                  ; get hi memory
  637 9c72: 59                     str     r9                  ; write to pointer
  638 9c73: 19                     inc     r9                  ; point to low byte
  639 9c74: 8a                     glo     ra                  ; get low byte
  640 9c75: 59                     str     r9                  ; and store
  641 9c76: d5                     sep     sret                ; return to caller
  642 9c77:             
  643 9c77:             ; ****************************************************
  644 9c77:             ; *** Function to retrieve value from return stack ***
  645 9c77:             ; *** Returns R[B] = value                         ***
  646 9c77:             ; ***         D=0 no error, D=1 error              ***
  647 9c77:             ; ****************************************************
  648 9c77: e2          rpop:      sex     r2                  ; be sure x points to stack
  649 9c78: f8 02                  ldi     low rstack          ; get stack address
  650 9c7a: a9                     plo     r9                  ; select in data segment
  651 9c7b: 49                     lda     r9
  652 9c7c: ba                     phi     ra
  653 9c7d: 09                     ldn     r9
  654 9c7e: aa                     plo     ra
  655 9c7f: 1a                     inc     ra                  ; point to high byte
  656 9c80: 4a                     lda     ra                  ; get it
  657 9c81: bb                     phi     rb                  ; put into r6
  658 9c82: 0a                     ldn     ra                  ; get low byte
  659 9c83: ab                     plo     rb
  660 9c84: f8 02                  ldi     low rstack          ; get stack address
  661 9c86: a9                     plo     r9                  ; select in data segment
  662 9c87: 9a                     ghi     ra                  ; get hi memory
  663 9c88: 59                     str     r9                  ; write to pointer
  664 9c89: 19                     inc     r9                  ; point to low byte
  665 9c8a: 8a                     glo     ra                  ; get low byte
  666 9c8b: 59                     str     r9                  ; and store
  667 9c8c: f8 00                  ldi     0                   ; signal no error
  668 9c8e: d5                     sep     sret                ; and return
  669 9c8f:             
  670 9c8f:             ; ***************************************************************
  671 9c8f:             ; *** Function to push value onto return stack, value in R[B] ***
  672 9c8f:             ; ***************************************************************
  673 9c8f: f8 02       rpush:     ldi     low rstack          ; get stack address
  674 9c91: a9                     plo     r9                  ; select in data segment
  675 9c92: 49                     lda     r9
  676 9c93: ba                     phi     ra
  677 9c94: 09                     ldn     r9
  678 9c95: aa                     plo     ra
  679 9c96: 8b                     glo     rb                  ; get low byte of value
  680 9c97: 5a                     str     ra                  ; store on forth stack
  681 9c98: 2a                     dec     ra                  ; point to next byte
  682 9c99: 9b                     ghi     rb                  ; get high value
  683 9c9a: 5a                     str     ra                  ; store on forth stack
  684 9c9b: 2a                     dec     ra                  ; point to next byte
  685 9c9c: f8 02                  ldi     low rstack          ; get stack address
  686 9c9e: a9                     plo     r9                  ; select in data segment
  687 9c9f: 9a                     ghi     ra                  ; get hi memory
  688 9ca0: 59                     str     r9                  ; write to pointer
  689 9ca1: 19                     inc     r9                  ; point to low byte
  690 9ca2: 8a                     glo     ra                  ; get low byte
  691 9ca3: 59                     str     r9                  ; and store
  692 9ca4: d5                     sep     sret                ; return to caller
  693 9ca5:             
  694 9ca5:             ;           org     200h 
  695 9ca5:             ; ********************************************
  696 9ca5:             ; *** Function to find stored name address ***
  697 9ca5:             ; ***  Needs: name to search in R[8]       ***
  698 9ca5:             ; ***  returns: R[B] first byte in data    ***
  699 9ca5:             ; ***           R[7] Address of descriptor ***
  700 9ca5:             ; ***           R[8] first addr after name ***
  701 9ca5:             ; ***           DF = 1 if not found        ***
  702 9ca5:             ; ********************************************
  703 9ca5: f8 03       findname:  ldi     high storage        ; get address of stored data
  704 9ca7: bb                     phi     rb                  ; put into r6
  705 9ca8: f8 0d                  ldi     low storage
  706 9caa: ab                     plo     rb
  707 9cab: e2                     sex     r2                  ; make sure X points to stack
  708 9cac: 9b          findlp:    ghi     rb                  ; copy address
  709 9cad: b7                     phi     r7
  710 9cae: 8b                     glo     rb
  711 9caf: a7                     plo     r7
  712 9cb0: 4b                     lda     rb                  ; get link address
  713 9cb1: ca 9c bc               lbnz    findgo              ; jump if nonzero
  714 9cb4: 0b                     ldn     rb                  ; get low byte
  715 9cb5: ca 9c bc               lbnz    findgo              ; jump if non zero
  716 9cb8: f8 01                  ldi     1                   ; not found
  717 9cba: f6          findret:   shr                         ; set DF
  718 9cbb: d5                     sep     sret                ; and return to caller
  719 9cbc: 1b          findgo:    inc     rb                  ; pointing now at type
  720 9cbd: 1b                     inc     rb                  ; pointing at ascii indicator
  721 9cbe: 1b                     inc     rb                  ; first byte of name
  722 9cbf: 88                     glo     r8                  ; save requested name
  723 9cc0: 73                     stxd
  724 9cc1: 98                     ghi     r8
  725 9cc2: 73                     stxd
  726 9cc3: 08          findchk:   ldn     r8                  ; get byte from requested name
  727 9cc4: 52                     str     r2                  ; place into memory
  728 9cc5: 0b                     ldn     rb                  ; get byte from descriptor
  729 9cc6: f7                     sm                          ; compare equality
  730 9cc7: ca 9c dc               lbnz    findnext            ; jump if not found
  731 9cca: 08                     ldn     r8                  ; get byte
  732 9ccb: c2 9c d3               lbz     findfound           ; entry is found
  733 9cce: 18                     inc     r8                  ; increment positions
  734 9ccf: 1b                     inc     rb
  735 9cd0: c0 9c c3               lbr     findchk             ; and keep looking
  736 9cd3: 1b          findfound: inc     rb                  ; r6 now points to data
  737 9cd4: 60                     irx                         ; remove r8 from stack
  738 9cd5: 60                     irx
  739 9cd6: 18                     inc     r8                  ; move past terminator in name
  740 9cd7: f8 00                  ldi     0                   ; signal success
  741 9cd9: c0 9c ba               lbr     findret             ; and return to caller
  742 9cdc: 60          findnext:  irx                         ; recover start of requested name
  743 9cdd: 72                     ldxa
  744 9cde: b8                     phi     r8
  745 9cdf: f0                     ldx
  746 9ce0: a8                     plo     r8
  747 9ce1: 47                     lda     r7                  ; get next link address
  748 9ce2: bb                     phi     rb
  749 9ce3: 07                     ldn     r7
  750 9ce4: ab                     plo     rb
  751 9ce5: c0 9c ac               lbr     findlp              ; and check next entry
  752 9ce8:             
  753 9ce8:             ; *********************************************
  754 9ce8:             ; *** Function to multiply 2 16 bit numbers ***
  755 9ce8:             ; *********************************************
  756 9ce8: f8 00       mul16:     ldi     0                   ; zero out total
  757 9cea: b8                     phi     r8
  758 9ceb: a8                     plo     r8
  759 9cec: bc                     phi     rc
  760 9ced: ac                     plo     rc
  761 9cee: e2                     sex     r2                  ; make sure X points to stack
  762 9cef: 87          mulloop:   glo     r7                  ; get low of multiplier
  763 9cf0: ca 9c fc               lbnz    mulcont             ; continue multiplying if nonzero
  764 9cf3: 97                     ghi     r7                  ; check hi byte as well
  765 9cf4: ca 9c fc               lbnz    mulcont
  766 9cf7: 98                     ghi     r8                  ; transfer answer
  767 9cf8: bb                     phi     rb
  768 9cf9: 88                     glo     r8
  769 9cfa: ab                     plo     rb
  770 9cfb: d5                     sep     sret                ; return to caller
  771 9cfc: 97          mulcont:   ghi     r7                  ; shift multiplier
  772 9cfd: f6                     shr
  773 9cfe: b7                     phi     r7
  774 9cff: 87                     glo     r7
  775 9d00: 76                     shrc
  776 9d01: a7                     plo     r7
  777 9d02: cb 9d 17               lbnf    mulcont2            ; loop if no addition needed
  778 9d05: 8b                     glo     rb                  ; add 6 to 8
  779 9d06: 52                     str     r2
  780 9d07: 88                     glo     r8
  781 9d08: f4                     add
  782 9d09: a8                     plo     r8
  783 9d0a: 9b                     ghi     rb
  784 9d0b: 52                     str     r2
  785 9d0c: 98                     ghi     r8
  786 9d0d: 74                     adc
  787 9d0e: b8                     phi     r8
  788 9d0f: 8c                     glo     rc                  ; carry into high word
  789 9d10: 7c 00                  adci    0
  790 9d12: ac                     plo     rc
  791 9d13: 9c                     ghi     rc
  792 9d14: 7c 00                  adci    0
  793 9d16: bc                     phi     rc
  794 9d17: 8b          mulcont2:  glo     rb                  ; shift first number
  795 9d18: fe                     shl
  796 9d19: ab                     plo     rb
  797 9d1a: 9b                     ghi     rb
  798 9d1b: 7e                     shlc
  799 9d1c: bb                     phi     rb
  800 9d1d: c0 9c ef               lbr     mulloop             ; loop until done
  801 9d20:             
  802 9d20:             ; ************************************
  803 9d20:             ; *** make both arguments positive ***
  804 9d20:             ; *** Arg1 RB                      ***
  805 9d20:             ; *** Arg2 R7                      ***
  806 9d20:             ; *** Returns D=0 - signs same     ***
  807 9d20:             ; ***         D=1 - signs difer    ***
  808 9d20:             ; ************************************
  809 9d20: 9b          mdnorm:    ghi     rb                  ; get high byte if divisor
  810 9d21: 52                     str     r2                  ; store for sign check
  811 9d22: 97                     ghi     r7                  ; get high byte of dividend
  812 9d23: f3                     xor                         ; compare
  813 9d24: fe                     shl                         ; shift into df
  814 9d25: f8 00                  ldi     0                   ; convert to 0 or 1
  815 9d27: 7e                     shlc                        ; shift into D
  816 9d28: ae                     plo     re                  ; store into sign flag
  817 9d29: 9b                     ghi     rb                  ; need to see if RB is negative
  818 9d2a: fe                     shl                         ; shift high byte to df
  819 9d2b: cb 9d 37               lbnf    mdnorm2             ; jump if not
  820 9d2e: 9b                     ghi     rb                  ; 2s compliment on RB
  821 9d2f: fb ff                  xri     0ffh
  822 9d31: bb                     phi     rb
  823 9d32: 8b                     glo     rb
  824 9d33: fb ff                  xri     0ffh
  825 9d35: ab                     plo     rb
  826 9d36: 1b                     inc     rb
  827 9d37: 97          mdnorm2:   ghi     r7                  ; now check r7 for negative
  828 9d38: fe                     shl                         ; shift sign bit into df
  829 9d39: cb 9d 45               lbnf    mdnorm3             ; jump if not
  830 9d3c: 97                     ghi     r7                  ; 2 compliment on R7
  831 9d3d: fb ff                  xri     0ffh
  832 9d3f: b7                     phi     r7
  833 9d40: 87                     glo     r7
  834 9d41: fb ff                  xri     0ffh
  835 9d43: a7                     plo     r7
  836 9d44: 17                     inc     r7
  837 9d45: 8e          mdnorm3:   glo     re                  ; recover sign flag
  838 9d46: d5                     sep     sret                ; and return to caller
  839 9d47:                         
  840 9d47:                        
  841 9d47:             
  842 9d47:             ; *** RC = RB/R7 
  843 9d47:             ; *** RB = remainder
  844 9d47:             ; *** uses R8 and R9
  845 9d47: d4          div16:     sep     scall               ; normalize numbers
  846 9d48: 9d 20                  dw      mdnorm
  847 9d4a: ae                     plo     re                  ; save sign comparison
  848 9d4b: f8 00                  ldi     0                   ; clear answer 
  849 9d4d: bc                     phi     rc
  850 9d4e: ac                     plo     rc
  851 9d4f: b8                     phi     r8                  ; set additive
  852 9d50: a8                     plo     r8
  853 9d51: 18                     inc     r8
  854 9d52: 87                     glo     r7                  ; check for divide by 0
  855 9d53: ca 9d 5f               lbnz    d16lp1
  856 9d56: 97                     ghi     r7
  857 9d57: ca 9d 5f               lbnz    d16lp1
  858 9d5a: f8 ff                  ldi     0ffh                ; return 0ffffh as div/0 error
  859 9d5c: bc                     phi     rc
  860 9d5d: ac                     plo     rc
  861 9d5e: d5                     sep     sret                ; return to caller
  862 9d5f: 97          d16lp1:    ghi     r7                  ; get high byte from r7
  863 9d60: fa 80                  ani     128                 ; check high bit 
  864 9d62: ca 9d 74               lbnz    divst               ; jump if set
  865 9d65: 87                     glo     r7                  ; lo byte of divisor
  866 9d66: fe                     shl                         ; multiply by 2
  867 9d67: a7                     plo     r7                  ; and put back
  868 9d68: 97                     ghi     r7                  ; get high byte of divisor
  869 9d69: 7e                     shlc                        ; continue multiply by 2
  870 9d6a: b7                     phi     r7                  ; and put back
  871 9d6b: 88                     glo     r8                  ; multiply additive by 2
  872 9d6c: fe                     shl     
  873 9d6d: a8                     plo     r8
  874 9d6e: 98                     ghi     r8
  875 9d6f: 7e                     shlc
  876 9d70: b8                     phi     r8
  877 9d71: c0 9d 5f               lbr     d16lp1              ; loop until high bit set in divisor
  878 9d74: 87          divst:     glo     r7                  ; get low of divisor
  879 9d75: ca 9d 8b               lbnz    divgo               ; jump if still nonzero
  880 9d78: 97                     ghi     r7                  ; check hi byte too
  881 9d79: ca 9d 8b               lbnz    divgo
  882 9d7c: 8e                     glo     re                  ; get sign flag
  883 9d7d: f6                     shr                         ; move to df
  884 9d7e: cb 9d 8a               lbnf    divret              ; jump if signs were the same
  885 9d81: 9c                     ghi     rc                  ; perform 2s compliment on answer
  886 9d82: fb ff                  xri     0ffh
  887 9d84: bc                     phi     rc
  888 9d85: 8c                     glo     rc
  889 9d86: fb ff                  xri     0ffh
  890 9d88: ac                     plo     rc
  891 9d89: 1c                     inc     rc
  892 9d8a: d5          divret:    sep     sret                ; jump if done
  893 9d8b: 9b          divgo:     ghi     rb                  ; copy dividend
  894 9d8c: b9                     phi     r9
  895 9d8d: 8b                     glo     rb
  896 9d8e: a9                     plo     r9
  897 9d8f: 87                     glo     r7                  ; get lo of divisor
  898 9d90: 73                     stxd                        ; place into memory
  899 9d91: 60                     irx                         ; point to memory
  900 9d92: 8b                     glo     rb                  ; get low byte of dividend
  901 9d93: f7                     sm                          ; subtract
  902 9d94: ab                     plo     rb                  ; put back into r6
  903 9d95: 97                     ghi     r7                  ; get hi of divisor
  904 9d96: 73                     stxd                        ; place into memory
  905 9d97: 60                     irx                         ; point to byte
  906 9d98: 9b                     ghi     rb                  ; get hi of dividend
  907 9d99: 77                     smb                         ; subtract
  908 9d9a: bb                     phi     rb                  ; and put back
  909 9d9b: c3 9d a5               lbdf    divyes              ; branch if no borrow happened
  910 9d9e: 99                     ghi     r9                  ; recover copy
  911 9d9f: bb                     phi     rb                  ; put back into dividend
  912 9da0: 89                     glo     r9
  913 9da1: ab                     plo     rb
  914 9da2: c0 9d b1               lbr     divno               ; jump to next iteration
  915 9da5: 88          divyes:    glo     r8                  ; get lo of additive
  916 9da6: 73                     stxd                        ; place in memory
  917 9da7: 60                     irx                         ; point to byte
  918 9da8: 8c                     glo     rc                  ; get lo of answer
  919 9da9: f4                     add                         ; and add
  920 9daa: ac                     plo     rc                  ; put back
  921 9dab: 98                     ghi     r8                  ; get hi of additive
  922 9dac: 73                     stxd                        ; place into memory
  923 9dad: 60                     irx                         ; point to byte
  924 9dae: 9c                     ghi     rc                  ; get hi byte of answer
  925 9daf: 74                     adc                         ; and continue addition
  926 9db0: bc                     phi     rc                  ; put back
  927 9db1: 97          divno:     ghi     r7                  ; get hi of divisor
  928 9db2: f6                     shr                         ; divide by 2
  929 9db3: b7                     phi     r7                  ; put back
  930 9db4: 87                     glo     r7                  ; get lo of divisor
  931 9db5: 76                     shrc                        ; continue divide by 2
  932 9db6: a7                     plo     r7
  933 9db7: 98                     ghi     r8                  ; get hi of divisor
  934 9db8: f6                     shr                         ; divide by 2
  935 9db9: b8                     phi     r8                  ; put back
  936 9dba: 88                     glo     r8                  ; get lo of divisor
  937 9dbb: 76                     shrc                        ; continue divide by 2
  938 9dbc: a8                     plo     r8
  939 9dbd: c0 9d 74               lbr     divst               ; next iteration
  940 9dc0:             
  941 9dc0:             ;           org     300h
  942 9dc0:             ; ***************************
  943 9dc0:             ; *** Setup for tokenizer ***
  944 9dc0:             ; ***************************
  945 9dc0: f8 02       tknizer:   ldi     high buffer         ; point to input buffer
  946 9dc2: bb                     phi     rb
  947 9dc3: f8 00                  ldi     low buffer
  948 9dc5: ab                     plo     rb
  949 9dc6: f8 06                  ldi     low freemem         ; get free memory pointer
  950 9dc8: a9                     plo     r9                  ; place into data segment
  951 9dc9: 49                     lda     r9                  ; get free memory pointer
  952 9dca: bf                     phi     rf                  ; place into rF
  953 9dcb: 09                     ldn     r9
  954 9dcc: af                     plo     rf
  955 9dcd: 1f                     inc     rf
  956 9dce: 1f                     inc     rf
  957 9dcf: e2                     sex     r2                  ; make sure x is pointing to stack
  958 9dd0:             
  959 9dd0:             ; ******************************
  960 9dd0:             ; *** Now the tokenizer loop ***
  961 9dd0:             ; ******************************
  962 9dd0: 0b          tokenlp:   ldn     rb                  ; get byte from buffer
  963 9dd1: c2 9f 72               lbz     tokendn             ; jump if found terminator
  964 9dd4: ff 21                  smi     (' '+1)             ; check for whitespace
  965 9dd6: c3 9d dd               lbdf    nonwhite            ; jump if not whitespace
  966 9dd9: 1b                     inc     rb                  ; move past white space
  967 9dda: c0 9d d0               lbr     tokenlp             ; and keep looking
  968 9ddd:             
  969 9ddd:             ; ********************************************
  970 9ddd:             ; *** Prepare to check against token table ***
  971 9ddd:             ; ********************************************
  972 9ddd: f8 ad       nonwhite:  ldi     high cmdTable       ; point to comand table
  973 9ddf: b7                     phi     r7                  ; r7 will be command table pointer
  974 9de0: f8 26                  ldi     low cmdTable
  975 9de2: a7                     plo     r7
  976 9de3: f8 01                  ldi     1                   ; first command number
  977 9de5: a8                     plo     r8                  ; r8 will keep track of command number
  978 9de6:             ; **************************
  979 9de6:             ; *** Command check loop ***
  980 9de6:             ; **************************
  981 9de6: 9b          cmdloop:   ghi     rb                  ; save buffer address
  982 9de7: bc                     phi     rc
  983 9de8: 8b                     glo     rb
  984 9de9: ac                     plo     rc
  985 9dea:             ; ************************
  986 9dea:             ; *** Check next token ***
  987 9dea:             ; ************************
  988 9dea: 07          tokloop:   ldn     r7                  ; get byte from token table
  989 9deb: fa 80                  ani     128                 ; check if last byte of token
  990 9ded: ca 9e 13               lbnz    cmdend              ; jump if last byte
  991 9df0: 07                     ldn     r7                  ; reget token byte
  992 9df1: 52                     str     r2                  ; store to stack
  993 9df2: 0b                     ldn     rb                  ; get byte from buffer
  994 9df3: f7                     sm                          ; do bytes match?
  995 9df4: ca 9d fc               lbnz    toknomtch           ; jump if no match
  996 9df7: 17                     inc     r7                  ; incrment token pointer
  997 9df8: 1b                     inc     rb                  ; increment buffer pointer
  998 9df9: c0 9d ea               lbr     tokloop             ; and keep looking
  999 9dfc:             ; *********************************************************
 1000 9dfc:             ; *** Token failed match, move to next and reset buffer ***
 1001 9dfc:             ; *********************************************************
 1002 9dfc: 9c          toknomtch: ghi     rc                  ; recover saved address
 1003 9dfd: bb                     phi     rb
 1004 9dfe: 8c                     glo     rc
 1005 9dff: ab                     plo     rb
 1006 9e00: 07          nomtch1:   ldn     r7                  ; get byte from token
 1007 9e01: fa 80                  ani     128                 ; looking for last byte of token
 1008 9e03: ca 9e 0a               lbnz    nomtch2             ; jump if found
 1009 9e06: 17                     inc     r7                  ; point to next byte
 1010 9e07: c0 9e 00               lbr     nomtch1             ; and keep looking
 1011 9e0a: 17          nomtch2:   inc     r7                  ; point to next token
 1012 9e0b: 18                     inc     r8                  ; increment command number
 1013 9e0c: 07                     ldn     r7                  ; get next token byte
 1014 9e0d: ca 9d e6               lbnz    cmdloop             ; jump if more tokens to check
 1015 9e10: c0 9e 47               lbr     notoken             ; jump if no token found
 1016 9e13:             ; ***********************************************************
 1017 9e13:             ; *** Made it to last byte of token, check remaining byte ***
 1018 9e13:             ; ***********************************************************
 1019 9e13: 07          cmdend:    ldn     r7                  ; get byte fro token
 1020 9e14: fa 7f                  ani     07fh                ; strip off end code
 1021 9e16: 52                     str     r2                  ; save to stack
 1022 9e17: 0b                     ldn     rb                  ; get byte from buffer
 1023 9e18: f7                     sm                          ; do they match
 1024 9e19: ca 9d fc               lbnz    toknomtch           ; jump if not
 1025 9e1c: 1b                     inc     rb                  ; point to next byte
 1026 9e1d: 0b                     ldn     rb                  ; get it
 1027 9e1e: ff 21                  smi     (' '+1)             ; it must be whitespace
 1028 9e20: c3 9d fc               lbdf    toknomtch           ; otherwise no match
 1029 9e23:             ; *************************************************************
 1030 9e23:             ; *** Match found, store command number into command buffer ***
 1031 9e23:             ; *************************************************************
 1032 9e23: 88                     glo     r8                  ; get command number
 1033 9e24: f9 80                  ori     128                 ; set high bit
 1034 9e26: 5f                     str     rf                  ; write to command buffer
 1035 9e27: 1f                     inc     rf                  ; point to next position
 1036 9e28: ff b0                  smi     FDOTQT              ; check for ." function
 1037 9e2a: ca 9d d0               lbnz    tokenlp             ; jump if not
 1038 9e2d: 1b                     inc     rb                  ; move past first space
 1039 9e2e: f8 fe                  ldi     T_ASCII             ; need an ascii token
 1040 9e30: 5f          tdotqtlp:  str     rf                  ; write to command buffer
 1041 9e31: 1f                     inc     rf
 1042 9e32: 0b                     ldn     rb                  ; get next byte
 1043 9e33: ff 22                  smi     34                  ; check for end quote
 1044 9e35: c2 9e 3c               lbz     tdotqtdn            ; jump if found
 1045 9e38: 4b                     lda     rb                  ; transfer character to code
 1046 9e39: c0 9e 30               lbr     tdotqtlp            ; and keep looking
 1047 9e3c: 0b          tdotqtdn:  ldn     rb                  ; retrieve quote
 1048 9e3d: 5f                     str     rf                  ; put quote into output
 1049 9e3e: 1f                     inc     rf
 1050 9e3f: f8 00                  ldi     0                   ; need string terminator
 1051 9e41: 5f                     str     rf
 1052 9e42: 1f                     inc     rf
 1053 9e43: 1b                     inc     rb                  ; move past quote
 1054 9e44: c0 9d d0               lbr     tokenlp             ; then continue tokenizing
 1055 9e47:             
 1056 9e47:             
 1057 9e47:             ; ------------------------------------------------------------------------
 1058 9e47:             ;     DECIMAL handler  if not valid decimal then proceed to ascii        ; 
 1059 9e47:             ; ------------------------------------------------------------------------
 1060 9e47:             
 1061 9e47:             notoken:   ; get number BASE [GDJ]
 1062 9e47: 8b ac 9b bc 	mov rc,rb
 1063 9e4b: 0b          	ldn rb
 1064 9e4c: ff 30       	smi '0'
 1065 9e4e: 3a 64       	bnz notokenbase  	; if no leading 0 can't be 0x or 0#
 1066 9e50: 1b          	inc rb
 1067 9e51: 0b          	ldn rb
 1068 9e52: ff 58       	smi 'X'
 1069 9e54: 32 5b       	bz notoken_0   		; 0xHexNumber
 1070 9e56: 0b          	ldn rb
 1071 9e57: ff 23       	smi '#'
 1072 9e59: 3a 63       	bnz notokenbaseadj		; 0#DecNumber
 1073 9e5b:             notoken_0:
 1074 9e5b: 0b          	ldn rb
 1075 9e5c: 1b          	inc rb
 1076 9e5d: ff 58       	smi 'X'
 1077 9e5f: 32 fa       	bz hexnum
 1078 9e61: 30 70       	br decnum
 1079 9e63: 2b          notokenbaseadj:	  dec rb   	; point back at 0
 1080 9e64:             notokenbase:	
 1081 9e64: f8 17 ad f8 
            03 bd                  mov     rd, basen
 1082 9e6a: 0d                     ldn     rd
 1083 9e6b: ff 0a                  smi     10
 1084 9e6d: ca 9e fa               lbnz    hexnum
 1085 9e70:             
 1086 9e70: f8 00 ad f8 
            00 bd       decnum:    mov     rd, 0               ; temp flag for minus sign
 1087 9e76: 8b ac 9b bc            mov     rc,rb               ; save pointer in case of bad number
 1088 9e7a: f8 00                  ldi     0                   ; clear negative flag
 1089 9e7c: ae                     plo     re
 1090 9e7d: 0b                     ldn     rb                  ; get byte
 1091 9e7e: ff 2d                  smi     '-'                 ; is it negative
 1092 9e80: ca 9e 88               lbnz    notoken1            ; jump if not
 1093 9e83: 1b                     inc     rb                  ; move past negative
 1094 9e84: f8 01                  ldi     1                   ; set negative flag
 1095 9e86: ae                     plo     re
 1096 9e87: ad                     plo     rd
 1097 9e88: 0b          notoken1:  ldn     rb                  ; get byte
 1098 9e89: ff 30                  smi     '0'                 ; check for below numbers
 1099 9e8b: cb 9f 4a               lbnf    nonnumber           ; jump if not a number
 1100 9e8e: 0b                     ldn     rb
 1101 9e8f: ff 3a                  smi     ('9'+1)
 1102 9e91: c3 9f 4a               lbdf    nonnumber
 1103 9e94:                        ; ghi     rb                  ; save pointer in case of bad number
 1104 9e94:                        ; phi     rc
 1105 9e94:                        ; glo     rb
 1106 9e94:                        ; plo     rc
 1107 9e94:             ; **********************
 1108 9e94:             ; *** Found a number ***
 1109 9e94:             ; **********************
 1110 9e94: f8 00       isnumber:  ldi     0                   ; number starts out as zero
 1111 9e96: b7                     phi     r7                  ; use r7 to compile number
 1112 9e97: a7                     plo     r7
 1113 9e98: e2                     sex     r2                  ; make sure x is pointing to stack
 1114 9e99: 97          numberlp:  ghi     r7                  ; copy number to temp
 1115 9e9a: b8                     phi     r8
 1116 9e9b: 87                     glo     r7
 1117 9e9c: a8                     plo     r8
 1118 9e9d: 87                     glo     r7                  ; mulitply by 2
 1119 9e9e: fe                     shl
 1120 9e9f: a7                     plo     r7
 1121 9ea0: 97                     ghi     r7
 1122 9ea1: 7e                     shlc
 1123 9ea2: b7                     phi     r7
 1124 9ea3: 87                     glo     r7                  ; mulitply by 4
 1125 9ea4: fe                     shl
 1126 9ea5: a7                     plo     r7
 1127 9ea6: 97                     ghi     r7
 1128 9ea7: 7e                     shlc
 1129 9ea8: b7                     phi     r7
 1130 9ea9: 88                     glo     r8                  ; multiply by 5
 1131 9eaa: 52                     str     r2
 1132 9eab: 87                     glo     r7
 1133 9eac: f4                     add
 1134 9ead: a7                     plo     r7
 1135 9eae: 98                     ghi     r8
 1136 9eaf: 52                     str     r2
 1137 9eb0: 97                     ghi     r7
 1138 9eb1: 74                     adc
 1139 9eb2: b7                     phi     r7
 1140 9eb3: 87                     glo     r7                  ; mulitply by 10
 1141 9eb4: fe                     shl
 1142 9eb5: a7                     plo     r7
 1143 9eb6: 97                     ghi     r7
 1144 9eb7: 7e                     shlc
 1145 9eb8: b7                     phi     r7
 1146 9eb9: 4b                     lda     rb                  ; get byte from buffer
 1147 9eba: ff 30                  smi     '0'                 ; convert to numeric
 1148 9ebc: 52                     str     r2                  ; store it
 1149 9ebd: 87                     glo     r7                  ; add to number
 1150 9ebe: f4                     add
 1151 9ebf: a7                     plo     r7
 1152 9ec0: 97                     ghi     r7                  ; propagate through high byte
 1153 9ec1: 7c 00                  adci    0
 1154 9ec3: b7                     phi     r7
 1155 9ec4: 0b                     ldn     rb                  ; get byte
 1156 9ec5: ff 21                  smi     (' '+1)             ; check for space
 1157 9ec7: cb 9e e0               lbnf    numberdn            ; number also done
 1158 9eca: 0b                     ldn     rb
 1159 9ecb: ff 30                  smi     '0'                 ; check for below numbers
 1160 9ecd: cb 9e d9               lbnf    numbererr           ; jump if not a number
 1161 9ed0: 0b                     ldn     rb
 1162 9ed1: ff 3a                  smi     ('9'+1)
 1163 9ed3: c3 9e d9               lbdf    numbererr
 1164 9ed6: c0 9e 99               lbr     numberlp            ; get rest of number
 1165 9ed9: 9c          numbererr: ghi     rc                  ; recover address
 1166 9eda: bb                     phi     rb
 1167 9edb: 8c                     glo     rc
 1168 9edc: ab                     plo     rb
 1169 9edd: c0 9f 4a               lbr     nonnumber
 1170 9ee0: 8e          numberdn:  glo     re                  ; get negative flag
 1171 9ee1: c2 9e ed               lbz     numberdn1           ; jump if positive number
 1172 9ee4: 97                     ghi     r7                  ; negative, so 2s compliment number
 1173 9ee5: fb ff                  xri     0ffh
 1174 9ee7: b7                     phi     r7
 1175 9ee8: 87                     glo     r7
 1176 9ee9: fb ff                  xri     0ffh
 1177 9eeb: a7                     plo     r7
 1178 9eec: 17                     inc     r7
 1179 9eed: f8 ff       numberdn1: ldi     T_NUM               ; code to signify a number
 1180 9eef: 5f                     str     rf                  ; write to code buffer
 1181 9ef0: 1f                     inc     rf                  ; point to next position
 1182 9ef1: 97                     ghi     r7                  ; get high byte of number
 1183 9ef2: 5f                     str     rf                  ; write to code buffer
 1184 9ef3: 1f                     inc     rf                  ; point to next position
 1185 9ef4: 87                     glo     r7                  ; get lo byte of numbr
 1186 9ef5: 5f                     str     rf                  ; write to code buffer
 1187 9ef6: 1f                     inc     rf                  ; point to next position
 1188 9ef7: c0 9d d0               lbr     tokenlp             ; continue reading tokens
 1189 9efa:             
 1190 9efa:             ; ------------------------------------------------------------------------
 1191 9efa:             ;       HEX handler  if not valid decimal then proceed to ascii          ; 
 1192 9efa:             ; ------------------------------------------------------------------------
 1193 9efa:             				; [GDJ]
 1194 9efa: f8 00       hexnum:    ldi     0h                  ; clear return value
 1195 9efc: a7                     plo     r7
 1196 9efd: b7                     phi     r7
 1197 9efe: 8b ac 9b bc            mov     rc,rb               ; save pointer in case of bad number
 1198 9f02:             
 1199 9f02:                        ; for first pass we reject non hex chars
 1200 9f02:                        ; in next pass this check has already been done but we
 1201 9f02:                        ; have to deal with the different offsets here for ascii to binary
 1202 9f02:                        ; Note: all strings have been converted to upper case previously
 1203 9f02: 0b          tohexlp:   ldn     rb                  ; get next byte
 1204 9f03: ff 30                  smi     '0'                 ; check for bottom of range
 1205 9f05: cb 9f 4a               lbnf    nonnumber           ; jump if non-numeric
 1206 9f08: 0b                     ldn     rb                  ; recover byte
 1207 9f09: ff 3a                  smi     '9'+1               ; upper range of digits
 1208 9f0b: cb 9f 1d               lbnf    tohexd              ; jump if digit
 1209 9f0e: 0b                     ldn     rb                  ; recover character
 1210 9f0f: ff 41                  smi     'A'                 ; check below uc A
 1211 9f11: cb 9f 4a               lbnf    nonnumber           ; jump if not hex character
 1212 9f14: 0b                     ldn     rb                  ; recover character
 1213 9f15: ff 47                  smi     'F'+1               ; check for above uc F
 1214 9f17: c3 9f 4a               lbdf    nonnumber           ; jump if not hex character
 1215 9f1a: c0 9f 23               lbr     tohex
 1216 9f1d: 0b          tohexd:    ldn     rb                  ; recover character 0..9
 1217 9f1e: ff 30                  smi     030h                ; convert to binary       
 1218 9f20: c0 9f 26               lbr     tohexad
 1219 9f23: 0b          tohex:     ldn     rb                  ; recover character A..F
 1220 9f24: ff 37                  smi     55                  ; convert to binary
 1221 9f26: 52          tohexad:   str     r2                  ; store value to add
 1222 9f27: f8 04                  ldi     4                   ; need to shift 4 times
 1223 9f29: ae                     plo     re
 1224 9f2a: 87          tohexal:   glo     r7
 1225 9f2b: fe                     shl
 1226 9f2c: a7                     plo     r7
 1227 9f2d: 97                     ghi     r7
 1228 9f2e: 7e                     shlc
 1229 9f2f: b7                     phi     r7
 1230 9f30: 2e                     dec     re                  ; decrement count
 1231 9f31: 8e                     glo     re                  ; get count
 1232 9f32: ca 9f 2a               lbnz    tohexal             ; loop until done
 1233 9f35: 87                     glo     r7                  ; now add in new value
 1234 9f36: f1                     or                          ; or with stored byte
 1235 9f37: a7                     plo     r7
 1236 9f38:             
 1237 9f38: 1b                     inc     rb
 1238 9f39: 0b                     ldn     rb
 1239 9f3a: ff 21                  smi     (' '+1)             ; check for space
 1240 9f3c: cb 9e ed               lbnf    numberdn1           ; number is complete
 1241 9f3f:                        
 1242 9f3f:                        ; words that begin with valid hex chars but have
 1243 9f3f:                        ; embedded non hex characters get filtered out here
 1244 9f3f: 0b                     ldn     rb
 1245 9f40: d4                     sep     scall               ; check for hex character
 1246 9f41: ac 5b                  dw      ishex
 1247 9f43: c3 9f 02               lbdf    tohexlp             ; loop back if so else
 1248 9f46:                                                    ; we dont have a hex char
 1249 9f46:                        
 1250 9f46:                        ; we got here since this was not a valid hex number           
 1251 9f46: 8c ab 9c bb nothexnum: mov     rb,rc               ; retrieve pointer
 1252 9f4a:             
 1253 9f4a:             
 1254 9f4a:             ; *************************************************************
 1255 9f4a:             ; *** Neither token or number found, insert as ascii string ***
 1256 9f4a:             ; *************************************************************
 1257 9f4a: 2b          nonnumber: dec     rb                  ; account for first increment
 1258 9f4b: f8 17 ac f8 
            03 bc                  mov     rc, basen
 1259 9f51: 0c                     ldn     rc
 1260 9f52: ff 0a                  smi     10
 1261 9f54: ca 9f 5c               lbnz    nonnumber1
 1262 9f57: 8d                     glo     rd
 1263 9f58: c2 9f 5c               lbz     nonnumber1
 1264 9f5b: 2b                     dec     rb                  ; account for previous minus sign in DECIMAL mode
 1265 9f5c:             nonnumber1:
 1266 9f5c: f8 fe                  ldi     T_ASCII             ; indicate ascii to follow
 1267 9f5e: 5f          notokenlp: str     rf                  ; write to buffer
 1268 9f5f: 1f                     inc     rf                  ; advance to next position
 1269 9f60: 1b                     inc     rb                  ; point to next position
 1270 9f61: 0b                     ldn     rb                  ; get next byte
 1271 9f62: ff 21                  smi     (' '+1)             ; check for whitespace
 1272 9f64: cb 9f 6b               lbnf    notokwht            ; found whitespace
 1273 9f67: 0b                     ldn     rb                  ; get byte
 1274 9f68: c0 9f 5e               lbr     notokenlp           ; get characters til whitespace
 1275 9f6b: f8 00       notokwht:  ldi     0                   ; need ascii terminator
 1276 9f6d: 5f                     str     rf                  ; store into buffer
 1277 9f6e: 1f                     inc     rf                  ; point to next position
 1278 9f6f: c0 9d d0               lbr     tokenlp             ; and keep looking
 1279 9f72: f8 00       tokendn:   ldi     0                   ; need to terminate command string
 1280 9f74: 5f                     str     rf                  ; write to buffer
 1281 9f75: d5                     sep    sret                 ; return to caller
 1282 9f76:             
 1283 9f76:             
 1284 9f76:             ;           org     500h
 1285 9f76:             ; ****************************************************
 1286 9f76:             ; *** Execute forth byte codes, RB points to codes ***
 1287 9f76:             ; ****************************************************
 1288 9f76: 0b          exec:      ldn     rb                  ; get byte from codestream
 1289 9f77: c2 a0 11               lbz     execdn              ; jump if at end of stream
 1290 9f7a: ff ff                  smi     T_NUM               ; check for numbers
 1291 9f7c: c2 9f c2               lbz     execnum             ; code is numeric
 1292 9f7f: 0b                     ldn     rb                  ; recover byte
 1293 9f80: ff fe                  smi     T_ASCII             ; check for ascii data
 1294 9f82: c2 9f d5               lbz     execascii           ; jump if ascii
 1295 9f85: f8 0a a8 f8 
            03 b8                  mov     r8, jump            ; point to jump address
 1296 9f8b: f8 c0                  ldi     0c0h                ; need LBR
 1297 9f8d: 58                     str     r8                  ; store it
 1298 9f8e: 18                     inc     r8
 1299 9f8f: 0b                     ldn     rb                  ; recover byte
 1300 9f90: fa 7f                  ani     07fh                ; strip high bit
 1301 9f92: ff 01                  smi     1                   ; reset to origin
 1302 9f94: fe                     shl                         ; addresses are two bytes
 1303 9f95: e2                     sex     r2                  ; point X to stack
 1304 9f96: 52                     str     r2                  ; write offset for addtion
 1305 9f97: f8 10                  ldi     low cmdvecs
 1306 9f99: f4                     add                         ; add offset
 1307 9f9a: a7                     plo     r7
 1308 9f9b: f8 ae                  ldi     high cmdvecs        ; high address of command vectors
 1309 9f9d: 7c 00                  adci    0                   ; propagate carry
 1310 9f9f: b7                     phi     r7                  ; r[7] now points to command vector
 1311 9fa0: 47                     lda     r7                  ; get high byte of vector
 1312 9fa1: 58                     str     r8
 1313 9fa2: 18                     inc     r8
 1314 9fa3: 47                     lda     r7                  ; get low byte of vector
 1315 9fa4: 58                     str     r8
 1316 9fa5: 1b                     inc     rb                  ; point rb to next command
 1317 9fa6: 8b                     glo     rb                  ; save rb
 1318 9fa7: 73                     stxd
 1319 9fa8: 9b                     ghi     rb
 1320 9fa9: 73                     stxd
 1321 9faa: c0 03 0a               lbr     jump
 1322 9fad: e2          execret:   sex     r2                  ; be sure X poits to stack
 1323 9fae: a7                     plo     r7                  ; save return code
 1324 9faf: 60                     irx                         ; recover rb
 1325 9fb0: 42                     lda     r2
 1326 9fb1: bb                     phi     rb
 1327 9fb2: 02                     ldn     r2
 1328 9fb3: ab                     plo     rb
 1329 9fb4: 87                     glo     r7                  ; get result code
 1330 9fb5: c2 9f 76               lbz     exec                ; jump if no error
 1331 9fb8: f8 ad                  ldi     high msempty        ; get error message
 1332 9fba: bf                     phi     rf
 1333 9fbb: f8 12                  ldi     low msempty
 1334 9fbd: af                     plo     rf
 1335 9fbe: d4          execrmsg:  sep     scall
            #else
 1339 9fbf: ff 09                  dw      f_msg
            #endif
 1341 9fc1: d5                     sep     sret                ; return to caller
 1342 9fc2:             
 1343 9fc2: 1b          execnum:   inc     rb                  ; point to number
 1344 9fc3: 9b                     ghi     rb
 1345 9fc4: b7                     phi     r7
 1346 9fc5: 8b                     glo     rb
 1347 9fc6: a7                     plo     r7
 1348 9fc7: 47                     lda     r7
 1349 9fc8: bb                     phi     rb
 1350 9fc9: 47                     lda     r7
 1351 9fca: ab                     plo     rb
 1352 9fcb: d4                     sep     scall
 1353 9fcc: 9c 61                  dw      push
 1354 9fce: 97                     ghi     r7
 1355 9fcf: bb                     phi     rb
 1356 9fd0: 87                     glo     r7
 1357 9fd1: ab                     plo     rb
 1358 9fd2: c0 9f 76               lbr     exec                ; execute next code
 1359 9fd5: 1b          execascii: inc     rb                  ; move past ascii code
 1360 9fd6: 9b                     ghi     rb                  ; transfer name to R8
 1361 9fd7: b8                     phi     r8
 1362 9fd8: 8b                     glo     rb
 1363 9fd9: a8                     plo     r8
 1364 9fda: d4                     sep     scall               ; find entry
 1365 9fdb: 9c a5                  dw      findname
 1366 9fdd: cb 9f e9               lbnf    ascnoerr            ; jump if name was found
 1367 9fe0: f8 ad       ascerr:    ldi     high msgerr         ; get error message
 1368 9fe2: bf                     phi     rf
 1369 9fe3: f8 20                  ldi     low msgerr
 1370 9fe5: af                     plo     rf
 1371 9fe6: c0 9f be               lbr     execrmsg
 1372 9fe9: 17          ascnoerr:  inc     r7                  ; point to type
 1373 9fea: 17                     inc     r7
 1374 9feb: 07                     ldn     r7                  ; get type
 1375 9fec: ff 86                  smi     86h                 ; check for variable
 1376 9fee: c2 a0 07               lbz     execvar             ; jump if so
 1377 9ff1: 07                     ldn     r7                  ; get type
 1378 9ff2: ff 87                  smi     87h                 ; check for function
 1379 9ff4: ca 9f e0               lbnz    ascerr              ; jump if not
 1380 9ff7: e2                     sex     r2                  ; be sure X is pointing to stack
 1381 9ff8: 88                     glo     r8                  ; save position
 1382 9ff9: 73                     stxd                        ; and store on stack
 1383 9ffa: 98                     ghi     r8
 1384 9ffb: 73                     stxd
 1385 9ffc: d4                     sep     scall               ; call exec to execute stored program
 1386 9ffd: 9f 76                  dw      exec
 1387 9fff: 60                     irx                         ; recover pointer
 1388 a000: 72                     ldxa
 1389 a001: bb                     phi     rb
 1390 a002: f0                     ldx
 1391 a003: ab                     plo     rb
 1392 a004: c0 9f 76               lbr     exec                ; and continue execution
 1393 a007: d4          execvar:   sep     scall               ; push var address to stack
 1394 a008: 9c 61                  dw      push
 1395 a00a: 98                     ghi     r8                  ; transfer address back to rb
 1396 a00b: bb                     phi     rb
 1397 a00c: 88                     glo     r8
 1398 a00d: ab                     plo     rb
 1399 a00e: c0 9f 76               lbr     exec                ; execute next code
 1400 a011:                        
 1401 a011: d5          execdn:    sep     sret                ; return to caller
 1402 a012:             
 1403 a012: f8 01       error:     ldi     1                   ; indicate error
 1404 a014: c0 9f ad               lbr     execret             ; return to caller
 1405 a017: f8 00       good:      ldi     0                   ; indicate success
 1406 a019: c0 9f ad               lbr     execret             ; return to caller
 1407 a01c:             
 1408 a01c:             ;          org     600h
 1409 a01c: d4          cdup:      sep     scall               ; pop value from forth stack
 1410 a01d: 9c 32                  dw      pop
 1411 a01f: c3 a0 12               lbdf    error               ; jump if stack was empty
 1412 a022: d4                     sep     scall               ; push back twice
 1413 a023: 9c 61                  dw      push
 1414 a025: d4                     sep     scall
 1415 a026: 9c 61                  dw      push
 1416 a028: c0 a0 17               lbr     good                ; return
 1417 a02b:             
 1418 a02b: d4          cdrop:     sep     scall               ; pop value from stack
 1419 a02c: 9c 32                  dw      pop
 1420 a02e: c3 a0 12               lbdf    error               ; jump if stack was empty
 1421 a031: c0 a0 17               lbr     good                ; return
 1422 a034:                        
 1423 a034: d4          cplus:     sep     scall               ; get value from stack
 1424 a035: 9c 32                  dw      pop
 1425 a037: c3 a0 12               lbdf    error               ; jump if stack was empty
 1426 a03a: 9b                     ghi     rb                  ; move number 
 1427 a03b: b7                     phi     r7
 1428 a03c: 8b                     glo     rb
 1429 a03d: a7                     plo     r7
 1430 a03e: d4                     sep     scall               ; get next number
 1431 a03f: 9c 32                  dw      pop
 1432 a041: c3 a0 12               lbdf    error               ; jump if stack was empty
 1433 a044: e2                     sex     r2                  ; be sure X points to stack
 1434 a045: 87                     glo     r7                  ; perform addition
 1435 a046: 52                     str     r2
 1436 a047: 8b                     glo     rb
 1437 a048: f4                     add
 1438 a049: ab                     plo     rb
 1439 a04a: 97                     ghi     r7
 1440 a04b: 52                     str     r2
 1441 a04c: 9b                     ghi     rb
 1442 a04d: 74                     adc
 1443 a04e: bb                     phi     rb
 1444 a04f: d4                     sep     scall               ; put answer back on stack
 1445 a050: 9c 61                  dw      push
 1446 a052: c0 a0 17               lbr     good
 1447 a055:             
 1448 a055:             
 1449 a055: d4          cminus:    sep     scall               ; get value from stack
 1450 a056: 9c 32                  dw      pop
 1451 a058: c3 a0 12               lbdf    error               ; jump if stack was empty
 1452 a05b: 9b                     ghi     rb                  ; move number 
 1453 a05c: b7                     phi     r7
 1454 a05d: 8b                     glo     rb
 1455 a05e: a7                     plo     r7
 1456 a05f: d4                     sep     scall               ; get next number
 1457 a060: 9c 32                  dw      pop
 1458 a062: c3 a0 12               lbdf    error               ; jump if stack was empty
 1459 a065: e2                     sex     r2                  ; be sure X points to stack
 1460 a066: 87                     glo     r7                  ; perform addition
 1461 a067: 52                     str     r2
 1462 a068: 8b                     glo     rb
 1463 a069: f7                     sm
 1464 a06a: ab                     plo     rb
 1465 a06b: 97                     ghi     r7
 1466 a06c: 52                     str     r2
 1467 a06d: 9b                     ghi     rb
 1468 a06e: 77                     smb
 1469 a06f: bb                     phi     rb
 1470 a070: d4                     sep     scall               ; put answer back on stack
 1471 a071: 9c 61                  dw      push
 1472 a073: c0 a0 17               lbr     good
 1473 a076:             
 1474 a076: d4          cdot:      sep     scall               ; get value from stack
 1475 a077: 9c 32                  dw      pop
 1476 a079: c3 a0 12               lbdf    error               ; jump if stack was empty
 1477 a07c: f8 01                  ldi     1
 1478 a07e: ae                     plo     re                  ; signal signed int
 1479 a07f: d4                     sep     scall
 1480 a080: ab ef                  dw      typenum             ; [GDJ]
 1481 a082:                        ; sep     scall               ; call integer out routine
 1482 a082:                        ; dw      intout
 1483 a082:                        ; ldi     ' '                 ; need a space
 1484 a082:                        ; sep     scall               ; need to call character out
 1485 a082:                        ; dw      disp
 1486 a082: c0 a0 17               lbr     good                ; return
 1487 a085:             
 1488 a085: d4          cudot:     sep     scall               ; get value from stack
 1489 a086: 9c 32                  dw      pop
 1490 a088: c3 a0 12               lbdf    error               ; jump if stack was empty
 1491 a08b: f8 00                  ldi     0
 1492 a08d: ae                     plo     re                  ; signal unsigned int
 1493 a08e: d4                     sep     scall               ; call integer out routine
 1494 a08f: ab ef                  dw      typenum             ; [GDJ]
 1495 a091:                        ; sep     scall
 1496 a091:                        ; dw      uintout
 1497 a091:                        ; ldi     ' '                 ; need a space
 1498 a091:                        ; sep     scall               ; need to call character out
 1499 a091:                        ; dw      disp
 1500 a091: c0 a0 17               lbr     good                ; return
 1501 a094:             
 1502 a094: d4          cand:      sep     scall               ; get value from stack
 1503 a095: 9c 32                  dw      pop
 1504 a097: c3 a0 12               lbdf    error               ; jump if stack was empty
 1505 a09a: 9b                     ghi     rb                  ; move number 
 1506 a09b: b7                     phi     r7
 1507 a09c: 8b                     glo     rb
 1508 a09d: a7                     plo     r7
 1509 a09e: d4                     sep     scall               ; get next number
 1510 a09f: 9c 32                  dw      pop
 1511 a0a1: c3 a0 12               lbdf    error               ; jump if stack was empty
 1512 a0a4: e2                     sex     r2                  ; be sure X points to stack
 1513 a0a5: 87                     glo     r7                  ; perform and
 1514 a0a6: 52                     str     r2
 1515 a0a7: 8b                     glo     rb
 1516 a0a8: f2                     and
 1517 a0a9: ab                     plo     rb
 1518 a0aa: 97                     ghi     r7
 1519 a0ab: 52                     str     r2
 1520 a0ac: 9b                     ghi     rb
 1521 a0ad: f2                     and
 1522 a0ae: bb                     phi     rb
 1523 a0af: d4                     sep     scall               ; put answer back on stack
 1524 a0b0: 9c 61                  dw      push
 1525 a0b2: c0 a0 17               lbr     good
 1526 a0b5:             
 1527 a0b5: d4          cor:       sep     scall               ; get value from stack
 1528 a0b6: 9c 32                  dw      pop
 1529 a0b8: c3 a0 12               lbdf    error               ; jump if stack was empty
 1530 a0bb: 9b                     ghi     rb                  ; move number 
 1531 a0bc: b7                     phi     r7
 1532 a0bd: 8b                     glo     rb
 1533 a0be: a7                     plo     r7
 1534 a0bf: d4                     sep     scall               ; get next number
 1535 a0c0: 9c 32                  dw      pop
 1536 a0c2: c3 a0 12               lbdf    error               ; jump if stack was empty
 1537 a0c5: e2                     sex     r2                  ; be sure X points to stack
 1538 a0c6: 87                     glo     r7                  ; perform and
 1539 a0c7: 52                     str     r2
 1540 a0c8: 8b                     glo     rb
 1541 a0c9: f1                     or
 1542 a0ca: ab                     plo     rb
 1543 a0cb: 97                     ghi     r7
 1544 a0cc: 52                     str     r2
 1545 a0cd: 9b                     ghi     rb
 1546 a0ce: f1                     or
 1547 a0cf: bb                     phi     rb
 1548 a0d0: d4                     sep     scall               ; put answer back on stack
 1549 a0d1: 9c 61                  dw      push
 1550 a0d3: c0 a0 17               lbr     good
 1551 a0d6:             
 1552 a0d6: d4          cxor:      sep     scall               ; get value from stack
 1553 a0d7: 9c 32                  dw      pop
 1554 a0d9: c3 a0 12               lbdf    error               ; jump if stack was empty
 1555 a0dc: 9b                     ghi     rb                  ; move number 
 1556 a0dd: b7                     phi     r7
 1557 a0de: 8b                     glo     rb
 1558 a0df: a7                     plo     r7
 1559 a0e0: d4                     sep     scall               ; get next number
 1560 a0e1: 9c 32                  dw      pop
 1561 a0e3: c3 a0 12               lbdf    error               ; jump if stack was empty
 1562 a0e6: e2                     sex     r2                  ; be sure X points to stack
 1563 a0e7: 87                     glo     r7                  ; perform and
 1564 a0e8: 52                     str     r2
 1565 a0e9: 8b                     glo     rb
 1566 a0ea: f3                     xor
 1567 a0eb: ab                     plo     rb
 1568 a0ec: 97                     ghi     r7
 1569 a0ed: 52                     str     r2
 1570 a0ee: 9b                     ghi     rb
 1571 a0ef: f3                     xor
 1572 a0f0: bb                     phi     rb
 1573 a0f1: d4                     sep     scall               ; put answer back on stack
 1574 a0f2: 9c 61                  dw      push
 1575 a0f4: c0 a0 17               lbr     good
 1576 a0f7:             
 1577 a0f7: d4          ccr:	   sep scall
 1578 a0f8: 9c 17       	   dw crlfout
 1579 a0fa: c0 a0 17               lbr     good                ; return
 1580 a0fd:             
 1581 a0fd: d4          cswap:     sep     scall               ; get value from stack
 1582 a0fe: 9c 32                  dw      pop
 1583 a100: c3 a0 12               lbdf    error               ; jump if stack was empty
 1584 a103: 9b                     ghi     rb                  ; move number 
 1585 a104: b7                     phi     r7
 1586 a105: 8b                     glo     rb
 1587 a106: a7                     plo     r7
 1588 a107: d4                     sep     scall               ; get next number
 1589 a108: 9c 32                  dw      pop
 1590 a10a: c3 a0 12               lbdf    error               ; jump if stack was empty
 1591 a10d: 9b                     ghi     rb                  ; move number 
 1592 a10e: b8                     phi     r8
 1593 a10f: 8b                     glo     rb
 1594 a110: a8                     plo     r8
 1595 a111: 97                     ghi     r7                  ; move number 
 1596 a112: bb                     phi     rb
 1597 a113: 87                     glo     r7
 1598 a114: ab                     plo     rb
 1599 a115: d4                     sep     scall               ; put answer back on stack
 1600 a116: 9c 61                  dw      push
 1601 a118: 98                     ghi     r8                  ; move number 
 1602 a119: bb                     phi     rb
 1603 a11a: 88                     glo     r8
 1604 a11b: ab                     plo     rb
 1605 a11c: d4                     sep     scall               ; put answer back on stack
 1606 a11d: 9c 61                  dw      push
 1607 a11f: c0 a0 17               lbr     good                ; return
 1608 a122:             
 1609 a122: d4          ci:        sep     scall               ; get value from return stack
 1610 a123: 9c 77                  dw      rpop
 1611 a125: d4                     sep     scall               ; put back on return stack
 1612 a126: 9c 8f                  dw      rpush 
 1613 a128: d4                     sep     scall               ; and forth stack
 1614 a129: 9c 61                  dw      push
 1615 a12b: c0 a0 17               lbr     good                ; return to caller
 1616 a12e:             
 1617 a12e: e2          cmem:      sex     r2                  ; be sure x is pointing to stack
 1618 a12f: f8 06                  ldi     low freemem         ; point to free memory pointer
 1619 a131: a9                     plo     r9                  ; place into data frame
 1620 a132: 49                     lda     r9                  ; get high byte of free memory pointer
 1621 a133: 73                     stxd                        ; store on stack
 1622 a134: 49                     lda     r9                  ; get low byte
 1623 a135: 52                     str     r2                  ; store on stack
 1624 a136: f8 08                  ldi     low fstack          ; get pointer to stack
 1625 a138: a9                     plo     r9                  ; set into data frame
 1626 a139: 19                     inc     r9                  ; point to lo byte
 1627 a13a: 09                     ldn     r9                  ; get it
 1628 a13b: f7                     sm                          ; perform subtract
 1629 a13c: ab                     plo     rb                  ; put into result
 1630 a13d: 29                     dec     r9                  ; high byte of stack pointer
 1631 a13e: 60                     irx                         ; point to high byte os free mem
 1632 a13f: 09                     ldn     r9                  ; get high byte of stack
 1633 a140: 77                     smb                         ; continue subtraction
 1634 a141: bb                     phi     rb                  ; store answer
 1635 a142: d4                     sep     scall               ; put answer back on stack
 1636 a143: 9c 61                  dw      push
 1637 a145: c0 a0 17               lbr     good                ; return
 1638 a148:              
 1639 a148:             
 1640 a148: d4          cdo:       sep     scall               ; get value from stack
 1641 a149: 9c 32                  dw      pop
 1642 a14b: c3 a0 12               lbdf    error               ; jump if stack was empty
 1643 a14e: 9b                     ghi     rb                  ; move number 
 1644 a14f: b7                     phi     r7
 1645 a150: 8b                     glo     rb
 1646 a151: a7                     plo     r7
 1647 a152: d4                     sep     scall               ; get next number
 1648 a153: 9c 32                  dw      pop
 1649 a155: c3 a0 12               lbdf    error               ; jump if stack was empty
 1650 a158: 9b                     ghi     rb                  ; move number 
 1651 a159: b8                     phi     r8
 1652 a15a: 8b                     glo     rb
 1653 a15b: a8                     plo     r8
 1654 a15c: 92                     ghi     r2                  ; get copy of machine stack
 1655 a15d: ba                     phi     ra
 1656 a15e: 82                     glo     r2
 1657 a15f: aa                     plo     ra
 1658 a160: 1a                     inc     ra                  ; pointing at R[6] value high
 1659 a161: 4a                     lda     ra                  ; get high of R[6]
 1660 a162: bb                     phi     rb                  ; put into r6
 1661 a163: 4a                     lda     ra
 1662 a164: ab                     plo     rb
 1663 a165: d4                     sep     scall               ; store inst point on return stack
 1664 a166: 9c 8f                  dw      rpush
 1665 a168: 98                     ghi     r8                  ; transfer termination to rb
 1666 a169: bb                     phi     rb
 1667 a16a: 88                     glo     r8
 1668 a16b: ab                     plo     rb
 1669 a16c: d4                     sep     scall               ; store termination on return stack
 1670 a16d: 9c 8f                  dw      rpush
 1671 a16f: 97                     ghi     r7                  ; transfer count to rb
 1672 a170: bb                     phi     rb
 1673 a171: 87                     glo     r7
 1674 a172: ab                     plo     rb
 1675 a173: d4                     sep     scall               ; store count on return stack
 1676 a174: 9c 8f                  dw      rpush
 1677 a176: c0 a0 17               lbr     good
 1678 a179:             
 1679 a179: d4          cloop:     sep     scall               ; get top or return stack
 1680 a17a: 9c 77                  dw      rpop
 1681 a17c: 1b                     inc     rb                  ; add 1 to it
 1682 a17d: 9b          loopcnt:   ghi     rb                  ; move it
 1683 a17e: b7                     phi     r7
 1684 a17f: 8b                     glo     rb
 1685 a180: a7                     plo     r7
 1686 a181: d4                     sep     scall               ; get termination
 1687 a182: 9c 77                  dw      rpop
 1688 a184: e2                     sex     r2                  ; make sure x is pointing to stack
 1689 a185: 8b                     glo     rb                  ; get lo of termination
 1690 a186: 52                     str     r2                  ; place into memory 
 1691 a187: 87                     glo     r7                  ; get count
 1692 a188: f7                     sm                          ; perform subtract
 1693 a189: 9b                     ghi     rb                  ; get hi of termination
 1694 a18a: 52                     str     r2                  ; place into memory
 1695 a18b: 97                     ghi     r7                  ; get high of count
 1696 a18c: 77                     smb                         ; continue subtract
 1697 a18d: c3 a1 b5               lbdf    cloopdn             ; jump if loop complete
 1698 a190: 9b                     ghi     rb                  ; move termination
 1699 a191: b8                     phi     r8
 1700 a192: 8b                     glo     rb
 1701 a193: a8                     plo     r8
 1702 a194: d4                     sep     scall               ; get loop address
 1703 a195: 9c 77                  dw      rpop
 1704 a197: d4                     sep     scall               ; keep on stack as well
 1705 a198: 9c 8f                  dw      rpush
 1706 a19a: 92                     ghi     r2                  ; get copy of machine stack
 1707 a19b: ba                     phi     ra
 1708 a19c: 82                     glo     r2
 1709 a19d: aa                     plo     ra
 1710 a19e: 1a                     inc     ra                  ; pointing at ra value high
 1711 a19f: 9b                     ghi     rb
 1712 a1a0: 5a                     str     ra                  ; and write it
 1713 a1a1: 1a                     inc     ra                 
 1714 a1a2: 8b                     glo     rb                  ; get rb lo value
 1715 a1a3: 5a                     str     ra                  ; and write it
 1716 a1a4: 98                     ghi     r8                  ; transfer termination
 1717 a1a5: bb                     phi     rb
 1718 a1a6: 88                     glo     r8
 1719 a1a7: ab                     plo     rb
 1720 a1a8: d4                     sep     scall               ; push onto return stack
 1721 a1a9: 9c 8f                  dw      rpush
 1722 a1ab: 97                     ghi     r7                  ; transfer count
 1723 a1ac: bb                     phi     rb
 1724 a1ad: 87                     glo     r7
 1725 a1ae: ab                     plo     rb
 1726 a1af: d4                     sep     scall               ; push onto return stack
 1727 a1b0: 9c 8f                  dw      rpush
 1728 a1b2: c0 a0 17               lbr     good                ; and return
 1729 a1b5: d4          cloopdn:   sep     scall               ; pop off start of loop address
 1730 a1b6: 9c 77                  dw      rpop
 1731 a1b8: c0 a0 17               lbr     good                ; and return
 1732 a1bb: d4          cploop:    sep     scall               ; get top or return stack
 1733 a1bc: 9c 77                  dw      rpop
 1734 a1be: e2                     sex     r2                  ; make sure X points to stack
 1735 a1bf: 9b                     ghi     rb                  ; put count into memory
 1736 a1c0: 73                     stxd
 1737 a1c1: 8b                     glo     rb
 1738 a1c2: 73                     stxd
 1739 a1c3: d4                     sep     scall               ; get word from data stack
 1740 a1c4: 9c 32                  dw      pop
 1741 a1c6: c3 a0 12               lbdf    error
 1742 a1c9: 60                     irx
 1743 a1ca: 8b                     glo     rb                  ; add to count
 1744 a1cb: f4                     add
 1745 a1cc: ab                     plo     rb
 1746 a1cd: 9b                     ghi     rb
 1747 a1ce: 60                     irx
 1748 a1cf: 74                     adc
 1749 a1d0: bb                     phi     rb
 1750 a1d1: c0 a1 7d               lbr     loopcnt             ; then standard loop code
 1751 a1d4:             
 1752 a1d4: 92          cbegin:    ghi     r2                  ; get copy of machine stack
 1753 a1d5: ba                     phi     ra
 1754 a1d6: 82                     glo     r2
 1755 a1d7: aa                     plo     ra
 1756 a1d8: 1a                     inc     ra                  ; pointing at ra value high
 1757 a1d9: 4a                     lda     ra                  ; get high of ra
 1758 a1da: bb                     phi     rb                  ; put into rb
 1759 a1db: 4a                     lda     ra
 1760 a1dc: ab                     plo     rb
 1761 a1dd: d4                     sep     scall               ; store inst point on return stack
 1762 a1de: 9c 8f                  dw      rpush
 1763 a1e0: c0 a0 17               lbr     good                ; and return
 1764 a1e3:             
 1765 a1e3:             ; [GDJ] corrected logic - BEGIN/UNTIL loop should repeat if flag preceding UNTIL is FALSE
 1766 a1e3: d4          cuntil:    sep     scall               ; get top of stack
 1767 a1e4: 9c 32                  dw      pop
 1768 a1e6: c3 a0 12               lbdf    error               ; jump if stack was empty
 1769 a1e9: 8b                     glo     rb                  ; [GDJ] check flag LSB - if true were done
 1770 a1ea: ca a1 f1               lbnz    untilno             ; [GDJ]
 1771 a1ed: 9b                     ghi     rb                  ; [GDJ] check flag MSB
 1772 a1ee: c2 a1 f7               lbz     untilyes
 1773 a1f1: d4          untilno:   sep     scall               ; pop off begin address
 1774 a1f2: 9c 77                  dw      rpop
 1775 a1f4: c0 a0 17               lbr     good                ; we are done, just return
 1776 a1f7: d4          untilyes:  sep     scall               ; get return address - continue looping
 1777 a1f8: 9c 77                  dw      rpop
 1778 a1fa: d4                     sep     scall               ; also keep on stack
 1779 a1fb: 9c 8f                  dw      rpush
 1780 a1fd: 92                     ghi     r2                  ; get copy of machine stack
 1781 a1fe: ba                     phi     ra
 1782 a1ff: 82                     glo     r2
 1783 a200: aa                     plo     ra
 1784 a201: 1a                     inc     ra                  ; pointing at ra value high
 1785 a202: 9b                     ghi     rb
 1786 a203: 5a                     str     ra                  ; and write it
 1787 a204: 1a                     inc     ra                 
 1788 a205: 8b                     glo     rb                  ; get rb lo value
 1789 a206: 5a                     str     ra                  ; and write it
 1790 a207: c0 a0 17               lbr     good                ; now return
 1791 a20a:             
 1792 a20a: d4          crgt:      sep     scall               ; get value from return stack
 1793 a20b: 9c 77                  dw      rpop
 1794 a20d: d4                     sep     scall               ; push to data stack
 1795 a20e: 9c 61                  dw      push
 1796 a210: c0 a0 17               lbr     good                ; return to caller
 1797 a213:             
 1798 a213: d4          cgtr:      sep     scall               ; get value from stack
 1799 a214: 9c 32                  dw      pop
 1800 a216: c3 a0 12               lbdf    error               ; jump if stack was empty
 1801 a219: d4                     sep     scall               ; push to return stack
 1802 a21a: 9c 8f                  dw      rpush
 1803 a21c: c0 a0 17               lbr     good                ; return to caller
 1804 a21f:             
 1805 a21f: d4          cunequal:  sep     scall               ; get value from stack
 1806 a220: 9c 32                  dw      pop
 1807 a222: c3 a0 12               lbdf    error               ; jump if stack was empty
 1808 a225: 9b                     ghi     rb                  ; move number 
 1809 a226: b7                     phi     r7
 1810 a227: 8b                     glo     rb
 1811 a228: a7                     plo     r7
 1812 a229: d4                     sep     scall               ; get next number
 1813 a22a: 9c 32                  dw      pop
 1814 a22c: c3 a0 12               lbdf    error               ; jump if stack was empty
 1815 a22f: e2                     sex     r2                  ; be sure X points to stack
 1816 a230: 87                     glo     r7                  ; perform and
 1817 a231: 52                     str     r2
 1818 a232: 8b                     glo     rb
 1819 a233: f3                     xor
 1820 a234: ca a2 46               lbnz    unequal             ; jump if not equal
 1821 a237: 97                     ghi     r7
 1822 a238: 52                     str     r2
 1823 a239: 9b                     ghi     rb
 1824 a23a: f3                     xor
 1825 a23b: ca a2 46               lbnz    unequal             ; jump if not equal
 1826 a23e: bb                     phi     rb                  ; set return result
 1827 a23f: ab                     plo     rb
 1828 a240: d4          eq2:       sep     scall               ; put answer back on stack
 1829 a241: 9c 61                  dw      push
 1830 a243: c0 a0 17               lbr     good
 1831 a246: f8 00       unequal:   ldi     0                   ; set return result
 1832 a248: bb                     phi     rb
 1833 a249: ab                     plo     rb
 1834 a24a: 1b                     inc     rb                  ; it is now 1
 1835 a24b: c0 a2 40               lbr     eq2
 1836 a24e:             
 1837 a24e:             
 1838 a24e:             ; [GDJ]
 1839 a24e:             ; determine if NOS < TOS
 1840 a24e: d4          cless:     sep     scall               ; get value from stack
 1841 a24f: 9c 32                  dw      pop
 1842 a251: c3 a0 12               lbdf    error               ; jump if stack was empty
 1843 a254: 9b                     ghi     rb                  ; move number 
 1844 a255: b8                     phi     r8
 1845 a256: 8b                     glo     rb
 1846 a257: a8                     plo     r8
 1847 a258: d4                     sep     scall               ; get next number
 1848 a259: 9c 32                  dw      pop
 1849 a25b: c3 a0 12               lbdf    error               ; jump if stack was empty
 1850 a25e: e2                     sex     r2                  ; be sure X points to stack
 1851 a25f:             
 1852 a25f: 9b                     ghi     rb                  ; move number 
 1853 a260: b7                     phi     r7
 1854 a261: 8b                     glo     rb
 1855 a262: a7                     plo     r7
 1856 a263:             
 1857 a263:                        ; bias numbers for comparison
 1858 a263: 97                     ghi     r7
 1859 a264: fb 80                  xri     080h                ; bias upwards
 1860 a266: b7                     phi     r7
 1861 a267:             
 1862 a267: 98                     ghi     r8
 1863 a268: fb 80                  xri     080h                ; bias upwards
 1864 a26a: b8                     phi     r8
 1865 a26b:             
 1866 a26b: 87                     glo     7                   ; subtract them
 1867 a26c: 52                     str     r2
 1868 a26d: 88                     glo     r8
 1869 a26e: f5                     sd
 1870 a26f: a7                     plo     r7
 1871 a270: 97                     ghi     r7
 1872 a271: 52                     str     r2
 1873 a272: 98                     ghi     r8
 1874 a273: 75                     sdb
 1875 a274: b7                     phi     r7
 1876 a275:             
 1877 a275: cb a2 81               lbnf    less1               ; DF signaled with borrow
 1878 a278: f8 00 ab f8 
            00 bb                  mov     rb, 0
 1879 a27e: c0 a2 87               lbr     lessdone
 1880 a281: f8 01 ab f8 
            00 bb       less1:     mov     rb, 1
 1881 a287: d4          lessdone:  sep     scall               ; put answer back on stack
 1882 a288: 9c 61                  dw      push
 1883 a28a: c0 a0 17               lbr     good
 1884 a28d:             
 1885 a28d:             
 1886 a28d:             
 1887 a28d:             ; [GDJ]
 1888 a28d: d4          culess:    sep     scall               ; get value from stack
 1889 a28e: 9c 32                  dw      pop
 1890 a290: c3 a0 12               lbdf    error               ; jump if stack was empty
 1891 a293: 9b                     ghi     rb                  ; move number 
 1892 a294: b7                     phi     r7
 1893 a295: 8b                     glo     rb
 1894 a296: a7                     plo     r7
 1895 a297: d4                     sep     scall               ; get next number
 1896 a298: 9c 32                  dw      pop
 1897 a29a: c3 a0 12               lbdf    error               ; jump if stack was empty
 1898 a29d: e2                     sex     r2                  ; be sure X points to stack
 1899 a29e:             
 1900 a29e: 9b                     ghi     rb                  ; move number 
 1901 a29f: b8                     phi     r8
 1902 a2a0: 8b                     glo     rb
 1903 a2a1: a8                     plo     r8
 1904 a2a2:             
 1905 a2a2:                        ; perform subtraction r8-r7  (NOS-TOS) to check for borrow
 1906 a2a2: 88                     glo     r8
 1907 a2a3: 52                     str     r2
 1908 a2a4: 87                     glo     r7
 1909 a2a5: f5                     sd
 1910 a2a6: a8                     plo     r8
 1911 a2a7: 98                     ghi     r8
 1912 a2a8: 52                     str     r2
 1913 a2a9: 97                     ghi     r7
 1914 a2aa: 75                     sdb                         ; subtract with borrow
 1915 a2ab: cb a2 b7               lbnf    uless1              ; DF signaled with borrow
 1916 a2ae: f8 00 ab f8 
            00 bb                  mov     rb, 0
 1917 a2b4: c0 a2 bd               lbr     ulessdone
 1918 a2b7: f8 01 ab f8 
            00 bb       uless1:    mov     rb, 1
 1919 a2bd: d4          ulessdone: sep     scall               ; put answer back on stack
 1920 a2be: 9c 61                  dw      push
 1921 a2c0: c0 a0 17               lbr     good
 1922 a2c3:             
 1923 a2c3:             
 1924 a2c3: f8 ad       cwords:    ldi     high cmdtable       ; point to command table
 1925 a2c5: b7                     phi     r7                  ; put into a pointer register
 1926 a2c6: f8 26                  ldi     low cmdtable
 1927 a2c8: a7                     plo     r7
 1928 a2c9: f8 00 ad f8 
            00 bd                  mov     rd, 0
 1929 a2cf: 47          cwordslp:  lda     r7                  ; get byte
 1930 a2d0: c2 a2 fe               lbz     cwordsdn            ; jump if done
 1931 a2d3: ab                     plo     rb                  ; save it
 1932 a2d4: fa 80                  ani     128                 ; check for final of token
 1933 a2d6: ca a2 e0               lbnz    cwordsf             ; jump if so
 1934 a2d9: 8b                     glo     rb                  ; get byte
 1935 a2da: d4                     sep     scall               ; display it
 1936 a2db: 9c 2a                  dw      disp 
 1937 a2dd: c0 a2 cf               lbr     cwordslp            ; and loop back
 1938 a2e0: 8b          cwordsf:   glo     rb                  ; get byte
 1939 a2e1: fa 7f                  ani     07fh                ; strip high bit
 1940 a2e3: d4                     sep     scall               ; display it
 1941 a2e4: 9c 2a                  dw      disp
 1942 a2e6: f8 20                  ldi     ' '                 ; display a space
 1943 a2e8: d4                     sep     scall               ; display it
 1944 a2e9: 9c 2a                  dw      disp
 1945 a2eb: 1d                     inc     rd
 1946 a2ec: 8d                     glo     rd
 1947 a2ed: ff 0c                  smi     12
 1948 a2ef: ca a2 cf               lbnz    cwordslp
 1949 a2f2: f8 00 ad f8 
            00 bd                  mov     rd, 0
 1950 a2f8: d4          	   sep scall
 1951 a2f9: 9c 17       	   dw crlfout
 1952 a2fb: c0 a2 cf               lbr     cwordslp            ; and loop back
 1953 a2fe: d4          cwordsdn:  sep scall
 1954 a2ff: 9c 17       	   dw  crlfout
 1955 a301: f8 03                  ldi     high storage        ; get beginning of program memory
 1956 a303: b7                     phi     r7
 1957 a304: f8 0d                  ldi     low storage
 1958 a306: a7                     plo     r7
 1959 a307: f8 00 ad f8 
            00 bd                  mov     rd, 0
 1960 a30d: 47          cwordslp2: lda     r7                  ; get pointer to next entry
 1961 a30e: b8                     phi     r8                  ; put into r8
 1962 a30f: 47                     lda     r7                  ; now pointing at type indicator
 1963 a310: a8                     plo     r8                  ; save low of link
 1964 a311: ca a3 1e               lbnz    cwordsnot           ; jump if not link terminator
 1965 a314: 98                     ghi     r8                  ; check high byte too
 1966 a315: ca a3 1e               lbnz    cwordsnot
 1967 a318: d4          cwordsdn1: sep  scall
 1968 a319: 9c 17       	   dw   crlfout 
 1969 a31b: c0 a0 17               lbr     good                ; return to caller
 1970 a31e: 17          cwordsnot: inc     r7                  ; now pointing at ascii indicator
 1971 a31f: 17                     inc     r7                  ; first character of name
 1972 a320: 47          wordsnotl: lda     r7                  ; get byte from string
 1973 a321: c2 a3 2a               lbz     wordsnxt            ; jump if end of string
 1974 a324: d4                     sep     scall               ; display it
 1975 a325: 9c 2a                  dw      disp
 1976 a327: c0 a3 20               lbr     wordsnotl           ; keep going
 1977 a32a: f8 20       wordsnxt:  ldi     ' '                 ; want a space
 1978 a32c: d4                     sep     scall               ; display it
 1979 a32d: 9c 2a                  dw      disp
 1980 a32f: 98                     ghi     r8                  ; transfer next word address to r7
 1981 a330: b7                     phi     r7
 1982 a331: 88                     glo     r8
 1983 a332: a7                     plo     r7
 1984 a333: 1d                     inc     rd
 1985 a334: 8d                     glo     rd
 1986 a335: ff 08                  smi     8
 1987 a337: ca a3 0d               lbnz    cwordslp2
 1988 a33a: f8 00 ad f8 
            00 bd                  mov     rd, 0
 1989 a340: d4           	   sep     scall
 1990 a341: 9c 17       	   dw crlfout
 1991 a343: c0 a3 0d               lbr     cwordslp2           ; and check next word
 1992 a346:             
 1993 a346:             
 1994 a346: d4          cemit:     sep     scall               ; get top of stack
 1995 a347: 9c 32                  dw      pop
 1996 a349: c3 a0 12               lbdf    error               ; jump if error
 1997 a34c: 8b                     glo     rb                  ; get low of return value
 1998 a34d: d4                     sep     scall               ; and display ti
 1999 a34e: 9c 2a                  dw      disp
 2000 a350: c0 a0 17               lbr     good                ; return to caller
 2001 a353:             
 2002 a353:             ; [GDJ]
 2003 a353: d4          cemitp:    sep     scall               ; get top of stack
 2004 a354: 9c 32                  dw      pop
 2005 a356: c3 a0 12               lbdf    error               ; jump if error
 2006 a359: 8b                     glo     rb                  ; get low of return value
 2007 a35a:             
 2008 a35a: ff 20                  smi     32                  ; check for below space
 2009 a35c: cb a3 69               lbnf    notprint            ; jump if not printable
 2010 a35f: 8b                     glo     rb
 2011 a360: ff 7f                  smi     127                 ; check for above tilde ~
 2012 a362: c3 a3 69               lbdf    notprint            ; jump if not printable
 2013 a365:             
 2014 a365: 8b                     glo     rb
 2015 a366: c0 a3 6b               lbr     emitpout            ; ok printable
 2016 a369:             
 2017 a369: f8 2e       notprint:  ldi     '.'
 2018 a36b:             
 2019 a36b: d4          emitpout:  sep     scall               ; and display ti
 2020 a36c: 9c 2a                  dw      disp
 2021 a36e: c0 a0 17               lbr     good                ; return to caller
 2022 a371:             
 2023 a371:             
 2024 a371: d4          cwhile:    sep     scall               ; get top of stack
 2025 a372: 9c 32                  dw      pop
 2026 a374: c3 a0 12               lbdf    error               ; jump if error
 2027 a377: 8b                     glo     rb                  ; need to check for zero
 2028 a378: ca a3 ad               lbnz    whileno             ; jump if not zero
 2029 a37b: 9b                     ghi     rb                  ; check high byte
 2030 a37c: ca a3 ad               lbnz    whileno
 2031 a37f: 92                     ghi     r2                  ; copy machine stack to RA
 2032 a380: ba                     phi     ra
 2033 a381: 82                     glo     r2
 2034 a382: aa                     plo     ra
 2035 a383: 1a                     inc     ra                  ; point to R[6]
 2036 a384: 4a                     lda     ra                  ; get command stream
 2037 a385: bb                     phi     rb                  ; put into r6
 2038 a386: 0a                     ldn     ra
 2039 a387: ab                     plo     rb
 2040 a388: f8 00                  ldi     0                   ; set while count to zero
 2041 a38a: a7                     plo     r7
 2042 a38b: 0b          findrep:   ldn     rb                  ; get byte from stream
 2043 a38c: ff 81                  smi     81h                 ; was a while found
 2044 a38e: ca a3 96               lbnz    notwhile            ; jump if not
 2045 a391: 17                     inc     r7                  ; increment while count
 2046 a392: 1b          notrep:    inc     rb                  ; point to next byte
 2047 a393: c0 a3 8b               lbr     findrep             ; and keep looking
 2048 a396: 0b          notwhile:  ldn     rb                  ; retrieve byte
 2049 a397: ff 82                  smi     82h                 ; is it a repeat
 2050 a399: ca a3 92               lbnz    notrep              ; jump if not
 2051 a39c: 87                     glo     r7                  ; get while count
 2052 a39d: c2 a3 a4               lbz     fndrep              ; jump if not zero
 2053 a3a0: 27                     dec     r7                  ; decrement count
 2054 a3a1: c0 a3 92               lbr     notrep              ; and keep looking
 2055 a3a4: 1b          fndrep:    inc     rb                  ; move past the while
 2056 a3a5: 8b                     glo     rb                  ; now put back into R[6]
 2057 a3a6: 5a                     str     ra
 2058 a3a7: 2a                     dec     ra
 2059 a3a8: 9b                     ghi     rb
 2060 a3a9: 5a                     str     ra
 2061 a3aa: c0 a0 17               lbr     good                ; then return to caller
 2062 a3ad: 92          whileno:   ghi     r2                  ; copy machine stack to RA
 2063 a3ae: ba                     phi     ra
 2064 a3af: 82                     glo     r2
 2065 a3b0: aa                     plo     ra
 2066 a3b1: 1a                     inc     ra                  ; now pointing to high byte of R[6]
 2067 a3b2: 4a                     lda     ra                  ; get it
 2068 a3b3: bb                     phi     rb                  ; and put into r6
 2069 a3b4: 0a                     ldn     ra                  ; get low byte
 2070 a3b5: ab                     plo     rb
 2071 a3b6: 2b                     dec     rb                  ; point back to while command
 2072 a3b7: d4                     sep     scall               ; put onto return stack
 2073 a3b8: 9c 8f                  dw      rpush
 2074 a3ba: c0 a0 17               lbr     good                ; then return
 2075 a3bd:             
 2076 a3bd: d4          crepeat:   sep     scall               ; get address on return stack
 2077 a3be: 9c 77                  dw      rpop
 2078 a3c0: 92                     ghi     r2                  ; transfer machine stack to RA
 2079 a3c1: ba                     phi     ra
 2080 a3c2: 82                     glo     r2
 2081 a3c3: aa                     plo     ra
 2082 a3c4: 1a                     inc     ra                  ; now pointing at high byte of R[6]
 2083 a3c5: 9b                     ghi     rb                  ; get while address
 2084 a3c6: 5a                     str     ra                  ; and place into R[6]
 2085 a3c7: 1a                     inc     ra
 2086 a3c8: 8b                     glo     rb
 2087 a3c9: 5a                     str     ra
 2088 a3ca: c0 a0 17               lbr     good                ; then return
 2089 a3cd:                        
 2090 a3cd: d4          cif:       sep     scall               ; get top of stack 
 2091 a3ce: 9c 32                  dw      pop
 2092 a3d0: c3 a0 12               lbdf    error               ; jump if error
 2093 a3d3: 8b                     glo     rb                  ; check for zero
 2094 a3d4: ca a4 13               lbnz    ifno                ; jump if not zero
 2095 a3d7: 9b                     ghi     rb                  ; check hi byte too
 2096 a3d8: ca a4 13               lbnz    ifno                ; jump if not zero
 2097 a3db: 92                     ghi     r2                  ; transfer machine stack to RA
 2098 a3dc: ba                     phi     ra
 2099 a3dd: 82                     glo     r2
 2100 a3de: aa                     plo     ra
 2101 a3df: 1a                     inc     ra                  ; now pointing at R[6]
 2102 a3e0: 4a                     lda     ra                  ; get R[6]
 2103 a3e1: bb                     phi     rb
 2104 a3e2: 0a                     ldn     ra
 2105 a3e3: ab                     plo     rb
 2106 a3e4: f8 00                  ldi     0                   ; set IF count
 2107 a3e6: a7                     plo     r7                  ; put into counter
 2108 a3e7: 0b          iflp1:     ldn     rb                  ; get next byte
 2109 a3e8: ff 83                  smi     83h                 ; check for IF
 2110 a3ea: ca a3 f2               lbnz    ifnotif             ; jump if not
 2111 a3ed: 17                     inc     r7                  ; increment if count
 2112 a3ee: 1b          ifcnt:     inc     rb                  ; point to next byte
 2113 a3ef: c0 a3 e7               lbr     iflp1               ; keep looking
 2114 a3f2: 0b          ifnotif:   ldn     rb                  ; retrieve byte
 2115 a3f3: ff 84                  smi     84h                 ; check for ELSE
 2116 a3f5: ca a4 05               lbnz    ifnotelse           ; jump if not
 2117 a3f8: 87                     glo     r7                  ; get IF count
 2118 a3f9: ca a3 ee               lbnz    ifcnt               ; jump if it is not zero
 2119 a3fc: 1b                     inc     rb                  ; move past the else
 2120 a3fd: 8b          ifsave:    glo     rb                  ; store back into instruction pointer
 2121 a3fe: 5a                     str     ra
 2122 a3ff: 2a                     dec     ra
 2123 a400: 9b                     ghi     rb
 2124 a401: 5a                     str     ra
 2125 a402: c0 a0 17               lbr     good                ; and return
 2126 a405: 0b          ifnotelse: ldn     rb                  ; retrieve byte
 2127 a406: ff 85                  smi     85h                 ; check for THEN
 2128 a408: ca a3 ee               lbnz    ifcnt               ; jump if not
 2129 a40b: 87                     glo     r7                  ; get if count
 2130 a40c: 27                     dec     r7                  ; decrement if count
 2131 a40d: ca a3 ee               lbnz    ifcnt               ; jump if not zero
 2132 a410: c0 a3 fd               lbr     ifsave              ; otherwise found
 2133 a413: c0 a0 17    ifno:      lbr     good                ; no action needed, just return
 2134 a416:             
 2135 a416: 92          celse:     ghi     r2                  ; transfer machine stack to ra
 2136 a417: ba                     phi     ra
 2137 a418: 82                     glo     r2
 2138 a419: aa                     plo     ra
 2139 a41a: 1a                     inc     ra                  ; now pointing at R[6]
 2140 a41b: 4a                     lda     ra                  ; get current R[6]
 2141 a41c: bb                     phi     rb                  ; and place into r6
 2142 a41d: 0a                     ldn     ra
 2143 a41e: ab                     plo     rb
 2144 a41f: f8 00                  ldi     0                   ; count of IFs
 2145 a421: a7                     plo     r7                  ; put into R7
 2146 a422: 0b          elselp1:   ldn     rb                  ; get next byte from stream
 2147 a423: ff 83                  smi     83h                 ; check for IF
 2148 a425: ca a4 2d               lbnz    elsenif             ; jump if not if
 2149 a428: 17                     inc     r7                  ; increment IF count
 2150 a429: 1b          elsecnt:   inc     rb                  ; point to next byte
 2151 a42a: c0 a4 22               lbr     elselp1             ; keep looking
 2152 a42d: 0b          elsenif:   ldn     rb                  ; retrieve byte
 2153 a42e: ff 85                  smi     85h                 ; is it THEN
 2154 a430: ca a4 29               lbnz    elsecnt             ; jump if not
 2155 a433: 87                     glo     r7                  ; get IF count
 2156 a434: 27                     dec     r7                  ; minus 1 IF
 2157 a435: ca a4 29               lbnz    elsecnt             ; jump if not 0
 2158 a438: 8b                     glo     rb                  ; put into instruction pointer
 2159 a439: 5a                     str     ra
 2160 a43a: 2a                     dec     ra
 2161 a43b: 9b                     ghi     rb
 2162 a43c: 5a                     str     ra
 2163 a43d: c0 a0 17               lbr     good                ; now pointing at a then
 2164 a440:             
 2165 a440: c0 a0 17    cthen:     lbr     good                ; then is nothing but a place holder
 2166 a443:             
 2167 a443: d4          cequal:    sep     scall               ; get value from stack
 2168 a444: 9c 32                  dw      pop
 2169 a446: c3 a0 12               lbdf    error               ; jump if stack was empty
 2170 a449: 9b                     ghi     rb                  ; move number 
 2171 a44a: b7                     phi     r7
 2172 a44b: 8b                     glo     rb
 2173 a44c: a7                     plo     r7
 2174 a44d: d4                     sep     scall               ; get next number
 2175 a44e: 9c 32                  dw      pop
 2176 a450: c3 a0 12               lbdf    error               ; jump if stack was empty
 2177 a453: e2                     sex     r2                  ; be sure X points to stack
 2178 a454: 87                     glo     r7                  ; perform and
 2179 a455: 52                     str     r2
 2180 a456: 8b                     glo     rb
 2181 a457: f3                     xor
 2182 a458: ca a4 6b               lbnz    unequal2            ; jump if not equal
 2183 a45b: 97                     ghi     r7
 2184 a45c: 52                     str     r2
 2185 a45d: 9b                     ghi     rb
 2186 a45e: f3                     xor
 2187 a45f: ca a4 6b               lbnz    unequal2            ; jump if not equal
 2188 a462: bb                     phi     rb                  ; set return result
 2189 a463: ab                     plo     rb
 2190 a464: 1b                     inc     rb
 2191 a465: d4          eq3:       sep     scall               ; put answer back on stack
 2192 a466: 9c 61                  dw      push
 2193 a468: c0 a0 17               lbr     good
 2194 a46b: f8 00       unequal2:  ldi     0                   ; set return result
 2195 a46d: bb                     phi     rb
 2196 a46e: ab                     plo     rb
 2197 a46f: c0 a4 65               lbr     eq3
 2198 a472:             
 2199 a472:             
 2200 a472: e2          cdepth:    sex     r2                  ; be sure x is pointing to stack
 2201 a473: f8 08                  ldi     low fstack          ; point to free memory pointer
 2202 a475: a9                     plo     r9                  ; place into data frame
 2203 a476: 49                     lda     r9                  ; get high byte of free memory pointer
 2204 a477: 73                     stxd                        ; store on stack
 2205 a478: 49                     lda     r9                  ; get low byte
 2206 a479: 52                     str     r2                  ; store on stack
 2207 a47a: f8 04                  ldi     low tos             ; get pointer to stack
 2208 a47c: a9                     plo     r9                  ; set into data frame
 2209 a47d: 19                     inc     r9                  ; point to lo byte
 2210 a47e: 09                     ldn     r9                  ; get it
 2211 a47f: f7                     sm                          ; perform subtract
 2212 a480: ab                     plo     rb                  ; put into result
 2213 a481: 29                     dec     r9                  ; high byte of stack pointer
 2214 a482: 60                     irx                         ; point to high byte os free mem
 2215 a483: 09                     ldn     r9                  ; get high byte of stack
 2216 a484: 77                     smb                         ; continue subtraction
 2217 a485: f6                     shr                         ; divide by 2
 2218 a486: bb                     phi     rb                  ; store answer
 2219 a487: 8b                     glo     rb                  ; propagate the shift
 2220 a488: 76                     shrc
 2221 a489: ab                     plo     rb
 2222 a48a: d4                     sep     scall               ; put answer back on stack
 2223 a48b: 9c 61                  dw      push
 2224 a48d: c0 a0 17               lbr     good                ; return
 2225 a490:              
 2226 a490: d4          crot:      sep     scall               ; get C
 2227 a491: 9c 32                  dw      pop
 2228 a493: c3 a0 12               lbdf    error               ; jump if error
 2229 a496: 9b                     ghi     rb                  ; transfer to R7
 2230 a497: b7                     phi     r7
 2231 a498: 8b                     glo     rb
 2232 a499: a7                     plo     r7
 2233 a49a: d4                     sep     scall               ; get B
 2234 a49b: 9c 32                  dw      pop
 2235 a49d: c3 a0 12               lbdf    error               ; jump if error
 2236 a4a0: 9b                     ghi     rb                  ; transfer to R7
 2237 a4a1: b8                     phi     r8
 2238 a4a2: 8b                     glo     rb
 2239 a4a3: a8                     plo     r8
 2240 a4a4: d4                     sep     scall               ; get A
 2241 a4a5: 9c 32                  dw      pop
 2242 a4a7: c3 a0 12               lbdf    error               ; jump if error
 2243 a4aa: 9b                     ghi     rb                  ; transfer to R7
 2244 a4ab: bc                     phi     rc
 2245 a4ac: 8b                     glo     rb
 2246 a4ad: ac                     plo     rc
 2247 a4ae: 98                     ghi     r8                  ; get B
 2248 a4af: bb                     phi     rb
 2249 a4b0: 88                     glo     r8
 2250 a4b1: ab                     plo     rb
 2251 a4b2: d4                     sep     scall               ; put onto stack
 2252 a4b3: 9c 61                  dw      push
 2253 a4b5: 97                     ghi     r7                  ; get C
 2254 a4b6: bb                     phi     rb
 2255 a4b7: 87                     glo     r7
 2256 a4b8: ab                     plo     rb
 2257 a4b9: d4                     sep     scall               ; put onto stack
 2258 a4ba: 9c 61                  dw      push
 2259 a4bc: 9c                     ghi     rc                  ; get A
 2260 a4bd: bb                     phi     rb
 2261 a4be: 8c                     glo     rc
 2262 a4bf: ab                     plo     rb
 2263 a4c0: d4                     sep     scall               ; put onto stack
 2264 a4c1: 9c 61                  dw      push
 2265 a4c3: c0 a0 17               lbr     good                ; return to caller
 2266 a4c6:              
 2267 a4c6: d4          cmrot:     sep     scall               ; get C
 2268 a4c7: 9c 32                  dw      pop
 2269 a4c9: c3 a0 12               lbdf    error               ; jump if error
 2270 a4cc: 9b                     ghi     rb                  ; transfer to R7
 2271 a4cd: b7                     phi     r7
 2272 a4ce: 8b                     glo     rb
 2273 a4cf: a7                     plo     r7
 2274 a4d0: d4                     sep     scall               ; get B
 2275 a4d1: 9c 32                  dw      pop
 2276 a4d3: c3 a0 12               lbdf    error               ; jump if error
 2277 a4d6: 9b                     ghi     rb                  ; transfer to R7
 2278 a4d7: b8                     phi     r8
 2279 a4d8: 8b                     glo     rb
 2280 a4d9: a8                     plo     r8
 2281 a4da: d4                     sep     scall               ; get A
 2282 a4db: 9c 32                  dw      pop
 2283 a4dd: c3 a0 12               lbdf    error               ; jump if error
 2284 a4e0: 9b                     ghi     rb                  ; transfer to R7
 2285 a4e1: bc                     phi     rc
 2286 a4e2: 8b                     glo     rb
 2287 a4e3: ac                     plo     rc
 2288 a4e4: 97                     ghi     r7                  ; get C
 2289 a4e5: bb                     phi     rb
 2290 a4e6: 87                     glo     r7
 2291 a4e7: ab                     plo     rb
 2292 a4e8: d4                     sep     scall               ; put onto stack
 2293 a4e9: 9c 61                  dw      push
 2294 a4eb: 9c                     ghi     rc                  ; get A
 2295 a4ec: bb                     phi     rb
 2296 a4ed: 8c                     glo     rc
 2297 a4ee: ab                     plo     rb
 2298 a4ef: d4                     sep     scall               ; put onto stack
 2299 a4f0: 9c 61                  dw      push
 2300 a4f2: 98                     ghi     r8                  ; get B
 2301 a4f3: bb                     phi     rb
 2302 a4f4: 88                     glo     r8
 2303 a4f5: ab                     plo     rb
 2304 a4f6: d4                     sep     scall               ; put onto stack
 2305 a4f7: 9c 61                  dw      push
 2306 a4f9: c0 a0 17               lbr     good                ; return to caller
 2307 a4fc:              
 2308 a4fc: d4          cover:     sep     scall               ; get B
 2309 a4fd: 9c 32                  dw      pop
 2310 a4ff: c3 a0 12               lbdf    error               ; jump if error
 2311 a502: 9b                     ghi     rb                  ; transfer to R7
 2312 a503: b7                     phi     r7
 2313 a504: 8b                     glo     rb
 2314 a505: a7                     plo     r7
 2315 a506: d4                     sep     scall               ; get A
 2316 a507: 9c 32                  dw      pop
 2317 a509: c3 a0 12               lbdf    error               ; jump if error
 2318 a50c: 9b                     ghi     rb                  ; transfer to R*
 2319 a50d: b8                     phi     r8
 2320 a50e: 8b                     glo     rb
 2321 a50f: a8                     plo     r8
 2322 a510: d4                     sep     scall               ; put onto stack
 2323 a511: 9c 61                  dw      push
 2324 a513: 97                     ghi     r7                  ; get B
 2325 a514: bb                     phi     rb
 2326 a515: 87                     glo     r7
 2327 a516: ab                     plo     rb
 2328 a517: d4                     sep     scall               ; put onto stack
 2329 a518: 9c 61                  dw      push
 2330 a51a: 98                     ghi     r8                  ; get A
 2331 a51b: bb                     phi     rb
 2332 a51c: 88                     glo     r8
 2333 a51d: ab                     plo     rb
 2334 a51e: d4                     sep     scall               ; put onto stack
 2335 a51f: 9c 61                  dw      push
 2336 a521: c0 a0 17               lbr     good                ; return to caller
 2337 a524:                        
 2338 a524: d4          cat:       sep     scall               ; get address from stack
 2339 a525: 9c 32                  dw      pop
 2340 a527: c3 a0 12               lbdf    error               ; jump on error
 2341 a52a: 9b                     ghi     rb                  ; transfer address
 2342 a52b: b7                     phi     r7
 2343 a52c: 8b                     glo     rb
 2344 a52d: a7                     plo     r7
 2345 a52e: 47                     lda     r7                  ; get word at address
 2346 a52f: bb                     phi     rb
 2347 a530: 07                     ldn     r7
 2348 a531: ab                     plo     rb
 2349 a532: d4                     sep     scall               ; put onto stack
 2350 a533: 9c 61                  dw      push
 2351 a535: c0 a0 17               lbr     good                ; return to caller
 2352 a538:                        
 2353 a538: d4          cexcl:     sep     scall               ; get address from stack
 2354 a539: 9c 32                  dw      pop
 2355 a53b: c3 a0 12               lbdf    error               ; jump on error
 2356 a53e: 9b                     ghi     rb                  ; transfer address
 2357 a53f: b7                     phi     r7
 2358 a540: 8b                     glo     rb
 2359 a541: a7                     plo     r7
 2360 a542: d4                     sep     scall               ; date data word from stack
 2361 a543: 9c 32                  dw      pop
 2362 a545: c3 a0 12               lbdf    error               ; jump on error
 2363 a548: 9b                     ghi     rb                  ; write word to memory
 2364 a549: 57                     str     r7
 2365 a54a: 17                     inc     r7
 2366 a54b: 8b                     glo     rb
 2367 a54c: 57                     str     r7
 2368 a54d: c0 a0 17               lbr     good                ; and return
 2369 a550:                        
 2370 a550: d4          ccat:      sep     scall               ; get address from stack
 2371 a551: 9c 32                  dw      pop
 2372 a553: c3 a0 12               lbdf    error               ; jump on error
 2373 a556: 9b                     ghi     rb                  ; transfer address
 2374 a557: b7                     phi     r7
 2375 a558: 8b                     glo     rb
 2376 a559: a7                     plo     r7
 2377 a55a: 47                     lda     r7                  ; get word at address
 2378 a55b: ab                     plo     rb
 2379 a55c: f8 00                  ldi     0                   ; high byte is zero
 2380 a55e: bb                     phi     rb
 2381 a55f: d4                     sep     scall               ; put onto stack
 2382 a560: 9c 61                  dw      push
 2383 a562: c0 a0 17               lbr     good                ; return to caller
 2384 a565:                        
 2385 a565: d4          ccexcl:    sep     scall               ; get address from stack
 2386 a566: 9c 32                  dw      pop
 2387 a568: c3 a0 12               lbdf    error               ; jump on error
 2388 a56b: 9b                     ghi     rb                  ; transfer address
 2389 a56c: b7                     phi     r7
 2390 a56d: 8b                     glo     rb
 2391 a56e: a7                     plo     r7
 2392 a56f: d4                     sep     scall               ; date data word from stack
 2393 a570: 9c 32                  dw      pop
 2394 a572: c3 a0 12               lbdf    error               ; jump on error
 2395 a575: 8b                     glo     rb                  ; write byte to memory
 2396 a576: 57                     str     r7
 2397 a577: c0 a0 17               lbr     good                ; and return
 2398 a57a:             
 2399 a57a: 92          cvariable: ghi     r2                  ; transfer machine stack
 2400 a57b: ba                     phi     ra
 2401 a57c: 82                     glo     r2
 2402 a57d: aa                     plo     ra
 2403 a57e: 1a                     inc     ra                  ; point to R[6]
 2404 a57f: 4a                     lda     ra                  ; and retrieve it
 2405 a580: bb                     phi     rb
 2406 a581: 0a                     ldn     ra
 2407 a582: ab                     plo     rb
 2408 a583: 0b                     ldn     rb                  ; get next byte
 2409 a584: ff fe                  smi     T_ASCII             ; it must be an ascii mark
 2410 a586: ca a0 12               lbnz    error               ; jump if not
 2411 a589: 1b                     inc     rb                  ; move into string
 2412 a58a: 4b          varlp1:    lda     rb                  ; get byte
 2413 a58b: ca a5 8a               lbnz    varlp1              ; jump if terminator not found
 2414 a58e: 1b                     inc     rb                  ; allow space for var value
 2415 a58f: 1b                     inc     rb                  ; new value of freemem
 2416 a590: f8 06                  ldi     low freemem         ; get current free memory pointer
 2417 a592: a9                     plo     r9                  ; put into data segment
 2418 a593: 49                     lda     r9                  ; get current pointer
 2419 a594: b7                     phi     r7                  ; place here
 2420 a595: 09                     ldn     r9                  ; get low byte
 2421 a596: a7                     plo     r7
 2422 a597: 9b                     ghi     rb                  ; get memory pointer
 2423 a598: 57                     str     r7                  ; and store into link list
 2424 a599: 17                     inc     r7
 2425 a59a: 8b                     glo     rb
 2426 a59b: 57                     str     r7
 2427 a59c: 8b                     glo     rb                  ; store new freemem value
 2428 a59d: 59                     str     r9
 2429 a59e: 29                     dec     r9
 2430 a59f: 9b                     ghi     rb
 2431 a5a0: 59                     str     r9
 2432 a5a1: f8 00                  ldi     0                   ; need zero at end of list
 2433 a5a3: 5b                     str     rb                  ; store it
 2434 a5a4: 1b                     inc     rb
 2435 a5a5: 5b                     str     rb
 2436 a5a6: 8b                     glo     rb                  ; write back to instruction pointer
 2437 a5a7: 5a                     str     ra
 2438 a5a8: 2a                     dec     ra
 2439 a5a9: 9b                     ghi     rb
 2440 a5aa: 5a                     str     ra
 2441 a5ab: c0 a0 17               lbr     good                ; return
 2442 a5ae:             
 2443 a5ae: 92          ccolon:    ghi     r2                  ; transfer machine stack
 2444 a5af: ba                     phi     ra
 2445 a5b0: 82                     glo     r2
 2446 a5b1: aa                     plo     ra
 2447 a5b2: 1a                     inc     ra                  ; point to R[6]
 2448 a5b3: 4a                     lda     ra                  ; and retrieve it
 2449 a5b4: bb                     phi     rb
 2450 a5b5: 0a                     ldn     ra
 2451 a5b6: ab                     plo     rb
 2452 a5b7: 0b                     ldn     rb                  ; get next byte
 2453 a5b8: ff fe                  smi     T_ASCII             ; it must be an ascii mark
 2454 a5ba: ca a0 12               lbnz    error               ; jump if not
 2455 a5bd: 1b                     inc     rb                  ; move into string
 2456 a5be: 4b          colonlp1:  lda     rb                  ; get byte
 2457 a5bf: ff 88                  smi     88h                 ; look for the ;
 2458 a5c1: ca a5 be               lbnz    colonlp1            ; jump if terminator not found
 2459 a5c4: f8 00                  ldi     0                   ; want a command terminator
 2460 a5c6: 5b                     str     rb                  ; write it
 2461 a5c7: 1b                     inc     rb                  ; new value for freemem
 2462 a5c8: f8 06                  ldi     low freemem         ; get current free memory pointer
 2463 a5ca: a9                     plo     r9                  ; put into data segment
 2464 a5cb: 49                     lda     r9                  ; get current pointer
 2465 a5cc: b7                     phi     r7                  ; place here
 2466 a5cd: 09                     ldn     r9                  ; get low byte
 2467 a5ce: a7                     plo     r7
 2468 a5cf: 9b                     ghi     rb                  ; get memory pointer
 2469 a5d0: 57                     str     r7                  ; and store into link list
 2470 a5d1: 17                     inc     r7
 2471 a5d2: 8b                     glo     rb
 2472 a5d3: 57                     str     r7
 2473 a5d4: 8b                     glo     rb                  ; store new freemem value
 2474 a5d5: 59                     str     r9
 2475 a5d6: 29                     dec     r9
 2476 a5d7: 9b                     ghi     rb
 2477 a5d8: 59                     str     r9
 2478 a5d9: f8 00                  ldi     0                   ; need zero at end of list
 2479 a5db: 5b                     str     rb                  ; store it
 2480 a5dc: 1b                     inc     rb
 2481 a5dd: 5b                     str     rb
 2482 a5de: 8b                     glo     rb                  ; write back to instruction pointer
 2483 a5df: 5a                     str     ra
 2484 a5e0: 2a                     dec     ra
 2485 a5e1: 9b                     ghi     rb
 2486 a5e2: 5a                     str     ra
 2487 a5e3: c0 a0 17               lbr     good                ; return
 2488 a5e6:             
 2489 a5e6: c0 a0 17    csemi:     lbr     good
 2490 a5e9:             
 2491 a5e9:             
 2492 a5e9: 92          csee:      ghi     r2                  ; transfer machine stack
 2493 a5ea: ba                     phi     ra
 2494 a5eb: 82                     glo     r2
 2495 a5ec: aa                     plo     ra
 2496 a5ed: 1a                     inc     ra                  ; point to R[6]
 2497 a5ee: 4a                     lda     ra                  ; and retrieve it
 2498 a5ef: b8                     phi     r8
 2499 a5f0: 0a                     ldn     ra
 2500 a5f1: a8                     plo     r8
 2501 a5f2: 08                     ldn     r8                  ; get next byte
 2502 a5f3: ff fe                  smi     T_ASCII             ; it must be an ascii mark
 2503 a5f5: ca a0 12               lbnz    error               ; jump if not
 2504 a5f8: 18                     inc     r8                  ; move into string
 2505 a5f9: d4                     sep     scall               ; find the name
 2506 a5fa: 9c a5                  dw      findname
 2507 a5fc: c3 a0 12               lbdf    error               ; jump if not found
 2508 a5ff: 88                     glo     r8                  ; put new address into inst pointer
 2509 a600: 5a                     str     ra 
 2510 a601: 2a                     dec     ra
 2511 a602: 98                     ghi     r8
 2512 a603: 5a                     str     ra
 2513 a604: d4          	   sep     scall
 2514 a605: a6 14       	   dw      csee_sub
 2515 a607: c0 a0 17    	   lbr     good                ; otherwise good	
 2516 a60a:             	
 2517 a60a:             	;;  make see callable so we can use it from inside Forth words
 2518 a60a:             	;;  r7= address of descriptor  (main pointer to word; points to next address)
 2519 a60a:             	;;  rb = first byte in data
 2520 a60a:             	;;  user callable csee_sub0 only requires r7. If r7 and rb are set call csee_sub
 2521 a60a:             csee_sub0:
 2522 a60a: 97          	ghi r7
 2523 a60b: bb          	phi rb
 2524 a60c: 87          	glo r7
 2525 a60d: ab          	plo rb
 2526 a60e: 1b          	inc rb
 2527 a60f: 1b          	inc rb
 2528 a610: 0b          csub0:	ldn rb    		; set up rb to point correctly
 2529 a611: 1b          	inc rb
 2530 a612: 3a 10       	bnz csub0
 2531 a614:             csee_sub:
 2532 a614: 47          	lda r7          ; move past next address  (store next in in RF for later)
 2533 a615: bf          	phi rf
 2534 a616: 47          	lda r7
 2535 a617: af          	plo rf
 2536 a618: 07                     ldn     r7                  ; get type byte
 2537 a619: ff 86                  smi     86h                 ; check for variable
 2538 a61b: ca a6 c0               lbnz    cseefunc            ; jump if not
 2539 a61e: d4          	   sep scall
 2540 a61f: ff 66       	   dw f_inmsg
 2541 a621: 56 41 52 49 
            41 42 4c 45 
            20 00       	   db 'VARIABLE ',0
 2542 a62b: 17          	   inc r7		       ; skip variable mark
 2543 a62c: 87 73 97 73 	   push r7
 2544 a630:             seevname:
 2545 a630: 17          	inc	   r7		       ; point to name
 2546 a631: 07          	ldn	   r7
 2547 a632: 32 39       	bz seeveq
 2548 a634: d4          	sep scall
 2549 a635: 9c 2a       	dw disp
 2550 a637: 30 30       	br seevname
 2551 a639:             seeveq:
 2552 a639:             	;;  need to see if we need an allot here 
 2553 a639:             	;; if [next]-2 == rb then we do not need it
 2554 a639: 2f          	dec rf
 2555 a63a: 2f          	dec rf 			; next-2
 2556 a63b: 8f          	glo rf
 2557 a63c: 52          	str r2
 2558 a63d: 8b          	glo rb   ; (next-2)-dataaddress
 2559 a63e: f5          	sd
 2560 a63f: af          	plo rf
 2561 a640: 9f          	ghi rf
 2562 a641: 52          	str r2
 2563 a642: 9b          	ghi rb
 2564 a643: 75          	sdb
 2565 a644: bf          	phi rf   		; now RF is the offset
 2566 a645: 52          	str r2
 2567 a646: 8f          	glo rf
 2568 a647: f1          	or
 2569 a648: 32 9a       	bz seevnoa            	; was equal, jump
 2570 a64a:             seevallot:	
 2571 a64a:             	;; ok we need to do the allot here
 2572 a64a: d4          	sep scall
 2573 a64b: 9c 17       	dw crlfout
 2574 a64d: 8b 73 9b 73 	push rb
 2575 a651: 9f          	ghi rf
 2576 a652: f6          	shr
 2577 a653: bb          	phi rb
 2578 a654: 8f          	glo rf
 2579 a655: 76          	shrc 
 2580 a656: ab          	plo rb
 2581 a657: d4          	sep scall
 2582 a658: ab ce       	dw typenumind    	; type count
 2583 a65a:             
 2584 a65a: d4          	sep scall
 2585 a65b: ff 66       	dw f_inmsg
 2586 a65d: 41 4c 4c 4f 
            54 0a 0d 00 	db 'ALLOT',10,13,0
 2587 a665:             	;;   dump all words (rf has byte count which needs +2 for the original word)
 2588 a665: 1f          	inc rf
 2589 a666: 1f          	inc rf
 2590 a667: 60 72 bb f0 
            ab          	pop rb 			; start address
 2591 a66c:             seesto:	
 2592 a66c: 8b 73 9b 73 	push rb  		; save for addr disp	
 2593 a670: 4b          	lda rb
 2594 a671: b7          	phi r7
 2595 a672: 4b          	lda rb
 2596 a673: ab          	plo rb
 2597 a674: 97          	ghi r7
 2598 a675: bb          	phi rb
 2599 a676: d4          	sep scall
 2600 a677: ab ce       	dw typenumind   	; print data
 2601 a679: 60 72 bb f0 
            ab          	pop rb  		; print address
 2602 a67e: d4          	sep scall
 2603 a67f: ab ce       	dw typenumind
 2604 a681: d4          	sep scall		;print !
 2605 a682: ff 66       	dw f_inmsg
 2606 a684: 21 0a 0d 00 	db '!',10,13,0
 2607 a688: 1b          	inc rb			; point to next word
 2608 a689: 1b          	inc rb
 2609 a68a: 2f          	dec rf			; two less bytes
 2610 a68b: 2f          	dec rf
 2611 a68c:             	;;  stop when rf is zero (assumes rf was even)
 2612 a68c: 8f          	glo rf
 2613 a68d: ca a6 6c    	lbnz seesto
 2614 a690: 9f          	ghi rf
 2615 a691: ca a6 6c    	lbnz seesto
 2616 a694: 60 72 b7 f0 
            a7          	pop r7
 2617 a699: d5          	sep sret   		; final CRLF already in place
 2618 a69a:             	
 2619 a69a:             seevnoa:	
 2620 a69a: f8 20       	ldi ' '
 2621 a69c: d4          	sep scall
 2622 a69d: 9c 2a       	dw disp
 2623 a69f: 4b                     lda     rb                  ; get value
 2624 a6a0: b7                     phi     r7
 2625 a6a1: 4b                     lda     rb
 2626 a6a2: ab                     plo     rb
 2627 a6a3: 97                     ghi     r7
 2628 a6a4: bb                     phi     rb
 2629 a6a5:                        
 2630 a6a5:                        ;sep     scall               ; display the value
 2631 a6a5:                        ;dw      intout
 2632 a6a5:                        ;   [GDJ]
 2633 a6a5: d4                     sep     scall               ; display the value
 2634 a6a6: ab ce                  dw      typenumind
 2635 a6a8: 60 72 b7 f0 
            a7          	pop r7
 2636 a6ad:             seevname1:
 2637 a6ad: 17          	inc r7
 2638 a6ae: 07          	ldn r7
 2639 a6af: 32 b6       	bz seeveq1
 2640 a6b1: d4          	sep scall
 2641 a6b2: 9c 2a       	dw disp
 2642 a6b4: 30 ad       	br seevname1
 2643 a6b6:             seeveq1:
 2644 a6b
6: d4          	sep scall
 2645 a6b7: ff 66       	dw f_inmsg
 2646 a6b9: 20 21 00    	db ' !',0
 2647 a6bc: d4          seeexit:   sep scall
 2648 a6bd: 9c 17       	   dw crlfout
 2649 a6bf: d5                     sep     sret
 2650 a6c0: f8 3a       cseefunc:  ldi     ':'                 ; start with a colon
 2651 a6c2: d4                     sep     scall               ; display character
 2652 a6c3: 9c 2a                  dw      disp
 2653 a6c5: 17                     inc     r7                  ; move address to name
 2654 a6c6: f8 20       seefunclp: ldi     ' '                 ; need a spae
 2655 a6c8: d4                     sep     scall               ; display character
 2656 a6c9: 9c 2a                  dw      disp
 2657 a6cb: 07                     ldn     r7                  ; get next token
 2658 a6cc: c2 a6 bc               lbz     seeexit             ; jump if done
 2659 a6cf: ff fe                  smi     T_ASCII             ; check for ascii
 2660 a6d1: ca a6 e4               lbnz    seenota             ; jump if not ascii
 2661 a6d4: 17                     inc     r7                  ; move into string
 2662 a6d5: 07          seestrlp:  ldn     r7                  ; get next byte
 2663 a6d6: c2 a6 e0               lbz     seenext             ; jump if done with token
 2664 a6d9: d4                     sep     scall               ; display character
 2665 a6da: 9c 2a                  dw      disp
 2666 a6dc: 17                     inc     r7                  ; point to next character
 2667 a6dd: c0 a6 d5               lbr     seestrlp            ; and continue til done
 2668 a6e0: 17          seenext:   inc     r7                  ; point to next token
 2669 a6e1: c0 a6 c6               lbr     seefunclp
 2670 a6e4: 07          seenota:   ldn     r7                  ; reget token
 2671 a6e5: ff ff                  smi     T_NUM               ; is it a number
 2672 a6e7: ca a6 fe               lbnz    seenotn             ; jump if not a number
 2673 a6ea: 17                     inc     r7                  ; move past token
 2674 a6eb: 47                     lda     r7                  ; get number into rb
 2675 a6ec: bb                     phi     rb
 2676 a6ed: 07                     ldn     r7
 2677 a6ee: ab                     plo     rb
 2678 a6ef: 87                     glo     r7                  ; save r7
 2679 a6f0: 73                     stxd
 2680 a6f1: 97                     ghi     r7
 2681 a6f2: 73                     stxd
 2682 a6f3:             
 2683 a6f3:                        ;sep     scall               ; display the number
 2684 a6f3:                        ;dw      intout
 2685 a6f3:                        ; [GDJ]
 2686 a6f3: d4                     sep     scall
 2687 a6f4: ab ce                  dw      typenumind             ; display the number
 2688 a6f6: 60                     irx                         ; retrieve r7
 2689 a6f7: 72                     ldxa
 2690 a6f8: b7                     phi     r7
 2691 a6f9: f0                     ldx
 2692 a6fa: a7                     plo     r7
 2693 a6fb: c0 a6 e0               lbr     seenext             ; on to next token
 2694 a6fe: f8 ad       seenotn:   ldi     high cmdtable       ; point to command table
 2695 a700: bb                     phi     rb
 2696 a701: f8 26                  ldi     low cmdtable
 2697 a703: ab                     plo     rb
 2698 a704: 07                     ldn     r7                  ; get token
 2699 a705: fa 7f                  ani     07fh                ; strip high bit
 2700 a707: a8                     plo     r8                  ; token counter
 2701 a708: 28          seenotnlp: dec     r8                  ; decrement count
 2702 a709: 88                     glo     r8                  ; get count
 2703 a70a: c2 a7 16               lbz     seetoken            ; found the token
 2704 a70d: 4b          seelp3:    lda     rb                  ; get byte from token
 2705 a70e: fa 80                  ani     128                 ; was it last one?
 2706 a710: ca a7 08               lbnz    seenotnlp           ; jump if it was
 2707 a713: c0 a7 0d               lbr     seelp3              ; keep looking
 2708 a716: 0b          seetoken:  ldn     rb                  ; get byte from token
 2709 a717: fa 80                  ani     128                 ; is it last
 2710 a719: ca a7 24               lbnz    seetklast           ; jump if so
 2711 a71c: 0b                     ldn     rb                  ; retrieve byte
 2712 a71d: d4                     sep     scall               ; display it
 2713 a71e: 9c 2a                  dw      disp
 2714 a720: 1b                     inc     rb                  ; point to next character
 2715 a721: c0 a7 16               lbr     seetoken            ; and loop til done
 2716 a724: 0b          seetklast: ldn     rb                  ; retrieve byte
 2717 a725: fa 7f                  ani     07fh                ; strip high bit
 2718 a727: d4                     sep     scall               ; display it
 2719 a728: 9c 2a                  dw      disp
 2720 a72a: c0 a6 e0               lbr     seenext             ; jump for next token
 2721 a72d:             
 2722 a72d: 92          cdotqt:    ghi     r2                  ; transfer machine stack
 2723 a72e: ba                     phi     ra
 2724 a72f: 82                     glo     r2
 2725 a730: aa                     plo     ra
 2726 a731: 1a                     inc     ra                  ; point to R[6]
 2727 a732: 4a                     lda     ra                  ; and retrieve it
 2728 a733: b8                     phi     r8
 2729 a734: 0a                     ldn     ra
 2730 a735: a8                     plo     r8
 2731 a736: 08                     ldn     r8                  ; get next byte
 2732 a737: ff fe                  smi     T_ASCII             ; it must be an ascii mark
 2733 a739: ca a0 12               lbnz    error               ; jump if not
 2734 a73c: 18                     inc     r8                  ; move past ascii mark
 2735 a73d: 48          cdotqtlp:  lda     r8                  ; get next byte
 2736 a73e: c2 a7 4e               lbz     cdotqtdn            ; jump if terinator
 2737 a741: ff 22                  smi     34                  ; check for quote
 2738 a743: c2 a7 3d               lbz     cdotqtlp            ; do not display quotes
 2739 a746: 28                     dec     r8
 2740 a747: 48                     lda     r8
 2741 a748: d4                     sep     scall               ; display byte
 2742 a749: 9c 2a                  dw      disp
 2743 a74b: c0 a7 3d               lbr     cdotqtlp            ; loop back
 2744 a74e: 88          cdotqtdn:  glo     r8                  ; put pointer back
 2745 a74f: 5a                     str     ra
 2746 a750: 2a                     dec     ra
 2747 a751: 98                     ghi     r8
 2748 a752: 5a                     str     ra
 2749 a753: c0 a0 17               lbr     good                ; and return
 2750 a756:             
 2751 a756: d4          ckey:      sep     scall               ; go and get a key
 2752 a757: 9c 2e                  dw      getkey
 2753 a759: ab                     plo     rb                  ; put into rb
 2754 a75a: f8 00                  ldi     0                   ; zero the high byte
 2755 a75c: bb                     phi     rb
 2756 a75d: d4                     sep     scall               ; place key on the stack
 2757 a75e: 9c 61                  dw      push
 2758 a760: c0 a0 17               lbr     good                ; then return to caller
 2759 a763:             	;; [GDJ]				
 2760 a763: f8 00 a7 f8 
            00 b7       ckeyq:     mov     r7, 0
 2761 a769: d4                     sep     scall               ; check for key pressed
 2762 a76a: ac 94                  dw      inkey
 2763 a76c: 87                     glo     r7
 2764 a76d: ab                     plo     rb                  ; put into rb
 2765 a76e: f8 00                  ldi     0                   ; zero the high byte
 2766 a770: bb                     phi     rb
 2767 a771: d4                     sep     scall               ; place key or null on the stack
 2768 a772: 9c 61                  dw      push
 2769 a774: c0 a0 17               lbr     good                ; then return to caller
 2770 a777:             
 2771 a777: f8 03       callot:    ldi     high storage        ; get address of storage
 2772 a779: b7                     phi     r7
 2773 a77a: f8 0d                  ldi     low storage
 2774 a77c: a7                     plo     r7
 2775 a77d: 47          callotlp1: lda     r7                  ; get next link
 2776 a77e: b8                     phi     r8
 2777 a77f: 07                     ldn     r7
 2778 a780: a8                     plo     r8
 2779 a781: 48                     lda     r8                  ; get value at that link
 2780 a782: bb                     phi     rb
 2781 a783: 08                     ldn     r8
 2782 a784: 28                     dec     r8                  ; keep r8 pointing at link
 2783 a785: ca a7 8f               lbnz    callotno            ; jump if next link is not zero
 2784 a788: 9b                     ghi     rb                  ; check high byte
 2785 a789: ca a7 8f               lbnz    callotno            ; jump if not zero
 2786 a78c: c0 a7 96               lbr     callotyes
 2787 a78f: 98          callotno:  ghi     r8                  ; transfer link to r7
 2788 a790: b7                     phi     r7
 2789 a791: 88                     glo     r8
 2790 a792: a7                     plo     r7
 2791 a793: c0 a7 7d               lbr     callotlp1           ; and keep looking
 2792 a796: 17          callotyes: inc     r7                  ; point to type byte
 2793 a797: 07                     ldn     r7                  ; get it
 2794 a798: ff 86                  smi     FVARIABLE           ; it must be a variable
 2795 a79a: ca a0 12               lbnz    error               ; jump if not
 2796 a79d: d4                     sep     scall               ; get word from stack
 2797 a79e: 9c 32                  dw      pop
 2798 a7a0: c3 a0 12               lbdf    error               ; jump if error
 2799 a7a3: 8b                     glo     rb                  ; multiply by 2
 2800 a7a4: fe                     shl
 2801 a7a5: ab                     plo     rb
 2802 a7a6: 9b                     ghi     rb
 2803 a7a7: 7e                     shlc
 2804 a7a8: bb                     phi     rb
 2805 a7a9: e2                     sex     r2                  ; be sure X points to stack
 2806 a7aa: 8b                     glo     rb                  ; add rb to r8
 2807 a7ab: 52                     str     r2
 2808 a7ac: 88                     glo     r8
 2809 a7ad: f4                     add
 2810 a7ae: a8                     plo     r8
 2811 a7af: 9b                     ghi     rb
 2812 a7b0: 52                     str     r2
 2813 a7b1: 98                     ghi     r8
 2814 a7b2: 74                     adc
 2815 a7b3: b8                     phi     r8
 2816 a7b4: 27                     dec     r7                  ; point back to link
 2817 a7b5: 88                     glo     r8                  ; and write new pointer
 2818 a7b6: 57                     str     r7
 2819 a7b7: 27                     dec     r7
 2820 a7b8: 98                     ghi     r8
 2821 a7b9: 57                     str     r7
 2822 a7ba: f8 06                  ldi     low freemem         ; need to adjust free memory pointer
 2823 a7bc: a9                     plo     r9                  ; put into data frame
 2824 a7bd: 98                     ghi     r8                  ; and save new memory position
 2825 a7be: 59                     str     r9
 2826 a7bf: 19                     inc     r9
 2827 a7c0: 88                     glo     r8
 2828 a7c1: 59                     str     r9
 2829 a7c2: f8 00                  ldi     0                   ; zero new position
 2830 a7c4: 58                     str     r8
 2831 a7c5: 18                     inc     r8
 2832 a7c6: 58                     str     r8
 2833 a7c7: c0 a0 17               lbr     good
 2834 a7ca:             
 2835 a7ca: d4          cmul:      sep     scall               ; get first value from stack
 2836 a7cb: 9c 32                  dw      pop
 2837 a7cd: c3 a0 12               lbdf    error               ; jump on error
 2838 a7d0: 9b                     ghi     rb                  ; transfer to r7
 2839 a7d1: b7                     phi     r7
 2840 a7d2: 8b                     glo     rb
 2841 a7d3: a7                     plo     r7
 2842 a7d4: d4                     sep     scall               ; get second number
 2843 a7d5: 9c 32                  dw      pop
 2844 a7d7: c3 a0 12               lbdf    error               ; jump on error
 2845 a7da: d4                     sep     scall               ; call multiply routine
 2846 a7db: 9c e8                  dw      mul16
 2847 a7dd: d4                     sep     scall               ; push onto stack
 2848 a7de: 9c 61                  dw      push
 2849 a7e0: c0 a0 17               lbr     good                ; return
 2850 a7e3:             
 2851 a7e3: d4          cdiv:      sep     scall               ; get first value from stack
 2852 a7e4: 9c 32                  dw      pop
 2853 a7e6: c3 a0 12               lbdf    error               ; jump on error
 2854 a7e9: 9b                     ghi     rb                  ; transfer to r7
 2855 a7ea: b7                     phi     r7
 2856 a7eb: 8b                     glo     rb
 2857 a7ec: a7                     plo     r7
 2858 a7ed: d4                     sep     scall               ; get second number
 2859 a7ee: 9c 32                  dw      pop
 2860 a7f0: c3 a0 12               lbdf    error               ; jump on error
 2861 a7f3: e2                     sex     r2
 2862 a7f4: 99                     ghi     r9
 2863 a7f5: 73                     stxd
 2864 a7f6: d4                     sep     scall               ; call multiply routine
 2865 a7f7: 9d 47                  dw      div16
 2866 a7f9: 60                     irx
 2867 a7fa: f0                     ldx
 2868 a7fb: b9                     phi     r9
 2869 a7fc: 9c                     ghi     rc                  ; transfer answer
 2870 a7fd: bb                     phi     rb
 2871 a7fe: 8c                     glo     rc
 2872 a7ff: ab                     plo     rb
 2873 a800: d4                     sep     scall               ; push onto stack
 2874 a801: 9c 61                  dw      push
 2875 a803: c0 a0 17               lbr     good                ; return
 2876 a806:             
 2877 a806: 92          cforget:   ghi     r2                  ; transfer machine stack
 2878 a807: ba                     phi     ra
 2879 a808: 82                     glo     r2
 2880 a809: aa                     plo     ra
 2881 a80a: 1a                     inc     ra                  ; point to ra
 2882 a80b: 4a                     lda     ra                  ; and retrieve it
 2883 a80c: b8                     phi     r8
 2884 a80d: 0a                     ldn     ra
 2885 a80e: a8                     plo     r8
 2886 a80f: 08                     ldn     r8                  ; get next byte
 2887 a810: ff fe                  smi     T_ASCII             ; it must be an ascii mark
 2888 a812: ca a0 12               lbnz    error               ; jump if not
 2889 a815: 18                     inc     r8                  ; move into string
 2890 a816: d4                     sep     scall               ; find the name
 2891 a817: 9c a5                  dw      findname
 2892 a819: c3 a0 12               lbdf    error               ; jump if not found
 2893 a81c: 88                     glo     r8
 2894 a81d: 5a                     str     ra
 2895 a81e: 2a                     dec     ra
 2896 a81f: 98                     ghi     r8
 2897 a820: 5a                     str     ra
 2898 a821: 47                     lda     r7                  ; get next entry
 2899 a822: bb                     phi     rb
 2900 a823: 07                     ldn     r7
 2901 a824: ab                     plo     rb
 2902 a825: 27                     dec     r7
 2903 a826: e2                     sex     r2                  ; be sure X is pointing to stack
 2904 a827: 87                     glo     r7                  ; find difference in pointers
 2905 a828: 52                     str     r2
 2906 a829: 8b                     glo     rb
 2907 a82a: f7                     sm
 2908 a82b: ac                     plo     rc
 2909 a82c: 97                     ghi     r7
 2910 a82d: 52                     str     r2
 2911 a82e: 9b                     ghi     rb
 2912 a82f: 77                     smb
 2913 a830: bc                     phi     rc                  ; RC now has offset, RB is next descr.
 2914 a831: 4b          forgetlp1: lda     rb                  ; get pointer
 2915 a832: ba                     phi     ra                  ; put into ra
 2916 a833: 52                     str     r2
 2917 a834: 0b                     ldn     rb
 2918 a835: aa                     plo     ra
 2919 a836: f1                     or                          ; see if it was zero
 2920 a837: c2 a8 4c               lbz     forgetd1            ; jump if it was
 2921 a83a: 8c                     glo     rc                  ; subtract RC from RA
 2922 a83b: 52                     str     r2
 2923 a83c: 8a                     glo     ra
 2924 a83d: f7                     sm
 2925 a83e: 5b                     str     rb                  ; store back into pointer
 2926 a83f: 2b                     dec     rb
 2927 a840: 9c                     ghi     rc
 2928 a841: 52                     str     r2
 2929 a842: 9a                     ghi     ra
 2930 a843: 77                     smb
 2931 a844: 5b                     str     rb
 2932 a845: 9a                     ghi     ra                  ; transfer value
 2933 a846: bb                     phi     rb
 2934 a847: 8a                     glo     ra
 2935 a848: ab                     plo     rb
 2936 a849: c0 a8 31               lbr     forgetlp1           ; loop until done
 2937 a84c:             
 2938 a84c: 47          forgetd1:  lda     r7                  ; get next entry
 2939 a84d: bb                     phi     rb
 2940 a84e: 07                     ldn     r7
 2941 a84f: ab                     plo     rb
 2942 a850: 27                     dec     r7
 2943 a851:             
 2944 a851: f8 06                  ldi     low freemem         ; get end of memory pointer
 2945 a853: a9                     plo     r9                  ; and place into data frame
 2946 a854: 49                     lda     r9                  ; get free memory position
 2947 a855: b8                     phi     r8
 2948 a856: 09                     ldn     r9
 2949 a857: a8                     plo     r8
 2950 a858: 18                     inc     r8                  ; account for zero bytes at end
 2951 a859: 18                     inc     r8
 2952 a85a: 8b                     glo     rb                  ; subtract RB from R8
 2953 a85b: 52                     str     r2
 2954 a85c: 88                     glo     r8
 2955 a85d: f7                     sm
 2956 a85e: a8                     plo     r8
 2957 a85f: 9b                     ghi     rb
 2958 a860: 52                     str     r2
 2959 a861: 98                     ghi     r8
 2960 a862: 77                     smb
 2961 a863: b8                     phi     r8                  ; r8 now has number of bytes to move
 2962 a864: 4b          forgetlp:  lda     rb                  ; get byte from higher memory
 2963 a865: 57                     str     r7                  ; write to lower memory
 2964 a866: 17                     inc     r7                  ; point to next position
 2965 a867: 28                     dec     r8                  ; decrement the count
 2966 a868: 88                     glo     r8                  ; check for zero
 2967 a869: ca a8 64               lbnz    forgetlp
 2968 a86c: 98                     ghi     r8
 2969 a86d: ca a8 64               lbnz    forgetlp
 2970 a870: 27                     dec     r7                  ; move back to freemem position
 2971 a871: 27                     dec     r7 
 2972 a872: 87                     glo     r7                  ; store back into freemem pointer
 2973 a873: 59                     str     r9
 2974 a874: 29                     dec     r9
 2975 a875: 97                     ghi     r7
 2976 a876: 59                     str     r9
 2977 a877: c0 a0 17               lbr     good                ; and return
 2978 a87a:             
 2979 a87a: d4          cerror:    sep     scall               ; get number fro stack
 2980 a87b: 9c 32                  dw      pop
 2981 a87d: c3 a0 12               lbdf    error               ; jump on error
 2982 a880: 8b                     glo     rb                  ; get returned value
 2983 a881: c0 9f ad               lbr     execret             ; return to caller
 2984 a884:             
 2985 a884:             ; [GDJ]
 2986 a884:             ; following org prevents short branch out of page for bn1..bn4
 2987 a884:             ; if any preceding code is added - may need change depending on
 2988 a884:             ; amount of any further additions above
 2989 a884:             ;           org 2e00h 
 2990 a884:             
 2991 a884: f8 00       cef:       ldi     0                   ; start with zero
 2992 a886: 3c 8a                  bn1     cef1                ; jump if ef1 not on
 2993 a888: f9 01                  ori     1                   ; signal ef1 is on
 2994 a88a: 3d 8e       cef1:      bn2     cef2                ; jump if ef2 ot on
 2995 a88c: f9 02                  ori     2                   ; signal ef2 is on
 2996 a88e: 3e 92       cef2:      bn3     cef3                ; jump if ef3 not on
 2997 a890: f9 04                  ori     4                   ; signal ef3 is on
 2998 a892: 3f 96       cef3:      bn4     cef4                ; jump if ef4 not on
 2999 a894: f9 08                  ori     8
 3000 a896: ab          cef4:      plo     rb                  ; prepare to put on stack
 3001 a897: f8 00                  ldi     0
 3002 a899: bb                     phi     rb
 3003 a89a: d4                     sep     scall               ; push onto stack
 3004 a89b: 9c 61                  dw      push
 3005 a89d: c0 a0 17               lbr     good
 3006 a8a0:             	
 3007 a8a0:             
 3008 a8a0:             
 3009 a8a0: d4          cout:      sep     scall               ; get value from stack
 3010 a8a1: 9c 32                  dw      pop
 3011 a8a3: c3 a0 12               lbdf    error               ; jump on error
 3012 a8a6: 8b                     glo     rb
 3013 a8a7: a8                     plo     r8                  ; hold onto it
 3014 a8a8: d4                     sep     scall               ; get port value
 3015 a8a9: 9c 32                  dw      pop
 3016 a8ab: c3 a0 12               lbdf    error               ; jump on error
 3017 a8ae: 88                     glo     r8                  ; get vlue
 3018 a8af: 73                     stxd                        ; store into memory for out
 3019 a8b0: 60                     irx                         ; point to value
 3020 a8b1: 8b                     glo     rb                  ; get port
 3021 a8b2: ff 01                  smi     1                   ; try port 1
 3022 a8b4: ca a8 bc               lbnz    cout2               ; jump if not
 3023 a8b7: 61                     out     1                   ; prform out
 3024 a8b8: 22                     dec     r2                  ; move pointer back
 3025 a8b9: c0 a0 17               lbr     good                ; and return to caller
 3026 a8bc: ff 01       cout2:     smi     1                   ; try port 1
 3027 a8be: ca a8 c6               lbnz    cout3               ; jump if not
 3028 a8c1: 62                     out     2                   ; prform out
 3029 a8c2: 22                     dec     r2                  ; move pointer back
 3030 a8c3: c0 a0 17               lbr     good                ; and return to caller
 3031 a8c6: ff 01       cout3:     smi     1                   ; try port 1
 3032 a8c8: ca a8 d0               lbnz    cout4               ; jump if not
 3033 a8cb: 63                     out     3                   ; prform out
 3034 a8cc: 22                     dec     r2                  ; move pointer back
 3035 a8cd: c0 a0 17               lbr     good                ; and return to caller
 3036 a8d0: ff 01       cout4:     smi     1                   ; try port 1
 3037 a8d2: ca a8 da               lbnz    cout5               ; jump if not
 3038 a8d5: 64                     out     4                   ; prform out
 3039 a8d6: 22                     dec     r2                  ; move pointer back
 3040 a8d7: c0 a0 17               lbr     good                ; and return to caller
 3041 a8da: ff 01       cout5:     smi     1                   ; try port 1
 3042 a8dc: ca a8 e4               lbnz    cout6               ; jump if not
 3043 a8df: 65                     out     5                   ; prform out
 3044 a8e0: 22                     dec     r2                  ; move pointer back
 3045 a8e1: c0 a0 17               lbr     good                ; and return to caller
 3046 a8e4: ff 01       cout6:     smi     1                   ; try port 1
 3047 a8e6: ca a8 ee               lbnz    cout7               ; jump if not
 3048 a8e9: 66                     out     6                   ; prform out
 3049 a8ea: 22                     dec     r2                  ; move pointer back
 3050 a8eb: c0 a0 17               lbr     good                ; and return to caller
 3051 a8ee: ff 01       cout7:     smi     1                   ; try port 1
 3052 a8f0: ca a8 f5               lbnz    cout8               ; jump if not
 3053 a8f3: 67                     out     7                   ; prform out
 3054 a8f4: 22                     dec     r2                  ; move pointer back
 3055 a8f5: c0 a0 17    cout8:     lbr     good                ; and return to caller
 3056 a8f8:             
 3057 a8f8: d4          cinp:      sep     scall               ; get port
 3058 a8f9: 9c 32                  dw      pop
 3059 a8fb: c3 a0 12               lbdf    error               ; jump on error
 3060 a8fe: 8b                     glo     rb                  ; get port
 3061 a8ff: ff 01                  smi     1                   ; check port 1
 3062 a901: ca a9 08               lbnz    cinp2               ; jump if not
 3063 a904: 69                     inp     1                   ; read port
 3064 a905: c0 a9 3b               lbr     cinpd               ; complete
 3065 a908: ff 01       cinp2:     smi     1                   ; check port 1
 3066 a90a: ca a9 11               lbnz    cinp3               ; jump if not
 3067 a90d: 6a                     inp     2                   ; read port
 3068 a90e: c0 a9 3b               lbr     cinpd               ; complete
 3069 a911: ff 01       cinp3:     smi     1                   ; check port 1
 3070 a913: ca a9 1a               lbnz    cinp4               ; jump if not
 3071 a916: 6b                     inp     3                   ; read port
 3072 a917: c0 a9 3b               lbr     cinpd               ; complete
 3073 a91a: ff 01       cinp4:     smi     1                   ; check port 1
 3074 a91c: ca a9 23               lbnz    cinp5               ; jump if not
 3075 a91f: 6c                     inp     4                   ; read port
 3076 a920: c0 a9 3b               lbr     cinpd               ; complete
 3077 a923: ff 01       cinp5:     smi     1                   ; check port 1
 3078 a925: ca a9 2c               lbnz    cinp6               ; jump if not
 3079 a928: 6d                     inp     5                   ; read port
 3080 a929: c0 a9 3b               lbr     cinpd               ; complete
 3081 a92c: ff 01       cinp6:     smi     1                   ; check port 1
 3082 a92e: ca a9 35               lbnz    cinp7               ; jump if not
 3083 a931: 6e                     inp     6                   ; read port
 3084 a932: c0 a9 3b               lbr     cinpd               ; complete
 3085 a935: ff 01       cinp7:     smi     1                   ; check port 1
 3086 a937: ca a0 12               lbnz    error               ; jump if not
 3087 a93a: 6f                     inp     7                   ; read port
 3088 a93b: ab          cinpd:     plo     rb                  ; prepare to put on stack
 3089 a93c: f8 00                  ldi     0
 3090 a93e: bb                     phi     rb
 3091 a93f: d4                     sep     scall               ; push onto stack
 3092 a940: 9c 61                  dw      push
 3093 a942: c0 a0 17               lbr     good
 3094 a945:             
 3095 a945:             
 3096 a945:             ; cstk:      mov     rb,fstack           ; get stack address
 3097 a945:                        ; sep     scall               ; push onto stack
 3098 a945:                        ; dw      push
 3099 a945:                        ; lbr     good
 3100 a945:             
 3101 a945:             ; [GDJ]
 3102 a945: f8 08 ab f8 
            03 bb       cspat:     mov     rb,fstack           ; get stack address pointer
 3103 a94b: 8b                     glo     rb
 3104 a94c: a8                     plo     r8
 3105 a94d: 9b                     ghi     rb
 3106 a94e: b8                     phi     r8
 3107 a94f:             
 3108 a94f:                        ; get stack address 
 3109 a94f: 48                     lda     r8
 3110 a950: bb                     phi     rb
 3111 a951: 08                     ldn     r8
 3112 a952: ab                     plo     rb
 3113 a953:             
 3114 a953:                        ; add 1 byte offset
 3115 a953: f8 01 a7 f8 
            00 b7                  mov     r7, 1
 3116 a959: e2                     sex     r2                  ; be sure X points to stack
 3117 a95a: 87                     glo     r7                  ; perform addition
 3118 a95b: 52                     str     r2
 3119 a95c: 8b                     glo     rb
 3120 a95d: f4                     add
 3121 a95e: ab                     plo     rb
 3122 a95f: 97                     ghi     r7
 3123 a960: 52                     str     r2
 3124 a961: 9b                     ghi     rb
 3125 a962: 74                     adc
 3126 a963: bb                     phi     rb
 3127 a964:             
 3128 a964: d4                     sep     scall               ; push onto stack
 3129 a965: 9c 61                  dw      push
 3130 a967: c0 a0 17               lbr     good
 3131 a96a:             
 3132 a96a:             ; -----------------------------------------------------------------
 3133 a96a:             ; additions April 2022  GDJ
 3134 a96a:             ; -----------------------------------------------------------------
 3135 a96a: d4          ccmove:    sep     scall               ; get top of stack
 3136 a96b: 9c 32                  dw      pop
 3137 a96d: c3 a0 12               lbdf    error               ; jump if error
 3138 a970: 8b ac 9b bc            mov     rc,rb               ; rc is count of bytes
 3139 a974: d4                     sep     scall               ; get top of stack
 3140 a975: 9c 32                  dw      pop
 3141 a977: c3 a0 12               lbdf    error               ; jump if error
 3142 a97a: 8b a8 9b b8            mov     r8,rb               ; r8 is destination address
 3143 a97e: d4                     sep     scall               ; get top of stack
 3144 a97f: 9c 32                  dw      pop
 3145 a981: c3 a0 12               lbdf    error               ; jump if error
 3146 a984: 8b a7 9b b7            mov     r7,rb               ; r7 is source address
 3147 a988:             
 3148 a988:                        ; transfer data
 3149 a988:                        ; begin check for zero byte count else tragedy could result
 3150 a988: 8c          cmovelp:   glo     rc
 3151 a989: ca a9 93               lbnz    cmovestr
 3152 a98c: 9c                     ghi     rc
 3153 a98d: ca a9 93               lbnz    cmovestr
 3154 a990: c0 a9 9a               lbr     cmovertn
 3155 a993: 47          cmovestr:  lda     r7
 3156 a994: 58                     str     r8
 3157 a995: 18                     inc     r8
 3158 a996: 2c                     dec     rc
 3159 a997: c0 a9 88               lbr     cmovelp
 3160 a99a: c0 a0 17    cmovertn:  lbr     good                ; return to caller
 3161 a99d:             
 3162 a99d:             
 3163 a99d: d4          csetq:     sep     scall               ; get top of stack
 3164 a99e: 9c 32                  dw      pop
 3165 a9a0: c3 a0 12               lbdf    error               ; jump if error
 3166 a9a3: 8b                     glo     rb                  ; get low of return value
 3167 a9a4: c2 a9 ab               lbz     setqno              ; jump if zero
 3168 a9a7: 7b                     seq
 3169 a9a8: c0 a0 17               lbr     good
 3170 a9ab: 7a          setqno:    req
 3171 a9ac: c0 a0 17               lbr     good                ; return to caller
 3172 a9af:             
 3173 a9af:             
 3174 a9af: f8 17 ad f8 
            03 bd       cdecimal:  mov     rd, basen
 3175 a9b5: f8 0a                  ldi     10
 3176 a9b7: 5d                     str     rd
 3177 a9b8: c0 a0 17               lbr     good
 3178 a9bb:             
 3179 a9bb: f8 17 ad f8 
            03 bd       chex:      mov     rd, basen
 3180 a9c1: f8 10                  ldi     16
 3181 a9c3: 5d                     str     rd
 3182 a9c4: c0 a0 17               lbr     good
 3183 a9c7:             
 3184 a9c7: d4          crat:      sep     scall               ; get value from return stack
 3185 a9c8: 9c 77                  dw      rpop
 3186 a9ca: d4                     sep     scall               ; put back on return stack
 3187 a9cb: 9c 8f                  dw      rpush 
 3188 a9cd: d4                     sep     scall               ; and forth stack
 3189 a9ce: 9c 61                  dw      push
 3190 a9d0: c0 a0 17               lbr     good                ; return to caller
 3191 a9d3:             
 3192 a9d3: d4          crand:     sep     scall
 3193 a9d4: ac de                  dw      randbyte
 3194 a9d6: 98                     ghi     r8
 3195 a9d7: ab                     plo     rb
 3196 a9d8: f8 00                  ldi     0
 3197 a9da: bb                     phi     rb
 3198 a9db: d4                     sep     scall               ; put rbyte on stack
 3199 a9dc: 9c 61                  dw      push
 3200 a9de: c0 a0 17               lbr     good
 3201 a9e1:             
 3202 a9e1:             
 3203 a9e1:             ; VT100 ansi control
 3204 a9e1:             ; printf("%c[%d;%dH",ESC,y,x);
 3205 a9e1: d4          cgotoxy:   sep     scall               ; get top of stack
 3206 a9e2: 9c 32                  dw      pop
 3207 a9e4: c3 a0 12               lbdf    error               ; jump if error
 3208 a9e7: 8b ad 9b bd            mov     rd,rb               ; rd is Y coord (row)
 3209 a9eb: d4                     sep     scall               ; get top of stack
 3210 a9ec: 9c 32                  dw      pop
 3211 a9ee: c3 a0 12               lbdf    error               ; jump if error
 3212 a9f1: 8b a8 9b b8            mov     r8,rb               ; r8 is X coord (col)
 3213 a9f5:             
 3214 a9f5:                        ; send CSI sequence
 3215 a9f5: d4                     sep    scall
 3216 a9f6: ff 66                  dw     f_inmsg
 3217 a9f8: 1b 5b 00               db     27, '[', 0
 3218 a9fb:             
 3219 a9fb:                        ; Y
 3220 a9fb: f8 00 af f8 
            02 bf                  mov     rf, buffer
 3221 aa01: d4                     sep     scall
 3222 aa02: ff 60                  dw      f_uintout
 3223 aa04: f8 00                  ldi     0                   ; write terminator
 3224 aa06: 5f                     str     rf
 3225 aa07: f8 00 af f8 
            02 bf                  mov     rf, buffer
 3226 aa0d: d4                     sep     scall
 3227 aa0e: ff 09                  dw      f_msg
 3228 aa10:             
 3229 aa10:                        ; type separator
 3230 aa10: f8 3b                  ldi     ';'
 3231 aa12: d4                     sep     scall               ; call type routine
 3232 aa13: ff 4e                  dw      f_tty
 3233 aa15:             
 3234 aa15:                        ; X
 3235 aa15: f8 00 af f8 
            02 bf                  mov     rf, buffer
 3236 aa1b: 88 ad 98 bd            mov     rd,r8
 3237 aa1f: d4                     sep     scall
 3238 aa20: ff 60                  dw      f_uintout
 3239 aa22: f8 00                  ldi     0                   ; write terminator
 3240 aa24: 5f                     str     rf
 3241 aa25: f8 00 af f8 
            02 bf                  mov     rf, buffer
 3242 aa2b: d4                     sep     scall
 3243 aa2c: ff 09                  dw      f_msg
 3244 aa2e:                        
 3245 aa2e:                        ; type ending char
 3246 aa2e: f8 48                  ldi     'H'
 3247 aa30: d4                     sep     scall               ; call type routine
 3248 aa31: ff 4e                  dw      f_tty
 3249 aa33:             
 3250 aa33: c0 a0 17               lbr     good
 3251 aa36:             
 3252 aa36:             
 3253 aa36:             ; -----------------------------------------------------------------------------
 3254 aa36:             ; 'C' style operators for bit shifting, note no range check on number of shifts
 3255 aa36:             ; -----------------------------------------------------------------------------
 3256 aa36: d4          clshift:   sep     scall               ; get value from stack
 3257 aa37: 9c 32                  dw      pop
 3258 aa39: c3 a0 12               lbdf    error               ; jump if stack was empty
 3259 aa3c: 8b                     glo     rb                  ; move number 
 3260 aa3d: a7                     plo     r7                  ; number of shifts
 3261 aa3e:             
 3262 aa3e: d4                     sep     scall               ; get next number
 3263 aa3f: 9c 32                  dw      pop
 3264 aa41: c3 a0 12               lbdf    error               ; jump if stack was empty
 3265 aa44: 8b a8 9b b8            mov     r8,rb               ; value to shift left
 3266 aa48:             
 3267 aa48: 87                     glo     r7                  ; zero shift is identity 
 3268 aa49: ca aa 4f               lbnz    lshiftlp
 3269 aa4c: c0 aa 5a               lbr     lshiftret           ; return with no shift
 3270 aa4f:             
 3271 aa4f: 88          lshiftlp:  glo     r8
 3272 aa50: fe                     shl                         ; shift lo byte
 3273 aa51: a8                     plo     r8
 3274 aa52: 98                     ghi     r8
 3275 aa53: 7e                     shlc                        ; shift hi byte with carry
 3276 aa54: b8                     phi     r8
 3277 aa55: 27                     dec     r7
 3278 aa56: 87                     glo     r7
 3279 aa57: ca aa 4f               lbnz    lshiftlp
 3280 aa5a:             
 3281 aa5a: 88 ab 98 bb lshiftret: mov     rb,r8
 3282 aa5e: d4                     sep     scall               ; put answer back on stack
 3283 aa5f: 9c 61                  dw      push
 3284 aa61: c0 a0 17               lbr     good
 3285 aa64:             
 3286 aa64:             
 3287 aa64: d4          crshift:   sep     scall               ; get value from stack
 3288 aa65: 9c 32                  dw      pop
 3289 aa67: c3 a0 12               lbdf    error               ; jump if stack was empty
 3290 aa6a: 8b                     glo     rb                  ; move number 
 3291 aa6b: a7                     plo     r7                  ; number of shifts
 3292 aa6c:             
 3293 aa6c: d4                     sep     scall               ; get next number
 3294 aa6d: 9c 32                  dw      pop
 3295 aa6f: c3 a0 12               lbdf    error               ; jump if stack was empty
 3296 aa72: 8b a8 9b b8            mov     r8,rb
 3297 aa76:             
 3298 aa76: 87                     glo     r7                  ; zero shift is identity 
 3299 aa77: ca aa 7d               lbnz    rshiftlp
 3300 aa7a: c0 aa 88               lbr     rshiftret           ; return with no shift
 3301 aa7d:             
 3302 aa7d: 98          rshiftlp:  ghi     r8
 3303 aa7e: f6                     shr                         ; shift hi byte
 3304 aa7f: b8                     phi     r8
 3305 aa80: 88                     glo     r8
 3306 aa81: 76                     shrc                        ; shift lo byte with carry
 3307 aa82: a8                     plo     r8
 3308 aa83: 27                     dec     r7
 3309 aa84: 87                     glo     r7
 3310 aa85: ca aa 7d               lbnz    rshiftlp
 3311 aa88:                
 3312 aa88: 88 ab 98 bb rshiftret: mov     rb,r8
 3313 aa8c: d4                     sep     scall               ; put answer back on stack
 3314 aa8d: 9c 61                  dw      push
 3315 aa8f: c0 a0 17               lbr     good
 3316 aa92:             
 3317 aa92:             
 3318 aa92:             ; delay for approx 1 millisecond on 4MHz 1802
 3319 aa92: d4          cdelay:    sep     scall               ; get value from stack
 3320 aa93: 9c 32                  dw      pop
 3321 aa95: c3 a0 12               lbdf    error               ; jump if stack was empty
 3322 aa98: 8b                     glo     rb                  ; move number 
 3323 aa99: a7                     plo     r7
 3324 aa9a: 9b                     ghi     rb
 3325 aa9b: b7                     phi     r7
 3326 aa9c:             
 3327 aa9c: f8 3c       delaylp1:  ldi     60
 3328 aa9e: c4          delaylp2:  nop
 3329 aa9f: ff 01                  smi     1
 3330 aaa1: ca aa 9e               lbnz    delaylp2
 3331 aaa4:             
 3332 aaa4: 27                     dec     r7
 3333 aaa5: 87                     glo     r7
 3334 aaa6: ca aa 9c               lbnz    delaylp1
 3335 aaa9: 97                     ghi     r7
 3336 aaaa: ca aa 9c               lbnz    delaylp1
 3337 aaad: c0 a0 17               lbr     good
 3338 aab0:             
 3339 aab0:             	
 3340 aab0: d4          cexec:	   sep scall
 3341 aab1: 9c 32       	   dw pop
 3342 aab3: c3 a0 12      	   lbdf error
 3343 aab6: f8 0a a8 f8 
            03 b8                  mov     r8, jump            ; point to jump address
 3344 aabc: f8 c0                  ldi     0c0h                ; lbr
 3345 aabe: 58                     str     r8                  ; store it
 3346 aabf: 18                     inc     r8
 3347 aac0: 9b          	   ghi     rb
 3348 aac1: 58                     str     r8
 3349 aac2: 18                     inc     r8
 3350 aac3: 8b          	   glo     rb
 3351 aac4: 58                     str     r8
 3352 aac5: d4          	   sep     scall
 3353 aac6: aa ce       	   dw      cexec0
 3354 aac8:             	;; if we return RB is pushed on stack
 3355 aac8: d4          	   sep scall
 3356 aac9: 9c 61       	   dw push
 3357 aacb: c0 a0 17    	   lbr good
 3358 aace: c0 03 0a    cexec0:	   lbr jump   		; transfer to user code. If it returns, it goes back to my scaller
 3359 aad1:             
 3360 aad1:             
 3361 aad1:             ; -----------------------------------------------------------------------------
 3362 aad1:             ; Load contents of dictionary - any session defined words/values will be zapped
 3363 aad1:             ; -----------------------------------------------------------------------------
 3364 aad1:             
 3365 aad1: 8f 73 9f 73 cbload:    push    rf
 3366 aad5: 8d 73 9d 73            push    rd
 3367 aad9: 8c 73 9c 73            push    rc
 3368 aadd:                        
 3369 aadd: f8 ba af f8 
            ae bf                  mov     rf, extblock        ; source address
            #else
 3373 aae3: f8 00 ad f8 
            03 bd                  mov     rd, 0300h           ; destination address
            #endif
 3375 aae9: f8 00 ac f8 
            05 bc                  mov     rc, endextblock-extblock  ; block size
 3376 aaef:             
 3377 aaef: 4f          bloadlp:   lda     rf
 3378 aaf0: 5d                     str     rd
 3379 aaf1: 1d                     inc     rd
 3380 aaf2: 2c                     dec     rc
 3381 aaf3: 8c                     glo     rc
 3382 aaf4: ca aa ef               lbnz    bloadlp
 3383 aaf7: 9c                     ghi     rc
 3384 aaf8: ca aa ef               lbnz    bloadlp
 3385 aafb:             
 3386 aafb: 60 72 bc f0 
            ac                     pop     rc
 3387 ab00: 60 72 bd f0 
            ad                     pop     rd
 3388 ab05: 60 72 bf f0 
            af                     pop     rf
 3389 ab0a: c0 9b e7               lbr     mainlp              ; back to main loop
 3390 ab0d:             
 3391 ab0d:             
 3392 ab0d:             ; -----------------------------------------------------------------
 3393 ab0d:             
 3394 ab0d:             
            #ifdef ANYROM
 3396 ab0d: 8f 73 9f 73 csave:     push    rf                  ; save consumed registers
 3397 ab11: 8c 73 9c 73            push    rc
 3398 ab15: d4                     sep     scall               ; open XMODEM channel for writing
 3399 ab16: ed 00                  dw      xopenw
 3400 ab18: f8 06 af f8 
            03 bf                  mov     rf,freemem          ; need pointer to freemem
 3401 ab1e: 4f                     lda     rf                  ; get high address of free memory
            #else
 3405 ab1f: ff 03                  smi     3                   ; subtract base address
            #endif
 3407 ab21: bc                     phi     rc                  ; store into count
 3408 ab22: 0f                     ldn     rf                  ; get low byte of free memory
 3409 ab23: ac                     plo     rc                  ; store into count
 3410 ab24: 1c                     inc     rc                  ; account for terminator
 3411 ab25: 1c                     inc     rc
 3412 ab26: f8 00 af f8 
            02 bf                  mov     rf,buffer           ; temporary storage
 3413 ab2c: 9c                     ghi     rc                  ; get high byte of count
 3414 ab2d: 5f                     str     rf                  ; store it
 3415 ab2e: 1f                     inc     rf                  ; point to low byte
 3416 ab2f: 8c                     glo     rc                  ; get it
 3417 ab30: 5f                     str     rf                  ; store into buffer
 3418 ab31: 2f                     dec     rf                  ; move back to buffer
 3419 ab32: f8 02 ac f8 
            00 bc                  mov     rc,2                ; 2 bytes of length
 3420 ab38: d4                     sep     scall               ; write to XMODEM channel
 3421 ab39: ed 09                  dw      xwrite
 3422 ab3b: f8 00 af f8 
            02 bf                  mov     rf,buffer           ; point to where count is
 3423 ab41: 4f                     lda     rf                  ; retrieve high byte
 3424 ab42: bc                     phi     rc                  ; set into count for write
 3425 ab43: 0f                     ldn     rf                  ; get low byte
 3426 ab44: ac                     plo     rc                  ; rc now has count of bytes to save
 3427 ab45: f8 00 af f8 
            03 bf                  mov     rf,himem            ; point to forth data
 3428 ab4b: d4                     sep     scall               ; write it all out
 3429 ab4c: ed 09                  dw      xwrite
 3430 ab4e: d4                     sep     scall               ; close XMODEM channel
 3431 ab4f: ed 0c                  dw      xclosew
 3432 ab51: 60 72 bc f0 
            ac                     pop     rc                  ; recover consumed registers
 3433 ab56: 60 72 bf f0 
            af                     pop     rf
 3434 ab5b: c0 a0 17               lbr     good                ; all done
            #endif
 3436 ab5e:             
            #endif
 3499 ab5e:             
            #ifdef ANYROM
 3501 ab5e: 8f 73 9f 73 cload:     push    rf                  ; save consumed registers
 3502 ab62: 8c 73 9c 73            push    rc
 3503 ab66: 8e 73 9e 73            push    re                  ; [GDJ]
 3504 ab6a: d4                     sep     scall               ; open XMODEM channel for reading
 3505 ab6b: ed 03                  dw      xopenr
 3506 ab6d: f8 00 af f8 
            02 bf                  mov     rf,buffer           ; point to buffer
 3507 ab73: f8 02 ac f8 
            00 bc                  mov     rc,2                ; need to read 2 bytes
 3508 ab79: d4                     sep     scall               ; read them
 3509 ab7a: ed 06                  dw      xread
 3510 ab7c: f8 00 af f8 
            02 bf                  mov     rf,buffer           ; point to buffer
 3511 ab82: 4f                     lda     rf                  ; retrieve count
 3512 ab83: bc                     phi     rc                  ; into rc
 3513 ab84: 0f                     ldn     rf
 3514 ab85: ac                     plo     rc                  ; rc now has count of bytes to read
 3515 ab86: f8 00 af f8 
            03 bf                  mov     rf,himem            ; point to forth data
 3516 ab8c: d4                     sep     scall               ; now read program data
 3517 ab8d: ed 06                  dw      xread
 3518 ab8f:                        
 3519 ab8f:                        ; temp removal [GDJ]
 3520 ab8f:                        ;sep     scall               ; close XMODEM channel
 3521 ab8f:                        ;dw      xcloser
 3522 ab8f: 60 72 be f0 
            ae                     pop     re                  ; [GDJ]
 3523 ab94: 60 72 bc f0 
            ac                     pop     rc                  ; recover consumed registers
 3524 ab99: 60 72 bf f0 
            af                     pop     rf
 3525 ab9e:                        ; irx                         ; [GDJ] remove exec portions from stack
 3526 ab9e:                        ; irx
 3527 ab9e:                        ; irx
 3528 ab9e:                        ; irx
 3529 ab9e:             
 3530 ab9e: c0 9b e7               lbr     mainlp              ; back to main loop
            #endif
 3532 aba1:             
            #endif
 3597 aba1:             
 3598 aba1: c0 80 03    cbye:      lbr     exitaddr
 3599 aba4:             
            #endif
 3620 aba4:             
 3621 aba4:             
 3622 aba4:             ; **********************************************************
 3623 aba4:             ; ***** Convert string to uppercase, honor quoted text *****
 3624 aba4:             ; **********************************************************
 3625 aba4: 0f          touc:      ldn     rf                  ; check for quote
 3626 aba5: ff 22                  smi     022h
 3627 aba7: c2 ab c1               lbz     touc_qt             ; jump if quote
 3628 abaa: 0f                     ldn     rf                  ; get byte from string
 3629 abab: c2 ab c0               lbz     touc_dn             ; jump if done
 3630 abae: ff 61                  smi     'a'                 ; check if below lc
 3631 abb0: cb ab bc               lbnf    touc_nxt            ; jump if so
 3632 abb3: ff 1b                  smi     27                  ; check upper rage
 3633 abb5: c3 ab bc               lbdf    touc_nxt            ; jump if above lc
 3634 abb8: 0f                     ldn     rf                  ; otherwise convert character to lc
 3635 abb9: ff 20                  smi     32
 3636 abbb: 5f                     str     rf
 3637 abbc: 1f          touc_nxt:  inc     rf                  ; point to next character
 3638 abbd: c0 ab a4               lbr     touc                ; loop to check rest of string
 3639 abc0: d5          touc_dn:   sep     sret                ; return to caller
 3640 abc1: 1f          touc_qt:   inc     rf                  ; move past quote
 3641 abc2: 4f          touc_qlp:  lda     rf                  ; get next character
 3642 abc3: c2 ab c0               lbz     touc_dn             ; exit if terminator found
 3643 abc6: ff 22                  smi     022h                ; check for quote charater
 3644 abc8: c2 ab a4               lbz     touc                ; back to main loop if quote
 3645 abcb: c0 ab c2               lbr     touc_qlp            ; otherwise keep looking
 3646 abce:             
 3647 abce:             
 3648 abce:             ; [GDJ] type out number according to selected BASE and signed/unsigned flag
 3649 abce:             typenumind:   ; get BASE  ; enter here to have 0x or 0# put on front
 3650 abce: 8f 73 9f 73         push    rf                  ; save rf for tokenizer
 3651 abd2: f8 00       	ldi 0
 3652 abd4: ae          	plo re  		; always unsigned here
 3653 abd5: f8 30       	ldi '0'
 3654 abd7: d4          	sep scall
 3655 abd8: 9c 2a       	dw disp
 3656 abda: f8 17 ad f8 
            03 bd               mov     rd, basen
 3657 abe0: 0d                  ldn     rd
 3658 abe1: ff 0a               smi     10
 3659 abe3: 32 e8       	bz typenuminddec
 3660 abe5: f8 78       	ldi 'x'
 3661 abe7: c8          	lskp
 3662 abe8:             typenuminddec:
 3663 abe8: f8 23       	ldi '#'
 3664 abea: d4          	sep scall
 3665 abeb: 9c 2a       	dw disp
 3666 abed: 30 f3       	br typenumx
 3667 abef:             
 3668 abef:             typenum:   ; get BASE  ; enter here for normal output
 3669 abef: 8f 73 9f 73            push    rf                  ; save rf for tokenizer
 3670 abf3:             typenumx:	
 3671 abf3: f8 17 ad f8 
            03 bd                  mov     rd, basen
 3672 abf9: 0d                     ldn     rd
 3673 abfa: ff 0a                  smi     10
 3674 abfc: ca ac 19               lbnz    typehex
 3675 abff: 8b ad 9b bd            mov     rd,rb
 3676 ac03: f8 00 af f8 
            02 bf                  mov     rf, buffer
 3677 ac09: 8e                     glo     re
 3678 ac0a: c2 ac 13               lbz     typenumU
 3679 ac0d: d4                     sep     scall
 3680 ac0e: ff 63                  dw      f_intout
 3681 ac10: c0 ac 30               lbr     typeout
 3682 ac13: d4          typenumU:  sep     scall
 3683 ac14: ff 60                  dw      f_uintout
 3684 ac16: c0 ac 30               lbr     typeout
 3685 ac19:             
 3686 ac19:             typehex:
 3687 ac19: 8b ad 9b bd 	   mov     rd,rb
 3688 ac1d: f8 00 af f8 
            02 bf                  mov     rf, buffer
 3689 ac23: 9d                     ghi     rd
 3690 ac24: c2 ac 2d               lbz     hexbyte
 3691 ac27: d4                     sep     scall
 3692 ac28: ff 4b                  dw      f_hexout4
 3693 ac2a: c0 ac 30               lbr     typeout
 3694 ac2d: d4          hexbyte:   sep     scall
 3695 ac2e: ff 48                  dw      f_hexout2
 3696 ac30:             
 3697 ac30: f8 20       typeout:   ldi     ' '                 ; add space
 3698 ac32: 5f                     str     rf
 3699 ac33: 1f                     inc     rf
 3700 ac34: f8 00                  ldi     0                   ; and terminator
 3701 ac36: 5f                     str     rf
 3702 ac37: f8 00 af f8 
            02 bf                  mov     rf, buffer
 3703 ac3d: d4                     sep     scall
 3704 ac3e: ff 09                  dw      f_msg
 3705 ac40: 60 72 bf f0 
            af                     pop     rf
 3706 ac45: d5                     sep     sret                ; return to caller
 3707 ac46:             
 3708 ac46:             
 3709 ac46:             
 3710 ac46:             ; *************************************
 3711 ac46:             ; *** Check if character is numeric ***
 3712 ac46:             ; *** D - char to check             ***
 3713 ac46:             ; *** Returns DF=1 if numeric       ***
 3714 ac46:             ; ***         DF=0 if not           ***
 3715 ac46:             ; *************************************
 3716 ac46: ae          isnum:     plo     re                  ; save a copy
 3717 ac47: ff 30                  smi     '0'                 ; check for below zero
 3718 ac49: cb ac 54               lbnf    fails               ; jump if below
 3719 ac4c: ff 0a                  smi     10                  ; see if above
 3720 ac4e: c3 ac 54               lbdf    fails               ; fails if so
 3721 ac51: ff 00       passes:    smi     0                   ; signal success
 3722 ac53: c8                     lskp
 3723 ac54: fc 00       fails:     adi     0                   ; signal failure
 3724 ac56: 8e                     glo     re                  ; recover character
 3725 ac57: d5                     sep     sret                ; and return
 3726 ac58:             
 3727 ac58: ff 00       err:       smi     0                   ; signal an error
 3728 ac5a: d5                     sep     sret                ; and return
 3729 ac5b:                        
 3730 ac5b:                        
 3731 ac5b:             ; **********************************
 3732 ac5b:             ; *** check D if hex             ***
 3733 ac5b:             ; *** Returns DF=1 - hex         ***
 3734 ac5b:             ; ***         DF=0 - non-hex     ***
 3735 ac5b:             ; **********************************
 3736 ac5b: d4          ishex:     sep     scall               ; see if it is numeric
 3737 ac5c: ac 46                  dw      isnum
 3738 ac5e: ae                     plo     re                  ; keep a copy
 3739 ac5f: c3 ac 51               lbdf    passes              ; jump if it is numeric
 3740 ac62: ff 41                  smi     'A'                 ; check for below uppercase a
 3741 ac64: cb ac 54               lbnf    fails               ; value is not hex
 3742 ac67: ff 06                  smi     6                   ; check for less then 'G'
 3743 ac69: cb ac 51               lbnf    passes              ; jump if so
 3744 ac6c: 8e                     glo     re                  ; recover value
 3745 ac6d: ff 61                  smi     'a'                 ; check for lowercase a
 3746 ac6f: cb ac 54               lbnf    fails               ; jump if not
 3747 ac72: ff 06                  smi     6                   ; check for less than 'g'
 3748 ac74: cb ac 51               lbnf    passes              ; jump if so
 3749 ac77: c0 ac 54               lbr     fails
 3750 ac7a:             
 3751 ac7a:             
 3752 ac7a:             
 3753 ac7a:                        ; clear tos, himem & rstack blocks 
 3754 ac7a: f8 00 a7 f8 
            03 b7       clrstacks: mov     r7, 300h            ; clear 768 bytes
 3755 ac80: f8 00 ac f8 
            7c bc                  mov     rc, 7c00h
 3756 ac86:                        
 3757 ac86: f8 00       clrmemlp:  ldi     0h
 3758 ac88: 5c                     str     rc
 3759 ac89: 1c                     inc     rc
 3760 ac8a: 27                     dec     r7
 3761 ac8b: 87                     glo     r7
 3762 ac8c: ca ac 86               lbnz    clrmemlp
 3763 ac8f: 97                     ghi     r7
 3764 ac90: ca ac 86               lbnz    clrmemlp
 3765 ac93: d5                     rtn
 3766 ac94:             
 3767 ac94:             
 3768 ac94:             ;--------------------------------------------------------------
 3769 ac94:             ;    Read byte from UART if char available  
 3770 ac94:             ;    return in r7.0 - else return null
 3771 ac94:             ;
 3772 ac94:             ;    from original bios code of Bob Armstrong
 3773 ac94:             ;    modified for non-blocking console input
 3774 ac94:             ;--------------------------------------------------------------
 3775 ac94: f8 15       inkey:  ldi     015h            ; need UART line status register
 3776 ac96: 52                  str     r2              ; prepare for out
 3777 ac97: 66                  out     UART_SELECT     ; write to register select port
 3778 ac98: 22                  dec     r2              ; correct for inc on out
 3779 ac99: 6f                  inp     UART_DATA       ; read line status register
 3780 ac9a: fa 01               ani     1               ; mask for data ready bit
 3781 ac9c: c2 ac a7            lbz     nokey           ; return if no bytes to read
 3782 ac9f: f8 10               ldi     010h            ; select data register
 3783 aca1: 52                  str     r2              ; prepare for out
 3784 aca2: 66                  out     UART_SELECT     ; write to register select port
 3785 aca3: 22                  dec     r2              ; back to free spot
 3786 aca4: 6f                  inp     UART_DATA       ; read UART data register
 3787 aca5: a7                  plo     r7
 3788 aca6: d5                  rtn
 3789 aca7:                     
 3790 aca7: f8 00       nokey:  ldi     0h
 3791 aca9: a7                  plo     r7
 3792 acaa: d5                  rtn
 3793 acab:             
 3794 acab:             
 3795 acab: f8 0d a7 f8 
            03 b7       clist:	mov r7,storage
 3796 acb1:             clist0:
 3797 acb1: 87 73 97 73 	push r7
 3798 acb5: 07          	ldn r7
 3799 acb6: 3a c4       	bnz clist1
 3800 acb8: 17          	inc r7
 3801 acb9: 07          	ldn r7
 3802 acba: 3a c4       	bnz clist1
 3803 acbc: 60 72 b7 f0 
            a7          	pop r7
 3804 acc1: c0 a0 17    	lbr good
 3805 acc4:             clist1:	
 3806 acc4: 60 72 b7 f0 
            a7          	pop r7
 3807 acc9: 87 73 97 73 	push r7
 3808 accd: d4          	sep scall
 3809 acce: a6 0a       	dw csee_sub0
 3810 acd0: 60 72 b7 f0 
            a7          	pop r7
 3811 acd5: 07          	ldn r7
 3812 acd6: bb          	phi rb
 3813 acd7: 17          	inc r7
 3814 acd8: 07          	ldn r7
 3815 acd9: a7          	plo r7
 3816 acda: 9b          	ghi rb
 3817 acdb: b7          	phi r7
 3818 acdc: 30 b1       	br clist0
 3819 acde:             	
 3820 acde:             
 3821 acde:             
 3822 acde:             ;------------------------------------------------------------------
 3823 acde:             ; Generate a psuedo-random byte
 3824 acde:             ;
 3825 acde:             ; IN:       N/A
 3826 acde:             ; OUT:      D=psuedo-random number
 3827 acde:             ; TRASHED:  RA
 3828 acde:             ;
 3829 acde:             ; This PRNG was extracted from AdventureLand
 3830 acde:             ; Copyright (C) 2019 by Richard Goedeken, All Rights Reserved.
 3831 acde:             ;
 3832 acde:             ; modified GDJ 2021 --> return in r8.1, changed r7 to ra
 3833 acde:             ;
 3834 acde:             ; Update1: 23 Jan 2022 no period has been determined, thus 
 3835 acde:             ; far a 320kB file has been checked - 12 minutes on the PicoElf2
 3836 acde:             ; gave 20479 lines of 16 samples --> 327664 bytes
 3837 acde:             ;
 3838 acde:             ; Update2: 25 Feb 2022 translated this code into 'C' and 
 3839 acde:             ; discovered a period of P = 2020966655
 3840 acde:             ; after which the sequence repeats!
 3841 acde:             ; other init params often gave the same period, however the
 3842 acde:             ; initial arrays:
 3843 acde:             ;        {1,3,5,7} gave a period of 543537919
 3844 acde:             ;   {12,137,98,32} gave a period of 1080837375
 3845 acde:             ;------------------------------------------------------------------
 3846 acde: f8 f0 ad f8 
            02 bd       randbyte:   mov rd,rseed
 3847 ace4: ed                      sex rd
 3848 ace5:             
 3849 ace5: 0d                      ldn rd      ; D = VarX
 3850 ace6: fc 01                   adi 1
 3851 ace8: 5d                      str rd
 3852 ace9: 1d                      inc rd
 3853 acea: 4d                      lda rd      ; D = VarA
 3854 aceb: 1d                      inc rd
 3855 acec: f3                      xor         ; D = VarA XOR VarC
 3856 aced: 2d                      dec rd
 3857 acee: 2d                      dec rd
 3858 acef: 2d                      dec rd
 3859 acf0: f3                      xor         ; D = VarA XOR VarC XOR VarX
 3860 acf1: 1d                      inc rd
 3861 acf2: 5d                      str rd      ; VarA = D
 3862 acf3: 1d                      inc rd
 3863 acf4: f4                      add
 3864 acf5: 73                      stxd
 3865 acf6: f6                      shr
 3866 acf7: f3                      xor
 3867 acf8: 1d                      inc rd
 3868 acf9: 1d                      inc rd
 3869 acfa: f4                      add
 3870 acfb: 5d                      str rd
 3871 acfc: b8                      phi r8      ; added GDJ
 3872 acfd:             
 3873 acfd: e2                      sex r2      ;    ...
 3874 acfe: d5                      rtn
 3875 acff:             
 3876 acff:             
 3877 acff:             
 3878 acff:             
 3879 acff: 52 63 2f 46 
            6f 72 74 68 
            20 30 2e 33 hello:     db      'Rc/Forth 0.3'
 3880 ad0b: 0a 0d 00    crlf:      db       10,13,0
 3881 ad0e: 6f 6b 20 00 prompt:    db      'ok ',0
 3882 ad12: 73 74 61 63 
            6b 20 65 6d 
            70 74 79 0a 
            0d 00       msempty:   db      'stack empty',10,13,0
 3883 ad20: 65 72 72 0a 
            0d 00       msgerr:    db      'err',10,13,0
 3884 ad26: 57 48 49 4c 
            c5          cmdtable:  db      'WHIL',('E'+80h)
 3885 ad2b: 52 45 50 45 
            41 d4                  db      'REPEA',('T'+80h)
 3886 ad31: 49 c6                  db      'I',('F'+80h)
 3887 ad33: 45 4c 53 c5            db      'ELS',('E'+80h)
 3888 ad37: 54 48 45 ce            db      'THE',('N'+80h)
 3889 ad3b: 56 41 52 49 
            41 42 4c c5            db      'VARIABL',('E'+80h)
 3890 ad43: ba                     db      (':'+80h)
 3891 ad44: bb                     db      (';'+80h)
 3892 ad45: 44 55 d0               db      'DU',('P'+80h)
 3893 ad48: 44 52 4f d0            db      'DRO',('P'+80h)
 3894 ad4c: 53 57 41 d0            db      'SWA',('P'+80h)
 3895 ad50: ab                     db      ('+'+80h)
 3896 ad51: ad                     db      ('-'+80h)
 3897 ad52: aa                     db      ('*'+80h)
 3898 ad53: af                     db      ('/'+80h)
 3899 ad54: ae                     db      ('.'+80h)
 3900 ad55: 55 ae                  db      'U',('.'+80h)
 3901 ad57: c9                     db      ('I'+80h)
 3902 ad58: 41 4e c4               db      'AN',('D'+80h)
 3903 ad5b: 4f d2                  db      'O',('R'+80h)
 3904 ad5d: 58 4f d2               db      'XO',('R'+80h)
 3905 ad60: 43 d2                  db      'C',('R'+80h)
 3906 ad62: 4d 45 cd               db      'ME',('M'+80h)
 3907 ad65: 44 cf                  db      'D',('O'+80h)
 3908 ad67: 4c 4f 4f d0            db      'LOO',('P'+80h)
 3909 ad6b: 2b 4c 4f 4f 
            d0                     db      '+LOO',('P'+80h)
 3910 ad70: bd                     db      ('='+80h)
 3911 ad71: 3c be                  db      '<',('>'+80h)
 3912 ad73: bc                     db      ('<'+80h)           ; [GDJ]
 3913 ad74: 55 bc                  db      'U',('<'+80h)       ; [GDJ]
 3914 ad76: 42 45 47 49 
            ce                     db      'BEGI',('N'+80h)
 3915 ad7b: 55 4e 54 49 
            cc                     db      'UNTI',('L'+80h)
 3916 ad80: 52 be                  db      'R',('>'+80h)
 3917 ad82: 3e d2                  db      '>',('R'+80h)
 3918 ad84: 52 c0                  db      'R',('@'+80h)       ; [GDJ]
 3919 ad86: 57 4f 52 44 
            d3                     db      'WORD',('S'+80h)
 3920 ad8b: 45 4d 49 d4            db      'EMI',('T'+80h)
 3921 ad8f: 45 4d 49 54 
            d0                     db      'EMIT',('P'+80h)    ; [GDJ]
 3922 ad94: 44 45 50 54 
            c8                     db      'DEPT',('H'+80h)
 3923 ad99: 52 4f d4               db      'RO',('T'+80h)
 3924 ad9c: 2d 52 4f d4            db      '-RO',('T'+80h)
 3925 ada0: 4f 56 45 d2            db      'OVE',('R'+80h)
 3926 ada4: c0                     db      ('@'+80h)
 3927 ada5: a1                     db      ('!'+80h)
 3928 ada6: 43 c0                  db      'C',('@'+80h)
 3929 ada8: 43 a1                  db      'C',('!'+80h)
 3930 adaa: 43 4d 4f 56 
            c5                     db      'CMOV',('E'+80h)    ; [GDJ]
 3931 adaf: 2e a2                  db      '.',(34+80h)
 3932 adb1: 4b 45 d9               db      'KE',('Y'+80h)
 3933 adb4: 4b 45 59 bf            db      'KEY',('?'+80h)     ; [GDJ]
 3934 adb8: 41 4c 4c 4f 
            d4                     db      'ALLO',('T'+80h)
 3935 adbd: 45 52 52 4f 
            d2                     db      'ERRO',('R'+80h)
 3936 adc2: 53 45 c5               db      'SE',('E'+80h)
 3937 adc5: 46 4f 52 47 
            45 d4                  db      'FORGE',('T'+80h)
 3938 adcb: 4f 55 d4               db      'OU',('T'+80h)
 3939 adce: 49 4e d0               db      'IN',('P'+80h)
 3940 add1: 45 c6                  db      'E',('F'+80h)
 3941 add3: 53 45 54 d1            db      'SET',('Q'+80h)     ; [GDJ]
 3942 add7: 53 41 56 c5            db      'SAV',('E'+80h)
 3943 addb: 4c 4f 41 c4            db      'LOA',('D'+80h)
 3944 addf: 42 59 c5               db      'BY',('E'+80h)
 3945 ade2: 53 50 c0               db      'SP',('@'+80h)      ; [GDJ]
 3946 ade5: 44 45 43 49 
            4d 41 cc               db      'DECIMA',('L'+80h)  ; [GDJ]
 3947 adec: 48 45 d8               db      'HE',('X'+80h)      ; [GDJ]
 3948 adef: 3c bc                  db      '<',('<'+80h)       ; [GDJ]
 3949 adf1: 3e be                  db      '>',('>'+80h)       ; [GDJ]
 3950 adf3: 44 45 4c 41 
            d9                     db      'DELA',('Y'+80h)    ; [GDJ]
 3951 adf8: 42 4c 4f 41 
            c4                     db      'BLOA',('D'+80h)    ; [GDJ]
 3952 adfd: 47 4f 54 4f 
            58 d9                  db      'GOTOX',('Y'+80h)   ; [GDJ]
 3953 ae03: 52 41 4e c4            db      'RAN',('D'+80h)     ; [GDJ]
 3954 ae07: 45 58 45 c3 	   db	   'EXE',('C'+80h) 
 3955 ae0b: 4c 49 53 d4 	   db      'LIS',('T'+80h)
 3956 ae0f: 00                     db      0                   ; no more tokens
 3957 ae10:             
 3958 ae10: a3 71       cmdvecs:   dw      cwhile              ; 81h
 3959 ae12: a3 bd                  dw      crepeat             ; 82h
 3960 ae14: a3 cd                  dw      cif                 ; 83h
 3961 ae16: a4 16                  dw      celse               ; 84h
 3962 ae18: a4 40                  dw      cthen               ; 85h
 3963 ae1a: a5 7a                  dw      cvariable           ; 86h
 3964 ae1c: a5 ae                  dw      ccolon              ; 87h
 3965 ae1e: a5 e6                  dw      csemi               ; 88h
 3966 ae20: a0 1c                  dw      cdup                ; 89h
 3967 ae22: a0 2b                  dw      cdrop               ; 8ah
 3968 ae24: a0 fd                  dw      cswap               ; 8bh
 3969 ae26: a0 34                  dw      cplus               ; 8ch
 3970 ae28: a0 55                  dw      cminus              ; 8dh
 3971 ae2a: a7 ca                  dw      cmul                ; 8eh
 3972 ae2c: a7 e3                  dw      cdiv                ; 8fh
 3973 ae2e: a0 76                  dw      cdot                ; 90h
 3974 ae30: a0 85                  dw      cudot               ; 91h
 3975 ae32: a1 22                  dw      ci                  ; 92h
 3976 ae34: a0 94                  dw      cand                ; 93h
 3977 ae36: a0 b5                  dw      cor                 ; 94h
 3978 ae38: a0 d6                  dw      cxor                ; 95h
 3979 ae3a: a0 f7                  dw      ccr                 ; 96h
 3980 ae3c: a1 2e                  dw      cmem                ; 97h
 3981 ae3e: a1 48                  dw      cdo                 ; 98h
 3982 ae40: a1 79                  dw      cloop               ; 99h
 3983 ae42: a1 bb                  dw      cploop              ; 9ah
 3984 ae44: a4 43                  dw      cequal              ; 9bh
 3985 ae46: a2 1f                  dw      cunequal            ; 9ch
 3986 ae48: a2 4e                  dw      cless               ; 9dh [GDJ]
 3987 ae4a: a2 8d                  dw      culess              ; 9eh [GDJ]
 3988 ae4c: a1 d4                  dw      cbegin              ; 9fh
 3989 ae4e: a1 e3                  dw      cuntil              ; a0h
 3990 ae50: a2 0a                  dw      crgt                ; a1h
 3991 ae52: a2 13                  dw      cgtr                ; a2h
 3992 ae54: a9 c7                  dw      crat                ; a3h [GDJ]
 3993 ae56: a2 c3                  dw      cwords              ; a4h
 3994 ae58: a3 46                  dw      cemit               ; a5h
 3995 ae5a: a3 53                  dw      cemitp              ; a6h [GDJ]
 3996 ae5c: a4 72                  dw      cdepth              ; a7h
 3997 ae5e: a4 90                  dw      crot                ; a8h
 3998 ae60: a4 c6                  dw      cmrot               ; a9h
 3999 ae62: a4 fc                  dw      cover               ; aah
 4000 ae64: a5 24                  dw      cat                 ; abh
 4001 ae66: a5 38                  dw      cexcl               ; ach
 4002 ae68: a5 50                  dw      ccat                ; adh
 4003 ae6a: a5 65                  dw      ccexcl              ; aeh
 4004 ae6c: a9 6a                  dw      ccmove              ; afh [GDJ]
 4005 ae6e: a7 2d                  dw      cdotqt              ; b0h
 4006 ae70: a7 56                  dw      ckey                ; b1h
 4007 ae72: a7 63                  dw      ckeyq               ; b2h [GDJ]
 4008 ae74: a7 77                  dw      callot              ; b3h
 4009 ae76: a8 7a                  dw      cerror              ; b4h
 4010 ae78: a5 e9                  dw      csee                ; b5h
 4011 ae7a: a8 06                  dw      cforget             ; b6h
 4012 ae7c: a8 a0                  dw      cout                ; b7h
 4013 ae7e: a8 f8                  dw      cinp                ; b8h
 4014 ae80: a8 84                  dw      cef                 ; b9h
 4015 ae82: a9 9d                  dw      csetq               ; bah [GDJ]
 4016 ae84: ab 0d                  dw      csave               ; bbh
 4017 ae86: ab 5e                  dw      cload               ; bch
 4018 ae88: ab a1                  dw      cbye                ; bdh
 4019 ae8a: a9 45                  dw      cspat               ; beh [GDJ]
 4020 ae8c: a9 af                  dw      cdecimal            ; bfh [GDJ]
 4021 ae8e: a9 bb                  dw      chex                ; c0h [GDJ]
 4022 ae90: aa 36                  dw      clshift             ; c1h [GDJ]
 4023 ae92: aa 64                  dw      crshift             ; c2h [GDJ]
 4024 ae94: aa 92                  dw      cdelay              ; c3h [GDJ]
 4025 ae96: aa d1                  dw      cbload              ; c4h [GDJ]
 4026 ae98: a9 e1                  dw      cgotoxy             ; c5h [GDJ]
 4027 ae9a: a9 d3                  dw      crand               ; c6h [GDJ]
 4028 ae9c: aa b0       	   dw      cexec               ; c7h [gnr]
 4029 ae9e: ac ab       	   dw	   clist	       ; c8h [gnr]
 4030 aea0:             
 4031 aea0:             
 4032 aea0:             ; this precompiled BASE variable is loaded at startup freemem
 4033 aea0:             ; important to zero next word else 'words' may interpret
 4034 aea0:             ; startup random data as valid (rarely) which will type garbage 
            #else
 4041 aea0: 03 18       basev:  db 003h, 018h,					   ; this must be basen+1 word
 4042 aea2: 7c ff c0 29 
            40 03 18 86         db 07ch, 0ffh, 0c0h, 029h, 040h, 003h, 018h, 086h, ; next word address + VARIABLE
 4043 aeaa: fe 42 41 53 
            45 00 00 0a         db 0feh, 042h, 041h, 053h, 045h, 000h, 000h, 00ah, ; T_NUM 'BASE' VALUE
 4044 aeb2: 00 00 00 00 
            00 00 00 00         db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h  ; zero next word
            #endif
 4046 aeba:             	
 4047 aeba:             
            #ifdef STGROM
 4049 aeba:             extblock:
 4050 aeba: 7e ff 7d ff 
            7c ff 07 c8             db  07eh, 0ffh, 07dh, 0ffh, 07ch, 0ffh, 007h, 0c8h, 
 4051 aec2: 7c ff c0 2f 
            1b 03 18 86             db  07ch, 0ffh, 0c0h, 02fh, 01bh, 003h, 018h, 086h, 
 4052 aeca: fe 42 41 53 
            45 00 00 0a             db  0feh, 042h, 041h, 053h, 045h, 000h, 000h, 00ah, 
 4053 aed2: 03 24 87 fe 
            4e 49 50 00             db  003h, 024h, 087h, 0feh, 04eh, 049h, 050h, 000h, 
 4054 aeda: 8b 8a 88 00 
            03 31 87 fe             db  08bh, 08ah, 088h, 000h, 003h, 031h, 087h, 0feh, 
 4055 aee2: 54 55 43 4b 
            00 8b aa 88             db  054h, 055h, 043h, 04bh, 000h, 08bh, 0aah, 088h, 
 4056 aeea: 00 03 47 87 
            fe 50 49 43             db  000h, 003h, 047h, 087h, 0feh, 050h, 049h, 043h, 
 4057 aef2: 4b 00 ff 00 
            02 8e ff 00             db  04bh, 000h, 0ffh, 000h, 002h, 08eh, 0ffh, 000h, 
 4058 aefa: 02 8c be 8c 
            ab 88 00 03             db  002h, 08ch, 0beh, 08ch, 0abh, 088h, 000h, 003h, 
 4059 af02: 54 87 fe 32 
            44 55 50 00             db  054h, 087h, 0feh, 032h, 044h, 055h, 050h, 000h, 
 4060 af0a: aa aa 88 00 
            03 62 87 fe             db  0aah, 0aah, 088h, 000h, 003h, 062h, 087h, 0feh, 
 4061 af12: 32 44 52 4f 
            50 00 8a 8a             db  032h, 044h, 052h, 04fh, 050h, 000h, 08ah, 08ah, 
 4062 af1a: 88 00 03 80 
            87 fe 32 4f             db  088h, 000h, 003h, 080h, 087h, 0feh, 032h, 04fh, 
 4063 af22: 56 45 52 00 
            ff 00 03 fe             db  056h, 045h, 052h, 000h, 0ffh, 000h, 003h, 0feh, 
 4064 af2a: 50 49 43 4b 
            00 ff 00 03             db  050h, 049h, 043h, 04bh, 000h, 0ffh, 000h, 003h, 
 4065 af32: fe 50 49 43 
            4b 00 88 00             db  0feh, 050h, 049h, 043h, 04bh, 000h, 088h, 000h, 
 4066 af3a: 03 90 87 fe 
            32 53 57 41             db  003h, 090h, 087h, 0feh, 032h, 053h, 057h, 041h, 
 4067 af42: 50 00 a2 a9 
            a1 a9 88 00             db  050h, 000h, 0a2h, 0a9h, 0a1h, 0a9h, 088h, 000h, 
 4068 af4a: 03 9e 87 fe 
            54 52 55 45             db  003h, 09eh, 087h, 0feh, 054h, 052h, 055h, 045h, 
 4069 af52: 00 ff 00 01 
            88 00 03 ad             db  000h, 0ffh, 000h, 001h, 088h, 000h, 003h, 0adh, 
 4070 af5a: 87 fe 46 41 
            4c 53 45 00             db  087h, 0feh, 046h, 041h, 04ch, 053h, 045h, 000h, 
 4071 af62: ff 00 00 88 
            00 03 b6 87             db  0ffh, 000h, 000h, 088h, 000h, 003h, 0b6h, 087h, 
 4072 af6a: fe 4a 00 a3 
            88 00 03 c3             db  0feh, 04ah, 000h, 0a3h, 088h, 000h, 003h, 0c3h, 
 4073 af72: 87 fe 31 2b 
            00 ff 00 01             db  087h, 0feh, 031h, 02bh, 000h, 0ffh, 000h, 001h, 
 4074 af7a: 8c 88 00 03 
            d0 87 fe 31             db  08ch, 088h, 000h, 003h, 0d0h, 087h, 0feh, 031h, 
 4075 af82: 2d 00 ff 00 
            01 8d 88 00             db  02dh, 000h, 0ffh, 000h, 001h, 08dh, 088h, 000h, 
 4076 af8a: 03 dd 87 fe 
            32 2b 00 ff             db  003h, 0ddh, 087h, 0feh, 032h, 02bh, 000h, 0ffh, 
 4077 af92: 00 02 8c 88 
            00 03 ea 87             db  000h, 002h, 08ch, 088h, 000h, 003h, 0eah, 087h, 
 4078 af9a: fe 32 2d 00 
            ff 00 02 8d             db  0feh, 032h, 02dh, 000h, 0ffh, 000h, 002h, 08dh, 
 4079 afa2: 88 00 03 f7 
            87 fe 30 3d             db  088h, 000h, 003h, 0f7h, 087h, 0feh, 030h, 03dh, 
 4080 afaa: 00 ff 00 00 
            9b 88 00 04             db  000h, 0ffh, 000h, 000h, 09bh, 088h, 000h, 004h, 
 4081 afb2: 05 87 fe 4e 
            4f 54 00 fe             db  005h, 087h, 0feh, 04eh, 04fh, 054h, 000h, 0feh, 
 4082 afba: 30 3d 00 88 
            00 04 10 87             db  030h, 03dh, 000h, 088h, 000h, 004h, 010h, 087h, 
 4083 afc2: fe 55 3e 00 
            8b 9e 88 00             db  0feh, 055h, 03eh, 000h, 08bh, 09eh, 088h, 000h, 
 4084 afca: 04 28 87 fe 
            55 3e 3d 00             db  004h, 028h, 087h, 0feh, 055h, 03eh, 03dh, 000h, 
 4085 afd2: fe 32 44 55 
            50 00 fe 55             db  0feh, 032h, 044h, 055h, 050h, 000h, 0feh, 055h, 
 4086 afda: 3e 00 a2 9b 
            a1 94 88 00             db  03eh, 000h, 0a2h, 09bh, 0a1h, 094h, 088h, 000h, 
 4087 afe2: 04 3c 87 fe 
            55 3c 3d 00             db  004h, 03ch, 087h, 0feh, 055h, 03ch, 03dh, 000h, 
 4088 afea: fe 55 3e 3d 
            00 fe 4e 4f             db  0feh, 055h, 03eh, 03dh, 000h, 0feh, 04eh, 04fh, 
 4089 aff2: 54 00 88 00 
            04 46 87 fe             db  054h, 000h, 088h, 000h, 004h, 046h, 087h, 0feh, 
 4090 affa: 3e 00 8b 9d 
            88 00 04 57             db  03eh, 000h, 08bh, 09dh, 088h, 000h, 004h, 057h, 
 4091 b002: 87 fe 3c 3d 
            00 fe 3e 00             db  087h, 0feh, 03ch, 03dh, 000h, 0feh, 03eh, 000h, 
 4092 b00a: fe 4e 4f 54 
            00 88 00 04             db  0feh, 04eh, 04fh, 054h, 000h, 088h, 000h, 004h, 
 4093 b012: 66 87 fe 3e 
            3d 00 9d fe             db  066h, 087h, 0feh, 03eh, 03dh, 000h, 09dh, 0feh, 
 4094 b01a: 4e 4f 54 00 
            88 00 04 75             db  04eh, 04fh, 054h, 000h, 088h, 000h, 004h, 075h, 
 4095 b022: 87 fe 30 3e 
            00 ff 00 00             db  087h, 0feh, 030h, 03eh, 000h, 0ffh, 000h, 000h, 
 4096 b02a: fe 3e 00 88 
            00 04 82 87             db  0feh, 03eh, 000h, 088h, 000h, 004h, 082h, 087h, 
 4097 b032: fe 30 3c 00 
            ff 00 00 9d             db  0feh, 030h, 03ch, 000h, 0ffh, 000h, 000h, 09dh, 
 4098 b03a: 88 00 04 90 
            87 fe 46 52             db  088h, 000h, 004h, 090h, 087h, 0feh, 046h, 052h, 
 4099 b042: 45 45 00 97 
            91 96 88 00             db  045h, 045h, 000h, 097h, 091h, 096h, 088h, 000h, 
 4100 b04a: 04 9f 87 fe 
            2b 21 00 8b             db  004h, 09fh, 087h, 0feh, 02bh, 021h, 000h, 08bh, 
 4101 b052: aa ab 8c 8b 
            ac 88 00 04             db  0aah, 0abh, 08ch, 08bh, 0ach, 088h, 000h, 004h, 
 4102 b05a: af 87 fe 2d 
            21 00 8b aa             db  0afh, 087h, 0feh, 02dh, 021h, 000h, 08bh, 0aah, 
 4103 b062: ab 8b 8d 8b 
            ac 88 00 04             db  0abh, 08bh, 08dh, 08bh, 0ach, 088h, 000h, 004h, 
 4104 b06a: be 87 fe 2a 
            21 00 8b aa             db  0beh, 087h, 0feh, 02ah, 021h, 000h, 08bh, 0aah, 
 4105 b072: ab 8e 8b ac 
            88 00 04 ce             db  0abh, 08eh, 08bh, 0ach, 088h, 000h, 004h, 0ceh, 
 4106 b07a: 87 fe 2f 21 
            00 8b aa ab             db  087h, 0feh, 02fh, 021h, 000h, 08bh, 0aah, 0abh, 
 4107 b082: 8b 8f 8b ac 
            88 00 04 de             db  08bh, 08fh, 08bh, 0ach, 088h, 000h, 004h, 0deh, 
 4108 b08a: 87 fe 43 2b 
            21 00 89 a2             db  087h, 0feh, 043h, 02bh, 021h, 000h, 089h, 0a2h, 
 4109 b092: ad 8c a1 ae 
            88 00 04 ef             db  0adh, 08ch, 0a1h, 0aeh, 088h, 000h, 004h, 0efh, 
 4110 b09a: 87 fe 43 2d 
            21 00 89 a2             db  087h, 0feh, 043h, 02dh, 021h, 000h, 089h, 0a2h, 
 4111 b0a2: ad 8b 8d a1 
            ae 88 00 05             db  0adh, 08bh, 08dh, 0a1h, 0aeh, 088h, 000h, 005h, 
 4112 b0aa: 00 87 fe 40 
            2b 00 89 ab             db  000h, 087h, 0feh, 040h, 02bh, 000h, 089h, 0abh, 
 4113 b0b2: 8b ff 00 02 
            8c 8b 88 00             db  08bh, 0ffh, 000h, 002h, 08ch, 08bh, 088h, 000h, 
 4114 b0ba: 05 0a 87 fe 
            3f 00 ab 91             db  005h, 00ah, 087h, 0feh, 03fh, 000h, 0abh, 091h, 
 4115 b0c2: 88 00 05 19 
            87 fe 4e 45             db  088h, 000h, 005h, 019h, 087h, 0feh, 04eh, 045h, 
 4116 b0ca: 47 00 ff 00 
            00 8b 8d 88             db  047h, 000h, 0ffh, 000h, 000h, 08bh, 08dh, 088h, 
 4117 b0d2: 00 05 30 87 
            fe 4d 49 4e             db  000h, 005h, 030h, 087h, 0feh, 04dh, 049h, 04eh, 
 4118 b0da: 00 fe 32 44 
            55 50 00 fe             db  000h, 0feh, 032h, 044h, 055h, 050h, 000h, 0feh, 
 4119 b0e2: 3e 00 83 8b 
            85 8a 88 00             db  03eh, 000h, 083h, 08bh, 085h, 08ah, 088h, 000h, 
 4120 b0ea: 05 45 87 fe 
            4d 41 58 00             db  005h, 045h, 087h, 0feh, 04dh, 041h, 058h, 000h, 
 4121 b0f2: fe 32 44 55 
            50 00 9d 83             db  0feh, 032h, 044h, 055h, 050h, 000h, 09dh, 083h, 
 4122 b0fa: 8b 85 8a 88 
            00 05 5e 87             db  08bh, 085h, 08ah, 088h, 000h, 005h, 05eh, 087h, 
 4123 b102: fe 55 4d 49 
            4e 00 fe 32             db  0feh, 055h, 04dh, 049h, 04eh, 000h, 0feh, 032h, 
 4124 b10a: 44 55 50 00 
            fe 55 3e 00             db  044h, 055h, 050h, 000h, 0feh, 055h, 03eh, 000h, 
 4125 b112: 83 8b 85 8a 
            88 00 05 74             db  083h, 08bh, 085h, 08ah, 088h, 000h, 005h, 074h, 
 4126 b11a: 87 fe 55 4d 
            41 58 00 fe             db  087h, 0feh, 055h, 04dh, 041h, 058h, 000h, 0feh, 
 4127 b122: 32 44 55 50 
            00 9e 83 8b             db  032h, 044h, 055h, 050h, 000h, 09eh, 083h, 08bh, 
 4128 b12a: 85 8a 88 00 
            05 83 87 fe             db  085h, 08ah, 088h, 000h, 005h, 083h, 087h, 0feh, 
 4129 b132: 3f 44 55 50 
            00 89 83 89             db  03fh, 044h, 055h, 050h, 000h, 089h, 083h, 089h, 
 4130 b13a: 85 88 00 05 
            99 87 fe 41             db  085h, 088h, 000h, 005h, 099h, 087h, 0feh, 041h, 
 4131 b142: 42 53 00 89 
            fe 30 3c 00             db  042h, 053h, 000h, 089h, 0feh, 030h, 03ch, 000h, 
 4132 b14a: 83 ff 00 00 
            8b 8d 85 88             db  083h, 0ffh, 000h, 000h, 08bh, 08dh, 085h, 088h, 
 4133 b152: 00 05 a5 87 
            fe 42 4c 00             db  000h, 005h, 0a5h, 087h, 0feh, 042h, 04ch, 000h, 
 4134 b15a: ff 00 20 88 
            00 05 b5 87             db  0ffh, 000h, 020h, 088h, 000h, 005h, 0b5h, 087h, 
 4135 b162: fe 53 50 41 
            43 45 00 ff             db  0feh, 053h, 050h, 041h, 043h, 045h, 000h, 0ffh, 
 4136 b16a: 00 20 a5 88 
            00 05 cb 87             db  000h, 020h, 0a5h, 088h, 000h, 005h, 0cbh, 087h, 
 4137 b172: fe 53 50 41 
            43 45 53 00             db  0feh, 053h, 050h, 041h, 043h, 045h, 053h, 000h, 
 4138 b17a: ff 00 00 98 
            ff 00 20 a5             db  0ffh, 000h, 000h, 098h, 0ffh, 000h, 020h, 0a5h, 
 4139 b182: 99 88 00 05 
            f1 87 fe 43             db  099h, 088h, 000h, 005h, 0f1h, 087h, 0feh, 043h, 
 4140 b18a: 4c 53 00 ff 
            00 1b a5 ff             db  04ch, 053h, 000h, 0ffh, 000h, 01bh, 0a5h, 0ffh, 
 4141 b192: 00 5b a5 ff 
            00 32 a5 ff             db  000h, 05bh, 0a5h, 0ffh, 000h, 032h, 0a5h, 0ffh, 
 4142 b19a: 00 4a a5 ff 
            00 1b a5 ff             db  000h, 04ah, 0a5h, 0ffh, 000h, 01bh, 0a5h, 0ffh, 
 4143 b1a2: 00 5b a5 ff 
            00 48 a5 88             db  000h, 05bh, 0a5h, 0ffh, 000h, 048h, 0a5h, 088h, 
 4144 b1aa: 00 06 0d 87 
            fe 4c 53 48             db  000h, 006h, 00dh, 087h, 0feh, 04ch, 053h, 048h, 
 4145 b1b2: 49 46 54 00 
            89 81 8b ff             db  049h, 046h, 054h, 000h, 089h, 081h, 08bh, 0ffh, 
 4146 b1ba: 00 02 8e 8b 
            ff 00 01 8d             db  000h, 002h, 08eh, 08bh, 0ffh, 000h, 001h, 08dh, 
 4147 b1c2: 89 82 8a 88 
            00 06 29 87             db  089h, 082h, 08ah, 088h, 000h, 006h, 029h, 087h, 
 4148 b1ca: fe 52 53 48 
            49 46 54 00             db  0feh, 052h, 053h, 048h, 049h, 046h, 054h, 000h, 
 4149 b1d2: 89 81 8b ff 
            00 02 8f 8b             db  089h, 081h, 08bh, 0ffh, 000h, 002h, 08fh, 08bh, 
 4150 b1da: ff 00 01 8d 
            89 82 8a 88             db  0ffh, 000h, 001h, 08dh, 089h, 082h, 08ah, 088h, 
 4151 b1e2: 00 06 3a 87 
            fe 49 4e 56             db  000h, 006h, 03ah, 087h, 0feh, 049h, 04eh, 056h, 
 4152 b1ea: 45 52 54 00 
            ff ff ff 95             db  045h, 052h, 054h, 000h, 0ffh, 0ffh, 0ffh, 095h, 
 4153 b1f2: 88 00 06 54 
            87 fe 53 47             db  088h, 000h, 006h, 054h, 087h, 0feh, 053h, 047h, 
 4154 b1fa: 4e 00 89 83 
            ff 80 00 93             db  04eh, 000h, 089h, 083h, 0ffh, 080h, 000h, 093h, 
 4155 b202: 83 ff ff ff 
            84 ff 00 01             db  083h, 0ffh, 0ffh, 0ffh, 084h, 0ffh, 000h, 001h, 
 4156 b20a: 85 85 88 00 
            06 66 87 fe             db  085h, 085h, 088h, 000h, 006h, 066h, 087h, 0feh, 
 4157 b212: 4d 4f 44 00 
            89 a8 89 a8             db  04dh, 04fh, 044h, 000h, 089h, 0a8h, 089h, 0a8h, 
 4158 b21a: 8f a8 8e 8d 
            88 00 06 7a             db  08fh, 0a8h, 08eh, 08dh, 088h, 000h, 006h, 07ah, 
 4159 b222: 87 fe 2f 4d 
            4f 44 00 aa             db  087h, 0feh, 02fh, 04dh, 04fh, 044h, 000h, 0aah, 
 4160 b22a: aa fe 4d 4f 
            44 00 a9 8f             db  0aah, 0feh, 04dh, 04fh, 044h, 000h, 0a9h, 08fh, 
 4161 b232: 88 00 06 8c 
            87 fe 47 45             db  088h, 000h, 006h, 08ch, 087h, 0feh, 047h, 045h, 
 4162 b23a: 54 42 49 54 
            00 c2 ff 00             db  054h, 042h, 049h, 054h, 000h, 0c2h, 0ffh, 000h, 
 4163 b242: 01 93 88 00 
            06 9f 87 fe             db  001h, 093h, 088h, 000h, 006h, 09fh, 087h, 0feh, 
 4164 b24a: 53 45 54 42 
            49 54 00 ff             db  053h, 045h, 054h, 042h, 049h, 054h, 000h, 0ffh, 
 4165 b252: 00 01 8b c1 
            94 88 00 06             db  000h, 001h, 08bh, 0c1h, 094h, 088h, 000h, 006h, 
 4166 b25a: b6 87 fe 43 
            4c 52 42 49             db  0b6h, 087h, 0feh, 043h, 04ch, 052h, 042h, 049h, 
 4167 b262: 54 00 ff 00 
            01 8b c1 ff             db  054h, 000h, 0ffh, 000h, 001h, 08bh, 0c1h, 0ffh, 
 4168 b26a: ff ff 95 93 
            88 00 06 c9             db  0ffh, 0ffh, 095h, 093h, 088h, 000h, 006h, 0c9h, 
 4169 b272: 87 fe 54 47 
            4c 42 49 54             db  087h, 0feh, 054h, 047h, 04ch, 042h, 049h, 054h, 
 4170 b27a: 00 ff 00 01 
            8b c1 95 88             db  000h, 0ffh, 000h, 001h, 08bh, 0c1h, 095h, 088h, 
 4171 b282: 00 06 e7 87 
            fe 42 59 54             db  000h, 006h, 0e7h, 087h, 0feh, 042h, 059h, 054h, 
 4172 b28a: 45 53 57 41 
            50 00 89 ff             db  045h, 053h, 057h, 041h, 050h, 000h, 089h, 0ffh, 
 4173 b292: 00 08 c2 8b 
            ff 00 ff 93             db  000h, 008h, 0c2h, 08bh, 0ffh, 000h, 0ffh, 093h, 
 4174 b29a: ff 00 08 c1 
            94 88 00 07             db  0ffh, 000h, 008h, 0c1h, 094h, 088h, 000h, 007h, 
 4175 b2a2: 01 87 fe 46 
            49 4c 4c 00             db  001h, 087h, 0feh, 046h, 049h, 04ch, 04ch, 000h, 
 4176 b2aa: 8b a2 aa ae 
            89 fe 31 2b             db  08bh, 0a2h, 0aah, 0aeh, 089h, 0feh, 031h, 02bh, 
 4177 b2b2: 00 a1 fe 31 
            2d 00 af 88             db  000h, 0a1h, 0feh, 031h, 02dh, 000h, 0afh, 088h, 
 4178 b2ba: 00 07 16 87 
            fe 45 52 41             db  000h, 007h, 016h, 087h, 0feh, 045h, 052h, 041h, 
 4179 b2c2: 53 45 00 ff 
            00 00 fe 46             db  053h, 045h, 000h, 0ffh, 000h, 000h, 0feh, 046h, 
 4180 b2ca: 49 4c 4c 00 
            88 00 07 27             db  049h, 04ch, 04ch, 000h, 088h, 000h, 007h, 027h, 
 4181 b2d2: 87 fe 43 4c 
            45 41 52 00             db  087h, 0feh, 043h, 04ch, 045h, 041h, 052h, 000h, 
 4182 b2da: a7 81 8a a7 
            82 88 00 07             db  0a7h, 081h, 08ah, 0a7h, 082h, 088h, 000h, 007h, 
 4183 b2e2: 60 87 fe 2e 
            53 00 b0 fe             db  060h, 087h, 0feh, 02eh, 053h, 000h, 0b0h, 0feh, 
 4184 b2ea: 3c 20 22 00 
            a7 ff 00 08             db  03ch, 020h, 022h, 000h, 0a7h, 0ffh, 000h, 008h, 
 4185 b2f2: a5 90 ff 00 
            08 a5 b0 fe             db  0a5h, 090h, 0ffh, 000h, 008h, 0a5h, 0b0h, 0feh, 
 4186 b2fa: 3e 20 22 00 
            a7 fe 3f 44             db  03eh, 020h, 022h, 000h, 0a7h, 0feh, 03fh, 044h, 
 4187 b302: 55 50 00 83 
            89 ff 00 00             db  055h, 050h, 000h, 083h, 089h, 0ffh, 000h, 000h, 
 4188 b30a: 98 89 92 8d 
            fe 50 49 43             db  098h, 089h, 092h, 08dh, 0feh, 050h, 049h, 043h, 
 4189 b312: 4b 00 90 99 
            8a 85 88 00             db  04bh, 000h, 090h, 099h, 08ah, 085h, 088h, 000h, 
 4190 b31a: 07 7d 87 fe 
            54 59 50 45             db  007h, 07dh, 087h, 0feh, 054h, 059h, 050h, 045h, 
 4191 b322: 00 89 83 ff 
            00 00 98 89             db  000h, 089h, 083h, 0ffh, 000h, 000h, 098h, 089h, 
 4192 b32a: ad a6 ff 00 
            01 8c 99 84             db  0adh, 0a6h, 0ffh, 000h, 001h, 08ch, 099h, 084h, 
 4193 b332: 8a 85 8a 88 
            00 07 c8 87             db  08ah, 085h, 08ah, 088h, 000h, 007h, 0c8h, 087h, 
 4194 b33a: fe 44 55 4d 
            50 00 96 ff             db  0feh, 044h, 055h, 04dh, 050h, 000h, 096h, 0ffh, 
 4195 b342: 00 05 fe 53 
            50 41 43 45             db  000h, 005h, 0feh, 053h, 050h, 041h, 043h, 045h, 
 4196 b34a: 53 00 ff 00 
            10 ff 00 00             db  053h, 000h, 0ffh, 000h, 010h, 0ffh, 000h, 000h, 
 4197 b352: 98 92 90 99 
            ff 00 00 98             db  098h, 092h, 090h, 099h, 0ffh, 000h, 000h, 098h, 
 4198 b35a: 96 89 90 ff 
            00 10 ff 00             db  096h, 089h, 090h, 0ffh, 000h, 010h, 0ffh, 000h, 
 4199 b362: 00 98 89 ad 
            90 fe 31 2b             db  000h, 098h, 089h, 0adh, 090h, 0feh, 031h, 02bh, 
 4200 b36a: 00 99 89 ff 
            00 10 8d ff             db  000h, 099h, 089h, 0ffh, 000h, 010h, 08dh, 0ffh, 
 4201 b372: 00 10 fe 54 
            59 50 45 00             db  000h, 010h, 0feh, 054h, 059h, 050h, 045h, 000h, 
 4202 b37a: ff 00 10 9a 
            8a 96 88 00             db  0ffh, 000h, 010h, 09ah, 08ah, 096h, 088h, 000h, 
 4203 b382: 00 00 00 00 
            00 00 00 00             db  000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h, 
 4204 b38a: 00 00 00 00 
            00 00 00 00             db  000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h, 
 4205 b392: 00 00 00 00 
            00 00 00 00             db  000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h, 
 4206 b39a: 00 00 00 00 
            00 00 00 00             db  000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h, 
 4207 b3a2: 00 00 00 00 
            00 00 00 00             db  000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h, 
 4208 b3aa: 00 00 00 00 
            00 00 00 00             db  000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h, 
 4209 b3b2: 00 00 00 00 
            00 00 00 00             db  000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
 4210 b3ba:             endextblock:
            #endif
 4212 b3ba:             
 4213 b3ba:             endrom:    equ     $
 4214 b3ba:             
            #endif
 4227 b3ba:             
 4228 b3ba:                        end     start
 4229 b3ba:             
 4230 b3ba:             
 4231 b3ba:                        
 4232 b3ba:             

9fe0h: ASCERR           - <  1367>   1379 
9fe9h: ASCNOERR         - <  1372>   1366 
0317h: BASEN            - <   103>   1081   1258   3174   3179   3656   3671 
aea0h: BASEV            - <  4041>    427 
aaefh: BLOADLP          - <  3377>   3382   3384 
0200h: BUFFER           - <    95>    508    510    521    945    947   3220 
         3225   3235   3241   3412   3422   3506   3510   3676   3688   3702 
ffe0h: CALL             - <   142> 
a777h: CALLOT           - <  2771>   4008 
a77dh: CALLOTLP1        - <  2775>   2791 
a78fh: CALLOTNO         - <  2787>   2783   2785 
a796h: CALLOTYES        - <  2792>   2786 
a094h: CAND             - <  1502>   3976 
a524h: CAT              - <  2338>   4000 
a1d4h: CBEGIN           - <  1752>   3988 
aad1h: CBLOAD           - <  3365>   4025 
aba1h: CBYE             - <  3598>   4018 
a550h: CCAT             - <  2370>   4002 
a565h: CCEXCL           - <  2385>   4003 
a96ah: CCMOVE           - <  3135>   4004 
a5aeh: CCOLON           - <  2443>   3964 
a0f7h: CCR              - <  1577>   3979 
a9afh: CDECIMAL         - <  3174>   4020 
aa92h: CDELAY           - <  3319>   4024 
a472h: CDEPTH           - <  2200>   3996 
a7e3h: CDIV             - <  2851>   3972 
a148h: CDO              - <  1640>   3981 
a076h: CDOT             - <  1474>   3973 
a72dh: CDOTQT           - <  2722>   4005 
a74eh: CDOTQTDN         - <  2744>   2736 
a73dh: CDOTQTLP         - <  2735>   2738   2743 
a02bh: CDROP            - <  1418>   3967 
a01ch: CDUP             - <  1409>   3966 
a884h: CEF              - <  2991>   4014 
a88ah: CEF1             - <  2994>   2992 
a88eh: CEF2             - <  2996>   2994 
a892h: CEF3             - <  2998>   2996 
a896h: CEF4             - <  3000>   2998 
a416h: CELSE            - <  2135>   3961 
a346h: CEMIT            - <  1994>   3994 
a353h: CEMITP           - <  2003>   3995 
a443h: CEQUAL           - <  2167>   3984 
a87ah: CERROR           - <  2979>   4009 
a538h: CEXCL            - <  2353>   4001 
aab0h: CEXEC            - <  3340>   4028 
aaceh: CEXEC0           - <  3358>   3353 
a806h: CFORGET          - <  2877>   4011 
a9e1h: CGOTOXY          - <  3205>   4026 
a213h: CGTR             - <  1798>   3991 
a9bbh: CHEX             - <  3179>   4021 
a122h: CI               - <  1609>   3975 
a3cdh: CIF              - <  2090>   3960 
a8f8h: CINP             - <  3057>   4013 
a908h: CINP2            - <  3065>   3062 
a911h: CINP3            - <  3069>   3066 
a91ah: CINP4            - <  3073>   3070 
a923h: CINP5            - <  3077>   3074 
a92ch: CINP6            - <  3081>   3078 
a935h: CINP7            - <  3085>   3082 
a93bh: CINPD            - <  3088>   3064   3068   3072   3076   3080   3084 
a756h: CKEY             - <  2751>   4006 
a763h: CKEYQ            - <  2760>   4007 
a24eh: CLESS            - <  1840>   3986 
acabh: CLIST            - <  3795>   4029 
acb1h: CLIST0           - <  3796>   3818 
acc4h: CLIST1           - <  3805>   3799   3802 
ab5eh: CLOAD            - <  3501>   4017 
a179h: CLOOP            - <  1679>   3982 
a1b5h: CLOOPDN          - <  1729>   1697 
ac86h: CLRMEMLP         - <  3757>   3762   3764 
ac7ah: CLRSTACKS        - <  3754>    437 
aa36h: CLSHIFT          - <  3256>   4022 
9e13h: CMDEND           - <  1019>    990 
9de6h: CMDLOOP          - <   981>   1014 
ad26h: CMDTABLE         - <  3884>    972    974   1924   1926   2694   2696 
ae10h: CMDVECS          - <  3958>   1305   1308 
a12eh: CMEM             - <  1617>   3980 
a055h: CMINUS           - <  1449>   3970 
a988h: CMOVELP          - <  3150>   3159 
a99ah: CMOVERTN         - <  3160>   3154 
a993h: CMOVESTR         - <  3155>   3151   3153 
a4c6h: CMROT            - <  2267>   3998 
a7cah: CMUL             - <  2835>   3971 
a5beh: COLONLP1         - <  2456>   2458 
a0b5h: COR              - <  1527>   3977 
a8a0h: COUT             - <  3009>   4012 
a8bch: COUT2            - <  3026>   3022 
a8c6h: COUT3            - <  3031>   3027 
a8d0h: COUT4            - <  3036>   3032 
a8dah: COUT5            - <  3041>   3037 
a8e4h: COUT6            - <  3046>   3042 
a8eeh: COUT7            - <  3051>   3047 
a8f5h: COUT8            - <  3055>   3052 
a4fch: COVER            - <  2308>   3999 
a1bbh: CPLOOP           - <  1732>   3983 
a034h: CPLUS            - <  1423>   3969 
a9d3h: CRAND            - <  3192>   4027 
a9c7h: CRAT             - <  3184>   3992 
a3bdh: CREPEAT          - <  2076>   3959 
a20ah: CRGT             - <  1792>   3990 
ad0bh: CRLF             - <  3880>    542    544 
9c17h: CRLFOUT          - <   540>    520   1578   1951   1954   1968   1990 
         2573   2648 
a490h: CROT             - <  2226>   3997 
aa64h: CRSHIFT          - <  3287>   4023 
ab0dh: CSAVE            - <  3396>   4016 
a5e9h: CSEE             - <  2492>   4010 
a6c0h: CSEEFUNC         - <  2650>   2538 
a614h: CSEE_SUB         - <  2531>   2514 
a60ah: CSEE_SUB0        - <  2521>   3809 
a5e6h: CSEMI            - <  2489>   3965 
a99dh: CSETQ            - <  3163>   4015 
a945h: CSPAT            - <  3102>   4019 
a610h: CSUB0            - <  2528>   2530 
a0fdh: CSWAP            - <  1581>   3968 
a440h: CTHEN            - <  2165>   3962 
a085h: CUDOT            - <  1488>   3974 
a28dh: CULESS           - <  1888>   3987 
a21fh: CUNEQUAL         - <  1805>   3985 
a1e3h: CUNTIL           - <  1766>   3989 
a57ah: CVARIABLE        - <  2399>   3963 
a371h: CWHILE           - <  2024>   3958 
a2c3h: CWORDS           - <  1924>   3993 
a2feh: CWORDSDN         - <  1953>   1930 
a318h: CWORDSDN1        - <  1967> 
a2e0h: CWORDSF          - <  1938>   1933 
a2cfh: CWORDSLP         - <  1929>   1937   1948   1952 
a30dh: CWORDSLP2        - <  1960>   1987   1991 
a31eh: CWORDSNOT        - <  1970>   1964   1966 
a0d6h: CXOR             - <  1552>   3978 
9d5fh: D16LP1           - <   862>    855    857    877 
9e70h: DECNUM           - <  1086>   1078 
aa9ch: DELAYLP1         - <  3327>   3334   3336 
aa9eh: DELAYLP2         - <  3328>   3330 
9c2ah: DISP             - <   558>   1936   1941   1944   1975   1979   1999 
         2020   2549   2622   2641   2652   2656   2665   2713   2719   2742 
         3655   3665 
9d47h: DIV16            - <   845>   2865 
9d8bh: DIVGO            - <   893>    879    881 
9db1h: DIVNO            - <   927>    914 
9d8ah: DIVRET           - <   892>    884 
9d74h: DIVST            - <   878>    864    939 
9da5h: DIVYES           - <   915>    909 
a429h: ELSECNT          - <  2150>   2154   2157 
a422h: ELSELP1          - <  2146>   2151 
a42dh: ELSENIF          - <  2152>   2148 
a36bh: EMITPOUT         - <  2019>   2015 
b3bah: ENDEXTBLOCK      - <  4210>   3375 
b3bah: ENDROM           - <  4213> 
a240h: EQ2              - <  1828>   1835 
a465h: EQ3              - <  2191>   2197 
ac58h: ERR              - <  3727> 
a012h: ERROR            - <  1403>   1411   1420   1425   1432   1451   1458 
         1476   1490   1504   1511   1529   1536   1554   1561   1583   1590 
         1642   1649   1741   1768   1800   1807   1814   1842   1849   1890 
         1897   1996   2005   2026   2092   2169   2176   2228   2235   2242 
         2269   2276   2283   2310   2317   2340   2355   2362   2372   2387 
         2394   2410   2454   2503   2507   2733   2795   2798   2837   2844 
         2853   2860   2888   2892   2981   3011   3016   3059   3086   3137 
         3141   3145   3165   3207   3211   3258   3264   3289   3295   3321 
         3342 
9f76h: EXEC             - <  1288>    536   1330   1358   1386   1392   1399 
9fd5h: EXECASCII        - <  1359>   1294 
a011h: EXECDN           - <  1401>   1289 
9fc2h: EXECNUM          - <  1343>   1291 
9fadh: EXECRET          - <  1322>   1404   1406   2983 
9fbeh: EXECRMSG         - <  1335>   1371 
a007h: EXECVAR          - <  1393>   1376 
8003h: EXITADDR         - <   106>   3598 
aebah: EXTBLOCK         - <  4049>   3369   3375 
ac54h: FAILS            - <  3723>   3718   3720   3741   3746   3749 
00b3h: FALLOT           - <   289>    290 
0093h: FAND             - <   257>    258 
00abh: FAT              - <   281>    282 
009fh: FBEGIN           - <   269>    270 
00adh: FCAT             - <   283>    284 
00aeh: FCEXCL           - <   284>    285 
00afh: FCMOVE           - <   285>    286 
0087h: FCOLON           - <   245>    246 
0096h: FCR              - <   260>    261 
00a7h: FDEPTH           - <   277>    278 
008fh: FDIV             - <   253>    254 
0098h: FDO              - <   262>    263 
0090h: FDOT             - <   254>    255 
00b0h: FDOTQT           - <   286>    287   1036 
008ah: FDROP            - <   248>    249 
0089h: FDUP             - <   247>    248 
0084h: FELSE            - <   242>    243 
00a5h: FEMIT            - <   275>    276 
00a6h: FEMITP           - <   276>    277 
009bh: FEQUAL           - <   265>    266 
00b4h: FERROR           - <   290>    291 
00ach: FEXCL            - <   282>    283 
00b7h: FEXEC            - <   293>    294 
00b6h: FFORGET          - <   292>    293 
00a2h: FGTR             - <   272>    273 
0092h: FI               - <   256>    257 
0083h: FIF              - <   241>    242 
9cc3h: FINDCHK          - <   726>    735 
9cd3h: FINDFOUND        - <   736>    732 
9cbch: FINDGO           - <   719>    713    715 
9cach: FINDLP           - <   708>    751 
9ca5h: FINDNAME         - <   703>   1365   2506   2891 
9cdch: FINDNEXT         - <   742>    730 
a38bh: FINDREP          - <  2042>   2047 
9cbah: FINDRET          - <   717>    741 
00b1h: FKEY             - <   287>    288 
00b2h: FKEYQ            - <   288>    289 
009dh: FLESS            - <   267>    268 
00b8h: FLIST            - <   294> 
0099h: FLOOP            - <   263>    264 
0097h: FMEM             - <   261>    262 
008dh: FMINUS           - <   251>    252 
00a9h: FMROT            - <   279>    280 
008eh: FMUL             - <   252>    253 
a3a4h: FNDREP           - <  2055>   2052 
0094h: FOR              - <   258>    259 
a84ch: FORGETD1         - <  2938>   2920 
a864h: FORGETLP         - <  2962>   2967   2969 
a831h: FORGETLP1        - <  2914>   2936 
00aah: FOVER            - <   280>    281 
009ah: FPLOOP           - <   264>    265 
008ch: FPLUS            - <   250>    251 
00a3h: FRAT             - <   273>    274 
0306h: FREEMEM          - <    99>    356    428    527    949   1618   2416 
         2462   2822   2944   3400 
0082h: FREPEAT          - <   240>    241 
00a1h: FRGT             - <   271>    272 
00a8h: FROT             - <   278>    279 
00b5h: FSEE             - <   291>    292 
0088h: FSEMI            - <   246>    247 
0308h: FSTACK           - <   100>    403    486    583    609    622    634 
         1624   2201   3102 
008bh: FSWAP            - <   249>    250 
0085h: FTHEN            - <   243>    244 
0091h: FUDOT            - <   255>    256 
009eh: FULESS           - <   268>    269 
009ch: FUNEQUAL         - <   266>    267 
00a0h: FUNTIL           - <   270>    271 
0086h: FVARIABLE        - <   244>    245   2794 
0081h: FWHILE           - <   239>    240 
00a4h: FWORDS           - <   274>    275 
0095h: FXOR             - <   259>    260 
f830h: F_ASTODT         - <   211> 
f833h: F_ASTOTM         - <   212> 
ff5dh: F_ATOI           - <   177> 
ff00h: F_BOOT           - <   146> 
ff42h: F_BOOTIDE        - <   168> 
f800h: F_BREAD          - <   195> 
ff6ch: F_BRKTEST        - <   182> 
f806h: F_BTEST          - <   197> 
f803h: F_BTYPE          - <   196> 
ff33h: F_DIV16          - <   163> 
ff2ah: F_DRIVE          - <   160> 
f827h: F_DTTOAS         - <   209> 
ff6fh: F_FINDTKN        - <   183> 
ff57h: F_FREEMEM        - <   175>    352 
ff81h: F_GETDEV         - <   189> 
f815h: F_GETTOD         - <   202> 
ff45h: F_HEXIN          - <   169> 
ff48h: F_HEXOUT2        - <   170>   3695 
ff4bh: F_HEXOUT4        - <   171>   3692 
f824h: F_IDEID          - <   207> 
ff3ch: F_IDEREAD        - <   166> 
ff36h: F_IDERESET       - <   164> 
f821h: F_IDESIZE        - <   206> 
ff39h: F_IDEWRITE       - <   165> 
ff7bh: F_IDNUM          - <   187> 
ff3fh: F_INITCALL       - <   167>    313    316 
ff66h: F_INMSG          - <   180>   2540   2585   2605   2645   3216 
ff0fh: F_INPUT          - <   151>    516 
ff69h: F_INPUTL         - <   181> 
ff63h: F_INTOUT         - <   179>   3680 
ff78h: F_ISALNUM        - <   186> 
ff72h: F_ISALPHA        - <   184> 
ff75h: F_ISHEX          - <   185> 
ff5ah: F_ISNUM          - <   176> 
ff7eh: F_ISTERM         - <   188> 
ff15h: F_LTRIM          - <   153> 
ff1bh: F_MEMCPY         - <   155> 
ff54h: F_MINIMON        - <   174> 
ff51h: F_MOVER          - <   173> 
ff09h: F_MSG            - <   149>    338    506    550   1339   3227   3243 
         3704 
ff30h: F_MUL16          - <   162> 
f836h: F_NVRCCHK        - <   213> 
f81bh: F_RDNVR          - <   204> 
ff21h: F_RDSEC          - <   157> 
ff06h: F_READ           - <   148>    573 
f82dh: F_RTCTEST        - <   210> 
ff27h: F_SEEK           - <   159> 
ff24h: F_SEEK0          - <   158> 
ff2dh: F_SETBD          - <   161> 
f818h: F_SETTOD         - <   203> 
ff12h: F_STRCMP         - <   152> 
ff18h: F_STRCPY         - <   154> 
f82ah: F_TMTOAS         - <   208> 
ff4eh: F_TTY            - <   172>   3232   3248 
ff03h: F_TYPE           - <   147>    327    562 
ff0ch: F_TYPEX          - <   150> 
ff60h: F_UINTOUT        - <   178>   3222   3238   3683 
f80ch: F_UREAD          - <   199> 
f812h: F_USETBD         - <   201> 
f80fh: F_UTEST          - <   200> 
f809h: F_UTYPE          - <   198> 
fff9h: F_VERSION        - <   191> 
f81eh: F_WRNVR          - <   205> 
ff1eh: F_WRTSEC         - <   156> 
9c2eh: GETKEY           - <   569>   2752 
a017h: GOOD             - <  1405>   1416   1421   1446   1472   1486   1500 
         1525   1550   1575   1579   1607   1615   1637   1677   1728   1731 
         1763   1775   1790   1796   1803   1830   1883   1921   1969   2000 
         2021   2061   2074   2088   2125   2133   2163   2165   2193   2224 
         2265   2306   2336   2351   2368   2383   2397   2441   2487   2489 
         2515   2749   2758   2769   2833   2849   2875   2977   3005   3025 
         3030   3035   3040   3045   3050   3055   3093   3130   3160   3169 
         3171   3177   3182   3190   3200   3250   3284   3315   3337   3357 
         3434   3804 
acffh: HELLO            - <  3879>    330    332 
ac2dh: HEXBYTE          - <  3694>   3690 
9efah: HEXNUM           - <  1194>   1077   1084 
0300h: HIMEM            - <    96>    319    378    460    462   3427   3515 
a3eeh: IFCNT            - <  2112>   2118   2128   2131 
a3e7h: IFLP1            - <  2108>   2113 
a413h: IFNO             - <  2133>   2094   2096 
a405h: IFNOTELSE        - <  2126>   2116 
a3f2h: IFNOTIF          - <  2114>   2110 
a3fdh: IFSAVE           - <  2120>   2132 
ac94h: INKEY            - <  3775>   2762 
ac5bh: ISHEX            - <  3736>   1246 
ac46h: ISNUM            - <  3716>   3737 
9e94h: ISNUMBER         - <  1110> 
030ah: JUMP             - <   101>   1295   1321   3343   3358 
a281h: LESS1            - <  1880>   1877 
a287h: LESSDONE         - <  1881>   1879 
a17dh: LOOPCNT          - <  1682>   1750 
aa4fh: LSHIFTLP         - <  3271>   3268   3279 
aa5ah: LSHIFTRET        - <  3281>   3269 
9be7h: MAINLP           - <   498>    458    538   3389   3530 
9d20h: MDNORM           - <   809>    846 
9d37h: MDNORM2          - <   827>    819 
9d45h: MDNORM3          - <   837>    829 
9b43h: MEMDONE          - <   378> 
ad12h: MSEMPTY          - <  3882>   1331   1333 
ad20h: MSGERR           - <  3883>   1367   1369 
9ce8h: MUL16            - <   756>   2846 
9cfch: MULCONT          - <   771>    763    765 
9d17h: MULCONT2         - <   794>    777 
9cefh: MULLOOP          - <   762>    800 
9b12h: NEW              - <   314>    309 
9b8dh: NEXTBASE         - <   429>    434 
aca7h: NOKEY            - <  3790>   3781 
9e00h: NOMTCH1          - <  1006>   1010 
9e0ah: NOMTCH2          - <  1011>   1008 
9f4ah: NONNUMBER        - <  1257>   1099   1102   1169   1205   1211   1214 
9f5ch: NONNUMBER1       - <  1265>   1261   1263 
9dddh: NONWHITE         - <   972>    965 
9f46h: NOTHEXNUM        - <  1251> 
9b03h: NOTNEW           - <   310> 
9e47h: NOTOKEN          - <  1061>   1015 
9e88h: NOTOKEN1         - <  1097>   1092 
9e64h: NOTOKENBASE      - <  1080>   1065 
9e63h: NOTOKENBASEADJ   - <  1079>   1072 
9f5eh: NOTOKENLP        - <  1267>   1274 
9e5bh: NOTOKEN_0        - <  1073>   1069 
9f6bh: NOTOKWHT         - <  1275>   1272 
a369h: NOTPRINT         - <  2017>   2009   2012 
a392h: NOTREP           - <  2046>   2050   2054 
a396h: NOTWHILE         - <  2048>   2044 
9ee0h: NUMBERDN         - <  1170>   1157 
9eedh: NUMBERDN1        - <  1179>   1171   1240 
9ed9h: NUMBERERR        - <  1165>   1160   1163 
9e99h: NUMBERLP         - <  1114>   1164 
9bbdh: OLD              - <   460>    312 
ac51h: PASSES           - <  3721>   3739   3743   3748 
9c32h: POP              - <   582>   1410   1419   1424   1431   1450   1457 
         1475   1489   1503   1510   1528   1535   1553   1560   1582   1589 
         1641   1648   1740   1767   1799   1806   1813   1841   1848   1889 
         1896   1995   2004   2025   2091   2168   2175   2227   2234   2241 
         2268   2275   2282   2309   2316   2339   2354   2361   2371   2386 
         2393   2797   2836   2843   2852   2859   2980   3010   3015   3058 
         3136   3140   3144   3164   3206   3210   3257   3263   3288   3294 
         3320   3341 
9c4dh: POPRET           - <   602>    617 
ad0eh: PROMPT           - <  3881>    498    500 
9c61h: PUSH             - <   622>   1353   1394   1413   1415   1445   1471 
         1524   1549   1574   1600   1606   1614   1636   1795   1829   1882 
         1920   2192   2223   2252   2258   2264   2293   2299   2305   2323 
         2329   2335   2350   2382   2757   2768   2848   2874   3004   3092 
         3129   3189   3199   3283   3314   3356 
acdeh: RANDBYTE         - <  3846>   3193 
fff1h: RET              - <   143> 
9c77h: RPOP             - <   648>   1610   1680   1687   1703   1730   1733 
         1774   1777   1793   2077   3185 
9c8fh: RPUSH            - <   673>   1612   1664   1670   1676   1705   1721 
         1727   1762   1779   1802   2073   3187 
02f0h: RSEED            - <   104>    442    450   3846 
aa7dh: RSHIFTLP         - <  3302>   3299   3310 
aa88h: RSHIFTRET        - <  3312>   3300 
0302h: RSTACK           - <    97>    387    470    649    660    673    685 
0004h: SCALL            - <   139>    323    334    351    502    512    519 
          522    524    535    546    558    569    845   1245   1335   1352 
         1364   1385   1393   1409   1412   1414   1418   1423   1430   1444 
         1449   1456   1470   1474   1479   1488   1493   1502   1509   1523 
         1527   1534   1548   1552   1559   1573   1577   1581   1588   1599 
         1605   1609   1611   1613   1635   1640   1647   1663   1669   1675 
         1679   1686   1702   1704   1720   1726   1729   1732   1739   1761 
         1766   1773   1776   1778   1792   1794   1798   1801   1805   1812 
         1828   1840   1847   1881   1888   1895   1919   1935   1940   1943 
         1950   1953   1967   1974   1978   1989   1994   1998   2003   2019 
         2024   2072   2076   2090   2167   2174   2191   2222   2226   2233 
         2240   2251   2257   2263   2267   2274   2281   2292   2298   2304 
         2308   2315   2322   2328   2334   2338   2349   2353   2360   2370 
         2381   2385   2392   2505   2513   2539   2548   2572   2581   2584 
         2599   2602   2604   2621   2633   2640   2644   2647   2651   2655 
         2664   2686   2712   2718   2741   2751   2756   2761   2767   2796 
         2835   2842   2845   2847   2851   2858   2864   2873   2890   2979 
         3003   3009   3014   3057   3091   3128   3135   3139   3143   3163 
         3184   3186   3188   3192   3198   3205   3209   3215   3221   3226 
         3231   3237   3242   3247   3256   3262   3282   3287   3293   3313 
         3319   3340   3352   3355   3398   3420   3428   3430   3504   3508 
         3516   3654   3664   3679   3682   3691   3694   3703   3736   3808 
a6bch: SEEEXIT          - <  2647>   2658 
a6c6h: SEEFUNCLP        - <  2654>   2669 
a70dh: SEELP3           - <  2704>   2707 
a6e0h: SEENEXT          - <  2668>   2663   2693   2720 
a6e4h: SEENOTA          - <  2670>   2660 
a6feh: SEENOTN          - <  2694>   2672 
a708h: SEENOTNLP        - <  2701>   2706 
a66ch: SEESTO           - <  2591>   2613   2615 
a6d5h: SEESTRLP         - <  2662>   2667 
a724h: SEETKLAST        - <  2716>   2710 
a716h: SEETOKEN         - <  2708>   2703   2715 
a64ah: SEEVALLOT        - <  2570> 
a639h: SEEVEQ           - <  2551>   2547 
a6b6h: SEEVEQ1          - <  2643>   2639 
a630h: SEEVNAME         - <  2544>   2550 
a6adh: SEEVNAME1        - <  2636>   2642 
a69ah: SEEVNOA          - <  2619>   2569 
a9abh: SETQNO           - <  3170>   3167 
0005h: SRET             - <   140>    553    564    575    603    641    668 
          692    718    770    838    861    892   1281   1341   1401   2617 
         2649   3639   3706   3725   3728 
01ffh: STACK            - <   105>    311    314 
9c4fh: STACKOK          - <   604>    595    600 
9b21h: START            - <   319>    315   4228   4228 
030dh: STORAGE          - <   102>    358    361    411    413    703    705 
         1955   1957   2771   2773   3795 
9e3ch: TDOTQTDN         - <  1047>   1044 
9e30h: TDOTQTLP         - <  1040>   1046 
9dc0h: TKNIZER          - <   945>    525 
9f23h: TOHEX            - <  1219>   1215 
9f26h: TOHEXAD          - <  1221>   1218 
9f2ah: TOHEXAL          - <  1224>   1232 
9f1dh: TOHEXD           - <  1216>   1208 
9f02h: TOHEXLP          - <  1203>   1247 
9f72h: TOKENDN          - <  1279>    963 
9dd0h: TOKENLP          - <   962>    967   1037   1054   1188   1278 
9deah: TOKLOOP          - <   988>    998 
9dfch: TOKNOMTCH        - <  1002>    995   1024   1028 
0304h: TOS              - <    98>    395    478    589   2207 
aba4h: TOUC             - <  3625>    523   3638   3644 
abc0h: TOUC_DN          - <  3639>   3629   3642 
abbch: TOUC_NXT         - <  3637>   3631   3633 
abc2h: TOUC_QLP         - <  3641>   3645 
abc1h: TOUC_QT          - <  3640>   3627 
ac19h: TYPEHEX          - <  3686>   3674 
abefh: TYPENUM          - <  3668>   1480   1494 
abceh: TYPENUMIND       - <  3649>   2582   2600   2603   2634   2687 
abe8h: TYPENUMINDDEC    - <  3662>   3659 
ac13h: TYPENUMU         - <  3682>   3678 
abf3h: TYPENUMX         - <  3670>   3666 
ac30h: TYPEOUT          - <  3697>   3681   3684   3693 
00feh: T_ASCII          - <   297>   1039   1266   1293   2409   2453   2502 
         2659   2732   2887 
00ffh: T_NUM            - <   296>   1179   1290   2671 
a2b7h: ULESS1           - <  1918>   1915 
a2bdh: ULESSDONE        - <  1919>   1917 
a246h: UNEQUAL          - <  1831>   1820   1825 
a46bh: UNEQUAL2         - <  2194>   2182   2187 
a1f1h: UNTILNO          - <  1773>   1770 
a1f7h: UNTILYES         - <  1776>   1772 
a58ah: VARLP1           - <  2412>   2413 
a3adh: WHILENO          - <  2062>   2028   2030 
a320h: WORDSNOTL        - <  1972>   1976 
a32ah: WORDSNXT         - <  1977>   1973 
ed0fh: XCLOSER          - <    94> 
ed0ch: XCLOSEW          - <    93>   3431 
ed03h: XOPENR           - <    90>   3505 
ed00h: XOPENW           - <    89>   3399 
ed06h: XREAD            - <    91>   3509   3517 
ed09h: XWRITE           - <    92>   3421   3429 

4232 Lines assembled
0 Errors
431 Labels
Object Code:6330 bytes

