1802 -> Native
2 Classes read.
186 Patterns read.
    1 0000:             ; *******************************************************************
    2 0000:             ; *** This software is copyright 2006 by Michael H Riley          ***
    3 0000:             ; *** You have permission to use, modify, copy, and distribute    ***
    4 0000:             ; *** this software so long as this copyright notice is retained. ***
    5 0000:             ; *** This software may not be used in commercial applications    ***
    6 0000:             ; *** without express written permission from the author.         ***
    7 0000:             ; *******************************************************************
    8 0000:             
    9 0000:             ;[RLA] These are defined on the rcasm command line!
   10 0000:             ;[RLA] #define ELFOS            ; build the version that runs under Elf/OS
   11 0000:             ;[RLA] #define STGROM           ; build the STG EPROM version
   12 0000:             ;[RLA] #define PICOROM          ; define for Mike's PIcoElf version
   13 0000:             
   14 0000:             ;[RLA]   rcasm doesn't have any way to do a logical "OR" of assembly
   15 0000:             ;[RLA} options, so define a master "ANYROM" option that's true for
   16 0000:             ;[RLA} any of the ROM conditions...
   17 0000:             	
   18 0000:             	;; [gnr] Bug fixes, assembler fixes,and the Exec word
   19 0000:             
            #endif
   42 0000:             
            #endif
   65 0000:             
   66 0000:             ; [GDJ] build: asm02 -i -L -DSTGROM forth.asm
            #ifdef STGROM
            #define    ANYROM 1
   69 0000:             	include config.inc
   70 0000:             ; DO NOT EDIT THIS FILE - EDIT CONFIG. INSTEAD!!
            #define BOOTS	 08000H
            #define WARMB	 (08000H+3)
            #define HELP	 09400H
            #define RAMPAGE	 07F00H
            #define BIOS	 0FF00H
            #define EBIOS	 0F800H
            #define FORTH	 09B00H
            #define EDTASM	 0B400H
            #define BASIC	 0D300H
            #define VISUAL	 0C100H
            #define XMODEM	 0ED00H
            #define CODE FORTH  		; [gnr] [GDG] says now bigger than 15 pages
   83 0000:             	; [gnr] The UART is used in inkey so when using bitbang, no inkey!
            #define    UART_SELECT   6             ; UART register select I/O port
            #define    UART_DATA     7             ; UART data I/O port
   86 0000:             
   87 0000:             
   88 0000:             ;[RLA] XMODEM entry vectors for the STG EPROM ...
   89 0000:             xopenw:    equ     XMODEM + 0*3
   90 0000:             xopenr:    equ     XMODEM + 1*3
   91 0000:             xread:     equ     XMODEM + 2*3
   92 0000:             xwrite:    equ     XMODEM + 3*3
   93 0000:             xclosew:   equ     XMODEM + 4*3
   94 0000:             xcloser:   equ     XMODEM + 5*3
   95 0000:             buffer:    equ     0200h
   96 0000:             himem:     equ     300h
   97 0000:             rstack:    equ     302h
   98 0000:             tos:       equ     304h
   99 0000:             freemem:   equ     306h
  100 0000:             fstack:    equ     308h
  101 0000:             jump:      equ     30ah
  102 0000:             storage:   equ     30dh
  103 0000:             basen:     equ     317h
  104 0000:             rseed:     equ     02f0h               ; note this limits size of buffer at 200h to 240 bytes
  105 0000:             stack:     equ     01ffh
  106 0000:             exitaddr:  equ     08003h
            #endif
  108 0000:             
            #endif
  114 0000:             
  115 0000:             include    bios.inc
  116 0000:             ; *******************************************************************
  117 0000:             ; *** This software is copyright 2006 by Michael H Riley          ***
  118 0000:             ; *** You have permission to use, modify, copy, and distribute    ***
  119 0000:             ; *** this software so long as this copyright notice is retained. ***
  120 0000:             ; *** This software may not be used in commercial applications    ***
  121 0000:             ; *** without express written permission from the author.         ***
  122 0000:             ; *******************************************************************
  123 0000:             
            #endif
  127 0000:             
  128 0000:             ; Define address for standard BIOS vectors
            #endif
  132 0000:             
  133 0000:             ; Define address for extended BIOS vectors
            #endif
  137 0000:             
            #ifndef TASM
  139 0000:             scall:      equ  r4                    ; register for SCALL
  140 0000:             sret:       equ  r5                    ; register for SRET
  141 0000:             
  142 0000:             call:       equ  0ffe0h                ; depricated
  143 0000:             ret:        equ  0fff1h                ; depricated
            #endif
  145 0000:             
  146 0000:             f_boot:     equ  (BIOS+00h)            ; boot from ide device
  147 0000:             f_type:     equ  (BIOS+03h)            ; type 1 character to console
  148 0000:             f_read:     equ  (BIOS+06h)            ; read 1 character from console
  149 0000:             f_msg:      equ  (BIOS+09h)            ; type asciiz string to console
  150 0000:             f_typex:    equ  (BIOS+0ch)            ; depricated, just returns now
  151 0000:             f_input:    equ  (BIOS+0fh)            ; read asciiz from console
  152 0000:             f_strcmp:   equ  (BIOS+12h)            ; compare 2 strings
  153 0000:             f_ltrim:    equ  (BIOS+15h)            ; trim leading spaces
  154 0000:             f_strcpy:   equ  (BIOS+18h)            ; copy an asciiz string
  155 0000:             f_memcpy:   equ  (BIOS+1bh)            ; copy memory
  156 0000:             f_wrtsec:   equ  (BIOS+1eh)            ; write floppy sector (depricated)
  157 0000:             f_rdsec:    equ  (BIOS+21h)            ; read floppy sector (depricated)
  158 0000:             f_seek0:    equ  (BIOS+24h)            ; floppy seek to track 0 (depricated)
  159 0000:             f_seek:     equ  (BIOS+27h)            ; floopy track seek (depricated)
  160 0000:             f_drive:    equ  (BIOS+2ah)            ; select floppy drive (depricated)
  161 0000:             f_setbd:    equ  (BIOS+2dh)            ; set console baud rate
  162 0000:             f_mul16:    equ  (BIOS+30h)            ; 16-bit multiply
  163 0000:             f_div16:    equ  (BIOS+33h)            ; 16-bit division
  164 0000:             f_idereset: equ  (BIOS+36h)            ; reset ide device
  165 0000:             f_idewrite: equ  (BIOS+39h)            ; write ide sector
  166 0000:             f_ideread:  equ  (BIOS+3ch)            ; read ide sector
  167 0000:             f_initcall: equ  (BIOS+3fh)            ; initialize R4 and R5
  168 0000:             f_bootide:  equ  (BIOS+42h)            ; boot from ide device
  169 0000:             f_hexin:    equ  (BIOS+45h)            ; convert ascii number to hex
  170 0000:             f_hexout2:  equ  (BIOS+48h)            ; convert hex to 2-digit ascii
  171 0000:             f_hexout4:  equ  (BIOS+4bh)            ; convert hex to 4-digit ascii
  172 0000:             f_tty:      equ  (BIOS+4eh)            ; type character to console
  173 0000:             f_mover:    equ  (BIOS+51h)            ; program relocator
  174 0000:             f_minimon:  equ  (BIOS+54h)            ; mini monitor
  175 0000:             f_freemem:  equ  (BIOS+57h)            ; determine memory size
  176 0000:             F_isnum:    equ  (BIOS+5ah)            ; determine if D is numeric
  177 0000:             f_atoi:     equ  (BIOS+5dh)            ; convert ascii to integer
  178 0000:             f_uintout:  equ  (BIOS+60h)            ; convert unsigned integer to ascii
  179 0000:             f_intout:   equ  (BIOS+63h)            ; convert signed integer to ascii
  180 0000:             f_inmsg:    equ  (BIOS+66h)            ; type in-line message
  181 0000:             f_inputl:   equ  (BIOS+69h)            ; read limited line from console
  182 0000:             f_brktest:  equ  (BIOS+6ch)            ; check for serial break
  183 0000:             f_findtkn:  equ  (BIOS+6fh)            ; find token in a token table
  184 0000:             f_isalpha:  equ  (BIOS+72h)            ; determine if D is alphabetic
  185 0000:             f_ishex:    equ  (BIOS+75h)            ; determine if D is hexadecimal
  186 0000:             f_isalnum:  equ  (BIOS+78h)            ; determine if D is alpha or numeric
  187 0000:             f_idnum:    equ  (BIOS+7bh)            ; determine type of ascii number
  188 0000:             f_isterm:   equ  (BIOS+7eh)            ; determine if D is a termination char
  189 0000:             f_getdev:   equ  (BIOS+81h)            ; get supported devices
  190 0000:             
  191 0000:             f_version:  equ  (BIOS+0f9h)           ; 3 bytes holding bios version number
  192 0000:             
  193 0000:             ; "Extended" BIOS vectors
  194 0000:             
  195 0000:             f_bread     equ  (EBIOS+00h)        ; read from onboard serial port
  196 0000:             f_btype     equ  (EBIOS+03h)        ; write to onboard serial port
  197 0000:             f_btest     equ  (EBIOS+06h)        ; test onboard serial port
  198 0000:             f_utype     equ  (EBIOS+09h)        ; write to disk board UART
  199 0000:             f_uread     equ  (EBIOS+0ch)        ; read from disk board UART
  200 0000:             f_utest     equ  (EBIOS+0fh)        ; test disk board UART
  201 0000:             f_usetbd    equ  (EBIOS+12h)        ; set disk board UART baud rate and format
  202 0000:             f_gettod    equ  (EBIOS+15h)        ; read time of day clock
  203 0000:             f_settod    equ  (EBIOS+18h)        ; set time of day clock
  204 0000:             f_rdnvr     equ  (EBIOS+1bh)        ; read non volatile RAM
  205 0000:             f_wrnvr     equ  (EBIOS+1eh)        ; write non volatile RAM
  206 0000:             f_idesize   equ  (EBIOS+21h)        ; return size of attached IDE drive(s)
  207 0000:             f_ideid     equ  (EBIOS+24h)        ; return device data for IDE drive(s)
  208 0000:             f_tmtoas    equ  (EBIOS+2ah)        ; time to ASCII string
  209 0000:             f_dttoas    equ  (EBIOS+27h)        ; date to ASCII string
  210 0000:             f_rtctest   equ  (EBIOS+2dh)        ; test size and presence of RTC/NVR
  211 0000:             f_astodt    equ  (EBIOS+30h)        ; convert ASCII string to date
  212 0000:             f_astotm    equ  (EBIOS+33h)        ; convert ASCII string to time
  213 0000:             f_nvrcchk   equ  (EBIOS+36h)	    ; [RLA] compute NVR checksum
  214 0000:             
  215 0000:             
  216 0000:             
            #endif
  229 0000:             
  230 0000:             ;  R2   - program stack
  231 0000:             ;  R3   - Main PC
  232 0000:             ;  R4   - standard call
  233 0000:             ;  R5   - standard ret
  234 0000:             ;  R6   - used by Scall/Sret linkage
  235 0000:             ;  R7   - general and command table pointer
  236 0000:             ;  R9   - Data segment
  237 0000:             ;  RB   - general SCRT return usage and token stream pointer
  238 0000:             
  239 0000:             FWHILE:    equ     81h
  240 0000:             FREPEAT:   equ     FWHILE+1
  241 0000:             FIF:       equ     FREPEAT+1
  242 0000:             FELSE:     equ     FIF+1
  243 0000:             FTHEN:     equ     FELSE+1
  244 0000:             FVARIABLE: equ     FTHEN+1
  245 0000:             FCOLON:    equ     FVARIABLE+1
  246 0000:             FSEMI:     equ     FCOLON+1
  247 0000:             FDUP:      equ     FSEMI+1
  248 0000:             FDROP:     equ     FDUP+1
  249 0000:             FSWAP:     equ     FDROP+1
  250 0000:             FPLUS:     equ     FSWAP+1
  251 0000:             FMINUS:    equ     FPLUS+1
  252 0000:             FMUL:      equ     FMINUS+1
  253 0000:             FDIV:      equ     FMUL+1
  254 0000:             FDOT:      equ     FDIV+1              ; 90h
  255 0000:             FUDOT:     equ     FDOT+1
  256 0000:             FI:        equ     FUDOT+1
  257 0000:             FAND:      equ     FI+1
  258 0000:             FOR:       equ     FAND+1
  259 0000:             FXOR:      equ     FOR+1
  260 0000:             FCR:       equ     FXOR+1
  261 0000:             FMEM:      equ     FCR+1
  262 0000:             FDO:       equ     FMEM+1
  263 0000:             FLOOP:     equ     FDO+1
  264 0000:             FPLOOP:    equ     FLOOP+1
  265 0000:             FEQUAL:    equ     FPLOOP+1
  266 0000:             FUNEQUAL:  equ     FEQUAL+1
  267 0000:             FLESS:     equ     FUNEQUAL+1          ; [GDJ]
  268 0000:             FULESS:    equ     FLESS+1             ; [GDJ]
  269 0000:             FBEGIN:    equ     FULESS+1
  270 0000:             FUNTIL:    equ     FBEGIN+1            ; a0h
  271 0000:             FRGT:      equ     FUNTIL+1
  272 0000:             FGTR:      equ     FRGT+1
  273 0000:             FRAT:      equ     FGTR+1              ; [GDJ]
  274 0000:             FWORDS:    equ     FRAT+1
  275 0000:             FEMIT:     equ     FWORDS+1
  276 0000:             FEMITP:    equ     FEMIT+1             ; [GDJ]
  277 0000:             FDEPTH:    equ     FEMITP+1
  278 0000:             FROT:      equ     FDEPTH+1
  279 0000:             FMROT:     equ     FROT+1
  280 0000:             FOVER:     equ     FMROT+1
  281 0000:             FAT:       equ     FOVER+1
  282 0000:             FEXCL:     equ     FAT+1
  283 0000:             FCAT:      equ     FEXCL+1
  284 0000:             FCEXCL:    equ     FCAT+1
  285 0000:             FCMOVE:    equ     FCEXCL+1            ; [GDJ]
  286 0000:             FDOTQT:    equ     FCMOVE+1            ; b0h
  287 0000:             FKEY:      equ     FDOTQT+1
  288 0000:             FKEYQ:     equ     FKEY+1              ; [GDJ]
  289 0000:             FALLOT:    equ     FKEYQ+1
  290 0000:             FERROR:    equ     FALLOT+1
  291 0000:             FSEE:      equ     FERROR+1
  292 0000:             FFORGET:   equ     FSEE+1
  293 0000:             FEXEC:	   equ     FFORGET+1
  294 0000:             FLIST:	   equ     FEXEC+1
  295 0000:             
  296 0000:             T_NUM:     equ     255
  297 0000:             T_ASCII:   equ     254
  298 0000:             
  299 0000:                        org     CODE
  300 9b00:             
            #endif
  307 9b00:             
            #ifdef     ANYROM
  309 9b00: c0 9b 12               lbr     new
  310 9b03:             notnew:	
  311 9b03: f8 ff a2 f8 
            01 b2                  mov     r2,stack
  312 9b09: f8 bd a6 f8 
            9b b6                  mov     r6,old
  313 9b0f: c0 ff 3f               lbr     f_initcall
  314 9b12: f8 ff a2 f8 
            01 b2       new:       mov     r2,stack
  315 9b18: f8 21 a6 f8 
            9b b6                  mov     r6,start
  316 9b1e: c0 ff 3f               lbr     f_initcall
            #endif
  318 9b21:             
  319 9b21: f8 03       start:     ldi     high himem          ; get page of data segment
  320 9b23: b9                     phi     r9                  ; place into r9
            #ifdef ANYROM
  322 9b24: f8 0c                  ldi     0ch                 ; form feed
  323 9b26: d4                     sep     scall               ; clear screen
            #else
  327 9b27: ff 03                  dw      f_type
            #endif
            #endif
  330 9b29: f8 ac                  ldi     high hello          ; address of signon message
  331 9b2b: bf                     phi     rf                  ; place into r6
  332 9b2c: f8 c6                  ldi     low hello
  333 9b2e: af                     plo     rf
  334 9b2f: d4                     sep     scall               ; call bios to display message
            #else
  338 9b30: ff 09                  dw      f_msg               ; function to display a message
            #endif
  340 9b32:             
  341 9b32:             ; ************************************************
  342 9b32:             ; **** Determine how much memory is installed ****
  343 9b32:             ; ************************************************
            #else
  351 9b32: d4                     sep     scall               ; ask BIOS for memory size
  352 9b33: ff 57                  dw      f_freemem
  353 9b35: 8f ab 9f bb            mov     rb,rf
            #endif
  355 9b39:             
  356 9b39: f8 06                  ldi     low freemem         ; free memory pointer
  357 9b3b: a9                     plo     r9                  ; place into data pointer
  358 9b3c: f8 03                  ldi     storage.1
  359 9b3e: 59                     str     r9
  360 9b3f: 19                     inc     r9
  361 9b40: f8 0d                  ldi     storage.0
  362 9b42: 59                     str     r9
  363 9b43:             
  364 9b43:             ;memlp:     ldi     0                   ; get a zero
  365 9b43:             ;           str     rb                  ; write to memory
  366 9b43:             ;           ldn     rb                  ; recover retrieved byte
  367 9b43:             ;           bnz     memdone             ; jump if not same
  368 9b43:             ;           ldi     255                 ; another value
  369 9b43:             ;           str     rb                  ; write to memory
  370 9b43:             ;           ldn     rb                  ; retrieve it
  371 9b43:             ;           smi     255                 ; compare against written
  372 9b43:             ;           bnz     memdone             ; jump if not same
  373 9b43:             ;           ghi     rb
  374 9b43:             ;           adi     1                   ; point to next page
  375 9b43:             ;           phi     rb                  ; and put it back
  376 9b43:             ;           smi     7fh                 ; prevent from going over 7f00h
  377 9b43:             ;           bnz     memlp
  378 9b43: f8 00       memdone:   ldi     low himem           ; memory pointer
  379 9b45: a9                     plo     r9                  ; place into r9
  380 9b46: 9b                     ghi     rb                  ; get high of last memory
  381 9b47: 59                     str     r9                  ; write to data
  382 9b48: b2                     phi     r2                  ; and to machine stack
  383 9b49: 19                     inc     r9                  ; point to low byte
  384 9b4a: 8b                     glo     rb                  ; get low of himem
  385 9b4b: 59                     str     r9                  ; and store
  386 9b4c: a2                     plo     r2
  387 9b4d: f8 02                  ldi     low rstack          ; get return stack address
  388 9b4f: a9                     plo     r9                  ; select in data segment
  389 9b50: 9b                     ghi     rb                  ; get hi memory
  390 9b51: ff 01                  smi     1                   ; 1 page lower for forth stack
  391 9b53: 59                     str     r9                  ; write to pointer
  392 9b54: 19                     inc     r9                  ; point to low byte
  393 9b55: 8b                     glo     rb                  ; get low byte
  394 9b56: 59                     str     r9                  ; and store
  395 9b57: f8 04                  ldi     low tos             ; get stack address
  396 9b59: a9                     plo     r9                  ; select in data segment
  397 9b5a: 9b                     ghi     rb                  ; get hi memory
  398 9b5b: ff 02                  smi     2                   ; 2 page lower for forth stack
  399 9b5d: 59                     str     r9                  ; write to pointer
  400 9b5e: 19                     inc     r9                  ; point to low byte
  401 9b5f: 8b                     glo     rb                  ; get low byte
  402 9b60: 59                     str     r9                  ; and store
  403 9b61: f8 08                  ldi     low fstack          ; get stack address
  404 9b63: a9                     plo     r9                  ; select in data segment
  405 9b64: 9b                     ghi     rb                  ; get hi memory
  406 9b65: ff 02                  smi     2                   ; 2 page lower for forth stack
  407 9b67: 59                     str     r9                  ; write to pointer
  408 9b68: 19                     inc     r9                  ; point to low byte
  409 9b69: 8b                     glo     rb                  ; get low byte
  410 9b6a: 59                     str     r9                  ; and store
  411 9b6b: f8 03                  ldi     high storage        ; point to storage
  412 9b6d: bf                     phi     rf
  413 9b6e: f8 0d                  ldi     low storage
  414 9b70: af                     plo     rf
  415 9b71: f8 00                  ldi     0
  416 9b73: 5f                     str     rf                  ; write zeroes as storage terminator
  417 9b74: 1f                     inc     rf
  418 9b75: 5f                     str     rf
  419 9b76: 1f                     inc     rf
  420 9b77: 5f                     str     rf
  421 9b78: 1f                     inc     rf
  422 9b79: 5f                     str     rf
  423 9b7a: 1f                     inc     rf
  424 9b7b:             
  425 9b7b:                        ; [GDJ] create and initialize BASE variable
  426 9b7b: f8 1a a7 f8 
            00 b7                  mov     r7, 26
  427 9b81: f8 67 ac f8 
            ae bc                  mov     rc, basev
  428 9b87: f8 06 ad f8 
            03 bd                  mov     rd, freemem
  429 9b8d: 4c          nextbase:  lda     rc
  430 9b8e: 5d                     str     rd
  431 9b8f: 1d                     inc     rd
  432 9b90: 27                     dec     r7
  433 9b91: 87                     glo     r7
  434 9b92: ca 9b 8d               lbnz    nextbase
  435 9b95:             
            #ifdef STGROM
  437 9b95: d4 ac 40               call    clrstacks           ; [GDJ]
            #endif
  439 9b98:             
  440 9b98:                        ; init 32 bit rng seed
  441 9b98: f8 a6 a7 f8 
            12 b7                  mov     r7, 012A6h
  442 9b9e: f8 f0 af f8 
            02 bf                  mov     rf, rseed
  443 9ba4: 97                     ghi     r7
  444 9ba5: 5f                     str     rf
  445 9ba6: 87                     glo     r7
  446 9ba7: 1f                     inc     rf
  447 9ba8: 5f                     str     rf
  448 9ba9:                        
  449 9ba9: f8 40 a7 f8 
            dc b7                  mov     r7, 0DC40h
  450 9baf: f8 f2 af f8 
            02 bf                  mov     rf, rseed+2
  451 9bb5: 97                     ghi     r7
  452 9bb6: 5f                     str     rf
  453 9bb7: 87                     glo     r7
  454 9bb8: 1f                     inc     rf
  455 9bb9: 5f                     str     rf
  456 9bba:             
  457 9bba:             
  458 9bba: c0 9b e7               lbr     mainlp
  459 9bbd:             
  460 9bbd: f8 03       old: 	   ldi     high himem	; [gnr] fix up r9 since this might be entry point
  461 9bbf: b9          	   phi     r9
  462 9bc0: f8 00       	   ldi     low himem           ; memory pointer
  463 9bc2: a9                     plo     r9                  ; place into r9
  464 9bc3: 49                     lda     r9                  ; retreive high memory
  465 9bc4: bb                     phi     rb
  466 9bc5: b2                     phi     r2                  ; and to machine stack
  467 9bc6: 49                     lda     r9
  468 9bc7: ab                     plo     rb
  469 9bc8: a2                     plo     r2
  470 9bc9: f8 02                  ldi     low rstack          ; get return stack address
  471 9bcb: a9                     plo     r9                  ; select in data segment
  472 9bcc: 9b                     ghi     rb                  ; get hi memory
  473 9bcd: ff 01                  smi     1                   ; 1 page lower for forth stack
  474 9bcf: 59                     str     r9                  ; write to pointer
  475 9bd0: 19                     inc     r9                  ; point to low byte
  476 9bd1: 8b                     glo     rb                  ; get low byte
  477 9bd2: 59                     str     r9                  ; and store
  478 9bd3: f8 04                  ldi     low tos             ; get stack address
  479 9bd5: a9                     plo     r9                  ; select in data segment
  480 9bd6: 9b                     ghi     rb                  ; get hi memory
  481 9bd7: ff 02                  smi     2                   ; 2 page lower for forth stack
  482 9bd9: 59                     str     r9                  ; write to pointer
  483 9bda: 19                     inc     r9                  ; point to low byte
  484 9bdb: 8b                     glo     rb                  ; get low byte
  485 9bdc: 59                     str     r9                  ; and store
  486 9bdd: f8 08                  ldi     low fstack          ; get stack address
  487 9bdf: a9                     plo     r9                  ; select in data segment
  488 9be0: 9b                     ghi     rb                  ; get hi memory
  489 9be1: ff 02                  smi     2                   ; 2 page lower for forth stack
  490 9be3: 59                     str     r9                  ; write to pointer
  491 9be4: 19                     inc     r9                  ; point to low byte
  492 9be5: 8b                     glo     rb                  ; get low byte
  493 9be6: 59                     str     r9                  ; and store
  494 9be7:             
  495 9be7:             ; *************************
  496 9be7:             ; *** Main program loop ***
  497 9be7:             ; *************************
  498 9be7: f8 ac       mainlp:    ldi     high prompt         ; address of prompt
  499 9be9: bf                     phi     rf                  ; place into r6
  500 9bea: f8 d5                  ldi     low prompt
  501 9bec: af                     plo     rf
  502 9bed: d4                     sep     scall               ; display prompt
            #else
  506 9bee: ff 09                  dw      f_msg               ; function to display a message
            #endif
  508 9bf0: f8 02                  ldi     high buffer         ; point to input buffer
  509 9bf2: bf                     phi     rf
  510 9bf3: f8 00                  ldi     low buffer
  511 9bf5: af                     plo     rf
  512 9bf6: d4                     sep     scall               ; read a line
            #else
  516 9bf7: ff 0f                  dw      f_input             ; function to read a line
            #endif
  518 9bf9:             
  519 9bf9: d4          	   sep     scall
  520 9bfa: 9c 17       	   dw      crlfout
  521 9bfc: f8 00 af f8 
            02 bf                  mov     rf,buffer           ; convert to uppercase
  522 9c02: d4                     sep     scall
  523 9c03: ab 6a                  dw      touc
  524 9c05: d4                     sep     scall               ; call tokenizer
  525 9c06: 9d c0                  dw      tknizer
  526 9c08:             
  527 9c08: f8 06                  ldi     low freemem         ; get free memory pointer
  528 9c0a: a9                     plo     r9                  ; place into data segment
  529 9c0b: 49                     lda     r9                  ; get free memory pointer
  530 9c0c: bb                     phi     rb                  ; place into rF
  531 9c0d: 09                     ldn     r9
  532 9c0e: ab                     plo     rb
  533 9c0f: 1b                     inc     rb
  534 9c10: 1b                     inc     rb
  535 9c11: d4                     sep     scall
  536 9c12: 9f 76                  dw      exec
  537 9c14:             
  538 9c14: c0 9b e7               lbr     mainlp              ; return to beginning of main loop
  539 9c17:             
  540 9c17:             crlfout:	
  541 9c17: 8f 73 9f 73 	   push rf
  542 9c1b: f8 ac                  ldi     high crlf           ; address of CR/LF
  543 9c1d: bf                     phi     rf                  ; place into r6
  544 9c1e: f8 d2                  ldi     low crlf  
  545 9c20: af                     plo     rf
  546 9c21: d4                     sep     scall               ; call bios
            #else
  550 9c22: ff 09                  dw      f_msg               ; function to display a message
            #endif
  552 9c24: 60 72 bf f0 
            af          	  pop rf
  553 9c29: d5          	   sep sret
  554 9c2a:             
  555 9c2a:             ; **************************************
  556 9c2a:             ; *** Display a character, char in D ***
  557 9c2a:             ; **************************************
            #if 0	
  559 9c2a: d4          disp:      sep     scall               ; call bios
            #else
  563 9c2b: ff 03                  dw      f_type              ; function to type a charactr
            #endif
  565 9c2d: d5                     sep     sret                ; return to caller
            #endif	
  573 9c2e:             
  574 9c2e:             ; ********************************
  575 9c2e:             ; *** Read a key, returns in D ***
  576 9c2e:             ; ********************************
            #if 0	
  578 9c2e: d4          getkey:    sep     scall               ; call bios
            #else
  582 9c2f: ff 06                  dw      f_read              ; function to read a key
            #endif
  584 9c31: d5                     sep     sret                ; return to caller
            #endif	
  593 9c32:             
  594 9c32:             
  595 9c32:             ; ***************************************************
  596 9c32:             ; *** Function to retrieve value from forth stack ***
  597 9c32:             ; *** Returns R[B] = value                        ***
  598 9c32:             ; ***         DF=0 no error, DF=1 error           ***
  599 9c32:             ; ***************************************************
  600 9c32: e2          pop:       sex     r2                  ; be sure x points to stack
  601 9c33: f8 08                  ldi     low fstack          ; get stack address
  602 9c35: a9                     plo     r9                  ; select in data segment
  603 9c36: 49                     lda     r9
  604 9c37: ba                     phi     ra
  605 9c38: 09                     ldn     r9
  606 9c39: aa                     plo     ra
  607 9c3a: f8 04                  ldi     low tos             ; pointer to maximum stack value
  608 9c3c: a9                     plo     r9                  ; put into data frame
  609 9c3d: 49                     lda     r9                  ; get high value
  610 9c3e: 52                     str     r2                  ; place into memory
  611 9c3f: 9a                     ghi     ra                  ; get high byte of forth stack
  612 9c40: f7                     sm                          ; check if same
  613 9c41: ca 9c 4f               lbnz    stackok             ; jump if ok
  614 9c44: 09                     ldn     r9                  ; get low byte of tos
  615 9c45: 52                     str     r2
  616 9c46: 8a                     glo     ra                  ; check low byte of stack pointer
  617 9c47: f7                     sm
  618 9c48: ca 9c 4f               lbnz    stackok             ; jump if ok
  619 9c4b: f8 01                  ldi     1                   ; signal error
  620 9c4d: f6          popret:    shr                         ; shift status into DF
  621 9c4e: d5                     sep     sret                ; return to caller
  622 9c4f: 1a          stackok:   inc     ra                  ; point to high byte
  623 9c50: 4a                     lda     ra                  ; get it
  624 9c51: bb                     phi     rb                  ; put into r6
  625 9c52: 0a                     ldn     ra                  ; get low byte
  626 9c53: ab                     plo     rb
  627 9c54: f8 08                  ldi     low fstack          ; get stack address
  628 9c56: a9                     plo     r9                  ; select in data segment
  629 9c57: 9a                     ghi     ra                  ; get hi memory
  630 9c58: 59                     str     r9                  ; write to pointer
  631 9c59: 19                     inc     r9                  ; point to low byte
  632 9c5a: 8a                     glo     ra                  ; get low byte
  633 9c5b: 59                     str     r9                  ; and store
  634 9c5c: f8 00                  ldi     0                   ; signal no error
  635 9c5e: c0 9c 4d               lbr     popret              ; and return to caller
  636 9c61:             
  637 9c61:             ; ********************************************************
  638 9c61:             ; *** Function to push value onto stack, value in R[B] ***
  639 9c61:             ; ********************************************************
  640 9c61: f8 08       push:      ldi     low fstack          ; get stack address
  641 9c63: a9                     plo     r9                  ; select in data segment
  642 9c64: 49                     lda     r9
  643 9c65: ba                     phi     ra
  644 9c66: 09                     ldn     r9
  645 9c67: aa                     plo     ra
  646 9c68: 8b                     glo     rb                  ; get low byte of value
  647 9c69: 5a                     str     ra                  ; store on forth stack
  648 9c6a: 2a                     dec     ra                  ; point to next byte
  649 9c6b: 9b                     ghi     rb                  ; get high value
  650 9c6c: 5a                     str     ra                  ; store on forth stack
  651 9c6d: 2a                     dec     ra                  ; point to next byte
  652 9c6e: f8 08                  ldi     low fstack          ; get stack address
  653 9c70: a9                     plo     r9                  ; select in data segment
  654 9c71: 9a                     ghi     ra                  ; get hi memory
  655 9c72: 59                     str     r9                  ; write to pointer
  656 9c73: 19                     inc     r9                  ; point to low byte
  657 9c74: 8a                     glo     ra                  ; get low byte
  658 9c75: 59                     str     r9                  ; and store
  659 9c76: d5                     sep     sret                ; return to caller
  660 9c77:             
  661 9c77:             ; ****************************************************
  662 9c77:             ; *** Function to retrieve value from return stack ***
  663 9c77:             ; *** Returns R[B] = value                         ***
  664 9c77:             ; ***         D=0 no error, D=1 error              ***
  665 9c77:             ; ****************************************************
  666 9c77: e2          rpop:      sex     r2                  ; be sure x points to stack
  667 9c78: f8 02                  ldi     low rstack          ; get stack address
  668 9c7a: a9                     plo     r9                  ; select in data segment
  669 9c7b: 49                     lda     r9
  670 9c7c: ba                     phi     ra
  671 9c7d: 09                     ldn     r9
  672 9c7e: aa                     plo     ra
  673 9c7f: 1a                     inc     ra                  ; point to high byte
  674 9c80: 4a                     lda     ra                  ; get it
  675 9c81: bb                     phi     rb                  ; put into r6
  676 9c82: 0a                     ldn     ra                  ; get low byte
  677 9c83: ab                     plo     rb
  678 9c84: f8 02                  ldi     low rstack          ; get stack address
  679 9c86: a9                     plo     r9                  ; select in data segment
  680 9c87: 9a                     ghi     ra                  ; get hi memory
  681 9c88: 59                     str     r9                  ; write to pointer
  682 9c89: 19                     inc     r9                  ; point to low byte
  683 9c8a: 8a                     glo     ra                  ; get low byte
  684 9c8b: 59                     str     r9                  ; and store
  685 9c8c: f8 00                  ldi     0                   ; signal no error
  686 9c8e: d5                     sep     sret                ; and return
  687 9c8f:             
  688 9c8f:             ; ***************************************************************
  689 9c8f:             ; *** Function to push value onto return stack, value in R[B] ***
  690 9c8f:             ; ***************************************************************
  691 9c8f: f8 02       rpush:     ldi     low rstack          ; get stack address
  692 9c91: a9                     plo     r9                  ; select in data segment
  693 9c92: 49                     lda     r9
  694 9c93: ba                     phi     ra
  695 9c94: 09                     ldn     r9
  696 9c95: aa                     plo     ra
  697 9c96: 8b                     glo     rb                  ; get low byte of value
  698 9c97: 5a                     str     ra                  ; store on forth stack
  699 9c98: 2a                     dec     ra                  ; point to next byte
  700 9c99: 9b                     ghi     rb                  ; get high value
  701 9c9a: 5a                     str     ra                  ; store on forth stack
  702 9c9b: 2a                     dec     ra                  ; point to next byte
  703 9c9c: f8 02                  ldi     low rstack          ; get stack address
  704 9c9e: a9                     plo     r9                  ; select in data segment
  705 9c9f: 9a                     ghi     ra                  ; get hi memory
  706 9ca0: 59                     str     r9                  ; write to pointer
  707 9ca1: 19                     inc     r9                  ; point to low byte
  708 9ca2: 8a                     glo     ra                  ; get low byte
  709 9ca3: 59                     str     r9                  ; and store
  710 9ca4: d5                     sep     sret                ; return to caller
  711 9ca5:             
  712 9ca5:             ;           org     200h 
  713 9ca5:             ; ********************************************
  714 9ca5:             ; *** Function to find stored name address ***
  715 9ca5:             ; ***  Needs: name to search in R[8]       ***
  716 9ca5:             ; ***  returns: R[B] first byte in data    ***
  717 9ca5:             ; ***           R[7] Address of descriptor ***
  718 9ca5:             ; ***           R[8] first addr after name ***
  719 9ca5:             ; ***           DF = 1 if not found        ***
  720 9ca5:             ; ********************************************
  721 9ca5: f8 03       findname:  ldi     high storage        ; get address of stored data
  722 9ca7: bb                     phi     rb                  ; put into r6
  723 9ca8: f8 0d                  ldi     low storage
  724 9caa: ab                     plo     rb
  725 9cab: e2                     sex     r2                  ; make sure X points to stack
  726 9cac: 9b          findlp:    ghi     rb                  ; copy address
  727 9cad: b7                     phi     r7
  728 9cae: 8b                     glo     rb
  729 9caf: a7                     plo     r7
  730 9cb0: 4b                     lda     rb                  ; get link address
  731 9cb1: ca 9c bc               lbnz    findgo              ; jump if nonzero
  732 9cb4: 0b                     ldn     rb                  ; get low byte
  733 9cb5: ca 9c bc               lbnz    findgo              ; jump if non zero
  734 9cb8: f8 01                  ldi     1                   ; not found
  735 9cba: f6          findret:   shr                         ; set DF
  736 9cbb: d5                     sep     sret                ; and return to caller
  737 9cbc: 1b          findgo:    inc     rb                  ; pointing now at type
  738 9cbd: 1b                     inc     rb                  ; pointing at ascii indicator
  739 9cbe: 1b                     inc     rb                  ; first byte of name
  740 9cbf: 88                     glo     r8                  ; save requested name
  741 9cc0: 73                     stxd
  742 9cc1: 98                     ghi     r8
  743 9cc2: 73                     stxd
  744 9cc3: 08          findchk:   ldn     r8                  ; get byte from requested name
  745 9cc4: 52                     str     r2                  ; place into memory
  746 9cc5: 0b                     ldn     rb                  ; get byte from descriptor
  747 9cc6: f7                     sm                          ; compare equality
  748 9cc7: ca 9c dc               lbnz    findnext            ; jump if not found
  749 9cca: 08                     ldn     r8                  ; get byte
  750 9ccb: c2 9c d3               lbz     findfound           ; entry is found
  751 9cce: 18                     inc     r8                  ; increment positions
  752 9ccf: 1b                     inc     rb
  753 9cd0: c0 9c c3               lbr     findchk             ; and keep looking
  754 9cd3: 1b          findfound: inc     rb                  ; r6 now points to data
  755 9cd4: 60                     irx                         ; remove r8 from stack
  756 9cd5: 60                     irx
  757 9cd6: 18                     inc     r8                  ; move past terminator in name
  758 9cd7: f8 00                  ldi     0                   ; signal success
  759 9cd9: c0 9c ba               lbr     findret             ; and return to caller
  760 9cdc: 60          findnext:  irx                         ; recover start of requested name
  761 9cdd: 72                     ldxa
  762 9cde: b8                     phi     r8
  763 9cdf: f0                     ldx
  764 9ce0: a8                     plo     r8
  765 9ce1: 47                     lda     r7                  ; get next link address
  766 9ce2: bb                     phi     rb
  767 9ce3: 07                     ldn     r7
  768 9ce4: ab                     plo     rb
  769 9ce5: c0 9c ac               lbr     findlp              ; and check next entry
  770 9ce8:             
  771 9ce8:             ; *********************************************
  772 9ce8:             ; *** Function to multiply 2 16 bit numbers ***
  773 9ce8:             ; *********************************************
  774 9ce8: f8 00       mul16:     ldi     0                   ; zero out total
  775 9cea: b8                     phi     r8
  776 9ceb: a8                     plo     r8
  777 9cec: bc                     phi     rc
  778 9ced: ac                     plo     rc
  779 9cee: e2                     sex     r2                  ; make sure X points to stack
  780 9cef: 87          mulloop:   glo     r7                  ; get low of multiplier
  781 9cf0: ca 9c fc               lbnz    mulcont             ; continue multiplying if nonzero
  782 9cf3: 97                     ghi     r7                  ; check hi byte as well
  783 9cf4: ca 9c fc               lbnz    mulcont
  784 9cf7: 98                     ghi     r8                  ; transfer answer
  785 9cf8: bb                     phi     rb
  786 9cf9: 88                     glo     r8
  787 9cfa: ab                     plo     rb
  788 9cfb: d5                     sep     sret                ; return to caller
  789 9cfc: 97          mulcont:   ghi     r7                  ; shift multiplier
  790 9cfd: f6                     shr
  791 9cfe: b7                     phi     r7
  792 9cff: 87                     glo     r7
  793 9d00: 76                     shrc
  794 9d01: a7                     plo     r7
  795 9d02: cb 9d 17               lbnf    mulcont2            ; loop if no addition needed
  796 9d05: 8b                     glo     rb                  ; add 6 to 8
  797 9d06: 52                     str     r2
  798 9d07: 88                     glo     r8
  799 9d08: f4                     add
  800 9d09: a8                     plo     r8
  801 9d0a: 9b                     ghi     rb
  802 9d0b: 52                     str     r2
  803 9d0c: 98                     ghi     r8
  804 9d0d: 74                     adc
  805 9d0e: b8                     phi     r8
  806 9d0f: 8c                     glo     rc                  ; carry into high word
  807 9d10: 7c 00                  adci    0
  808 9d12: ac                     plo     rc
  809 9d13: 9c                     ghi     rc
  810 9d14: 7c 00                  adci    0
  811 9d16: bc                     phi     rc
  812 9d17: 8b          mulcont2:  glo     rb                  ; shift first number
  813 9d18: fe                     shl
  814 9d19: ab                     plo     rb
  815 9d1a: 9b                     ghi     rb
  816 9d1b: 7e                     shlc
  817 9d1c: bb                     phi     rb
  818 9d1d: c0 9c ef               lbr     mulloop             ; loop until done
  819 9d20:             
  820 9d20:             ; ************************************
  821 9d20:             ; *** make both arguments positive ***
  822 9d20:             ; *** Arg1 RB                      ***
  823 9d20:             ; *** Arg2 R7                      ***
  824 9d20:             ; *** Returns D=0 - signs same     ***
  825 9d20:             ; ***         D=1 - signs difer    ***
  826 9d20:             ; ************************************
  827 9d20: 9b          mdnorm:    ghi     rb                  ; get high byte if divisor
  828 9d21: 52                     str     r2                  ; store for sign check
  829 9d22: 97                     ghi     r7                  ; get high byte of dividend
  830 9d23: f3                     xor                         ; compare
  831 9d24: fe                     shl                         ; shift into df
  832 9d25: f8 00                  ldi     0                   ; convert to 0 or 1
  833 9d27: 7e                     shlc                        ; shift into D
  834 9d28: ae                     plo     re                  ; store into sign flag
  835 9d29: 9b                     ghi     rb                  ; need to see if RB is negative
  836 9d2a: fe                     shl                         ; shift high byte to df
  837 9d2b: cb 9d 37               lbnf    mdnorm2             ; jump if not
  838 9d2e: 9b                     ghi     rb                  ; 2s compliment on RB
  839 9d2f: fb ff                  xri     0ffh
  840 9d31: bb                     phi     rb
  841 9d32: 8b                     glo     rb
  842 9d33: fb ff                  xri     0ffh
  843 9d35: ab                     plo     rb
  844 9d36: 1b                     inc     rb
  845 9d37: 97          mdnorm2:   ghi     r7                  ; now check r7 for negative
  846 9d38: fe                     shl                         ; shift sign bit into df
  847 9d39: cb 9d 45               lbnf    mdnorm3             ; jump if not
  848 9d3c: 97                     ghi     r7                  ; 2 compliment on R7
  849 9d3d: fb ff                  xri     0ffh
  850 9d3f: b7                     phi     r7
  851 9d40: 87                     glo     r7
  852 9d41: fb ff                  xri     0ffh
  853 9d43: a7                     plo     r7
  854 9d44: 17                     inc     r7
  855 9d45: 8e          mdnorm3:   glo     re                  ; recover sign flag
  856 9d46: d5                     sep     sret                ; and return to caller
  857 9d47:                         
  858 9d47:                        
  859 9d47:             
  860 9d47:             ; *** RC = RB/R7 
  861 9d47:             ; *** RB = remainder
  862 9d47:             ; *** uses R8 and R9
  863 9d47: d4          div16:     sep     scall               ; normalize numbers
  864 9d48: 9d 20                  dw      mdnorm
  865 9d4a: ae                     plo     re                  ; save sign comparison
  866 9d4b: f8 00                  ldi     0                   ; clear answer 
  867 9d4d: bc                     phi     rc
  868 9d4e: ac                     plo     rc
  869 9d4f: b8                     phi     r8                  ; set additive
  870 9d50: a8                     plo     r8
  871 9d51: 18                     inc     r8
  872 9d52: 87                     glo     r7                  ; check for divide by 0
  873 9d53: ca 9d 5f               lbnz    d16lp1
  874 9d56: 97                     ghi     r7
  875 9d57: ca 9d 5f               lbnz    d16lp1
  876 9d5a: f8 ff                  ldi     0ffh                ; return 0ffffh as div/0 error
  877 9d5c: bc                     phi     rc
  878 9d5d: ac                     plo     rc
  879 9d5e: d5                     sep     sret                ; return to caller
  880 9d5f: 97          d16lp1:    ghi     r7                  ; get high byte from r7
  881 9d60: fa 80                  ani     128                 ; check high bit 
  882 9d62: ca 9d 74               lbnz    divst               ; jump if set
  883 9d65: 87                     glo     r7                  ; lo byte of divisor
  884 9d66: fe                     shl                         ; multiply by 2
  885 9d67: a7                     plo     r7                  ; and put back
  886 9d68: 97                     ghi     r7                  ; get high byte of divisor
  887 9d69: 7e                     shlc                        ; continue multiply by 2
  888 9d6a: b7                     phi     r7                  ; and put back
  889 9d6b: 88                     glo     r8                  ; multiply additive by 2
  890 9d6c: fe                     shl     
  891 9d6d: a8                     plo     r8
  892 9d6e: 98                     ghi     r8
  893 9d6f: 7e                     shlc
  894 9d70: b8                     phi     r8
  895 9d71: c0 9d 5f               lbr     d16lp1              ; loop until high bit set in divisor
  896 9d74: 87          divst:     glo     r7                  ; get low of divisor
  897 9d75: ca 9d 8b               lbnz    divgo               ; jump if still nonzero
  898 9d78: 97                     ghi     r7                  ; check hi byte too
  899 9d79: ca 9d 8b               lbnz    divgo
  900 9d7c: 8e                     glo     re                  ; get sign flag
  901 9d7d: f6                     shr                         ; move to df
  902 9d7e: cb 9d 8a               lbnf    divret              ; jump if signs were the same
  903 9d81: 9c                     ghi     rc                  ; perform 2s compliment on answer
  904 9d82: fb ff                  xri     0ffh
  905 9d84: bc                     phi     rc
  906 9d85: 8c                     glo     rc
  907 9d86: fb ff                  xri     0ffh
  908 9d88: ac                     plo     rc
  909 9d89: 1c                     inc     rc
  910 9d8a: d5          divret:    sep     sret                ; jump if done
  911 9d8b: 9b          divgo:     ghi     rb                  ; copy dividend
  912 9d8c: b9                     phi     r9
  913 9d8d: 8b                     glo     rb
  914 9d8e: a9                     plo     r9
  915 9d8f: 87                     glo     r7                  ; get lo of divisor
  916 9d90: 73                     stxd                        ; place into memory
  917 9d91: 60                     irx                         ; point to memory
  918 9d92: 8b                     glo     rb                  ; get low byte of dividend
  919 9d93: f7                     sm                          ; subtract
  920 9d94: ab                     plo     rb                  ; put back into r6
  921 9d95: 97                     ghi     r7                  ; get hi of divisor
  922 9d96: 73                     stxd                        ; place into memory
  923 9d97: 60                     irx                         ; point to byte
  924 9d98: 9b                     ghi     rb                  ; get hi of dividend
  925 9d99: 77                     smb                         ; subtract
  926 9d9a: bb                     phi     rb                  ; and put back
  927 9d9b: c3 9d a5               lbdf    divyes              ; branch if no borrow happened
  928 9d9e: 99                     ghi     r9                  ; recover copy
  929 9d9f: bb                     phi     rb                  ; put back into dividend
  930 9da0: 89                     glo     r9
  931 9da1: ab                     plo     rb
  932 9da2: c0 9d b1               lbr     divno               ; jump to next iteration
  933 9da5: 88          divyes:    glo     r8                  ; get lo of additive
  934 9da6: 73                     stxd                        ; place in memory
  935 9da7: 60                     irx                         ; point to byte
  936 9da8: 8c                     glo     rc                  ; get lo of answer
  937 9da9: f4                     add                         ; and add
  938 9daa: ac                     plo     rc                  ; put back
  939 9dab: 98                     ghi     r8                  ; get hi of additive
  940 9dac: 73                     stxd                        ; place into memory
  941 9dad: 60                     irx                         ; point to byte
  942 9dae: 9c                     ghi     rc                  ; get hi byte of answer
  943 9daf: 74                     adc                         ; and continue addition
  944 9db0: bc                     phi     rc                  ; put back
  945 9db1: 97          divno:     ghi     r7                  ; get hi of divisor
  946 9db2: f6                     shr                         ; divide by 2
  947 9db3: b7                     phi     r7                  ; put back
  948 9db4: 87                     glo     r7                  ; get lo of divisor
  949 9db5: 76                     shrc                        ; continue divide by 2
  950 9db6: a7                     plo     r7
  951 9db7: 98                     ghi     r8                  ; get hi of divisor
  952 9db8: f6                     shr                         ; divide by 2
  953 9db9: b8                     phi     r8                  ; put back
  954 9dba: 88                     glo     r8                  ; get lo of divisor
  955 9dbb: 76                     shrc                        ; continue divide by 2
  956 9dbc: a8                     plo     r8
  957 9dbd: c0 9d 74               lbr     divst               ; next iteration
  958 9dc0:             
  959 9dc0:             ;           org     300h
  960 9dc0:             ; ***************************
  961 9dc0:             ; *** Setup for tokenizer ***
  962 9dc0:             ; ***************************
  963 9dc0: f8 02       tknizer:   ldi     high buffer         ; point to input buffer
  964 9dc2: bb                     phi     rb
  965 9dc3: f8 00                  ldi     low buffer
  966 9dc5: ab                     plo     rb
  967 9dc6: f8 06                  ldi     low freemem         ; get free memory pointer
  968 9dc8: a9                     plo     r9                  ; place into data segment
  969 9dc9: 49                     lda     r9                  ; get free memory pointer
  970 9dca: bf                     phi     rf                  ; place into rF
  971 9dcb: 09                     ldn     r9
  972 9dcc: af                     plo     rf
  973 9dcd: 1f                     inc     rf
  974 9dce: 1f                     inc     rf
  975 9dcf: e2                     sex     r2                  ; make sure x is pointing to stack
  976 9dd0:             
  977 9dd0:             ; ******************************
  978 9dd0:             ; *** Now the tokenizer loop ***
  979 9dd0:             ; ******************************
  980 9dd0: 0b          tokenlp:   ldn     rb                  ; get byte from buffer
  981 9dd1: c2 9f 72               lbz     tokendn             ; jump if found terminator
  982 9dd4: ff 21                  smi     (' '+1)             ; check for whitespace
  983 9dd6: c3 9d dd               lbdf    nonwhite            ; jump if not whitespace
  984 9dd9: 1b                     inc     rb                  ; move past white space
  985 9dda: c0 9d d0               lbr     tokenlp             ; and keep looking
  986 9ddd:             
  987 9ddd:             ; ********************************************
  988 9ddd:             ; *** Prepare to check against token table ***
  989 9ddd:             ; ********************************************
  990 9ddd: f8 ac       nonwhite:  ldi     high cmdTable       ; point to comand table
  991 9ddf: b7                     phi     r7                  ; r7 will be command table pointer
  992 9de0: f8 ed                  ldi     low cmdTable
  993 9de2: a7                     plo     r7
  994 9de3: f8 01                  ldi     1                   ; first command number
  995 9de5: a8                     plo     r8                  ; r8 will keep track of command number
  996 9de6:             ; **************************
  997 9de6:             ; *** Command check loop ***
  998 9de6:             ; **************************
  999 9de6: 9b          cmdloop:   ghi     rb                  ; save buffer address
 1000 9de7: bc                     phi     rc
 1001 9de8: 8b                     glo     rb
 1002 9de9: ac                     plo     rc
 1003 9dea:             ; ************************
 1004 9dea:             ; *** Check next token ***
 1005 9dea:             ; ************************
 1006 9dea: 07          tokloop:   ldn     r7                  ; get byte from token table
 1007 9deb: fa 80                  ani     128                 ; check if last byte of token
 1008 9ded: ca 9e 13               lbnz    cmdend              ; jump if last byte
 1009 9df0: 07                     ldn     r7                  ; reget token byte
 1010 9df1: 52                     str     r2                  ; store to stack
 1011 9df2: 0b                     ldn     rb                  ; get byte from buffer
 1012 9df3: f7                     sm                          ; do bytes match?
 1013 9df4: ca 9d fc               lbnz    toknomtch           ; jump if no match
 1014 9df7: 17                     inc     r7                  ; incrment token pointer
 1015 9df8: 1b                     inc     rb                  ; increment buffer pointer
 1016 9df9: c0 9d ea               lbr     tokloop             ; and keep looking
 1017 9dfc:             ; *********************************************************
 1018 9dfc:             ; *** Token failed match, move to next and reset buffer ***
 1019 9dfc:             ; *********************************************************
 1020 9dfc: 9c          toknomtch: ghi     rc                  ; recover saved address
 1021 9dfd: bb                     phi     rb
 1022 9dfe: 8c                     glo     rc
 1023 9dff: ab                     plo     rb
 1024 9e00: 07          nomtch1:   ldn     r7                  ; get byte from token
 1025 9e01: fa 80                  ani     128                 ; looking for last byte of token
 1026 9e03: ca 9e 0a               lbnz    nomtch2             ; jump if found
 1027 9e06: 17                     inc     r7                  ; point to next byte
 1028 9e07: c0 9e 00               lbr     nomtch1             ; and keep looking
 1029 9e0a: 17          nomtch2:   inc     r7                  ; point to next token
 1030 9e0b: 18                     inc     r8                  ; increment command number
 1031 9e0c: 07                     ldn     r7                  ; get next token byte
 1032 9e0d: ca 9d e6               lbnz    cmdloop             ; jump if more tokens to check
 1033 9e10: c0 9e 47               lbr     notoken             ; jump if no token found
 1034 9e13:             ; ***********************************************************
 1035 9e13:             ; *** Made it to last byte of token, check remaining byte ***
 1036 9e13:             ; ***********************************************************
 1037 9e13: 07          cmdend:    ldn     r7                  ; get byte fro token
 1038 9e14: fa 7f                  ani     07fh                ; strip off end code
 1039 9e16: 52                     str     r2                  ; save to stack
 1040 9e17: 0b                     ldn     rb                  ; get byte from buffer
 1041 9e18: f7                     sm                          ; do they match
 1042 9e19: ca 9d fc               lbnz    toknomtch           ; jump if not
 1043 9e1c: 1b                     inc     rb                  ; point to next byte
 1044 9e1d: 0b                     ldn     rb                  ; get it
 1045 9e1e: ff 21                  smi     (' '+1)             ; it must be whitespace
 1046 9e20: c3 9d fc               lbdf    toknomtch           ; otherwise no match
 1047 9e23:             ; *************************************************************
 1048 9e23:             ; *** Match found, store command number into command buffer ***
 1049 9e23:             ; *************************************************************
 1050 9e23: 88                     glo     r8                  ; get command number
 1051 9e24: f9 80                  ori     128                 ; set high bit
 1052 9e26: 5f                     str     rf                  ; write to command buffer
 1053 9e27: 1f                     inc     rf                  ; point to next position
 1054 9e28: ff b0                  smi     FDOTQT              ; check for ." function
 1055 9e2a: ca 9d d0               lbnz    tokenlp             ; jump if not
 1056 9e2d: 1b                     inc     rb                  ; move past first space
 1057 9e2e: f8 fe                  ldi     T_ASCII             ; need an ascii token
 1058 9e30: 5f          tdotqtlp:  str     rf                  ; write to command buffer
 1059 9e31: 1f                     inc     rf
 1060 9e32: 0b                     ldn     rb                  ; get next byte
 1061 9e33: ff 22                  smi     34                  ; check for end quote
 1062 9e35: c2 9e 3c               lbz     tdotqtdn            ; jump if found
 1063 9e38: 4b                     lda     rb                  ; transfer character to code
 1064 9e39: c0 9e 30               lbr     tdotqtlp            ; and keep looking
 1065 9e3c: 0b          tdotqtdn:  ldn     rb                  ; retrieve quote
 1066 9e3d: 5f                     str     rf                  ; put quote into output
 1067 9e3e: 1f                     inc     rf
 1068 9e3f: f8 00                  ldi     0                   ; need string terminator
 1069 9e41: 5f                     str     rf
 1070 9e42: 1f                     inc     rf
 1071 9e43: 1b                     inc     rb                  ; move past quote
 1072 9e44: c0 9d d0               lbr     tokenlp             ; then continue tokenizing
 1073 9e47:             
 1074 9e47:             
 1075 9e47:             ; ------------------------------------------------------------------------
 1076 9e47:             ;     DECIMAL handler  if not valid decimal then proceed to ascii        ; 
 1077 9e47:             ; ------------------------------------------------------------------------
 1078 9e47:             
 1079 9e47:             notoken:   ; get number BASE [GDJ]
 1080 9e47: 8b ac 9b bc 	mov rc,rb
 1081 9e4b: 0b          	ldn rb
 1082 9e4c: ff 30       	smi '0'
 1083 9e4e: 3a 64       	bnz notokenbase  	; if no leading 0 can't be 0x or 0#
 1084 9e50: 1b          	inc rb
 1085 9e51: 0b          	ldn rb
 1086 9e52: ff 58       	smi 'X'
 1087 9e54: 32 5b       	bz notoken_0   		; 0xHexNumber
 1088 9e56: 0b          	ldn rb
 1089 9e57: ff 23       	smi '#'
 1090 9e59: 3a 63       	bnz notokenbaseadj		; 0#DecNumber
 1091 9e5b:             notoken_0:
 1092 9e5b: 0b          	ldn rb
 1093 9e5c: 1b          	inc rb
 1094 9e5d: ff 58       	smi 'X'
 1095 9e5f: 32 fa       	bz hexnum
 1096 9e61: 30 70       	br decnum
 1097 9e63: 2b          notokenbaseadj:	  dec rb   	; point back at 0
 1098 9e64:             notokenbase:	
 1099 9e64: f8 17 ad f8 
            03 bd                  mov     rd, basen
 1100 9e6a: 0d                     ldn     rd
 1101 9e6b: ff 0a                  smi     10
 1102 9e6d: ca 9e fa               lbnz    hexnum
 1103 9e70:             
 1104 9e70: f8 00 ad f8 
            00 bd       decnum:    mov     rd, 0               ; temp flag for minus sign
 1105 9e76: 8b ac 9b bc            mov     rc,rb               ; save pointer in case of bad number
 1106 9e7a: f8 00                  ldi     0                   ; clear negative flag
 1107 9e7c: ae                     plo     re
 1108 9e7d: 0b                     ldn     rb                  ; get byte
 1109 9e7e: ff 2d                  smi     '-'                 ; is it negative
 1110 9e80: ca 9e 88               lbnz    notoken1            ; jump if not
 1111 9e83: 1b                     inc     rb                  ; move past negative
 1112 9e84: f8 01                  ldi     1                   ; set negative flag
 1113 9e86: ae                     plo     re
 1114 9e87: ad                     plo     rd
 1115 9e88: 0b          notoken1:  ldn     rb                  ; get byte
 1116 9e89: ff 30                  smi     '0'                 ; check for below numbers
 1117 9e8b: cb 9f 4a               lbnf    nonnumber           ; jump if not a number
 1118 9e8e: 0b                     ldn     rb
 1119 9e8f: ff 3a                  smi     ('9'+1)
 1120 9e91: c3 9f 4a               lbdf    nonnumber
 1121 9e94:                        ; ghi     rb                  ; save pointer in case of bad number
 1122 9e94:                        ; phi     rc
 1123 9e94:                        ; glo     rb
 1124 9e94:                        ; plo     rc
 1125 9e94:             ; **********************
 1126 9e94:             ; *** Found a number ***
 1127 9e94:             ; **********************
 1128 9e94: f8 00       isnumber:  ldi     0                   ; number starts out as zero
 1129 9e96: b7                     phi     r7                  ; use r7 to compile number
 1130 9e97: a7                     plo     r7
 1131 9e98: e2                     sex     r2                  ; make sure x is pointing to stack
 1132 9e99: 97          numberlp:  ghi     r7                  ; copy number to temp
 1133 9e9a: b8                     phi     r8
 1134 9e9b: 87                     glo     r7
 1135 9e9c: a8                     plo     r8
 1136 9e9d: 87                     glo     r7                  ; mulitply by 2
 1137 9e9e: fe                     shl
 1138 9e9f: a7                     plo     r7
 1139 9ea0: 97                     ghi     r7
 1140 9ea1: 7e                     shlc
 1141 9ea2: b7                     phi     r7
 1142 9ea3: 87                     glo     r7                  ; mulitply by 4
 1143 9ea4: fe                     shl
 1144 9ea5: a7                     plo     r7
 1145 9ea6: 97                     ghi     r7
 1146 9ea7: 7e                     shlc
 1147 9ea8: b7                     phi     r7
 1148 9ea9: 88                     glo     r8                  ; multiply by 5
 1149 9eaa: 52                     str     r2
 1150 9eab: 87                     glo     r7
 1151 9eac: f4                     add
 1152 9ead: a7                     plo     r7
 1153 9eae: 98                     ghi     r8
 1154 9eaf: 52                     str     r2
 1155 9eb0: 97                     ghi     r7
 1156 9eb1: 74                     adc
 1157 9eb2: b7                     phi     r7
 1158 9eb3: 87                     glo     r7                  ; mulitply by 10
 1159 9eb4: fe                     shl
 1160 9eb5: a7                     plo     r7
 1161 9eb6: 97                     ghi     r7
 1162 9eb7: 7e                     shlc
 1163 9eb8: b7                     phi     r7
 1164 9eb9: 4b                     lda     rb                  ; get byte from buffer
 1165 9eba: ff 30                  smi     '0'                 ; convert to numeric
 1166 9ebc: 52                     str     r2                  ; store it
 1167 9ebd: 87                     glo     r7                  ; add to number
 1168 9ebe: f4                     add
 1169 9ebf: a7                     plo     r7
 1170 9ec0: 97                     ghi     r7                  ; propagate through high byte
 1171 9ec1: 7c 00                  adci    0
 1172 9ec3: b7                     phi     r7
 1173 9ec4: 0b                     ldn     rb                  ; get byte
 1174 9ec5: ff 21                  smi     (' '+1)             ; check for space
 1175 9ec7: cb 9e e0               lbnf    numberdn            ; number also done
 1176 9eca: 0b                     ldn     rb
 1177 9ecb: ff 30                  smi     '0'                 ; check for below numbers
 1178 9ecd: cb 9e d9               lbnf    numbererr           ; jump if not a number
 1179 9ed0: 0b                     ldn     rb
 1180 9ed1: ff 3a                  smi     ('9'+1)
 1181 9ed3: c3 9e d9               lbdf    numbererr
 1182 9ed6: c0 9e 99               lbr     numberlp            ; get rest of number
 1183 9ed9: 9c          numbererr: ghi     rc                  ; recover address
 1184 9eda: bb                     phi     rb
 1185 9edb: 8c                     glo     rc
 1186 9edc: ab                     plo     rb
 1187 9edd: c0 9f 4a               lbr     nonnumber
 1188 9ee0: 8e          numberdn:  glo     re                  ; get negative flag
 1189 9ee1: c2 9e ed               lbz     numberdn1           ; jump if positive number
 1190 9ee4: 97                     ghi     r7                  ; negative, so 2s compliment number
 1191 9ee5: fb ff                  xri     0ffh
 1192 9ee7: b7                     phi     r7
 1193 9ee8: 87                     glo     r7
 1194 9ee9: fb ff                  xri     0ffh
 1195 9eeb: a7                     plo     r7
 1196 9eec: 17                     inc     r7
 1197 9eed: f8 ff       numberdn1: ldi     T_NUM               ; code to signify a number
 1198 9eef: 5f                     str     rf                  ; write to code buffer
 1199 9ef0: 1f                     inc     rf                  ; point to next position
 1200 9ef1: 97                     ghi     r7                  ; get high byte of number
 1201 9ef2: 5f                     str     rf                  ; write to code buffer
 1202 9ef3: 1f                     inc     rf                  ; point to next position
 1203 9ef4: 87                     glo     r7                  ; get lo byte of numbr
 1204 9ef5: 5f                     str     rf                  ; write to code buffer
 1205 9ef6: 1f                     inc     rf                  ; point to next position
 1206 9ef7: c0 9d d0               lbr     tokenlp             ; continue reading tokens
 1207 9efa:             
 1208 9efa:             ; ------------------------------------------------------------------------
 1209 9efa:             ;       HEX handler  if not valid decimal then proceed to ascii          ; 
 1210 9efa:             ; ------------------------------------------------------------------------
 1211 9efa:             				; [GDJ]
 1212 9efa: f8 00       hexnum:    ldi     0h                  ; clear return value
 1213 9efc: a7                     plo     r7
 1214 9efd: b7                     phi     r7
 1215 9efe: 8b ac 9b bc            mov     rc,rb               ; save pointer in case of bad number
 1216 9f02:             
 1217 9f02:                        ; for first pass we reject non hex chars
 1218 9f02:                        ; in next pass this check has already been done but we
 1219 9f02:                        ; have to deal with the different offsets here for ascii to binary
 1220 9f02:                        ; Note: all strings have been converted to upper case previously
 1221 9f02: 0b          tohexlp:   ldn     rb                  ; get next byte
 1222 9f03: ff 30                  smi     '0'                 ; check for bottom of range
 1223 9f05: cb 9f 4a               lbnf    nonnumber           ; jump if non-numeric
 1224 9f08: 0b                     ldn     rb                  ; recover byte
 1225 9f09: ff 3a                  smi     '9'+1               ; upper range of digits
 1226 9f0b: cb 9f 1d               lbnf    tohexd              ; jump if digit
 1227 9f0e: 0b                     ldn     rb                  ; recover character
 1228 9f0f: ff 41                  smi     'A'                 ; check below uc A
 1229 9f11: cb 9f 4a               lbnf    nonnumber           ; jump if not hex character
 1230 9f14: 0b                     ldn     rb                  ; recover character
 1231 9f15: ff 47                  smi     'F'+1               ; check for above uc F
 1232 9f17: c3 9f 4a               lbdf    nonnumber           ; jump if not hex character
 1233 9f1a: c0 9f 23               lbr     tohex
 1234 9f1d: 0b          tohexd:    ldn     rb                  ; recover character 0..9
 1235 9f1e: ff 30                  smi     030h                ; convert to binary       
 1236 9f20: c0 9f 26               lbr     tohexad
 1237 9f23: 0b          tohex:     ldn     rb                  ; recover character A..F
 1238 9f24: ff 37                  smi     55                  ; convert to binary
 1239 9f26: 52          tohexad:   str     r2                  ; store value to add
 1240 9f27: f8 04                  ldi     4                   ; need to shift 4 times
 1241 9f29: ae                     plo     re
 1242 9f2a: 87          tohexal:   glo     r7
 1243 9f2b: fe                     shl
 1244 9f2c: a7                     plo     r7
 1245 9f2d: 97                     ghi     r7
 1246 9f2e: 7e                     shlc
 1247 9f2f: b7                     phi     r7
 1248 9f30: 2e                     dec     re                  ; decrement count
 1249 9f31: 8e                     glo     re                  ; get count
 1250 9f32: ca 9f 2a               lbnz    tohexal             ; loop until done
 1251 9f35: 87                     glo     r7                  ; now add in new value
 1252 9f36: f1                     or                          ; or with stored byte
 1253 9f37: a7                     plo     r7
 1254 9f38:             
 1255 9f38: 1b                     inc     rb
 1256 9f39: 0b                     ldn     rb
 1257 9f3a: ff 21                  smi     (' '+1)             ; check for space
 1258 9f3c: cb 9e ed               lbnf    numberdn1           ; number is complete
 1259 9f3f:                        
 1260 9f3f:                        ; words that begin with valid hex chars but have
 1261 9f3f:                        ; embedded non hex characters get filtered out here
 1262 9f3f: 0b                     ldn     rb
 1263 9f40: d4                     sep     scall               ; check for hex character
 1264 9f41: ac 21                  dw      ishex
 1265 9f43: c3 9f 02               lbdf    tohexlp             ; loop back if so else
 1266 9f46:                                                    ; we dont have a hex char
 1267 9f46:                        
 1268 9f46:                        ; we got here since this was not a valid hex number           
 1269 9f46: 8c ab 9c bb nothexnum: mov     rb,rc               ; retrieve pointer
 1270 9f4a:             
 1271 9f4a:             
 1272 9f4a:             ; *************************************************************
 1273 9f4a:             ; *** Neither token or number found, insert as ascii string ***
 1274 9f4a:             ; *************************************************************
 1275 9f4a: 2b          nonnumber: dec     rb                  ; account for first increment
 1276 9f4b: f8 17 ac f8 
            03 bc                  mov     rc, basen
 1277 9f51: 0c                     ldn     rc
 1278 9f52: ff 0a                  smi     10
 1279 9f54: ca 9f 5c               lbnz    nonnumber1
 1280 9f57: 8d                     glo     rd
 1281 9f58: c2 9f 5c               lbz     nonnumber1
 1282 9f5b: 2b                     dec     rb                  ; account for previous minus sign in DECIMAL mode
 1283 9f5c:             nonnumber1:
 1284 9f5c: f8 fe                  ldi     T_ASCII             ; indicate ascii to follow
 1285 9f5e: 5f          notokenlp: str     rf                  ; write to buffer
 1286 9f5f: 1f                     inc     rf                  ; advance to next position
 1287 9f60: 1b                     inc     rb                  ; point to next position
 1288 9f61: 0b                     ldn     rb                  ; get next byte
 1289 9f62: ff 21                  smi     (' '+1)             ; check for whitespace
 1290 9f64: cb 9f 6b               lbnf    notokwht            ; found whitespace
 1291 9f67: 0b                     ldn     rb                  ; get byte
 1292 9f68: c0 9f 5e               lbr     notokenlp           ; get characters til whitespace
 1293 9f6b: f8 00       notokwht:  ldi     0                   ; need ascii terminator
 1294 9f6d: 5f                     str     rf                  ; store into buffer
 1295 9f6e: 1f                     inc     rf                  ; point to next position
 1296 9f6f: c0 9d d0               lbr     tokenlp             ; and keep looking
 1297 9f72: f8 00       tokendn:   ldi     0                   ; need to terminate command string
 1298 9f74: 5f                     str     rf                  ; write to buffer
 1299 9f75: d5                     sep    sret                 ; return to caller
 1300 9f76:             
 1301 9f76:             
 1302 9f76:             ;           org     500h
 1303 9f76:             ; ****************************************************
 1304 9f76:             ; *** Execute forth byte codes, RB points to codes ***
 1305 9f76:             ; ****************************************************
 1306 9f76: 0b          exec:      ldn     rb                  ; get byte from codestream
 1307 9f77: c2 a6 88               lbz     execdn              ; jump if at end of stream
 1308 9f7a: ff ff                  smi     T_NUM               ; check for numbers
 1309 9f7c: c2 9f c1               lbz     execnum             ; code is numeric
 1310 9f7f: 0b                     ldn     rb                  ; recover byte
 1311 9f80: ff fe                  smi     T_ASCII             ; check for ascii data
 1312 9f82: c2 9f d4               lbz     execascii           ; jump if ascii
 1313 9f85: f8 0a a8 f8 
            03 b8                  mov     r8, jump            ; point to jump address
 1314 9f8b: f8 c0                  ldi     0c0h                ; need LBR
 1315 9f8d: 58                     str     r8                  ; store it
 1316 9f8e: 18                     inc     r8
 1317 9f8f: 0b                     ldn     rb                  ; recover byte
 1318 9f90: fa 7f                  ani     07fh                ; strip high bit
 1319 9f92: ff 01                  smi     1                   ; reset to origin
 1320 9f94: fe                     shl                         ; addresses are two bytes
 1321 9f95: e2                     sex     r2                  ; point X to stack
 1322 9f96: 52                     str     r2                  ; write offset for addtion
 1323 9f97: f8 d7                  ldi     low cmdvecs
 1324 9f99: f4                     add                         ; add offset
 1325 9f9a: a7                     plo     r7
 1326 9f9b: f8 ad                  ldi     high cmdvecs        ; high address of command vectors
 1327 9f9d: 7c 00                  adci    0                   ; propagate carry
 1328 9f9f: b7                     phi     r7                  ; r[7] now points to command vector
 1329 9fa0: 47                     lda     r7                  ; get high byte of vector
 1330 9fa1: 58                     str     r8
 1331 9fa2: 18                     inc     r8
 1332 9fa3: 47                     lda     r7                  ; get low byte of vector
 1333 9fa4: 58                     str     r8
 1334 9fa5: 1b                     inc     rb                  ; point rb to next command
 1335 9fa6: 8b                     glo     rb                  ; save rb
 1336 9fa7: 73                     stxd
 1337 9fa8: 9b                     ghi     rb
 1338 9fa9: 73                     stxd
 1339 9faa: c0 03 0a               lbr     jump
 1340 9fad: e2          execret:   sex     r2                  ; be sure X poits to stack
 1341 9fae: a7                     plo     r7                  ; save return code
 1342 9faf: 60                     irx                         ; recover rb
 1343 9fb0: 42                     lda     r2
 1344 9fb1: bb                     phi     rb
 1345 9fb2: 02                     ldn     r2
 1346 9fb3: ab                     plo     rb
 1347 9fb4: 87                     glo     r7                  ; get result code
 1348 9fb5: c2 9f 76               lbz     exec                ; jump if no error
 1349 9fb8: f8 ac                  ldi     high msempty        ; get error message
 1350 9fba: bf                     phi     rf
 1351 9fbb: f8 d9                  ldi     low msempty
 1352 9fbd: af                     plo     rf
 1353 9fbe:             execrmsg:  			;	sep     scall	
            #else
 1357 9fbe: c0 ff 09               lbr      f_msg
            #endif
 1359 9fc1:             	;;            sep     sret                ; return to caller
 1360 9fc1:             
 1361 9fc1: 1b          execnum:   inc     rb                  ; point to number
 1362 9fc2: 9b                     ghi     rb
 1363 9fc3: b7                     phi     r7
 1364 9fc4: 8b                     glo     rb
 1365 9fc5: a7                     plo     r7
 1366 9fc6: 47                     lda     r7
 1367 9fc7: bb                     phi     rb
 1368 9fc8: 47                     lda     r7
 1369 9fc9: ab                     plo     rb
 1370 9fca: d4                     sep     scall
 1371 9fcb: 9c 61                  dw      push
 1372 9fcd: 97                     ghi     r7
 1373 9fce: bb                     phi     rb
 1374 9fcf: 87                     glo     r7
 1375 9fd0: ab                     plo     rb
 1376 9fd1: c0 9f 76               lbr     exec                ; execute next code
 1377 9fd4: 1b          execascii: inc     rb                  ; move past ascii code
 1378 9fd5: 9b                     ghi     rb                  ; transfer name to R8
 1379 9fd6: b8                     phi     r8
 1380 9fd7: 8b                     glo     rb
 1381 9fd8: a8                     plo     r8
 1382 9fd9: d4                     sep     scall               ; find entry
 1383 9fda: 9c a5                  dw      findname
 1384 9fdc: cb 9f e8               lbnf    ascnoerr            ; jump if name was found
 1385 9fdf: f8 ac       ascerr:    ldi     high msgerr         ; get error message
 1386 9fe1: bf                     phi     rf
 1387 9fe2: f8 e7                  ldi     low msgerr
 1388 9fe4: af                     plo     rf
 1389 9fe5: c0 9f be               lbr     execrmsg
 1390 9fe8: 17          ascnoerr:  inc     r7                  ; point to type
 1391 9fe9: 17                     inc     r7
 1392 9fea: 07                     ldn     r7                  ; get type
 1393 9feb: ff 86                  smi     86h                 ; check for variable
 1394 9fed: c2 a0 06               lbz     execvar             ; jump if so
 1395 9ff0: 07                     ldn     r7                  ; get type
 1396 9ff1: ff 87                  smi     87h                 ; check for function
 1397 9ff3: ca 9f df               lbnz    ascerr              ; jump if not
 1398 9ff6: e2                     sex     r2                  ; be sure X is pointing to stack
 1399 9ff7: 88                     glo     r8                  ; save position
 1400 9ff8: 73                     stxd                        ; and store on stack
 1401 9ff9: 98                     ghi     r8
 1402 9ffa: 73                     stxd
 1403 9ffb: d4                     sep     scall               ; call exec to execute stored program
 1404 9ffc: 9f 76                  dw      exec
 1405 9ffe: 60                     irx                         ; recover pointer
 1406 9fff: 72                     ldxa
 1407 a000: bb                     phi     rb
 1408 a001: f0                     ldx
 1409 a002: ab                     plo     rb
 1410 a003: c0 9f 76               lbr     exec                ; and continue execution
 1411 a006: d4          execvar:   sep     scall               ; push var address to stack
 1412 a007: 9c 61                  dw      push
 1413 a009: 98                     ghi     r8                  ; transfer address back to rb
 1414 a00a: bb                     phi     rb
 1415 a00b: 88                     glo     r8
 1416 a00c: ab                     plo     rb
 1417 a00d: c0 9f 76               lbr     exec                ; execute next code
 1418 a010:                        
 1419 a010:             
 1420 a010:             
 1421 a010: f8 01       error:     ldi     1                   ; indicate error
 1422 a012: c0 9f ad               lbr     execret             ; return to caller
 1423 a015:             
 1424 a015:             ;          org     600h
 1425 a015: d4          cdup:      sep     scall               ; pop value from forth stack
 1426 a016: 9c 32                  dw      pop
 1427 a018: c3 a0 10               lbdf    error               ; jump if stack was empty
 1428 a01b: d4                     sep     scall               ; push back twice
 1429 a01c: 9c 61                  dw      push
 1430 a01e:             goodpush:	
 1431 a01e: d4                     sep     scall
 1432 a01f: 9c 61                  dw      push
 1433 a021: f8 00       good:      ldi     0                   ; indicate success
 1434 a023: c0 9f ad               lbr     execret             ; return to caller
 1435 a026:             
 1436 a026:             
 1437 a026: d4          cdrop:     sep     scall               ; pop value from stack
 1438 a027: 9c 32                  dw      pop
 1439 a029: c3 a0 10               lbdf    error               ; jump if stack was empty
 1440 a02c: c0 a0 21               lbr     good                ; return
 1441 a02f:                        
 1442 a02f: d4          cplus:     sep     scall               ; get value from stack
 1443 a030: 9c 32                  dw      pop
 1444 a032: c3 a0 10               lbdf    error               ; jump if stack was empty
 1445 a035: 9b                     ghi     rb                  ; move number 
 1446 a036: b7                     phi     r7
 1447 a037: 8b                     glo     rb
 1448 a038: a7                     plo     r7
 1449 a039: d4                     sep     scall               ; get next number
 1450 a03a: 9c 32                  dw      pop
 1451 a03c: c3 a0 10               lbdf    error               ; jump if stack was empty
 1452 a03f: e2                     sex     r2                  ; be sure X points to stack
 1453 a040: 87                     glo     r7                  ; perform addition
 1454 a041: 52                     str     r2
 1455 a042: 8b                     glo     rb
 1456 a043: f4                     add
 1457 a044: ab                     plo     rb
 1458 a045: 97                     ghi     r7
 1459 a046: 52                     str     r2
 1460 a047: 9b                     ghi     rb
 1461 a048: 74                     adc
 1462 a049: bb                     phi     rb
 1463 a04a: c0 a0 1e    	   lbr     goodpush
 1464 a04d:             
 1465 a04d:             
 1466 a04d:             
 1467 a04d: d4          cminus:    sep     scall               ; get value from stack
 1468 a04e: 9c 32                  dw      pop
 1469 a050: c3 a0 10               lbdf    error               ; jump if stack was empty
 1470 a053: 9b                     ghi     rb                  ; move number 
 1471 a054: b7                     phi     r7
 1472 a055: 8b                     glo     rb
 1473 a056: a7                     plo     r7
 1474 a057: d4                     sep     scall               ; get next number
 1475 a058: 9c 32                  dw      pop
 1476 a05a: c3 a0 10               lbdf    error               ; jump if stack was empty
 1477 a05d: e2                     sex     r2                  ; be sure X points to stack
 1478 a05e: 87                     glo     r7                  ; perform addition
 1479 a05f: 52                     str     r2
 1480 a060: 8b                     glo     rb
 1481 a061: f7                     sm
 1482 a062: ab                     plo     rb
 1483 a063: 97                     ghi     r7
 1484 a064: 52                     str     r2
 1485 a065: 9b                     ghi     rb
 1486 a066: 77                     smb
 1487 a067: bb                     phi     rb
 1488 a068: c0 a0 1e    	   lbr goodpush
 1489 a06b:             
 1490 a06b:             
 1491 a06b: d4          cdot:      sep     scall               ; get value from stack
 1492 a06c: 9c 32                  dw      pop
 1493 a06e: c3 a0 10               lbdf    error               ; jump if stack was empty
 1494 a071: f8 01                  ldi     1
 1495 a073: ae                     plo     re                  ; signal signed int
 1496 a074:             typegood:	
 1497 a074: d4                     sep     scall
 1498 a075: ab b5                  dw      typenum             ; [GDJ]
 1499 a077:                        ; sep     scall               ; call integer out routine
 1500 a077:                        ; dw      intout
 1501 a077:                        ; ldi     ' '                 ; need a space
 1502 a077:                        ; sep     scall               ; need to call character out
 1503 a077:                        ; dw      disp
 1504 a077: c0 a0 21               lbr     good                ; return
 1505 a07a:             
 1506 a07a: d4          cudot:     sep     scall               ; get value from stack
 1507 a07b: 9c 32                  dw      pop
 1508 a07d: c3 a0 10               lbdf    error               ; jump if stack was empty
 1509 a080: f8 00                  ldi     0
 1510 a082: ae                     plo     re                  ; signal unsigned int
 1511 a083: 30 74       	   br typegood
 1512 a085:             
 1513 a085: d4          cand:      sep     scall               ; get value from stack
 1514 a086: 9c 32                  dw      pop
 1515 a088: c3 a0 10               lbdf    error               ; jump if stack was empty
 1516 a08b: 9b                     ghi     rb                  ; move number 
 1517 a08c: b7                     phi     r7
 1518 a08d: 8b                     glo     rb
 1519 a08e: a7                     plo     r7
 1520 a08f: d4                     sep     scall               ; get next number
 1521 a090: 9c 32                  dw      pop
 1522 a092: c3 a0 10               lbdf    error               ; jump if stack was empty
 1523 a095: e2                     sex     r2                  ; be sure X points to stack
 1524 a096: 87                     glo     r7                  ; perform and
 1525 a097: 52                     str     r2
 1526 a098: 8b                     glo     rb
 1527 a099: f2                     and
 1528 a09a: ab                     plo     rb
 1529 a09b: 97                     ghi     r7
 1530 a09c: 52                     str     r2
 1531 a09d: 9b                     ghi     rb
 1532 a09e: f2                     and
 1533 a09f: bb                     phi     rb
 1534 a0a0: c0 a0 1e    	   lbr goodpush
 1535 a0a3:             
 1536 a0a3:             
 1537 a0a3: d4          cor:       sep     scall               ; get value from stack
 1538 a0a4: 9c 32                  dw      pop
 1539 a0a6: c3 a0 10               lbdf    error               ; jump if stack was empty
 1540 a0a9: 9b                     ghi     rb                  ; move number 
 1541 a0aa: b7                     phi     r7
 1542 a0ab: 8b                     glo     rb
 1543 a0ac: a7                     plo     r7
 1544 a0ad: d4                     sep     scall               ; get next number
 1545 a0ae: 9c 32                  dw      pop
 1546 a0b0: c3 a0 10               lbdf    error               ; jump if stack was empty
 1547 a0b3: e2                     sex     r2                  ; be sure X points to stack
 1548 a0b4: 87                     glo     r7                  ; perform and
 1549 a0b5: 52                     str     r2
 1550 a0b6: 8b                     glo     rb
 1551 a0b7: f1                     or
 1552 a0b8: ab                     plo     rb
 1553 a0b9: 97                     ghi     r7
 1554 a0ba: 52                     str     r2
 1555 a0bb: 9b                     ghi     rb
 1556 a0bc: f1                     or
 1557 a0bd: bb                     phi     rb
 1558 a0be: c0 a0 1e    	   lbr     goodpush
 1559 a0c1:             
 1560 a0c1: d4          cxor:      sep     scall               ; get value from stack
 1561 a0c2: 9c 32                  dw      pop
 1562 a0c4: c3 a0 10               lbdf    error               ; jump if stack was empty
 1563 a0c7: 9b                     ghi     rb                  ; move number 
 1564 a0c8: b7                     phi     r7
 1565 a0c9: 8b                     glo     rb
 1566 a0ca: a7                     plo     r7
 1567 a0cb: d4                     sep     scall               ; get next number
 1568 a0cc: 9c 32                  dw      pop
 1569 a0ce: c3 a0 10               lbdf    error               ; jump if stack was empty
 1570 a0d1: e2                     sex     r2                  ; be sure X points to stack
 1571 a0d2: 87                     glo     r7                  ; perform and
 1572 a0d3: 52                     str     r2
 1573 a0d4: 8b                     glo     rb
 1574 a0d5: f3                     xor
 1575 a0d6: ab                     plo     rb
 1576 a0d7: 97                     ghi     r7
 1577 a0d8: 52                     str     r2
 1578 a0d9: 9b                     ghi     rb
 1579 a0da: f3                     xor
 1580 a0db: bb                     phi     rb
 1581 a0dc: c0 a0 1e    	   lbr    goodpush
 1582 a0df:             
 1583 a0df:             
 1584 a0df: d4          ccr:	   sep scall
 1585 a0e0: 9c 17       	   dw crlfout
 1586 a0e2: c0 a0 21               lbr     good                ; return
 1587 a0e5:             
 1588 a0e5: d4          cswap:     sep     scall               ; get value from stack
 1589 a0e6: 9c 32                  dw      pop
 1590 a0e8: c3 a0 10               lbdf    error               ; jump if stack was empty
 1591 a0eb: 9b                     ghi     rb                  ; move number 
 1592 a0ec: b7                     phi     r7
 1593 a0ed: 8b                     glo     rb
 1594 a0ee: a7                     plo     r7
 1595 a0ef: d4                     sep     scall               ; get next number
 1596 a0f0: 9c 32                  dw      pop
 1597 a0f2: c3 a0 10               lbdf    error               ; jump if stack was empty
 1598 a0f5: 9b                     ghi     rb                  ; move number 
 1599 a0f6: b8                     phi     r8
 1600 a0f7: 8b                     glo     rb
 1601 a0f8: a8                     plo     r8
 1602 a0f9: 97                     ghi     r7                  ; move number 
 1603 a0fa: bb                     phi     rb
 1604 a0fb: 87                     glo     r7
 1605 a0fc: ab                     plo     rb
 1606 a0fd: d4                     sep     scall               ; put answer back on stack
 1607 a0fe: 9c 61                  dw      push
 1608 a100: 98                     ghi     r8                  ; move number 
 1609 a101: bb                     phi     rb
 1610 a102: 88                     glo     r8
 1611 a103: ab                     plo     rb
 1612 a104: d4                     sep     scall               ; put answer back on stack
 1613 a105: 9c 61                  dw      push
 1614 a107: c0 a0 21               lbr     good                ; return
 1615 a10a:             
 1616 a10a: d4          ci:        sep     scall               ; get value from return stack
 1617 a10b: 9c 77                  dw      rpop
 1618 a10d: d4                     sep     scall               ; put back on return stack
 1619 a10e: 9c 8f                  dw      rpush 
 1620 a110: c0 a0 1e    	   lbr  goodpush
 1621 a113:             
 1622 a113: e2          cmem:      sex     r2                  ; be sure x is pointing to stack
 1623 a114: f8 06                  ldi     low freemem         ; point to free memory pointer
 1624 a116: a9                     plo     r9                  ; place into data frame
 1625 a117: 49                     lda     r9                  ; get high byte of free memory pointer
 1626 a118: 73                     stxd                        ; store on stack
 1627 a119: 49                     lda     r9                  ; get low byte
 1628 a11a: 52                     str     r2                  ; store on stack
 1629 a11b: f8 08                  ldi     low fstack          ; get pointer to stack
 1630 a11d: a9                     plo     r9                  ; set into data frame
 1631 a11e: 19                     inc     r9                  ; point to lo byte
 1632 a11f: 09                     ldn     r9                  ; get it
 1633 a120: f7                     sm                          ; perform subtract
 1634 a121: ab                     plo     rb                  ; put into result
 1635 a122: 29                     dec     r9                  ; high byte of stack pointer
 1636 a123: 60                     irx                         ; point to high byte os free mem
 1637 a124: 09                     ldn     r9                  ; get high byte of stack
 1638 a125: 77                     smb                         ; continue subtraction
 1639 a126: bb                     phi     rb                  ; store answer
 1640 a127: c0 a0 1e    	   lbr  goodpush
 1641 a12a:             
 1642 a12a:              
 1643 a12a:             
 1644 a12a: d4          cdo:       sep     scall               ; get value from stack
 1645 a12b: 9c 32                  dw      pop
 1646 a12d: c3 a0 10               lbdf    error               ; jump if stack was empty
 1647 a130: 9b                     ghi     rb                  ; move number 
 1648 a131: b7                     phi     r7
 1649 a132: 8b                     glo     rb
 1650 a133: a7                     plo     r7
 1651 a134: d4                     sep     scall               ; get next number
 1652 a135: 9c 32                  dw      pop
 1653 a137: c3 a0 10               lbdf    error               ; jump if stack was empty
 1654 a13a: 9b                     ghi     rb                  ; move number 
 1655 a13b: b8                     phi     r8
 1656 a13c: 8b                     glo     rb
 1657 a13d: a8                     plo     r8
 1658 a13e: 92                     ghi     r2                  ; get copy of machine stack
 1659 a13f: ba                     phi     ra
 1660 a140: 82                     glo     r2
 1661 a141: aa                     plo     ra
 1662 a142: 1a                     inc     ra                  ; pointing at R[6] value high
 1663 a143: 4a                     lda     ra                  ; get high of R[6]
 1664 a144: bb                     phi     rb                  ; put into r6
 1665 a145: 4a                     lda     ra
 1666 a146: ab                     plo     rb
 1667 a147: d4                     sep     scall               ; store inst point on return stack
 1668 a148: 9c 8f                  dw      rpush
 1669 a14a: 98                     ghi     r8                  ; transfer termination to rb
 1670 a14b: bb                     phi     rb
 1671 a14c: 88                     glo     r8
 1672 a14d: ab                     plo     rb
 1673 a14e: d4                     sep     scall               ; store termination on return stack
 1674 a14f: 9c 8f                  dw      rpush
 1675 a151: 97                     ghi     r7                  ; transfer count to rb
 1676 a152: bb                     phi     rb
 1677 a153: 87                     glo     r7
 1678 a154: ab                     plo     rb
 1679 a155: d4                     sep     scall
 1680 a156: 9c 8f       	   dw rpush
 1681 a158: c0 a0 21    	   lbr good
 1682 a15b:             
 1683 a15b:             
 1684 a15b: d4          cloop:     sep     scall               ; get top or return stack
 1685 a15c: 9c 77                  dw      rpop
 1686 a15e: 1b                     inc     rb                  ; add 1 to it
 1687 a15f: 9b          loopcnt:   ghi     rb                  ; move it
 1688 a160: b7                     phi     r7
 1689 a161: 8b                     glo     rb
 1690 a162: a7                     plo     r7
 1691 a163: d4                     sep     scall               ; get termination
 1692 a164: 9c 77                  dw      rpop
 1693 a166: e2                     sex     r2                  ; make sure x is pointing to stack
 1694 a167: 8b                     glo     rb                  ; get lo of termination
 1695 a168: 52                     str     r2                  ; place into memory 
 1696 a169: 87                     glo     r7                  ; get count
 1697 a16a: f7                     sm                          ; perform subtract
 1698 a16b: 9b                     ghi     rb                  ; get hi of termination
 1699 a16c: 52                     str     r2                  ; place into memory
 1700 a16d: 97                     ghi     r7                  ; get high of count
 1701 a16e: 77                     smb                         ; continue subtract
 1702 a16f: c3 a1 97               lbdf    cloopdn             ; jump if loop complete
 1703 a172: 9b                     ghi     rb                  ; move termination
 1704 a173: b8                     phi     r8
 1705 a174: 8b                     glo     rb
 1706 a175: a8                     plo     r8
 1707 a176: d4                     sep     scall               ; get loop address
 1708 a177: 9c 77                  dw      rpop
 1709 a179: d4                     sep     scall               ; keep on stack as well
 1710 a17a: 9c 8f                  dw      rpush
 1711 a17c: 92                     ghi     r2                  ; get copy of machine stack
 1712 a17d: ba                     phi     ra
 1713 a17e: 82                     glo     r2
 1714 a17f: aa                     plo     ra
 1715 a180: 1a                     inc     ra                  ; pointing at ra value high
 1716 a181: 9b                     ghi     rb
 1717 a182: 5a                     str     ra                  ; and write it
 1718 a183: 1a                     inc     ra                 
 1719 a184: 8b                     glo     rb                  ; get rb lo value
 1720 a185: 5a                     str     ra                  ; and write it
 1721 a186: 98                     ghi     r8                  ; transfer termination
 1722 a187: bb                     phi     rb
 1723 a188: 88                     glo     r8
 1724 a189: ab                     plo     rb
 1725 a18a: d4                     sep     scall               ; push onto return stack
 1726 a18b: 9c 8f                  dw      rpush
 1727 a18d: 97                     ghi     r7                  ; transfer count
 1728 a18e: bb                     phi     rb
 1729 a18f: 87                     glo     r7
 1730 a190: ab                     plo     rb
 1731 a191: d4                     sep     scall               ; push onto return stack
 1732 a192: 9c 8f                  dw      rpush
 1733 a194: c0 a0 21               lbr     good                ; and return
 1734 a197: d4          cloopdn:   sep     scall               ; pop off start of loop address
 1735 a198: 9c 77                  dw      rpop
 1736 a19a: c0 a0 21               lbr     good                ; and return
 1737 a19d: d4          cploop:    sep     scall               ; get top or return stack
 1738 a19e: 9c 77                  dw      rpop
 1739 a1a0: e2                     sex     r2                  ; make sure X points to stack
 1740 a1a1: 9b                     ghi     rb                  ; put count into memory
 1741 a1a2: 73                     stxd
 1742 a1a3: 8b                     glo     rb
 1743 a1a4: 73                     stxd
 1744 a1a5: d4                     sep     scall               ; get word from data stack
 1745 a1a6: 9c 32                  dw      pop
 1746 a1a8: c3 a0 10               lbdf    error
 1747 a1ab: 60                     irx
 1748 a1ac: 8b                     glo     rb                  ; add to count
 1749 a1ad: f4                     add
 1750 a1ae: ab                     plo     rb
 1751 a1af: 9b                     ghi     rb
 1752 a1b0: 60                     irx
 1753 a1b1: 74                     adc
 1754 a1b2: bb                     phi     rb
 1755 a1b3: c0 a1 5f               lbr     loopcnt             ; then standard loop code
 1756 a1b6:             
 1757 a1b6: 92          cbegin:    ghi     r2                  ; get copy of machine stack
 1758 a1b7: ba                     phi     ra
 1759 a1b8: 82                     glo     r2
 1760 a1b9: aa                     plo     ra
 1761 a1ba: 1a                     inc     ra                  ; pointing at ra value high
 1762 a1bb: 4a                     lda     ra                  ; get high of ra
 1763 a1bc: bb                     phi     rb                  ; put into rb
 1764 a1bd: 4a                     lda     ra
 1765 a1be: ab                     plo     rb
 1766 a1bf: d4                     sep     scall               ; store inst point on return stack
 1767 a1c0: 9c 8f                  dw      rpush
 1768 a1c2: c0 a0 21               lbr     good                ; and return
 1769 a1c5:             
 1770 a1c5:             ; [GDJ] corrected logic - BEGIN/UNTIL loop should repeat if flag preceding UNTIL is FALSE
 1771 a1c5: d4          cuntil:    sep     scall               ; get top of stack
 1772 a1c6: 9c 32                  dw      pop
 1773 a1c8: c3 a0 10               lbdf    error               ; jump if stack was empty
 1774 a1cb: 8b                     glo     rb                  ; [GDJ] check flag LSB - if true were done
 1775 a1cc: ca a1 d3               lbnz    untilno             ; [GDJ]
 1776 a1cf: 9b                     ghi     rb                  ; [GDJ] check flag MSB
 1777 a1d0: c2 a1 d9               lbz     untilyes
 1778 a1d3: d4          untilno:   sep     scall               ; pop off begin address
 1779 a1d4: 9c 77                  dw      rpop
 1780 a1d6: c0 a0 21               lbr     good                ; we are done, just return
 1781 a1d9: d4          untilyes:  sep     scall               ; get return address - continue looping
 1782 a1da: 9c 77                  dw      rpop
 1783 a1dc: d4                     sep     scall               ; also keep on stack
 1784 a1dd: 9c 8f                  dw      rpush
 1785 a1df: 92                     ghi     r2                  ; get copy of machine stack
 1786 a1e0: ba                     phi     ra
 1787 a1e1: 82                     glo     r2
 1788 a1e2: aa                     plo     ra
 1789 a1e3: 1a                     inc     ra                  ; pointing at ra value high
 1790 a1e4: 9b                     ghi     rb
 1791 a1e5: 5a                     str     ra                  ; and write it
 1792 a1e6: 1a                     inc     ra                 
 1793 a1e7: 8b                     glo     rb                  ; get rb lo value
 1794 a1e8: 5a                     str     ra                  ; and write it
 1795 a1e9: c0 a0 21               lbr     good                ; now return
 1796 a1ec:             
 1797 a1ec: d4          crgt:      sep     scall               ; get value from return stack
 1798 a1ed: 9c 77                  dw      rpop
 1799 a1ef: c0 a0 1e    	   lbr goodpush
 1800 a1f2:             
 1801 a1f2:             
 1802 a1f2: d4          cgtr:      sep     scall               ; get value from stack
 1803 a1f3: 9c 32                  dw      pop
 1804 a1f5: c3 a0 10               lbdf    error               ; jump if stack was empty
 1805 a1f8: d4                     sep     scall               ; push to return stack
 1806 a1f9: 9c 8f                  dw      rpush
 1807 a1fb: c0 a0 21               lbr     good                ; return to caller
 1808 a1fe:             
 1809 a1fe: d4          cunequal:  sep     scall               ; get value from stack
 1810 a1ff: 9c 32                  dw      pop
 1811 a201: c3 a0 10               lbdf    error               ; jump if stack was empty
 1812 a204: 9b                     ghi     rb                  ; move number 
 1813 a205: b7                     phi     r7
 1814 a206: 8b                     glo     rb
 1815 a207: a7                     plo     r7
 1816 a208: d4                     sep     scall               ; get next number
 1817 a209: 9c 32                  dw      pop
 1818 a20b: c3 a0 10               lbdf    error               ; jump if stack was empty
 1819 a20e: e2                     sex     r2                  ; be sure X points to stack
 1820 a20f: 87                     glo     r7                  ; perform and
 1821 a210: 52                     str     r2
 1822 a211: 8b                     glo     rb
 1823 a212: f3                     xor
 1824 a213: ca a2 22               lbnz    unequal             ; jump if not equal
 1825 a216: 97                     ghi     r7
 1826 a217: 52                     str     r2
 1827 a218: 9b                     ghi     rb
 1828 a219: f3                     xor
 1829 a21a: ca a2 22               lbnz    unequal             ; jump if not equal
 1830 a21d: bb                     phi     rb                  ; set return result
 1831 a21e: ab                     plo     rb
 1832 a21f: c0 a0 1e    	   lbr goodpush
 1833 a222:             
 1834 a222: f8 00       unequal:   ldi     0                   ; set return result
 1835 a224: bb                     phi     rb
 1836 a225: ab                     plo     rb
 1837 a226: 1b                     inc     rb                  ; it is now 1
 1838 a227: c0 a0 1e               lbr     goodpush
 1839 a22a:             
 1840 a22a:             
 1841 a22a:             ; [GDJ]
 1842 a22a:             ; determine if NOS < TOS
 1843 a22a: d4          cless:     sep     scall               ; get value from stack
 1844 a22b: 9c 32                  dw      pop
 1845 a22d: c3 a0 10               lbdf    error               ; jump if stack was empty
 1846 a230: 9b                     ghi     rb                  ; move number 
 1847 a231: b8                     phi     r8
 1848 a232: 8b                     glo     rb
 1849 a233: a8                     plo     r8
 1850 a234: d4                     sep     scall               ; get next number
 1851 a235: 9c 32                  dw      pop
 1852 a237: c3 a0 10               lbdf    error               ; jump if stack was empty
 1853 a23a: e2                     sex     r2                  ; be sure X points to stack
 1854 a23b:             
 1855 a23b: 9b                     ghi     rb                  ; move number 
 1856 a23c: b7                     phi     r7
 1857 a23d: 8b                     glo     rb
 1858 a23e: a7                     plo     r7
 1859 a23f:             
 1860 a23f:                        ; bias numbers for comparison
 1861 a23f: 97                     ghi     r7
 1862 a240: fb 80                  xri     080h                ; bias upwards
 1863 a242: b7                     phi     r7
 1864 a243:             
 1865 a243: 98                     ghi     r8
 1866 a244: fb 80                  xri     080h                ; bias upwards
 1867 a246: b8                     phi     r8
 1868 a247:             
 1869 a247: 87                     glo     7                   ; subtract them
 1870 a248: 52                     str     r2
 1871 a249: 88                     glo     r8
 1872 a24a: f5                     sd
 1873 a24b: a7                     plo     r7
 1874 a24c: 97                     ghi     r7
 1875 a24d: 52                     str     r2
 1876 a24e: 98                     ghi     r8
 1877 a24f: 75                     sdb
 1878 a250: b7                     phi     r7
 1879 a251:             
 1880 a251: cb a2 5d               lbnf    less1               ; DF signaled with borrow
 1881 a254: f8 00 ab f8 
            00 bb                  mov     rb, 0
 1882 a25a: c0 a0 1e               lbr     goodpush
 1883 a25d: f8 01 ab f8 
            00 bb       less1:     mov     rb, 1
 1884 a263: c0 a0 1e    	   lbr goodpush 
 1885 a266:             
 1886 a266:             
 1887 a266:             
 1888 a266:             
 1889 a266:             ; [GDJ]
 1890 a266: d4          culess:    sep     scall               ; get value from stack
 1891 a267: 9c 32                  dw      pop
 1892 a269: c3 a0 10               lbdf    error               ; jump if stack was empty
 1893 a26c: 9b                     ghi     rb                  ; move number 
 1894 a26d: b7                     phi     r7
 1895 a26e: 8b                     glo     rb
 1896 a26f: a7                     plo     r7
 1897 a270: d4                     sep     scall               ; get next number
 1898 a271: 9c 32                  dw      pop
 1899 a273: c3 a0 10               lbdf    error               ; jump if stack was empty
 1900 a276: e2                     sex     r2                  ; be sure X points to stack
 1901 a277:             
 1902 a277: 9b                     ghi     rb                  ; move number 
 1903 a278: b8                     phi     r8
 1904 a279: 8b                     glo     rb
 1905 a27a: a8                     plo     r8
 1906 a27b:             
 1907 a27b:                        ; perform subtraction r8-r7  (NOS-TOS) to check for borrow
 1908 a27b: 88                     glo     r8
 1909 a27c: 52                     str     r2
 1910 a27d: 87                     glo     r7
 1911 a27e: f5                     sd
 1912 a27f: a8                     plo     r8
 1913 a280: 98                     ghi     r8
 1914 a281: 52                     str     r2
 1915 a282: 97                     ghi     r7
 1916 a283: 75                     sdb                         ; subtract with borrow
 1917 a284: cb a2 90               lbnf    uless1              ; DF signaled with borrow
 1918 a287: f8 00 ab f8 
            00 bb                  mov     rb, 0
 1919 a28d: c0 a0 1e               lbr     goodpush
 1920 a290: f8 01 ab f8 
            00 bb       uless1:    mov     rb, 1
 1921 a296: c0 a0 1e    	   lbr     goodpush
 1922 a299:             
 1923 a299:             
 1924 a299: f8 ac       cwords:    ldi     high cmdtable       ; point to command table
 1925 a29b: b7                     phi     r7                  ; put into a pointer register
 1926 a29c: f8 ed                  ldi     low cmdtable
 1927 a29e: a7                     plo     r7
 1928 a29f: f8 00 ad f8 
            00 bd                  mov     rd, 0
 1929 a2a5: 47          cwordslp:  lda     r7                  ; get byte
 1930 a2a6: c2 a2 d4               lbz     cwordsdn            ; jump if done
 1931 a2a9: ab                     plo     rb                  ; save it
 1932 a2aa: fa 80                  ani     128                 ; check for final of token
 1933 a2ac: ca a2 b6               lbnz    cwordsf             ; jump if so
 1934 a2af: 8b                     glo     rb                  ; get byte
 1935 a2b0: d4                     sep     scall               ; display it
 1936 a2b1: 9c 2a                  dw      disp 
 1937 a2b3: c0 a2 a5               lbr     cwordslp            ; and loop back
 1938 a2b6: 8b          cwordsf:   glo     rb                  ; get byte
 1939 a2b7: fa 7f                  ani     07fh                ; strip high bit
 1940 a2b9: d4                     sep     scall               ; display it
 1941 a2ba: 9c 2a                  dw      disp
 1942 a2bc: f8 20                  ldi     ' '                 ; display a space
 1943 a2be: d4                     sep     scall               ; display it
 1944 a2bf: 9c 2a                  dw      disp
 1945 a2c1: 1d                     inc     rd
 1946 a2c2: 8d                     glo     rd
 1947 a2c3: ff 0c                  smi     12
 1948 a2c5: ca a2 a5               lbnz    cwordslp
 1949 a2c8: f8 00 ad f8 
            00 bd                  mov     rd, 0
 1950 a2ce: d4          	   sep scall
 1951 a2cf: 9c 17       	   dw crlfout
 1952 a2d1: c0 a2 a5               lbr     cwordslp            ; and loop back
 1953 a2d4: d4          cwordsdn:  sep scall
 1954 a2d5: 9c 17       	   dw  crlfout
 1955 a2d7: f8 03                  ldi     high storage        ; get beginning of program memory
 1956 a2d9: b7                     phi     r7
 1957 a2da: f8 0d                  ldi     low storage
 1958 a2dc: a7                     plo     r7
 1959 a2dd: f8 00 ad f8 
            00 bd                  mov     rd, 0
 1960 a2e3: 47          cwordslp2: lda     r7                  ; get pointer to next entry
 1961 a2e4: b8                     phi     r8                  ; put into r8
 1962 a2e5: 47                     lda     r7                  ; now pointing at type indicator
 1963 a2e6: a8                     plo     r8                  ; save low of link
 1964 a2e7: ca a2 f4               lbnz    cwordsnot           ; jump if not link terminator
 1965 a2ea: 98                     ghi     r8                  ; check high byte too
 1966 a2eb: ca a2 f4               lbnz    cwordsnot
 1967 a2ee: d4          cwordsdn1: sep  scall
 1968 a2ef: 9c 17       	   dw   crlfout 
 1969 a2f1: c0 a0 21               lbr     good                ; return to caller
 1970 a2f4: 17          cwordsnot: inc     r7                  ; now pointing at ascii indicator
 1971 a2f5: 17                     inc     r7                  ; first character of name
 1972 a2f6: 47          wordsnotl: lda     r7                  ; get byte from string
 1973 a2f7: c2 a3 00               lbz     wordsnxt            ; jump if end of string
 1974 a2fa: d4                     sep     scall               ; display it
 1975 a2fb: 9c 2a                  dw      disp
 1976 a2fd: c0 a2 f6               lbr     wordsnotl           ; keep going
 1977 a300: f8 20       wordsnxt:  ldi     ' '                 ; want a space
 1978 a302: d4                     sep     scall               ; display it
 1979 a303: 9c 2a                  dw      disp
 1980 a305: 98                     ghi     r8                  ; transfer next word address to r7
 1981 a306: b7                     phi     r7
 1982 a307: 88                     glo     r8
 1983 a308: a7                     plo     r7
 1984 a309: 1d                     inc     rd
 1985 a30a: 8d                     glo     rd
 1986 a30b: ff 08                  smi     8
 1987 a30d: ca a2 e3               lbnz    cwordslp2
 1988 a310: f8 00 ad f8 
            00 bd                  mov     rd, 0
 1989 a316: d4           	   sep     scall
 1990 a317: 9c 17       	   dw crlfout
 1991 a319: c0 a2 e3               lbr     cwordslp2           ; and check next word
 1992 a31c:             
 1993 a31c:             
 1994 a31c: d4          cemit:     sep     scall               ; get top of stack
 1995 a31d: 9c 32                  dw      pop
 1996 a31f: c3 a0 10               lbdf    error               ; jump if error
 1997 a322: 8b                     glo     rb                  ; get low of return value
 1998 a323: d4                     sep     scall               ; and display ti
 1999 a324: 9c 2a                  dw      disp
 2000 a326: c0 a0 21               lbr     good                ; return to caller
 2001 a329:             
 2002 a329:             ; [GDJ]
 2003 a329: d4          cemitp:    sep     scall               ; get top of stack
 2004 a32a: 9c 32                  dw      pop
 2005 a32c: c3 a0 10               lbdf    error               ; jump if error
 2006 a32f: 8b                     glo     rb                  ; get low of return value
 2007 a330:             
 2008 a330: ff 20                  smi     32                  ; check for below space
 2009 a332: cb a3 3f               lbnf    notprint            ; jump if not printable
 2010 a335: 8b                     glo     rb
 2011 a336: ff 7f                  smi     127                 ; check for above tilde ~
 2012 a338: c3 a3 3f               lbdf    notprint            ; jump if not printable
 2013 a33b:             
 2014 a33b: 8b                     glo     rb
 2015 a33c: c0 a3 41               lbr     emitpout            ; ok printable
 2016 a33f:             
 2017 a33f: f8 2e       notprint:  ldi     '.'
 2018 a341:             
 2019 a341: d4          emitpout:  sep     scall               ; and display ti
 2020 a342: 9c 2a                  dw      disp
 2021 a344: c0 a0 21               lbr     good                ; return to caller
 2022 a347:             
 2023 a347:             
 2024 a347: d4          cwhile:    sep     scall               ; get top of stack
 2025 a348: 9c 32                  dw      pop
 2026 a34a: c3 a0 10               lbdf    error               ; jump if error
 2027 a34d: 8b                     glo     rb                  ; need to check for zero
 2028 a34e: ca a3 83               lbnz    whileno             ; jump if not zero
 2029 a351: 9b                     ghi     rb                  ; check high byte
 2030 a352: ca a3 83               lbnz    whileno
 2031 a355: 92                     ghi     r2                  ; copy machine stack to RA
 2032 a356: ba                     phi     ra
 2033 a357: 82                     glo     r2
 2034 a358: aa                     plo     ra
 2035 a359: 1a                     inc     ra                  ; point to R[6]
 2036 a35a: 4a                     lda     ra                  ; get command stream
 2037 a35b: bb                     phi     rb                  ; put into r6
 2038 a35c: 0a                     ldn     ra
 2039 a35d: ab                     plo     rb
 2040 a35e: f8 00                  ldi     0                   ; set while count to zero
 2041 a360: a7                     plo     r7
 2042 a361: 0b          findrep:   ldn     rb                  ; get byte from stream
 2043 a362: ff 81                  smi     81h                 ; was a while found
 2044 a364: ca a3 6c               lbnz    notwhile            ; jump if not
 2045 a367: 17                     inc     r7                  ; increment while count
 2046 a368: 1b          notrep:    inc     rb                  ; point to next byte
 2047 a369: c0 a3 61               lbr     findrep             ; and keep looking
 2048 a36c: 0b          notwhile:  ldn     rb                  ; retrieve byte
 2049 a36d: ff 82                  smi     82h                 ; is it a repeat
 2050 a36f: ca a3 68               lbnz    notrep              ; jump if not
 2051 a372: 87                     glo     r7                  ; get while count
 2052 a373: c2 a3 7a               lbz     fndrep              ; jump if not zero
 2053 a376: 27                     dec     r7                  ; decrement count
 2054 a377: c0 a3 68               lbr     notrep              ; and keep looking
 2055 a37a: 1b          fndrep:    inc     rb                  ; move past the while
 2056 a37b: 8b                     glo     rb                  ; now put back into R[6]
 2057 a37c: 5a                     str     ra
 2058 a37d: 2a                     dec     ra
 2059 a37e: 9b                     ghi     rb
 2060 a37f: 5a                     str     ra
 2061 a380: c0 a0 21               lbr     good                ; then return to caller
 2062 a383: 92          whileno:   ghi     r2                  ; copy machine stack to RA
 2063 a384: ba                     phi     ra
 2064 a385: 82                     glo     r2
 2065 a386: aa                     plo     ra
 2066 a387: 1a                     inc     ra                  ; now pointing to high byte of R[6]
 2067 a388: 4a                     lda     ra                  ; get it
 2068 a389: bb                     phi     rb                  ; and put into r6
 2069 a38a: 0a                     ldn     ra                  ; get low byte
 2070 a38b: ab                     plo     rb
 2071 a38c: 2b                     dec     rb                  ; point back to while command
 2072 a38d: d4                     sep     scall               ; put onto return stack
 2073 a38e: 9c 8f                  dw      rpush
 2074 a390: c0 a0 21               lbr     good                ; then return
 2075 a393:             
 2076 a393: d4          crepeat:   sep     scall               ; get address on return stack
 2077 a394: 9c 77                  dw      rpop
 2078 a396: 92                     ghi     r2                  ; transfer machine stack to RA
 2079 a397: ba                     phi     ra
 2080 a398: 82                     glo     r2
 2081 a399: aa                     plo     ra
 2082 a39a: 1a                     inc     ra                  ; now pointing at high byte of R[6]
 2083 a39b: 9b                     ghi     rb                  ; get while address
 2084 a39c: 5a                     str     ra                  ; and place into R[6]
 2085 a39d: 1a                     inc     ra
 2086 a39e: 8b                     glo     rb
 2087 a39f: 5a                     str     ra
 2088 a3a0: c0 a0 21               lbr     good                ; then return
 2089 a3a3:                        
 2090 a3a3: d4          cif:       sep     scall               ; get top of stack 
 2091 a3a4: 9c 32                  dw      pop
 2092 a3a6: c3 a0 10               lbdf    error               ; jump if error
 2093 a3a9: 8b                     glo     rb                  ; check for zero
 2094 a3aa: ca a3 e9               lbnz    ifno                ; jump if not zero
 2095 a3ad: 9b                     ghi     rb                  ; check hi byte too
 2096 a3ae: ca a3 e9               lbnz    ifno                ; jump if not zero
 2097 a3b1: 92                     ghi     r2                  ; transfer machine stack to RA
 2098 a3b2: ba                     phi     ra
 2099 a3b3: 82                     glo     r2
 2100 a3b4: aa                     plo     ra
 2101 a3b5: 1a                     inc     ra                  ; now pointing at R[6]
 2102 a3b6: 4a                     lda     ra                  ; get R[6]
 2103 a3b7: bb                     phi     rb
 2104 a3b8: 0a                     ldn     ra
 2105 a3b9: ab                     plo     rb
 2106 a3ba: f8 00                  ldi     0                   ; set IF count
 2107 a3bc: a7                     plo     r7                  ; put into counter
 2108 a3bd: 0b          iflp1:     ldn     rb                  ; get next byte
 2109 a3be: ff 83                  smi     83h                 ; check for IF
 2110 a3c0: ca a3 c8               lbnz    ifnotif             ; jump if not
 2111 a3c3: 17                     inc     r7                  ; increment if count
 2112 a3c4: 1b          ifcnt:     inc     rb                  ; point to next byte
 2113 a3c5: c0 a3 bd               lbr     iflp1               ; keep looking
 2114 a3c8: 0b          ifnotif:   ldn     rb                  ; retrieve byte
 2115 a3c9: ff 84                  smi     84h                 ; check for ELSE
 2116 a3cb: ca a3 db               lbnz    ifnotelse           ; jump if not
 2117 a3ce: 87                     glo     r7                  ; get IF count
 2118 a3cf: ca a3 c4               lbnz    ifcnt               ; jump if it is not zero
 2119 a3d2: 1b                     inc     rb                  ; move past the else
 2120 a3d3: 8b          ifsave:    glo     rb                  ; store back into instruction pointer
 2121 a3d4: 5a                     str     ra
 2122 a3d5: 2a                     dec     ra
 2123 a3d6: 9b                     ghi     rb
 2124 a3d7: 5a                     str     ra
 2125 a3d8: c0 a0 21               lbr     good                ; and return
 2126 a3db: 0b          ifnotelse: ldn     rb                  ; retrieve byte
 2127 a3dc: ff 85                  smi     85h                 ; check for THEN
 2128 a3de: ca a3 c4               lbnz    ifcnt               ; jump if not
 2129 a3e1: 87                     glo     r7                  ; get if count
 2130 a3e2: 27                     dec     r7                  ; decrement if count
 2131 a3e3: ca a3 c4               lbnz    ifcnt               ; jump if not zero
 2132 a3e6: c0 a3 d3               lbr     ifsave              ; otherwise found
 2133 a3e9: c0 a0 21    ifno:      lbr     good                ; no action needed, just return
 2134 a3ec:             
 2135 a3ec: 92          celse:     ghi     r2                  ; transfer machine stack to ra
 2136 a3ed: ba                     phi     ra
 2137 a3ee: 82                     glo     r2
 2138 a3ef: aa                     plo     ra
 2139 a3f0: 1a                     inc     ra                  ; now pointing at R[6]
 2140 a3f1: 4a                     lda     ra                  ; get current R[6]
 2141 a3f2: bb                     phi     rb                  ; and place into r6
 2142 a3f3: 0a                     ldn     ra
 2143 a3f4: ab                     plo     rb
 2144 a3f5: f8 00                  ldi     0                   ; count of IFs
 2145 a3f7: a7                     plo     r7                  ; put into R7
 2146 a3f8: 0b          elselp1:   ldn     rb                  ; get next byte from stream
 2147 a3f9: ff 83                  smi     83h                 ; check for IF
 2148 a3fb: ca a4 03               lbnz    elsenif             ; jump if not if
 2149 a3fe: 17                     inc     r7                  ; increment IF count
 2150 a3ff: 1b          elsecnt:   inc     rb                  ; point to next byte
 2151 a400: c0 a3 f8               lbr     elselp1             ; keep looking
 2152 a403: 0b          elsenif:   ldn     rb                  ; retrieve byte
 2153 a404: ff 85                  smi     85h                 ; is it THEN
 2154 a406: ca a3 ff               lbnz    elsecnt             ; jump if not
 2155 a409: 87                     glo     r7                  ; get IF count
 2156 a40a: 27                     dec     r7                  ; minus 1 IF
 2157 a40b: ca a3 ff               lbnz    elsecnt             ; jump if not 0
 2158 a40e: 8b                     glo     rb                  ; put into instruction pointer
 2159 a40f: 5a                     str     ra
 2160 a410: 2a                     dec     ra
 2161 a411: 9b                     ghi     rb
 2162 a412: 5a                     str     ra
 2163 a413: c0 a0 21               lbr     good                ; now pointing at a then
 2164 a416:             
 2165 a416: c0 a0 21    cthen:     lbr     good                ; then is nothing but a place holder
 2166 a419:             
 2167 a419: d4          cequal:    sep     scall               ; get value from stack
 2168 a41a: 9c 32                  dw      pop
 2169 a41c: c3 a0 10               lbdf    error               ; jump if stack was empty
 2170 a41f: 9b                     ghi     rb                  ; move number 
 2171 a420: b7                     phi     r7
 2172 a421: 8b                     glo     rb
 2173 a422: a7                     plo     r7
 2174 a423: d4                     sep     scall               ; get next number
 2175 a424: 9c 32                  dw      pop
 2176 a426: c3 a0 10               lbdf    error               ; jump if stack was empty
 2177 a429: e2                     sex     r2                  ; be sure X points to stack
 2178 a42a: 87                     glo     r7                  ; perform and
 2179 a42b: 52                     str     r2
 2180 a42c: 8b                     glo     rb
 2181 a42d: f3                     xor
 2182 a42e: ca a4 3e               lbnz    unequal2            ; jump if not equal
 2183 a431: 97                     ghi     r7
 2184 a432: 52                     str     r2
 2185 a433: 9b                     ghi     rb
 2186 a434: f3                     xor
 2187 a435: ca a4 3e               lbnz    unequal2            ; jump if not equal
 2188 a438: bb                     phi     rb                  ; set return result
 2189 a439: ab                     plo     rb
 2190 a43a: 1b                     inc     rb
 2191 a43b: c0 a0 1e               lbr goodpush
 2192 a43e: f8 00       unequal2:  ldi     0                   ; set return result
 2193 a440: bb                     phi     rb
 2194 a441: ab                     plo     rb
 2195 a442: c0 a0 1e               lbr     goodpush
 2196 a445:             
 2197 a445:             
 2198 a445: e2          cdepth:    sex     r2                  ; be sure x is pointing to stack
 2199 a446: f8 08                  ldi     low fstack          ; point to free memory pointer
 2200 a448: a9                     plo     r9                  ; place into data frame
 2201 a449: 49                     lda     r9                  ; get high byte of free memory pointer
 2202 a44a: 73                     stxd                        ; store on stack
 2203 a44b: 49                     lda     r9                  ; get low byte
 2204 a44c: 52                     str     r2                  ; store on stack
 2205 a44d: f8 04                  ldi     low tos             ; get pointer to stack
 2206 a44f: a9                     plo     r9                  ; set into data frame
 2207 a450: 19                     inc     r9                  ; point to lo byte
 2208 a451: 09                     ldn     r9                  ; get it
 2209 a452: f7                     sm                          ; perform subtract
 2210 a453: ab                     plo     rb                  ; put into result
 2211 a454: 29                     dec     r9                  ; high byte of stack pointer
 2212 a455: 60                     irx                         ; point to high byte os free mem
 2213 a456: 09                     ldn     r9                  ; get high byte of stack
 2214 a457: 77                     smb                         ; continue subtraction
 2215 a458: f6                     shr                         ; divide by 2
 2216 a459: bb                     phi     rb                  ; store answer
 2217 a45a: 8b                     glo     rb                  ; propagate the shift
 2218 a45b: 76                     shrc
 2219 a45c: ab                     plo     rb
 2220 a45d: c0 a0 1e    	   lbr goodpush
 2221 a460:             
 2222 a460:              
 2223 a460: d4          crot:      sep     scall               ; get C
 2224 a461: 9c 32                  dw      pop
 2225 a463: c3 a0 10               lbdf    error               ; jump if error
 2226 a466: 9b                     ghi     rb                  ; transfer to R7
 2227 a467: b7                     phi     r7
 2228 a468: 8b                     glo     rb
 2229 a469: a7                     plo     r7
 2230 a46a: d4                     sep     scall               ; get B
 2231 a46b: 9c 32                  dw      pop
 2232 a46d: c3 a0 10               lbdf    error               ; jump if error
 2233 a470: 9b                     ghi     rb                  ; transfer to R7
 2234 a471: b8                     phi     r8
 2235 a472: 8b                     glo     rb
 2236 a473: a8                     plo     r8
 2237 a474: d4                     sep     scall               ; get A
 2238 a475: 9c 32                  dw      pop
 2239 a477: c3 a0 10               lbdf    error               ; jump if error
 2240 a47a: 9b                     ghi     rb                  ; transfer to R7
 2241 a47b: bc                     phi     rc
 2242 a47c: 8b                     glo     rb
 2243 a47d: ac                     plo     rc
 2244 a47e: 98                     ghi     r8                  ; get B
 2245 a47f: bb                     phi     rb
 2246 a480: 88                     glo     r8
 2247 a481: ab                     plo     rb
 2248 a482: d4                     sep     scall               ; put onto stack
 2249 a483: 9c 61                  dw      push
 2250 a485: 97                     ghi     r7                  ; get C
 2251 a486: bb                     phi     rb
 2252 a487: 87                     glo     r7
 2253 a488: ab                     plo     rb
 2254 a489: d4                     sep     scall               ; put onto stack
 2255 a48a: 9c 61                  dw      push
 2256 a48c: 9c                     ghi     rc                  ; get A
 2257 a48d: bb                     phi     rb
 2258 a48e: 8c                     glo     rc
 2259 a48f: ab                     plo     rb
 2260 a490: c0 a0 1e    	   lbr goodpush
 2261 a493:             
 2262 a493:              
 2263 a493: d4          cmrot:     sep     scall               ; get C
 2264 a494: 9c 32                  dw      pop
 2265 a496: c3 a0 10               lbdf    error               ; jump if error
 2266 a499: 9b                     ghi     rb                  ; transfer to R7
 2267 a49a: b7                     phi     r7
 2268 a49b: 8b                     glo     rb
 2269 a49c: a7                     plo     r7
 2270 a49d: d4                     sep     scall               ; get B
 2271 a49e: 9c 32                  dw      pop
 2272 a4a0: c3 a0 10               lbdf    error               ; jump if error
 2273 a4a3: 9b                     ghi     rb                  ; transfer to R7
 2274 a4a4: b8                     phi     r8
 2275 a4a5: 8b                     glo     rb
 2276 a4a6: a8                     plo     r8
 2277 a4a7: d4                     sep     scall               ; get A
 2278 a4a8: 9c 32                  dw      pop
 2279 a4aa: c3 a0 10               lbdf    error               ; jump if error
 2280 a4ad: 9b                     ghi     rb                  ; transfer to R7
 2281 a4ae: bc                     phi     rc
 2282 a4af: 8b                     glo     rb
 2283 a4b0: ac                     plo     rc
 2284 a4b1: 97                     ghi     r7                  ; get C
 2285 a4b2: bb                     phi     rb
 2286 a4b3: 87                     glo     r7
 2287 a4b4: ab                     plo     rb
 2288 a4b5: d4                     sep     scall               ; put onto stack
 2289 a4b6: 9c 61                  dw      push
 2290 a4b8: 9c                     ghi     rc                  ; get A
 2291 a4b9: bb                     phi     rb
 2292 a4ba: 8c                     glo     rc
 2293 a4bb: ab                     plo     rb
 2294 a4bc: d4                     sep     scall               ; put onto stack
 2295 a4bd: 9c 61                  dw      push
 2296 a4bf: 98                     ghi     r8                  ; get B
 2297 a4c0: bb                     phi     rb
 2298 a4c1: 88                     glo     r8
 2299 a4c2: ab                     plo     rb
 2300 a4c3: c0 a0 1e    	   lbr goodpush
 2301 a4c6:             
 2302 a4c6:              
 2303 a4c6: d4          cover:     sep     scall               ; get B
 2304 a4c7: 9c 32                  dw      pop
 2305 a4c9: c3 a0 10               lbdf    error               ; jump if error
 2306 a4cc: 9b                     ghi     rb                  ; transfer to R7
 2307 a4cd: b7                     phi     r7
 2308 a4ce: 8b                     glo     rb
 2309 a4cf: a7                     plo     r7
 2310 a4d0: d4                     sep     scall               ; get A
 2311 a4d1: 9c 32                  dw      pop
 2312 a4d3: c3 a0 10               lbdf    error               ; jump if error
 2313 a4d6: 9b                     ghi     rb                  ; transfer to R*
 2314 a4d7: b8                     phi     r8
 2315 a4d8: 8b                     glo     rb
 2316 a4d9: a8                     plo     r8
 2317 a4da: d4                     sep     scall               ; put onto stack
 2318 a4db: 9c 61                  dw      push
 2319 a4dd: 97                     ghi     r7                  ; get B
 2320 a4de: bb                     phi     rb
 2321 a4df: 87                     glo     r7
 2322 a4e0: ab                     plo     rb
 2323 a4e1: d4                     sep     scall               ; put onto stack
 2324 a4e2: 9c 61                  dw      push
 2325 a4e4: 98                     ghi     r8                  ; get A
 2326 a4e5: bb                     phi     rb
 2327 a4e6: 88                     glo     r8
 2328 a4e7: ab                     plo     rb
 2329 a4e8: c0 a0 1e    	  lbr goodpush
 2330 a4eb:             
 2331 a4eb:                        
 2332 a4eb: d4          cat:       sep     scall               ; get address from stack
 2333 a4ec: 9c 32                  dw      pop
 2334 a4ee: c3 a0 10               lbdf    error               ; jump on error
 2335 a4f1: 9b                     ghi     rb                  ; transfer address
 2336 a4f2: b7                     phi     r7
 2337 a4f3: 8b                     glo     rb
 2338 a4f4: a7                     plo     r7
 2339 a4f5: 47                     lda     r7                  ; get word at address
 2340 a4f6: bb                     phi     rb
 2341 a4f7: 07                     ldn     r7
 2342 a4f8: ab                     plo     rb
 2343 a4f9: c0 a0 1e    	   lbr goodpush
 2344 a4fc:             
 2345 a4fc:                        
 2346 a4fc: d4          cexcl:     sep     scall               ; get address from stack
 2347 a4fd: 9c 32                  dw      pop
 2348 a4ff: c3 a0 10               lbdf    error               ; jump on error
 2349 a502: 9b                     ghi     rb                  ; transfer address
 2350 a503: b7                     phi     r7
 2351 a504: 8b                     glo     rb
 2352 a505: a7                     plo     r7
 2353 a506: d4                     sep     scall               ; date data word from stack
 2354 a507: 9c 32                  dw      pop
 2355 a509: c3 a0 10               lbdf    error               ; jump on error
 2356 a50c: 9b                     ghi     rb                  ; write word to memory
 2357 a50d: 57                     str     r7
 2358 a50e: 17                     inc     r7
 2359 a50f: 8b                     glo     rb
 2360 a510: 57                     str     r7
 2361 a511: c0 a0 21               lbr     good                ; and return
 2362 a514:                        
 2363 a514: d4          ccat:      sep     scall               ; get address from stack
 2364 a515: 9c 32                  dw      pop
 2365 a517: c3 a0 10               lbdf    error               ; jump on error
 2366 a51a: 9b                     ghi     rb                  ; transfer address
 2367 a51b: b7                     phi     r7
 2368 a51c: 8b                     glo     rb
 2369 a51d: a7                     plo     r7
 2370 a51e: 47                     lda     r7                  ; get word at address
 2371 a51f: ab                     plo     rb
 2372 a520: f8 00                  ldi     0                   ; high byte is zero
 2373 a522: bb                     phi     rb
 2374 a523: c0 a0 1e    	   lbr goodpush
 2375 a526:             
 2376 a526:                        
 2377 a526: d4          ccexcl:    sep     scall               ; get address from stack
 2378 a527: 9c 32                  dw      pop
 2379 a529: c3 a0 10               lbdf    error               ; jump on error
 2380 a52c: 9b                     ghi     rb                  ; transfer address
 2381 a52d: b7                     phi     r7
 2382 a52e: 8b                     glo     rb
 2383 a52f: a7                     plo     r7
 2384 a530: d4                     sep     scall               ; date data word from stack
 2385 a531: 9c 32                  dw      pop
 2386 a533: c3 a0 10               lbdf    error               ; jump on error
 2387 a536: 8b                     glo     rb                  ; write byte to memory
 2388 a537: 57                     str     r7
 2389 a538: c0 a0 21               lbr     good                ; and return
 2390 a53b:             
 2391 a53b: 92          cvariable: ghi     r2                  ; transfer machine stack
 2392 a53c: ba                     phi     ra
 2393 a53d: 82                     glo     r2
 2394 a53e: aa                     plo     ra
 2395 a53f: 1a                     inc     ra                  ; point to R[6]
 2396 a540: 4a                     lda     ra                  ; and retrieve it
 2397 a541: bb                     phi     rb
 2398 a542: 0a                     ldn     ra
 2399 a543: ab                     plo     rb
 2400 a544: 0b                     ldn     rb                  ; get next byte
 2401 a545: ff fe                  smi     T_ASCII             ; it must be an ascii mark
 2402 a547: ca a0 10               lbnz    error               ; jump if not
 2403 a54a: 1b                     inc     rb                  ; move into string
 2404 a54b: 4b          varlp1:    lda     rb                  ; get byte
 2405 a54c: ca a5 4b               lbnz    varlp1              ; jump if terminator not found
 2406 a54f: 1b                     inc     rb                  ; allow space for var value
 2407 a550: 1b                     inc     rb                  ; new value of freemem
 2408 a551: f8 06                  ldi     low freemem         ; get current free memory pointer
 2409 a553: a9                     plo     r9                  ; put into data segment
 2410 a554: 49                     lda     r9                  ; get current pointer
 2411 a555: b7                     phi     r7                  ; place here
 2412 a556: 09                     ldn     r9                  ; get low byte
 2413 a557: a7                     plo     r7
 2414 a558: 9b                     ghi     rb                  ; get memory pointer
 2415 a559: 57                     str     r7                  ; and store into link list
 2416 a55a: 17                     inc     r7
 2417 a55b: 8b                     glo     rb
 2418 a55c: 57                     str     r7
 2419 a55d: 8b                     glo     rb                  ; store new freemem value
 2420 a55e: 59                     str     r9
 2421 a55f: 29                     dec     r9
 2422 a560: 9b                     ghi     rb
 2423 a561: 59                     str     r9
 2424 a562: f8 00                  ldi     0                   ; need zero at end of list
 2425 a564: 5b                     str     rb                  ; store it
 2426 a565: 1b                     inc     rb
 2427 a566: 5b                     str     rb
 2428 a567: 8b                     glo     rb                  ; write back to instruction pointer
 2429 a568: 5a                     str     ra
 2430 a569: 2a                     dec     ra
 2431 a56a: 9b                     ghi     rb
 2432 a56b: 5a                     str     ra
 2433 a56c: c0 a0 21               lbr     good                ; return
 2434 a56f:             
 2435 a56f: 92          ccolon:    ghi     r2                  ; transfer machine stack
 2436 a570: ba                     phi     ra
 2437 a571: 82                     glo     r2
 2438 a572: aa                     plo     ra
 2439 a573: 1a                     inc     ra                  ; point to R[6]
 2440 a574: 4a                     lda     ra                  ; and retrieve it
 2441 a575: bb                     phi     rb
 2442 a576: 0a                     ldn     ra
 2443 a577: ab                     plo     rb
 2444 a578: 0b                     ldn     rb                  ; get next byte
 2445 a579: ff fe                  smi     T_ASCII             ; it must be an ascii mark
 2446 a57b: ca a0 10               lbnz    error               ; jump if not
 2447 a57e: 1b                     inc     rb                  ; move into string
 2448 a57f: 4b          colonlp1:  lda     rb                  ; get byte
 2449 a580: ff 88                  smi     88h                 ; look for the ;
 2450 a582: ca a5 7f               lbnz    colonlp1            ; jump if terminator not found
 2451 a585: f8 00                  ldi     0                   ; want a command terminator
 2452 a587: 5b                     str     rb                  ; write it
 2453 a588: 1b                     inc     rb                  ; new value for freemem
 2454 a589: f8 06                  ldi     low freemem         ; get current free memory pointer
 2455 a58b: a9                     plo     r9                  ; put into data segment
 2456 a58c: 49                     lda     r9                  ; get current pointer
 2457 a58d: b7                     phi     r7                  ; place here
 2458 a58e: 09                     ldn     r9                  ; get low byte
 2459 a58f: a7                     plo     r7
 2460 a590: 9b                     ghi     rb                  ; get memory pointer
 2461 a591: 57                     str     r7                  ; and store into link list
 2462 a592: 17                     inc     r7
 2463 a593: 8b                     glo     rb
 2464 a594: 57                     str     r7
 2465 a595: 8b                     glo     rb                  ; store new freemem value
 2466 a596: 59                     str     r9
 2467 a597: 29                     dec     r9
 2468 a598: 9b                     ghi     rb
 2469 a599: 59                     str     r9
 2470 a59a: f8 00                  ldi     0                   ; need zero at end of list
 2471 a59c: 5b                     str     rb                  ; store it
 2472 a59d: 1b                     inc     rb
 2473 a59e: 5b                     str     rb
 2474 a59f: 8b                     glo     rb                  ; write back to instruction pointer
 2475 a5a0: 5a                     str     ra
 2476 a5a1: 2a                     dec     ra
 2477 a5a2: 9b                     ghi     rb
 2478 a5a3: 5a                     str     ra
 2479 a5a4: c0 a0 21               lbr     good                ; return
 2480 a5a7:             
 2481 a5a7: c0 a0 21    csemi:     lbr     good
 2482 a5aa:             
 2483 a5aa:             
 2484 a5aa: 92          csee:      ghi     r2                  ; transfer machine stack
 2485 a5ab: ba                     phi     ra
 2486 a5ac: 82                     glo     r2
 2487 a5ad: aa                     plo     ra
 2488 a5ae: 1a                     inc     ra                  ; point to R[6]
 2489 a5af: 4a                     lda     ra                  ; and retrieve it
 2490 a5b0: b8                     phi     r8
 2491 a5b1: 0a                     ldn     ra
 2492 a5b2: a8                     plo     r8
 2493 a5b3: 08                     ldn     r8                  ; get next byte
 2494 a5b4: ff fe                  smi     T_ASCII             ; it must be an ascii mark
 2495 a5b6: ca a0 10               lbnz    error               ; jump if not
 2496 a5b9: 18                     inc     r8                  ; move into string
 2497 a5ba: d4                     sep     scall               ; find the name
 2498 a5bb: 9c a5                  dw      findname
 2499 a5bd: c3 a0 10               lbdf    error               ; jump if not found
 2500 a5c0: 88                     glo     r8                  ; put new address into inst pointer
 2501 a5c1: 5a                     str     ra 
 2502 a5c2: 2a                     dec     ra
 2503 a5c3: 98                     ghi     r8
 2504 a5c4: 5a                     str     ra
 2505 a5c5: d4          	   sep     scall
 2506 a5c6: a5 d5       	   dw      csee_sub
 2507 a5c8: c0 a0 21    	   lbr     good                ; otherwise good	
 2508 a5cb:             	
 2509 a5cb:             	;;  make see callable so we can use it from inside Forth words
 2510 a5cb:             	;;  r7= address of descriptor  (main pointer to word; points to next address)
 2511 a5cb:             	;;  rb = first byte in data
 2512 a5cb:             	;;  user callable csee_sub0 only requires r7. If r7 and rb are set call csee_sub
 2513 a5cb:             csee_sub0:
 2514 a5cb: 97          	ghi r7
 2515 a5cc: bb          	phi rb
 2516 a5cd: 87          	glo r7
 2517 a5ce: ab          	plo rb
 2518 a5cf: 1b          	inc rb
 2519 a5d0: 1b          	inc rb
 2520 a5d1: 0b          csub0:	ldn rb    		; set up rb to point correctly
 2521 a5d2: 1b          	inc rb
 2522 a5d3: 3a d1       	bnz csub0
 2523 a5d5:             csee_sub:
 2524 a5d5: 47          	lda r7          ; move past next address  (store next in in RF for later)
 2525 a5d6: bf          	phi rf
 2526 a5d7: 47          	lda r7
 2527 a5d8: af          	plo rf
 2528 a5d9: 07                     ldn     r7                  ; get type byte
 2529 a5da: ff 86                  smi     86h                 ; check for variable
 2530 a5dc: ca a6 aa               lbnz    cseefunc            ; jump if not
 2531 a5df: d4          	   sep scall
 2532 a5e0: ff 66       	   dw f_inmsg
 2533 a5e2: 56 41 52 49 
            41 42 4c 45 
            20 00       	   db 'VARIABLE ',0
 2534 a5ec: 17          	   inc r7		       ; skip variable mark
 2535 a5ed: 87 73 97 73 	   push r7
 2536 a5f1:             seevname:
 2537 a5f1: 17          	inc	   r7		       ; point to name
 2538 a5f2: 07          	ldn	   r7
 2539 a5f3: c2 a5 fc    	lbz seeveq
 2540 a5f6: d4          	sep scall
 2541 a5f7: 9c 2a       	dw disp
 2542 a5f9: c0 a5 f1    	lbr seevname
 2543 a5fc:             seeveq:
 2544 a5fc: d4          	sep scall
 2545 a5fd: 9c 17       	dw crlfout
 2546 a5ff:             	;;  need to see if we need an allot here 
 2547 a5ff:             	;; if [next]-2 == rb then we do not need it
 2548 a5ff: 2f          	dec rf
 2549 a600: 2f          	dec rf 			; next-2
 2550 a601: 8f          	glo rf
 2551 a602: 52          	str r2
 2552 a603: 8b          	glo rb   ; (next-2)-dataaddress
 2553 a604: f5          	sd
 2554 a605: af          	plo rf
 2555 a606: 9f          	ghi rf
 2556 a607: 52          	str r2
 2557 a608: 9b          	ghi rb
 2558 a609: 75          	sdb
 2559 a60a: bf          	phi rf   		; now RF is the offset
 2560 a60b: 52          	str r2
 2561 a60c: 8f          	glo rf
 2562 a60d: f1          	or
 2563 a60e: 32 89       	bz seevnoa            	; was equal, jump
 2564 a610:             seevallot:	
 2565 a610:             	;; ok we need to do the allot here
 2566 a610: 8b 73 9b 73 	push rb
 2567 a614: 9f          	ghi rf
 2568 a615: f6          	shr
 2569 a616: bb          	phi rb
 2570 a617: 8f          	glo rf
 2571 a618: 76          	shrc 
 2572 a619: ab          	plo rb
 2573 a61a: d4          	sep scall
 2574 a61b: ab 94       	dw typenumind    	; type count
 2575 a61d:             
 2576 a61d: d4          	sep scall
 2577 a61e: ff 66       	dw f_inmsg
 2578 a620: 41 4c 4c 4f 
            54 0a 0d 00 	db 'ALLOT',10,13,0
 2579 a628:             	;;   dump all words (rf has byte count which needs +2 for the original word)
 2580 a628: 1f          	inc rf
 2581 a629: 1f          	inc rf
 2582 a62a: 60 72 bb f0 
            ab          	pop rb 			; start address
 2583 a62f: f8 00       	ldi 0
 2584 a631: bc          	phi rc
 2585 a632: ac          	plo rc
 2586 a633:             seesto:	
 2587 a633: 8b 73 9b 73 	push rb  		; save for addr disp	
 2588 a637: 4b          	lda rb
 2589 a638: b7          	phi r7
 2590 a639: 4b          	lda rb
 2591 a63a: ab          	plo rb
 2592 a63b: 97          	ghi r7
 2593 a63c: bb          	phi rb
 2594 a63d: d4          	sep scall
 2595 a63e: ab 94       	dw typenumind   	; print data
 2596 a640:             	
 2597 a640: 60 72 bb f0 
            ab          	pop rb
 2598 a645: 60 72 b7 f0 
            a7          	pop r7
 2599 a64a: 87 73 97 73 	push r7
 2600 a64e: 8b 73 9b 73 	push rb
 2601 a652:             seevnamea:
 2602 a652: 17          	inc	   r7		       ; point to name
 2603 a653: 07          	ldn	   r7
 2604 a654: 32 5b       	bz seevdata
 2605 a656: d4          	sep scall
 2606 a657: 9c 2a       	dw disp
 2607 a659: 30 52       	br seevnamea
 2608 a65b:             seevdata:
 2609 a65b: f8 20       	ldi ' '
 2610 a65d: d4          	sep scall
 2611 a65e: 9c 2a       	dw disp
 2612 a660: 8c          	glo rc
 2613 a661: ab          	plo rb
 2614 a662: 9c          	ghi rc
 2615 a663: bb          	phi rb
 2616 a664: 1c          	inc rc
 2617 a665: 1c          	inc rc    		; increase count
 2618 a666: d4          	sep scall
 2619 a667: ab 94       	dw typenumind
 2620 a669: 60 72 bb f0 
            ab          	pop rb  		; print n  
 2621 a66e:             	
 2622 a66e:             
 2623 a66e: d4          	sep scall		;print !
 2624 a66f: ff 66       	dw f_inmsg
 2625 a671: 2b 20 21 0a 
            0d 00       	db '+ !',10,13,0
 2626 a677: 1b          	inc rb			; point to next word
 2627 a678: 1b          	inc rb
 2628 a679: 2f          	dec rf			; two less bytes
 2629 a67a: 2f          	dec rf
 2630 a67b:             	;;  stop when rf is zero (assumes rf was even)
 2631 a67b: 8f          	glo rf
 2632 a67c: ca a6 33    	lbnz seesto
 2633 a67f: 9f          	ghi rf
 2634 a680: ca a6 33    	lbnz seesto
 2635 a683: 60 72 b7 f0 
            a7          	pop r7
 2636 a688: d5          execdn:	sep sret   		; final CRLF already in place
 2637 a689:             	
 2638 a689:             seevnoa:	
 2639 a689: 4b                     lda     rb                  ; get value
 2640 a68a: b7                     phi     r7
 2641 a68b: 4b                     lda     rb
 2642 a68c: ab                     plo     rb
 2643 a68d: 97                     ghi     r7
 2644 a68e: bb                     phi     rb
 2645 a68f:                        
 2646 a68f:                        ;sep     scall               ; display the value
 2647 a68f:                        ;dw      intout
 2648 a68f:                        ;   [GDJ]
 2649 a68f: d4                     sep     scall               ; display the value
 2650 a690: ab 94                  dw      typenumind
 2651 a692: 60 72 b7 f0 
            a7          	pop r7
 2652 a697:             seevname1:
 2653 a697: 17          	inc r7
 2654 a698: 07          	ldn r7
 2655 a699: 32 a0       	bz seeveq1
 2656 a69b: d4          	sep scall
 2657 a69c: 9c 2a       	dw disp
 2658 a69e: 30 97       	br seevname1
 2659 a6a0:             seeveq1:
 2660 a6a0: d4          	sep scall
 2661 a6a1: ff 66       	dw f_inmsg
 2662 a6a3: 20 21 00    	db ' !',0
 2663 a6a6: d4          seeexit:   sep scall
 2664 a6a7: 9c 17       	   dw crlfout
 2665 a6a9: d5                     sep     sret
 2666 a6aa: f8 3a       cseefunc:  ldi     ':'                 ; start with a colon
 2667 a6ac: d4                     sep     scall               ; display character
 2668 a6ad: 9c 2a                  dw      disp
 2669 a6af: 17                     inc     r7                  ; move address to name
 2670 a6b0: f8 20       seefunclp: ldi     ' '                 ; need a space
 2671 a6b2: d4                     sep     scall               ; display character
 2672 a6b3: 9c 2a                  dw      disp
 2673 a6b5: 07                     ldn     r7                  ; get next token
 2674 a6b6: c2 a6 a6               lbz     seeexit             ; jump if done
 2675 a6b9: ff fe                  smi     T_ASCII             ; check for ascii
 2676 a6bb: ca a6 ce               lbnz    seenota             ; jump if not ascii
 2677 a6be: 17                     inc     r7                  ; move into string
 2678 a6bf: 07          seestrlp:  ldn     r7                  ; get next byte
 2679 a6c0: c2 a6 ca               lbz     seenext             ; jump if done with token
 2680 a6c3: d4                     sep     scall               ; display character
 2681 a6c4: 9c 2a                  dw      disp
 2682 a6c6: 17                     inc     r7                  ; point to next character
 2683 a6c7: c0 a6 bf               lbr     seestrlp            ; and continue til done
 2684 a6ca: 17          seenext:   inc     r7                  ; point to next token
 2685 a6cb: c0 a6 b0               lbr     seefunclp
 2686 a6ce: 07          seenota:   ldn     r7                  ; reget token
 2687 a6cf: ff ff                  smi     T_NUM               ; is it a number
 2688 a6d1: ca a6 e8               lbnz    seenotn             ; jump if not a number
 2689 a6d4: 17                     inc     r7                  ; move past token
 2690 a6d5: 47                     lda     r7                  ; get number into rb
 2691 a6d6: bb                     phi     rb
 2692 a6d7: 07                     ldn     r7
 2693 a6d8: ab                     plo     rb
 2694 a6d9: 87                     glo     r7                  ; save r7
 2695 a6da: 73                     stxd
 2696 a6db: 97                     ghi     r7
 2697 a6dc: 73                     stxd
 2698 a6dd:             
 2699 a6dd:                        ;sep     scall               ; display the number
 2700 a6dd:                        ;dw      intout
 2701 a6dd:                        ; [GDJ]
 2702 a6dd: d4                     sep     scall
 2703 a6de: ab 94                  dw      typenumind             ; display the number
 2704 a6e0: 60                     irx                         ; retrieve r7
 2705 a6e1: 72                     ldxa
 2706 a6e2: b7                     phi     r7
 2707 a6e3: f0                     ldx
 2708 a6e4: a7                     plo     r7
 2709 a6e5: c0 a6 ca               lbr     seenext             ; on to next token
 2710 a6e8: f8 ac       seenotn:   ldi     high cmdtable       ; point to command table
 2711 a6ea: bb                     phi     rb
 2712 a6eb: f8 ed                  ldi     low cmdtable
 2713 a6ed: ab                     plo     rb
 2714 a6ee: 07                     ldn     r7                  ; get token
 2715 a6ef: fa 7f                  ani     07fh                ; strip high bit
 2716 a6f1: a8                     plo     r8                  ; token counter
 2717 a6f2: 28          seenotnlp: dec     r8                  ; decrement count
 2718 a6f3: 88                     glo     r8                  ; get count
 2719 a6f4: c2 a7 00               lbz     seetoken            ; found the token
 2720 a6f7: 4b          seelp3:    lda     rb                  ; get byte from token
 2721 a6f8: fa 80                  ani     128                 ; was it last one?
 2722 a6fa: ca a6 f2               lbnz    seenotnlp           ; jump if it was
 2723 a6fd: c0 a6 f7               lbr     seelp3              ; keep looking
 2724 a700: 0b          seetoken:  ldn     rb                  ; get byte from token
 2725 a701: fa 80                  ani     128                 ; is it last
 2726 a703: ca a7 0e               lbnz    seetklast           ; jump if so
 2727 a706: 0b                     ldn     rb                  ; retrieve byte
 2728 a707: d4                     sep     scall               ; display it
 2729 a708: 9c 2a                  dw      disp
 2730 a70a: 1b                     inc     rb                  ; point to next character
 2731 a70b: c0 a7 00               lbr     seetoken            ; and loop til done
 2732 a70e: 0b          seetklast: ldn     rb                  ; retrieve byte
 2733 a70f: fa 7f                  ani     07fh                ; strip high bit
 2734 a711: d4                     sep     scall               ; display it
 2735 a712: 9c 2a                  dw      disp
 2736 a714: c0 a6 ca               lbr     seenext             ; jump for next token
 2737 a717:             
 2738 a717: 92          cdotqt:    ghi     r2                  ; transfer machine stack
 2739 a718: ba                     phi     ra
 2740 a719: 82                     glo     r2
 2741 a71a: aa                     plo     ra
 2742 a71b: 1a                     inc     ra                  ; point to R[6]
 2743 a71c: 4a                     lda     ra                  ; and retrieve it
 2744 a71d: b8                     phi     r8
 2745 a71e: 0a                     ldn     ra
 2746 a71f: a8                     plo     r8
 2747 a720: 08                     ldn     r8                  ; get next byte
 2748 a721: ff fe                  smi     T_ASCII             ; it must be an ascii mark
 2749 a723: ca a0 10               lbnz    error               ; jump if not
 2750 a726: 18                     inc     r8                  ; move past ascii mark
 2751 a727: 48          cdotqtlp:  lda     r8                  ; get next byte
 2752 a728: c2 a7 38               lbz     cdotqtdn            ; jump if terinator
 2753 a72b: ff 22                  smi     34                  ; check for quote
 2754 a72d: c2 a7 27               lbz     cdotqtlp            ; do not display quotes
 2755 a730: 28                     dec     r8
 2756 a731: 48                     lda     r8
 2757 a732: d4                     sep     scall               ; display byte
 2758 a733: 9c 2a                  dw      disp
 2759 a735: c0 a7 27               lbr     cdotqtlp            ; loop back
 2760 a738: 88          cdotqtdn:  glo     r8                  ; put pointer back
 2761 a739: 5a                     str     ra
 2762 a73a: 2a                     dec     ra
 2763 a73b: 98                     ghi     r8
 2764 a73c: 5a                     str     ra
 2765 a73d: c0 a0 21               lbr     good                ; and return
 2766 a740:             
 2767 a740: d4          ckey:      sep     scall               ; go and get a key
 2768 a741: 9c 2e                  dw      getkey
 2769 a743: ab                     plo     rb                  ; put into rb
 2770 a744: f8 00                  ldi     0                   ; zero the high byte
 2771 a746: bb                     phi     rb
 2772 a747: c0 a0 1e    	   lbr     goodpush
 2773 a74a:             
 2774 a74a:             	;; [GDJ]				
 2775 a74a: f8 00 a7 f8 
            00 b7       ckeyq:     mov     r7, 0
 2776 a750: d4                     sep     scall               ; check for key pressed
 2777 a751: ac 5a                  dw      inkey
 2778 a753: 87                     glo     r7
 2779 a754: ab                     plo     rb                  ; put into rb
 2780 a755: f8 00                  ldi     0                   ; zero the high byte
 2781 a757: bb                     phi     rb
 2782 a758: c0 a0 1e    	   lbr	   goodpush
 2783 a75b:             
 2784 a75b: f8 03       callot:    ldi     high storage        ; get address of storage
 2785 a75d: b7                     phi     r7
 2786 a75e: f8 0d                  ldi     low storage
 2787 a760: a7                     plo     r7
 2788 a761: 47          callotlp1: lda     r7                  ; get next link
 2789 a762: b8                     phi     r8
 2790 a763: 07                     ldn     r7
 2791 a764: a8                     plo     r8
 2792 a765: 48                     lda     r8                  ; get value at that link
 2793 a766: bb                     phi     rb
 2794 a767: 08                     ldn     r8
 2795 a768: 28                     dec     r8                  ; keep r8 pointing at link
 2796 a769: ca a7 73               lbnz    callotno            ; jump if next link is not zero
 2797 a76c: 9b                     ghi     rb                  ; check high byte
 2798 a76d: ca a7 73               lbnz    callotno            ; jump if not zero
 2799 a770: c0 a7 7a               lbr     callotyes
 2800 a773: 98          callotno:  ghi     r8                  ; transfer link to r7
 2801 a774: b7                     phi     r7
 2802 a775: 88                     glo     r8
 2803 a776: a7                     plo     r7
 2804 a777: c0 a7 61               lbr     callotlp1           ; and keep looking
 2805 a77a: 17          callotyes: inc     r7                  ; point to type byte
 2806 a77b: 07                     ldn     r7                  ; get it
 2807 a77c: ff 86                  smi     FVARIABLE           ; it must be a variable
 2808 a77e: ca a0 10               lbnz    error               ; jump if not
 2809 a781: d4                     sep     scall               ; get word from stack
 2810 a782: 9c 32                  dw      pop
 2811 a784: c3 a0 10               lbdf    error               ; jump if error
 2812 a787: 8b                     glo     rb                  ; multiply by 2
 2813 a788: fe                     shl
 2814 a789: ab                     plo     rb
 2815 a78a: 9b                     ghi     rb
 2816 a78b: 7e                     shlc
 2817 a78c: bb                     phi     rb
 2818 a78d: e2                     sex     r2                  ; be sure X points to stack
 2819 a78e: 8b                     glo     rb                  ; add rb to r8
 2820 a78f: 52                     str     r2
 2821 a790: 88                     glo     r8
 2822 a791: f4                     add
 2823 a792: a8                     plo     r8
 2824 a793: 9b                     ghi     rb
 2825 a794: 52                     str     r2
 2826 a795: 98                     ghi     r8
 2827 a796: 74                     adc
 2828 a797: b8                     phi     r8
 2829 a798: 27                     dec     r7                  ; point back to link
 2830 a799: 88                     glo     r8                  ; and write new pointer
 2831 a79a: 57                     str     r7
 2832 a79b: 27                     dec     r7
 2833 a79c: 98                     ghi     r8
 2834 a79d: 57                     str     r7
 2835 a79e: f8 06                  ldi     low freemem         ; need to adjust free memory pointer
 2836 a7a0: a9                     plo     r9                  ; put into data frame
 2837 a7a1: 98                     ghi     r8                  ; and save new memory position
 2838 a7a2: 59                     str     r9
 2839 a7a3: 19                     inc     r9
 2840 a7a4: 88                     glo     r8
 2841 a7a5: 59                     str     r9
 2842 a7a6: f8 00                  ldi     0                   ; zero new position
 2843 a7a8: 58                     str     r8
 2844 a7a9: 18                     inc     r8
 2845 a7aa: 58                     str     r8
 2846 a7ab: c0 a0 21               lbr     good
 2847 a7ae:             
 2848 a7ae: d4          cmul:      sep     scall               ; get first value from stack
 2849 a7af: 9c 32                  dw      pop
 2850 a7b1: c3 a0 10               lbdf    error               ; jump on error
 2851 a7b4: 9b                     ghi     rb                  ; transfer to r7
 2852 a7b5: b7                     phi     r7
 2853 a7b6: 8b                     glo     rb
 2854 a7b7: a7                     plo     r7
 2855 a7b8: d4                     sep     scall               ; get second number
 2856 a7b9: 9c 32                  dw      pop
 2857 a7bb: c3 a0 10               lbdf    error               ; jump on error
 2858 a7be: d4                     sep     scall               ; call multiply routine
 2859 a7bf: 9c e8                  dw      mul16
 2860 a7c1: c0 a0 1e    	   lbr goodpush
 2861 a7c4:             
 2862 a7c4:             
 2863 a7c4: d4          cdiv:      sep     scall               ; get first value from stack
 2864 a7c5: 9c 32                  dw      pop
 2865 a7c7: c3 a0 10               lbdf    error               ; jump on error
 2866 a7ca: 9b                     ghi     rb                  ; transfer to r7
 2867 a7cb: b7                     phi     r7
 2868 a7cc: 8b                     glo     rb
 2869 a7cd: a7                     plo     r7
 2870 a7ce: d4                     sep     scall               ; get second number
 2871 a7cf: 9c 32                  dw      pop
 2872 a7d1: c3 a0 10               lbdf    error               ; jump on error
 2873 a7d4: e2                     sex     r2
 2874 a7d5: 99                     ghi     r9
 2875 a7d6: 73                     stxd
 2876 a7d7: d4                     sep     scall               ; call multiply routine
 2877 a7d8: 9d 47                  dw      div16
 2878 a7da: 60                     irx
 2879 a7db: f0                     ldx
 2880 a7dc: b9                     phi     r9
 2881 a7dd: 9c                     ghi     rc                  ; transfer answer
 2882 a7de: bb                     phi     rb
 2883 a7df: 8c                     glo     rc
 2884 a7e0: ab                     plo     rb
 2885 a7e1: c0 a0 1e    	   lbr goodpush
 2886 a7e4:             
 2887 a7e4: 92          cforget:   ghi     r2                  ; transfer machine stack
 2888 a7e5: ba                     phi     ra
 2889 a7e6: 82                     glo     r2
 2890 a7e7: aa                     plo     ra
 2891 a7e8: 1a                     inc     ra                  ; point to ra
 2892 a7e9: 4a                     lda     ra                  ; and retrieve it
 2893 a7ea: b8                     phi     r8
 2894 a7eb: 0a                     ldn     ra
 2895 a7ec: a8                     plo     r8
 2896 a7ed: 08                     ldn     r8                  ; get next byte
 2897 a7ee: ff fe                  smi     T_ASCII             ; it must be an ascii mark
 2898 a7f0: ca a0 10               lbnz    error               ; jump if not
 2899 a7f3: 18                     inc     r8                  ; move into string
 2900 a7f4: d4                     sep     scall               ; find the name
 2901 a7f5: 9c a5                  dw      findname
 2902 a7f7: c3 a0 10               lbdf    error               ; jump if not found
 2903 a7fa: 88                     glo     r8
 2904 a7fb: 5a                     str     ra
 2905 a7fc: 2a                     dec     ra
 2906 a7fd: 98                     ghi     r8
 2907 a7fe: 5a                     str     ra
 2908 a7ff: 47                     lda     r7                  ; get next entry
 2909 a800: bb                     phi     rb
 2910 a801: 07                     ldn     r7
 2911 a802: ab                     plo     rb
 2912 a803: 27                     dec     r7
 2913 a804: e2                     sex     r2                  ; be sure X is pointing to stack
 2914 a805: 87                     glo     r7                  ; find difference in pointers
 2915 a806: 52                     str     r2
 2916 a807: 8b                     glo     rb
 2917 a808: f7                     sm
 2918 a809: ac                     plo     rc
 2919 a80a: 97                     ghi     r7
 2920 a80b: 52                     str     r2
 2921 a80c: 9b                     ghi     rb
 2922 a80d: 77                     smb
 2923 a80e: bc                     phi     rc                  ; RC now has offset, RB is next descr.
 2924 a80f: 4b          forgetlp1: lda     rb                  ; get pointer
 2925 a810: ba                     phi     ra                  ; put into ra
 2926 a811: 52                     str     r2
 2927 a812: 0b                     ldn     rb
 2928 a813: aa                     plo     ra
 2929 a814: f1                     or                          ; see if it was zero
 2930 a815: c2 a8 2a               lbz     forgetd1            ; jump if it was
 2931 a818: 8c                     glo     rc                  ; subtract RC from RA
 2932 a819: 52                     str     r2
 2933 a81a: 8a                     glo     ra
 2934 a81b: f7                     sm
 2935 a81c: 5b                     str     rb                  ; store back into pointer
 2936 a81d: 2b                     dec     rb
 2937 a81e: 9c                     ghi     rc
 2938 a81f: 52                     str     r2
 2939 a820: 9a                     ghi     ra
 2940 a821: 77                     smb
 2941 a822: 5b                     str     rb
 2942 a823: 9a                     ghi     ra                  ; transfer value
 2943 a824: bb                     phi     rb
 2944 a825: 8a                     glo     ra
 2945 a826: ab                     plo     rb
 2946 a827: c0 a8 0f               lbr     forgetlp1           ; loop until done
 2947 a82a:             
 2948 a82a: 47          forgetd1:  lda     r7                  ; get next entry
 2949 a82b: bb                     phi     rb
 2950 a82c: 07                     ldn     r7
 2951 a82d: ab                     plo     rb
 2952 a82e: 27                     dec     r7
 2953 a82f:             
 2954 a82f: f8 06                  ldi     low freemem         ; get end of memory pointer
 2955 a831: a9                     plo     r9                  ; and place into data frame
 2956 a832: 49                     lda     r9                  ; get free memory position
 2957 a833: b8                     phi     r8
 2958 a834: 09                     ldn     r9
 2959 a835: a8                     plo     r8
 2960 a836: 18                     inc     r8                  ; account for zero bytes at end
 2961 a837: 18                     inc     r8
 2962 a838: 8b                     glo     rb                  ; subtract RB from R8
 2963 a839: 52                     str     r2
 2964 a83a: 88                     glo     r8
 2965 a83b: f7                     sm
 2966 a83c: a8                     plo     r8
 2967 a83d: 9b                     ghi     rb
 2968 a83e: 52                     str     r2
 2969 a83f: 98                     ghi     r8
 2970 a840: 77                     smb
 2971 a841: b8                     phi     r8                  ; r8 now has number of bytes to move
 2972 a842: 4b          forgetlp:  lda     rb                  ; get byte from higher memory
 2973 a843: 57                     str     r7                  ; write to lower memory
 2974 a844: 17                     inc     r7                  ; point to next position
 2975 a845: 28                     dec     r8                  ; decrement the count
 2976 a846: 88                     glo     r8                  ; check for zero
 2977 a847: ca a8 42               lbnz    forgetlp
 2978 a84a: 98                     ghi     r8
 2979 a84b: ca a8 42               lbnz    forgetlp
 2980 a84e: 27                     dec     r7                  ; move back to freemem position
 2981 a84f: 27                     dec     r7 
 2982 a850: 87                     glo     r7                  ; store back into freemem pointer
 2983 a851: 59                     str     r9
 2984 a852: 29                     dec     r9
 2985 a853: 97                     ghi     r7
 2986 a854: 59                     str     r9
 2987 a855: c0 a0 21               lbr     good                ; and return
 2988 a858:             
 2989 a858: d4          cerror:    sep     scall               ; get number fro stack
 2990 a859: 9c 32                  dw      pop
 2991 a85b: c3 a0 10               lbdf    error               ; jump on error
 2992 a85e: 8b                     glo     rb                  ; get returned value
 2993 a85f: c0 9f ad               lbr     execret             ; return to caller
 2994 a862:             
 2995 a862:             ; [GDJ]
 2996 a862:             ; following org prevents short branch out of page for bn1..bn4
 2997 a862:             ; if any preceding code is added - may need change depending on
 2998 a862:             ; amount of any further additions above
 2999 a862:             ;           org 2e00h 
 3000 a862:             
 3001 a862: f8 00       cef:       ldi     0                   ; start with zero
 3002 a864: 3c 68                  bn1     cef1                ; jump if ef1 not on
 3003 a866: f9 01                  ori     1                   ; signal ef1 is on
 3004 a868: 3d 6c       cef1:      bn2     cef2                ; jump if ef2 ot on
 3005 a86a: f9 02                  ori     2                   ; signal ef2 is on
 3006 a86c: 3e 70       cef2:      bn3     cef3                ; jump if ef3 not on
 3007 a86e: f9 04                  ori     4                   ; signal ef3 is on
 3008 a870: 3f 74       cef3:      bn4     cef4                ; jump if ef4 not on
 3009 a872: f9 08                  ori     8
 3010 a874: ab          cef4:      plo     rb                  ; prepare to put on stack
 3011 a875: f8 00                  ldi     0
 3012 a877: bb                     phi     rb
 3013 a878: c0 a0 1e    	   lbr goodpush
 3014 a87b:             	
 3015 a87b:             
 3016 a87b:             
 3017 a87b: d4          cout:      sep     scall               ; get value from stack
 3018 a87c: 9c 32                  dw      pop
 3019 a87e: c3 a0 10               lbdf    error               ; jump on error
 3020 a881: 8b                     glo     rb
 3021 a882: a8                     plo     r8                  ; hold onto it
 3022 a883: d4                     sep     scall               ; get port value
 3023 a884: 9c 32                  dw      pop
 3024 a886: c3 a0 10               lbdf    error               ; jump on error
 3025 a889: 88                     glo     r8                  ; get vlue
 3026 a88a: 73                     stxd                        ; store into memory for out
 3027 a88b: 60                     irx                         ; point to value
 3028 a88c: 8b                     glo     rb                  ; get port
 3029 a88d: ff 01                  smi     1                   ; try port 1
 3030 a88f: ca a8 97               lbnz    cout2               ; jump if not
 3031 a892: 61                     out     1                   ; prform out
 3032 a893: 22                     dec     r2                  ; move pointer back
 3033 a894: c0 a0 21               lbr     good                ; and return to caller
 3034 a897: ff 01       cout2:     smi     1                   ; try port 1
 3035 a899: ca a8 a1               lbnz    cout3               ; jump if not
 3036 a89c: 62                     out     2                   ; prform out
 3037 a89d: 22                     dec     r2                  ; move pointer back
 3038 a89e: c0 a0 21               lbr     good                ; and return to caller
 3039 a8a1: ff 01       cout3:     smi     1                   ; try port 1
 3040 a8a3: ca a8 ab               lbnz    cout4               ; jump if not
 3041 a8a6: 63                     out     3                   ; prform out
 3042 a8a7: 22                     dec     r2                  ; move pointer back
 3043 a8a8: c0 a0 21               lbr     good                ; and return to caller
 3044 a8ab: ff 01       cout4:     smi     1                   ; try port 1
 3045 a8ad: ca a8 b5               lbnz    cout5               ; jump if not
 3046 a8b0: 64                     out     4                   ; prform out
 3047 a8b1: 22                     dec     r2                  ; move pointer back
 3048 a8b2: c0 a0 21               lbr     good                ; and return to caller
 3049 a8b5: ff 01       cout5:     smi     1                   ; try port 1
 3050 a8b7: ca a8 bf               lbnz    cout6               ; jump if not
 3051 a8ba: 65                     out     5                   ; prform out
 3052 a8bb: 22                     dec     r2                  ; move pointer back
 3053 a8bc: c0 a0 21               lbr     good                ; and return to caller
 3054 a8bf: ff 01       cout6:     smi     1                   ; try port 1
 3055 a8c1: ca a8 c9               lbnz    cout7               ; jump if not
 3056 a8c4: 66                     out     6                   ; prform out
 3057 a8c5: 22                     dec     r2                  ; move pointer back
 3058 a8c6: c0 a0 21               lbr     good                ; and return to caller
 3059 a8c9: ff 01       cout7:     smi     1                   ; try port 1
 3060 a8cb: ca a8 d0               lbnz    cout8               ; jump if not
 3061 a8ce: 67                     out     7                   ; prform out
 3062 a8cf: 22                     dec     r2                  ; move pointer back
 3063 a8d0: c0 a0 21    cout8:     lbr     good                ; and return to caller
 3064 a8d3:             
 3065 a8d3: d4          cinp:      sep     scall               ; get port
 3066 a8d4: 9c 32                  dw      pop
 3067 a8d6: c3 a0 10               lbdf    error               ; jump on error
 3068 a8d9: 8b                     glo     rb                  ; get port
 3069 a8da: ff 01                  smi     1                   ; check port 1
 3070 a8dc: ca a8 e3               lbnz    cinp2               ; jump if not
 3071 a8df: 69                     inp     1                   ; read port
 3072 a8e0: c0 a9 16               lbr     cinpd               ; complete
 3073 a8e3: ff 01       cinp2:     smi     1                   ; check port 1
 3074 a8e5: ca a8 ec               lbnz    cinp3               ; jump if not
 3075 a8e8: 6a                     inp     2                   ; read port
 3076 a8e9: c0 a9 16               lbr     cinpd               ; complete
 3077 a8ec: ff 01       cinp3:     smi     1                   ; check port 1
 3078 a8ee: ca a8 f5               lbnz    cinp4               ; jump if not
 3079 a8f1: 6b                     inp     3                   ; read port
 3080 a8f2: c0 a9 16               lbr     cinpd               ; complete
 3081 a8f5: ff 01       cinp4:     smi     1                   ; check port 1
 3082 a8f7: ca a8 fe               lbnz    cinp5               ; jump if not
 3083 a8fa: 6c                     inp     4                   ; read port
 3084 a8fb: c0 a9 16               lbr     cinpd               ; complete
 3085 a8fe: ff 01       cinp5:     smi     1                   ; check port 1
 3086 a900: ca a9 07               lbnz    cinp6               ; jump if not
 3087 a903: 6d                     inp     5                   ; read port
 3088 a904: c0 a9 16               lbr     cinpd               ; complete
 3089 a907: ff 01       cinp6:     smi     1                   ; check port 1
 3090 a909: ca a9 10               lbnz    cinp7               ; jump if not
 3091 a90c: 6e                     inp     6                   ; read port
 3092 a90d: c0 a9 16               lbr     cinpd               ; complete
 3093 a910: ff 01       cinp7:     smi     1                   ; check port 1
 3094 a912: ca a0 10               lbnz    error               ; jump if not
 3095 a915: 6f                     inp     7                   ; read port
 3096 a916: ab          cinpd:     plo     rb                  ; prepare to put on stack
 3097 a917: f8 00                  ldi     0
 3098 a919: bb                     phi     rb
 3099 a91a: c0 a0 1e    	   lbr goodpush
 3100 a91d:             
 3101 a91d:             
 3102 a91d:             
 3103 a91d:             ; cstk:      mov     rb,fstack           ; get stack address
 3104 a91d:                        ; sep     scall               ; push onto stack
 3105 a91d:                        ; dw      push
 3106 a91d:                        ; lbr     good
 3107 a91d:             
 3108 a91d:             ; [GDJ]
 3109 a91d: f8 08 ab f8 
            03 bb       cspat:     mov     rb,fstack           ; get stack address pointer
 3110 a923: 8b                     glo     rb
 3111 a924: a8                     plo     r8
 3112 a925: 9b                     ghi     rb
 3113 a926: b8                     phi     r8
 3114 a927:             
 3115 a927:                        ; get stack address 
 3116 a927: 48                     lda     r8
 3117 a928: bb                     phi     rb
 3118 a929: 08                     ldn     r8
 3119 a92a: ab                     plo     rb
 3120 a92b:             
 3121 a92b:                        ; add 1 byte offset
 3122 a92b: f8 01 a7 f8 
            00 b7                  mov     r7, 1
 3123 a931: e2                     sex     r2                  ; be sure X points to stack
 3124 a932: 87                     glo     r7                  ; perform addition
 3125 a933: 52                     str     r2
 3126 a934: 8b                     glo     rb
 3127 a935: f4                     add
 3128 a936: ab                     plo     rb
 3129 a937: 97                     ghi     r7
 3130 a938: 52                     str     r2
 3131 a939: 9b                     ghi     rb
 3132 a93a: 74                     adc
 3133 a93b: bb                     phi     rb
 3134 a93c:             
 3135 a93c: c0 a0 1e    	   lbr goodpush
 3136 a93f:             
 3137 a93f:             
 3138 a93f:             ; -----------------------------------------------------------------
 3139 a93f:             ; additions April 2022  GDJ
 3140 a93f:             ; -----------------------------------------------------------------
 3141 a93f: d4          ccmove:    sep     scall               ; get top of stack
 3142 a940: 9c 32                  dw      pop
 3143 a942: c3 a0 10               lbdf    error               ; jump if error
 3144 a945: 8b ac 9b bc            mov     rc,rb               ; rc is count of bytes
 3145 a949: d4                     sep     scall               ; get top of stack
 3146 a94a: 9c 32                  dw      pop
 3147 a94c: c3 a0 10               lbdf    error               ; jump if error
 3148 a94f: 8b a8 9b b8            mov     r8,rb               ; r8 is destination address
 3149 a953: d4                     sep     scall               ; get top of stack
 3150 a954: 9c 32                  dw      pop
 3151 a956: c3 a0 10               lbdf    error               ; jump if error
 3152 a959: 8b a7 9b b7            mov     r7,rb               ; r7 is source address
 3153 a95d:             
 3154 a95d:                        ; transfer data
 3155 a95d:                        ; begin check for zero byte count else tragedy could result
 3156 a95d: 8c          cmovelp:   glo     rc
 3157 a95e: ca a9 68               lbnz    cmovestr
 3158 a961: 9c                     ghi     rc
 3159 a962: ca a9 68               lbnz    cmovestr
 3160 a965: c0 a9 6f               lbr     cmovertn
 3161 a968: 47          cmovestr:  lda     r7
 3162 a969: 58                     str     r8
 3163 a96a: 18                     inc     r8
 3164 a96b: 2c                     dec     rc
 3165 a96c: c0 a9 5d               lbr     cmovelp
 3166 a96f: c0 a0 21    cmovertn:  lbr     good                ; return to caller
 3167 a972:             
 3168 a972:             
 3169 a972: d4          csetq:     sep     scall               ; get top of stack
 3170 a973: 9c 32                  dw      pop
 3171 a975: c3 a0 10               lbdf    error               ; jump if error
 3172 a978: 8b                     glo     rb                  ; get low of return value
 3173 a979: c2 a9 80               lbz     setqno              ; jump if zero
 3174 a97c: 7b                     seq
 3175 a97d: c0 a0 21               lbr     good
 3176 a980: 7a          setqno:    req
 3177 a981: c0 a0 21               lbr     good                ; return to caller
 3178 a984:             
 3179 a984:             
 3180 a984: f8 17 ad f8 
            03 bd       cdecimal:  mov     rd, basen
 3181 a98a: f8 0a                  ldi     10
 3182 a98c: 5d                     str     rd
 3183 a98d: c0 a0 21               lbr     good
 3184 a990:             
 3185 a990: f8 17 ad f8 
            03 bd       chex:      mov     rd, basen
 3186 a996: f8 10                  ldi     16
 3187 a998: 5d                     str     rd
 3188 a999: c0 a0 21               lbr     good
 3189 a99c:             
 3190 a99c: d4          crat:      sep     scall               ; get value from return stack
 3191 a99d: 9c 77                  dw      rpop
 3192 a99f: d4                     sep     scall               ; put back on return stack
 3193 a9a0: 9c 8f                  dw      rpush 
 3194 a9a2: c0 a0 1e    	   lbr goodpush
 3195 a9a5:             
 3196 a9a5:             
 3197 a9a5: d4          crand:     sep     scall
 3198 a9a6: ac a5                  dw      randbyte
 3199 a9a8: 98                     ghi     r8
 3200 a9a9: ab                     plo     rb
 3201 a9aa: f8 00                  ldi     0
 3202 a9ac: bb                     phi     rb
 3203 a9ad: c0 a0 1e    	   lbr goodpush
 3204 a9b0:             
 3205 a9b0:             
 3206 a9b0:             ; VT100 ansi control
 3207 a9b0:             ; printf("%c[%d;%dH",ESC,y,x);
 3208 a9b0: d4          cgotoxy:   sep     scall               ; get top of stack
 3209 a9b1: 9c 32                  dw      pop
 3210 a9b3: c3 a0 10               lbdf    error               ; jump if error
 3211 a9b6: 8b ad 9b bd            mov     rd,rb               ; rd is Y coord (row)
 3212 a9ba: d4                     sep     scall               ; get top of stack
 3213 a9bb: 9c 32                  dw      pop
 3214 a9bd: c3 a0 10               lbdf    error               ; jump if error
 3215 a9c0: 8b a8 9b b8            mov     r8,rb               ; r8 is X coord (col)
 3216 a9c4:             
 3217 a9c4:                        ; send CSI sequence
 3218 a9c4: d4                     sep    scall
 3219 a9c5: ff 66                  dw     f_inmsg
 3220 a9c7: 1b 5b 00               db     27, '[', 0
 3221 a9ca:             
 3222 a9ca:                        ; Y
 3223 a9ca: f8 00 af f8 
            02 bf                  mov     rf, buffer
 3224 a9d0: d4                     sep     scall
 3225 a9d1: ff 60                  dw      f_uintout
 3226 a9d3: f8 00                  ldi     0                   ; write terminator
 3227 a9d5: 5f                     str     rf
 3228 a9d6: f8 00 af f8 
            02 bf                  mov     rf, buffer
 3229 a9dc: d4                     sep     scall
 3230 a9dd: ff 09                  dw      f_msg
 3231 a9df:             
 3232 a9df:                        ; type separator
 3233 a9df: f8 3b                  ldi     ';'
 3234 a9e1: d4                     sep     scall               ; call type routine
 3235 a9e2: ff 4e                  dw      f_tty
 3236 a9e4:             
 3237 a9e4:                        ; X
 3238 a9e4: f8 00 af f8 
            02 bf                  mov     rf, buffer
 3239 a9ea: 88 ad 98 bd            mov     rd,r8
 3240 a9ee: d4                     sep     scall
 3241 a9ef: ff 60                  dw      f_uintout
 3242 a9f1: f8 00                  ldi     0                   ; write terminator
 3243 a9f3: 5f                     str     rf
 3244 a9f4: f8 00 af f8 
            02 bf                  mov     rf, buffer
 3245 a9fa: d4                     sep     scall
 3246 a9fb: ff 09                  dw      f_msg
 3247 a9fd:                        
 3248 a9fd:                        ; type ending char
 3249 a9fd: f8 48                  ldi     'H'
 3250 a9ff: d4                     sep     scall               ; call type routine
 3251 aa00: ff 4e                  dw      f_tty
 3252 aa02:             
 3253 aa02: c0 a0 21               lbr     good
 3254 aa05:             
 3255 aa05:             
 3256 aa05:             ; -----------------------------------------------------------------------------
 3257 aa05:             ; 'C' style operators for bit shifting, note no range check on number of shifts
 3258 aa05:             ; -----------------------------------------------------------------------------
 3259 aa05: d4          clshift:   sep     scall               ; get value from stack
 3260 aa06: 9c 32                  dw      pop
 3261 aa08: c3 a0 10               lbdf    error               ; jump if stack was empty
 3262 aa0b: 8b                     glo     rb                  ; move number 
 3263 aa0c: a7                     plo     r7                  ; number of shifts
 3264 aa0d:             
 3265 aa0d: d4                     sep     scall               ; get next number
 3266 aa0e: 9c 32                  dw      pop
 3267 aa10: c3 a0 10               lbdf    error               ; jump if stack was empty
 3268 aa13: 8b a8 9b b8            mov     r8,rb               ; value to shift left
 3269 aa17:             
 3270 aa17: 87                     glo     r7                  ; zero shift is identity 
 3271 aa18: ca aa 1e               lbnz    lshiftlp
 3272 aa1b: c0 aa 29               lbr     lshiftret           ; return with no shift
 3273 aa1e:             
 3274 aa1e: 88          lshiftlp:  glo     r8
 3275 aa1f: fe                     shl                         ; shift lo byte
 3276 aa20: a8                     plo     r8
 3277 aa21: 98                     ghi     r8
 3278 aa22: 7e                     shlc                        ; shift hi byte with carry
 3279 aa23: b8                     phi     r8
 3280 aa24: 27                     dec     r7
 3281 aa25: 87                     glo     r7
 3282 aa26: ca aa 1e               lbnz    lshiftlp
 3283 aa29:             
 3284 aa29: 88 ab 98 bb lshiftret: mov     rb,r8
 3285 aa2d: c0 a0 1e    	   lbr goodpush
 3286 aa30:             
 3287 aa30:             
 3288 aa30: d4          crshift:   sep     scall               ; get value from stack
 3289 aa31: 9c 32                  dw      pop
 3290 aa33: c3 a0 10               lbdf    error               ; jump if stack was empty
 3291 aa36: 8b                     glo     rb                  ; move number 
 3292 aa37: a7                     plo     r7                  ; number of shifts
 3293 aa38:             
 3294 aa38: d4                     sep     scall               ; get next number
 3295 aa39: 9c 32                  dw      pop
 3296 aa3b: c3 a0 10               lbdf    error               ; jump if stack was empty
 3297 aa3e: 8b a8 9b b8            mov     r8,rb
 3298 aa42:             
 3299 aa42: 87                     glo     r7                  ; zero shift is identity 
 3300 aa43: ca aa 49               lbnz    rshiftlp
 3301 aa46: c0 aa 54               lbr     rshiftret           ; return with no shift
 3302 aa49:             
 3303 aa49: 98          rshiftlp:  ghi     r8
 3304 aa4a: f6                     shr                         ; shift hi byte
 3305 aa4b: b8                     phi     r8
 3306 aa4c: 88                     glo     r8
 3307 aa4d: 76                     shrc                        ; shift lo byte with carry
 3308 aa4e: a8                     plo     r8
 3309 aa4f: 27                     dec     r7
 3310 aa50: 87                     glo     r7
 3311 aa51: ca aa 49               lbnz    rshiftlp
 3312 aa54:                
 3313 aa54: 88 ab 98 bb rshiftret: mov     rb,r8
 3314 aa58: c0 a0 1e    	   lbr goodpush
 3315 aa5b:             
 3316 aa5b:             
 3317 aa5b:             ; delay for approx 1 millisecond on 4MHz 1802
 3318 aa5b: d4          cdelay:    sep     scall               ; get value from stack
 3319 aa5c: 9c 32                  dw      pop
 3320 aa5e: c3 a0 10               lbdf    error               ; jump if stack was empty
 3321 aa61: 8b                     glo     rb                  ; move number 
 3322 aa62: a7                     plo     r7
 3323 aa63: 9b                     ghi     rb
 3324 aa64: b7                     phi     r7
 3325 aa65:             
 3326 aa65: f8 3c       delaylp1:  ldi     60
 3327 aa67: c4          delaylp2:  nop
 3328 aa68: ff 01                  smi     1
 3329 aa6a: ca aa 67               lbnz    delaylp2
 3330 aa6d:             
 3331 aa6d: 27                     dec     r7
 3332 aa6e: 87                     glo     r7
 3333 aa6f: ca aa 65               lbnz    delaylp1
 3334 aa72: 97                     ghi     r7
 3335 aa73: ca aa 65               lbnz    delaylp1
 3336 aa76: c0 a0 21               lbr     good
 3337 aa79:             
 3338 aa79:             	
 3339 aa79: d4          cexec:	   sep scall
 3340 aa7a: 9c 32       	   dw pop
 3341 aa7c: c3 a0 10      	   lbdf error
 3342 aa7f: f8 0a a8 f8 
            03 b8                  mov     r8, jump            ; point to jump address
 3343 aa85: f8 c0                  ldi     0c0h                ; lbr
 3344 aa87: 58                     str     r8                  ; store it
 3345 aa88: 18                     inc     r8
 3346 aa89: 9b          	   ghi     rb
 3347 aa8a: 58                     str     r8
 3348 aa8b: 18                     inc     r8
 3349 aa8c: 8b          	   glo     rb
 3350 aa8d: 58                     str     r8
 3351 aa8e: d4          	   sep     scall
 3352 aa8f: aa 94       	   dw      cexec0
 3353 aa91:             	;; if we return RB is pushed on stack
 3354 aa91: c0 a0 1e    	   lbr goodpush
 3355 aa94: c0 03 0a    cexec0:	   lbr jump   		; transfer to user code. If it returns, it goes back to my scaller
 3356 aa97:             
 3357 aa97:             
 3358 aa97:             ; -----------------------------------------------------------------------------
 3359 aa97:             ; Load contents of dictionary - any session defined words/values will be zapped
 3360 aa97:             ; -----------------------------------------------------------------------------
 3361 aa97:             
 3362 aa97: 8f 73 9f 73 cbload:    push    rf
 3363 aa9b: 8d 73 9d 73            push    rd
 3364 aa9f: 8c 73 9c 73            push    rc
 3365 aaa3:                        
 3366 aaa3: f8 81 af f8 
            ae bf                  mov     rf, extblock        ; source address
            #else
 3370 aaa9: f8 00 ad f8 
            03 bd                  mov     rd, 0300h           ; destination address
            #endif
 3372 aaaf: f8 00 ac f8 
            05 bc                  mov     rc, endextblock-extblock  ; block size
 3373 aab5:             
 3374 aab5: 4f          bloadlp:   lda     rf
 3375 aab6: 5d                     str     rd
 3376 aab7: 1d                     inc     rd
 3377 aab8: 2c                     dec     rc
 3378 aab9: 8c                     glo     rc
 3379 aaba: ca aa b5               lbnz    bloadlp
 3380 aabd: 9c                     ghi     rc
 3381 aabe: ca aa b5               lbnz    bloadlp
 3382 aac1:             
 3383 aac1: 60 72 bc f0 
            ac                     pop     rc
 3384 aac6: 60 72 bd f0 
            ad                     pop     rd
 3385 aacb: 60 72 bf f0 
            af                     pop     rf
 3386 aad0: c0 9b e7               lbr     mainlp              ; back to main loop
 3387 aad3:             
 3388 aad3:             
 3389 aad3:             ; -----------------------------------------------------------------
 3390 aad3:             
 3391 aad3:             
            #ifdef ANYROM
 3393 aad3: 8f 73 9f 73 csave:     push    rf                  ; save consumed registers
 3394 aad7: 8c 73 9c 73            push    rc
 3395 aadb: d4                     sep     scall               ; open XMODEM channel for writing
 3396 aadc: ed 00                  dw      xopenw
 3397 aade: f8 06 af f8 
            03 bf                  mov     rf,freemem          ; need pointer to freemem
 3398 aae4: 4f                     lda     rf                  ; get high address of free memory
            #else
 3402 aae5: ff 03                  smi     3                   ; subtract base address
            #endif
 3404 aae7: bc                     phi     rc                  ; store into count
 3405 aae8: 0f                     ldn     rf                  ; get low byte of free memory
 3406 aae9: ac                     plo     rc                  ; store into count
 3407 aaea: 1c                     inc     rc                  ; account for terminator
 3408 aaeb: 1c                     inc     rc
 3409 aaec: f8 00 af f8 
            02 bf                  mov     rf,buffer           ; temporary storage
 3410 aaf2: 9c                     ghi     rc                  ; get high byte of count
 3411 aaf3: 5f                     str     rf                  ; store it
 3412 aaf4: 1f                     inc     rf                  ; point to low byte
 3413 aaf5: 8c                     glo     rc                  ; get it
 3414 aaf6: 5f                     str     rf                  ; store into buffer
 3415 aaf7: 2f                     dec     rf                  ; move back to buffer
 3416 aaf8: f8 02 ac f8 
            00 bc                  mov     rc,2                ; 2 bytes of length
 3417 aafe: d4                     sep     scall               ; write to XMODEM channel
 3418 aaff: ed 09                  dw      xwrite
 3419 ab01: f8 00 af f8 
            02 bf                  mov     rf,buffer           ; point to where count is
 3420 ab07: 4f                     lda     rf                  ; retrieve high byte
 3421 ab08: bc                     phi     rc                  ; set into count for write
 3422 ab09: 0f                     ldn     rf                  ; get low byte
 3423 ab0a: ac                     plo     rc                  ; rc now has count of bytes to save
 3424 ab0b: f8 00 af f8 
            03 bf                  mov     rf,himem            ; point to forth data
 3425 ab11: d4                     sep     scall               ; write it all out
 3426 ab12: ed 09                  dw      xwrite
 3427 ab14: d4                     sep     scall               ; close XMODEM channel
 3428 ab15: ed 0c                  dw      xclosew
 3429 ab17: 60 72 bc f0 
            ac                     pop     rc                  ; recover consumed registers
 3430 ab1c: 60 72 bf f0 
            af                     pop     rf
 3431 ab21: c0 a0 21               lbr     good                ; all done
            #endif
 3433 ab24:             
            #endif
 3496 ab24:             
            #ifdef ANYROM
 3498 ab24: 8f 73 9f 73 cload:     push    rf                  ; save consumed registers
 3499 ab28: 8c 73 9c 73            push    rc
 3500 ab2c: 8e 73 9e 73            push    re                  ; [GDJ]
 3501 ab30: d4                     sep     scall               ; open XMODEM channel for reading
 3502 ab31: ed 03                  dw      xopenr
 3503 ab33: f8 00 af f8 
            02 bf                  mov     rf,buffer           ; point to buffer
 3504 ab39: f8 02 ac f8 
            00 bc                  mov     rc,2                ; need to read 2 bytes
 3505 ab3f: d4                     sep     scall               ; read them
 3506 ab40: ed 06                  dw      xread
 3507 ab42: f8 00 af f8 
            02 bf                  mov     rf,buffer           ; point to buffer
 3508 ab48: 4f                     lda     rf                  ; retrieve count
 3509 ab49: bc                     phi     rc                  ; into rc
 3510 ab4a: 0f                     ldn     rf
 3511 ab4b: ac                     plo     rc                  ; rc now has count of bytes to read
 3512 ab4c: f8 00 af f8 
            03 bf                  mov     rf,himem            ; point to forth data
 3513 ab52: d4                     sep     scall               ; now read program data
 3514 ab53: ed 06                  dw      xread
 3515 ab55:                        
 3516 ab55:                        ; temp removal [GDJ]
 3517 ab55:                        ;sep     scall               ; close XMODEM channel
 3518 ab55:                        ;dw      xcloser
 3519 ab55: 60 72 be f0 
            ae                     pop     re                  ; [GDJ]
 3520 ab5a: 60 72 bc f0 
            ac                     pop     rc                  ; recover consumed registers
 3521 ab5f: 60 72 bf f0 
            af                     pop     rf
 3522 ab64:                        ; irx                         ; [GDJ] remove exec portions from stack
 3523 ab64:                        ; irx
 3524 ab64:                        ; irx
 3525 ab64:                        ; irx
 3526 ab64:             
 3527 ab64: c0 9b e7               lbr     mainlp              ; back to main loop
            #endif
 3529 ab67:             
            #endif
 3594 ab67:             
 3595 ab67: c0 80 03    cbye:      lbr     exitaddr
 3596 ab6a:             
            #endif
 3617 ab6a:             
 3618 ab6a:             
 3619 ab6a:             ; **********************************************************
 3620 ab6a:             ; ***** Convert string to uppercase, honor quoted text *****
 3621 ab6a:             ; **********************************************************
 3622 ab6a: 0f          touc:      ldn     rf                  ; check for quote
 3623 ab6b: ff 22                  smi     022h
 3624 ab6d: c2 ab 87               lbz     touc_qt             ; jump if quote
 3625 ab70: 0f                     ldn     rf                  ; get byte from string
 3626 ab71: c2 ab 86               lbz     touc_dn             ; jump if done
 3627 ab74: ff 61                  smi     'a'                 ; check if below lc
 3628 ab76: cb ab 82               lbnf    touc_nxt            ; jump if so
 3629 ab79: ff 1b                  smi     27                  ; check upper rage
 3630 ab7b: c3 ab 82               lbdf    touc_nxt            ; jump if above lc
 3631 ab7e: 0f                     ldn     rf                  ; otherwise convert character to lc
 3632 ab7f: ff 20                  smi     32
 3633 ab81: 5f                     str     rf
 3634 ab82: 1f          touc_nxt:  inc     rf                  ; point to next character
 3635 ab83: c0 ab 6a               lbr     touc                ; loop to check rest of string
 3636 ab86: d5          touc_dn:   sep     sret                ; return to caller
 3637 ab87: 1f          touc_qt:   inc     rf                  ; move past quote
 3638 ab88: 4f          touc_qlp:  lda     rf                  ; get next character
 3639 ab89: c2 ab 86               lbz     touc_dn             ; exit if terminator found
 3640 ab8c: ff 22                  smi     022h                ; check for quote charater
 3641 ab8e: c2 ab 6a               lbz     touc                ; back to main loop if quote
 3642 ab91: c0 ab 88               lbr     touc_qlp            ; otherwise keep looking
 3643 ab94:             
 3644 ab94:             
 3645 ab94:             ; [GDJ] type out number according to selected BASE and signed/unsigned flag
 3646 ab94:             typenumind:   ; get BASE  ; enter here to have 0x or 0# put on front
 3647 ab94: 8f 73 9f 73         push    rf                  ; save rf for tokenizer
 3648 ab98: f8 30       	ldi '0'
 3649 ab9a: d4          	sep scall
 3650 ab9b: 9c 2a       	dw disp
 3651 ab9d: f8 17 ad f8 
            03 bd               mov     rd, basen
 3652 aba3: 0d                  ldn     rd
 3653 aba4: ff 0a               smi     10
 3654 aba6: 32 ab       	bz typenuminddec
 3655 aba8: f8 78       	ldi 'x'
 3656 abaa: c8          	lskp
 3657 abab:             typenuminddec:
 3658 abab: f8 23       	ldi '#'
 3659 abad: d4          	sep scall
 3660 abae: 9c 2a       	dw disp
 3661 abb0: f8 00       	ldi 0
 3662 abb2: ae          	plo re  		; always unsigned here
 3663 abb3: 30 b9       	br typenumx
 3664 abb5:             
 3665 abb5:             typenum:   ; get BASE  ; enter here for normal output
 3666 abb5: 8f 73 9f 73            push    rf                  ; save rf for tokenizer
 3667 abb9:             typenumx:	
 3668 abb9: f8 17 ad f8 
            03 bd                  mov     rd, basen
 3669 abbf: 0d                     ldn     rd
 3670 abc0: ff 0a                  smi     10
 3671 abc2: ca ab df               lbnz    typehex
 3672 abc5: 8b ad 9b bd            mov     rd,rb
 3673 abc9: f8 00 af f8 
            02 bf                  mov     rf, buffer
 3674 abcf: 8e                     glo     re
 3675 abd0: c2 ab d9               lbz     typenumU
 3676 abd3: d4                     sep     scall
 3677 abd4: ff 63                  dw      f_intout
 3678 abd6: c0 ab f6               lbr     typeout
 3679 abd9: d4          typenumU:  sep     scall
 3680 abda: ff 60                  dw      f_uintout
 3681 abdc: c0 ab f6               lbr     typeout
 3682 abdf:             
 3683 abdf:             typehex:
 3684 abdf: 8b ad 9b bd 	   mov     rd,rb
 3685 abe3: f8 00 af f8 
            02 bf                  mov     rf, buffer
 3686 abe9: 9d                     ghi     rd
 3687 abea: c2 ab f3               lbz     hexbyte
 3688 abed: d4                     sep     scall
 3689 abee: ff 4b                  dw      f_hexout4
 3690 abf0: c0 ab f6               lbr     typeout
 3691 abf3: d4          hexbyte:   sep     scall
 3692 abf4: ff 48                  dw      f_hexout2
 3693 abf6:             
 3694 abf6: f8 20       typeout:   ldi     ' '                 ; add space
 3695 abf8: 5f                     str     rf
 3696 abf9: 1f                     inc     rf
 3697 abfa: f8 00                  ldi     0                   ; and terminator
 3698 abfc: 5f                     str     rf
 3699 abfd: f8 00 af f8 
            02 bf                  mov     rf, buffer
 3700 ac03: d4                     sep     scall
 3701 ac04: ff 09                  dw      f_msg
 3702 ac06: 60 72 bf f0 
            af                     pop     rf
 3703 ac0b: d5                     sep     sret                ; return to caller
 3704 ac0c:             
 3705 ac0c:             
 3706 ac0c:             
 3707 ac0c:             ; *************************************
 3708 ac0c:             ; *** Check if character is numeric ***
 3709 ac0c:             ; *** D - char to check             ***
 3710 ac0c:             ; *** Returns DF=1 if numeric       ***
 3711 ac0c:             ; ***         DF=0 if not           ***
 3712 ac0c:             ; *************************************
 3713 ac0c: ae          isnum:     plo     re                  ; save a copy
 3714 ac0d: ff 30                  smi     '0'                 ; check for below zero
 3715 ac0f: cb ac 1a               lbnf    fails               ; jump if below
 3716 ac12: ff 0a                  smi     10                  ; see if above
 3717 ac14: c3 ac 1a               lbdf    fails               ; fails if so
 3718 ac17: ff 00       passes:    smi     0                   ; signal success
 3719 ac19: c8                     lskp
 3720 ac1a: fc 00       fails:     adi     0                   ; signal failure
 3721 ac1c: 8e                     glo     re                  ; recover character
 3722 ac1d: d5                     sep     sret                ; and return
 3723 ac1e:             
 3724 ac1e: ff 00       err:       smi     0                   ; signal an error
 3725 ac20: d5                     sep     sret                ; and return
 3726 ac21:                        
 3727 ac21:                        
 3728 ac21:             ; **********************************
 3729 ac21:             ; *** check D if hex             ***
 3730 ac21:             ; *** Returns DF=1 - hex         ***
 3731 ac21:             ; ***         DF=0 - non-hex     ***
 3732 ac21:             ; **********************************
 3733 ac21: d4          ishex:     sep     scall               ; see if it is numeric
 3734 ac22: ac 0c                  dw      isnum
 3735 ac24: ae                     plo     re                  ; keep a copy
 3736 ac25: c3 ac 17               lbdf    passes              ; jump if it is numeric
 3737 ac28: ff 41                  smi     'A'                 ; check for below uppercase a
 3738 ac2a: cb ac 1a               lbnf    fails               ; value is not hex
 3739 ac2d: ff 06                  smi     6                   ; check for less then 'G'
 3740 ac2f: cb ac 17               lbnf    passes              ; jump if so
 3741 ac32: 8e                     glo     re                  ; recover value
 3742 ac33: ff 61                  smi     'a'                 ; check for lowercase a
 3743 ac35: cb ac 1a               lbnf    fails               ; jump if not
 3744 ac38: ff 06                  smi     6                   ; check for less than 'g'
 3745 ac3a: cb ac 17               lbnf    passes              ; jump if so
 3746 ac3d: c0 ac 1a               lbr     fails
 3747 ac40:             
 3748 ac40:             
 3749 ac40:             
 3750 ac40:                        ; clear tos, himem & rstack blocks 
 3751 ac40: f8 00 a7 f8 
            03 b7       clrstacks: mov     r7, 300h            ; clear 768 bytes
 3752 ac46: f8 00 ac f8 
            7c bc                  mov     rc, 7c00h
 3753 ac4c:                        
 3754 ac4c: f8 00       clrmemlp:  ldi     0h
 3755 ac4e: 5c                     str     rc
 3756 ac4f: 1c                     inc     rc
 3757 ac50: 27                     dec     r7
 3758 ac51: 87                     glo     r7
 3759 ac52: ca ac 4c               lbnz    clrmemlp
 3760 ac55: 97                     ghi     r7
 3761 ac56: ca ac 4c               lbnz    clrmemlp
 3762 ac59: d5                     rtn
 3763 ac5a:             
 3764 ac5a:             
 3765 ac5a:             ;--------------------------------------------------------------
 3766 ac5a:             ;    Read byte from UART if char available  
 3767 ac5a:             ;    return in r7.0 - else return null
 3768 ac5a:             ;
 3769 ac5a:             ;    from original bios code of Bob Armstrong
 3770 ac5a:             ;    modified for non-blocking console input
 3771 ac5a:             ;--------------------------------------------------------------
 3772 ac5a: f8 15       inkey:  ldi     015h            ; need UART line status register
 3773 ac5c: 52                  str     r2              ; prepare for out
 3774 ac5d: 66                  out     UART_SELECT     ; write to register select port
 3775 ac5e: 22                  dec     r2              ; correct for inc on out
 3776 ac5f: 6f                  inp     UART_DATA       ; read line status register
 3777 ac60: fa 01               ani     1               ; mask for data ready bit
 3778 ac62: c2 ac 6d            lbz     nokey           ; return if no bytes to read
 3779 ac65: f8 10               ldi     010h            ; select data register
 3780 ac67: 52                  str     r2              ; prepare for out
 3781 ac68: 66                  out     UART_SELECT     ; write to register select port
 3782 ac69: 22                  dec     r2              ; back to free spot
 3783 ac6a: 6f                  inp     UART_DATA       ; read UART data register
 3784 ac6b: a7                  plo     r7
 3785 ac6c: d5                  rtn
 3786 ac6d:                     
 3787 ac6d: f8 00       nokey:  ldi     0h
 3788 ac6f: a7                  plo     r7
 3789 ac70: d5                  rtn
 3790 ac71:             
 3791 ac71:             
 3792 ac71: f8 0d a7 f8 
            03 b7       clist:	mov r7,storage
 3793 ac77:             clist0:
 3794 ac77: 87 73 97 73 	push r7
 3795 ac7b: 07          	ldn r7
 3796 ac7c: 3a 8a       	bnz clist1
 3797 ac7e: 17          	inc r7
 3798 ac7f: 07          	ldn r7
 3799 ac80: 3a 8a       	bnz clist1
 3800 ac82: 60 72 b7 f0 
            a7          	pop r7
 3801 ac87: c0 a0 21    	lbr good
 3802 ac8a:             clist1:	
 3803 ac8a: 60 72 b7 f0 
            a7          	pop r7
 3804 ac8f: 87 73 97 73 	push r7
 3805 ac93: d4          	sep scall
 3806 ac94: a5 cb       	dw csee_sub0
 3807 ac96: 60 72 b7 f0 
            a7          	pop r7
 3808 ac9b: 07          	ldn r7
 3809 ac9c: bb          	phi rb
 3810 ac9d: 17          	inc r7
 3811 ac9e: 07          	ldn r7
 3812 ac9f: a7          	plo r7
 3813 aca0: 9b          	ghi rb
 3814 aca1: b7          	phi r7
 3815 aca2: c0 ac 77    	lbr clist0
 3816 aca5:             	
 3817 aca5:             
 3818 aca5:             
 3819 aca5:             ;------------------------------------------------------------------
 3820 aca5:             ; Generate a psuedo-random byte
 3821 aca5:             ;
 3822 aca5:             ; IN:       N/A
 3823 aca5:             ; OUT:      D=psuedo-random number
 3824 aca5:             ; TRASHED:  RA
 3825 aca5:             ;
 3826 aca5:             ; This PRNG was extracted from AdventureLand
 3827 aca5:             ; Copyright (C) 2019 by Richard Goedeken, All Rights Reserved.
 3828 aca5:             ;
 3829 aca5:             ; modified GDJ 2021 --> return in r8.1, changed r7 to ra
 3830 aca5:             ;
 3831 aca5:             ; Update1: 23 Jan 2022 no period has been determined, thus 
 3832 aca5:             ; far a 320kB file has been checked - 12 minutes on the PicoElf2
 3833 aca5:             ; gave 20479 lines of 16 samples --> 327664 bytes
 3834 aca5:             ;
 3835 aca5:             ; Update2: 25 Feb 2022 translated this code into 'C' and 
 3836 aca5:             ; discovered a period of P = 2020966655
 3837 aca5:             ; after which the sequence repeats!
 3838 aca5:             ; other init params often gave the same period, however the
 3839 aca5:             ; initial arrays:
 3840 aca5:             ;        {1,3,5,7} gave a period of 543537919
 3841 aca5:             ;   {12,137,98,32} gave a period of 1080837375
 3842 aca5:             ;------------------------------------------------------------------
 3843 aca5: f8 f0 ad f8 
            02 bd       randbyte:   mov rd,rseed
 3844 acab: ed                      sex rd
 3845 acac:             
 3846 acac: 0d                      ldn rd      ; D = VarX
 3847 acad: fc 01                   adi 1
 3848 acaf: 5d                      str rd
 3849 acb0: 1d                      inc rd
 3850 acb1: 4d                      lda rd      ; D = VarA
 3851 acb2: 1d                      inc rd
 3852 acb3: f3                      xor         ; D = VarA XOR VarC
 3853 acb4: 2d                      dec rd
 3854 acb5: 2d                      dec rd
 3855 acb6: 2d                      dec rd
 3856 acb7: f3                      xor         ; D = VarA XOR VarC XOR VarX
 3857 acb8: 1d                      inc rd
 3858 acb9: 5d                      str rd      ; VarA = D
 3859 acba: 1d                      inc rd
 3860 acbb: f4                      add
 3861 acbc: 73                      stxd
 3862 acbd: f6                      shr
 3863 acbe: f3                      xor
 3864 acbf: 1d                      inc rd
 3865 acc0: 1d                      inc rd
 3866 acc1: f4                      add
 3867 acc2: 5d                      str rd
 3868 acc3: b8                      phi r8      ; added GDJ
 3869 acc4:             
 3870 acc4: e2                      sex r2      ;    ...
 3871 acc5: d5                      rtn
 3872 acc6:             
 3873 acc6:             
 3874 acc6:             
 3875 acc6:             
 3876 acc6: 52 63 2f 46 
            6f 72 74 68 
            20 30 2e 33 hello:     db      'Rc/Forth 0.3'
 3877 acd2: 0a 0d 00    crlf:      db       10,13,0
 3878 acd5: 6f 6b 20 00 prompt:    db      'ok ',0
 3879 acd9: 73 74 61 63 
            6b 20 65 6d 
            70 74 79 0a 
            0d 00       msempty:   db      'stack empty',10,13,0
 3880 ace7: 65 72 72 0a 
            0d 00       msgerr:    db      'err',10,13,0
 3881 aced: 57 48 49 4c 
            c5          cmdtable:  db      'WHIL',('E'+80h)
 3882 acf2: 52 45 50 45 
            41 d4                  db      'REPEA',('T'+80h)
 3883 acf8: 49 c6                  db      'I',('F'+80h)
 3884 acfa: 45 4c 53 c5            db      'ELS',('E'+80h)
 3885 acfe: 54 48 45 ce            db      'THE',('N'+80h)
 3886 ad02: 56 41 52 49 
            41 42 4c c5            db      'VARIABL',('E'+80h)
 3887 ad0a: ba                     db      (':'+80h)
 3888 ad0b: bb                     db      (';'+80h)
 3889 ad0c: 44 55 d0               db      'DU',('P'+80h)
 3890 ad0f: 44 52 4f d0            db      'DRO',('P'+80h)
 3891 ad13: 53 57 41 d0            db      'SWA',('P'+80h)
 3892 ad17: ab                     db      ('+'+80h)
 3893 ad18: ad                     db      ('-'+80h)
 3894 ad19: aa                     db      ('*'+80h)
 3895 ad1a: af                     db      ('/'+80h)
 3896 ad1b: ae                     db      ('.'+80h)
 3897 ad1c: 55 ae                  db      'U',('.'+80h)
 3898 ad1e: c9                     db      ('I'+80h)
 3899 ad1f: 41 4e c4               db      'AN',('D'+80h)
 3900 ad22: 4f d2                  db      'O',('R'+80h)
 3901 ad24: 58 4f d2               db      'XO',('R'+80h)
 3902 ad27: 43 d2                  db      'C',('R'+80h)
 3903 ad29: 4d 45 cd               db      'ME',('M'+80h)
 3904 ad2c: 44 cf                  db      'D',('O'+80h)
 3905 ad2e: 4c 4f 4f d0            db      'LOO',('P'+80h)
 3906 ad32: 2b 4c 4f 4f 
            d0                     db      '+LOO',('P'+80h)
 3907 ad37: bd                     db      ('='+80h)
 3908 ad38: 3c be                  db      '<',('>'+80h)
 3909 ad3a: bc                     db      ('<'+80h)           ; [GDJ]
 3910 ad3b: 55 bc                  db      'U',('<'+80h)       ; [GDJ]
 3911 ad3d: 42 45 47 49 
            ce                     db      'BEGI',('N'+80h)
 3912 ad42: 55 4e 54 49 
            cc                     db      'UNTI',('L'+80h)
 3913 ad47: 52 be                  db      'R',('>'+80h)
 3914 ad49: 3e d2                  db      '>',('R'+80h)
 3915 ad4b: 52 c0                  db      'R',('@'+80h)       ; [GDJ]
 3916 ad4d: 57 4f 52 44 
            d3                     db      'WORD',('S'+80h)
 3917 ad52: 45 4d 49 d4            db      'EMI',('T'+80h)
 3918 ad56: 45 4d 49 54 
            d0                     db      'EMIT',('P'+80h)    ; [GDJ]
 3919 ad5b: 44 45 50 54 
            c8                     db      'DEPT',('H'+80h)
 3920 ad60: 52 4f d4               db      'RO',('T'+80h)
 3921 ad63: 2d 52 4f d4            db      '-RO',('T'+80h)
 3922 ad67: 4f 56 45 d2            db      'OVE',('R'+80h)
 3923 ad6b: c0                     db      ('@'+80h)
 3924 ad6c: a1                     db      ('!'+80h)
 3925 ad6d: 43 c0                  db      'C',('@'+80h)
 3926 ad6f: 43 a1                  db      'C',('!'+80h)
 3927 ad71: 43 4d 4f 56 
            c5                     db      'CMOV',('E'+80h)    ; [GDJ]
 3928 ad76: 2e a2                  db      '.',(34+80h)
 3929 ad78: 4b 45 d9               db      'KE',('Y'+80h)
 3930 ad7b: 4b 45 59 bf            db      'KEY',('?'+80h)     ; [GDJ]
 3931 ad7f: 41 4c 4c 4f 
            d4                     db      'ALLO',('T'+80h)
 3932 ad84: 45 52 52 4f 
            d2                     db      'ERRO',('R'+80h)
 3933 ad89: 53 45 c5               db      'SE',('E'+80h)
 3934 ad8c: 46 4f 52 47 
            45 d4                  db      'FORGE',('T'+80h)
 3935 ad92: 4f 55 d4               db      'OU',('T'+80h)
 3936 ad95: 49 4e d0               db      'IN',('P'+80h)
 3937 ad98: 45 c6                  db      'E',('F'+80h)
 3938 ad9a: 53 45 54 d1            db      'SET',('Q'+80h)     ; [GDJ]
 3939 ad9e: 53 41 56 c5            db      'SAV',('E'+80h)
 3940 ada2: 4c 4f 41 c4            db      'LOA',('D'+80h)
 3941 ada6: 42 59 c5               db      'BY',('E'+80h)
 3942 ada9: 53 50 c0               db      'SP',('@'+80h)      ; [GDJ]
 3943 adac: 44 45 43 49 
            4d 41 cc               db      'DECIMA',('L'+80h)  ; [GDJ]
 3944 adb3: 48 45 d8               db      'HE',('X'+80h)      ; [GDJ]
 3945 adb6: 3c bc                  db      '<',('<'+80h)       ; [GDJ]
 3946 adb8: 3e be                  db      '>',('>'+80h)       ; [GDJ]
 3947 adba: 44 45 4c 41 
            d9                     db      'DELA',('Y'+80h)    ; [GDJ]
 3948 adbf: 42 4c 4f 41 
            c4                     db      'BLOA',('D'+80h)    ; [GDJ]
 3949 adc4: 47 4f 54 4f 
            58 d9                  db      'GOTOX',('Y'+80h)   ; [GDJ]
 3950 adca: 52 41 4e c4            db      'RAN',('D'+80h)     ; [GDJ]
 3951 adce: 45 58 45 c3 	   db	   'EXE',('C'+80h) 
 3952 add2: 4c 49 53 d4 	   db      'LIS',('T'+80h)
 3953 add6: 00                     db      0                   ; no more tokens
 3954 add7:             
 3955 add7: a3 47       cmdvecs:   dw      cwhile              ; 81h
 3956 add9: a3 93                  dw      crepeat             ; 82h
 3957 addb: a3 a3                  dw      cif                 ; 83h
 3958 addd: a3 ec                  dw      celse               ; 84h
 3959 addf: a4 16                  dw      cthen               ; 85h
 3960 ade1: a5 3b                  dw      cvariable           ; 86h
 3961 ade3: a5 6f                  dw      ccolon              ; 87h
 3962 ade5: a5 a7                  dw      csemi               ; 88h
 3963 ade7: a0 15                  dw      cdup                ; 89h
 3964 ade9: a0 26                  dw      cdrop               ; 8ah
 3965 adeb: a0 e5                  dw      cswap               ; 8bh
 3966 aded: a0 2f                  dw      cplus               ; 8ch
 3967 adef: a0 4d                  dw      cminus              ; 8dh
 3968 adf1: a7 ae                  dw      cmul                ; 8eh
 3969 adf3: a7 c4                  dw      cdiv                ; 8fh
 3970 adf5: a0 6b                  dw      cdot                ; 90h
 3971 adf7: a0 7a                  dw      cudot               ; 91h
 3972 adf9: a1 0a                  dw      ci                  ; 92h
 3973 adfb: a0 85                  dw      cand                ; 93h
 3974 adfd: a0 a3                  dw      cor                 ; 94h
 3975 adff: a0 c1                  dw      cxor                ; 95h
 3976 ae01: a0 df                  dw      ccr                 ; 96h
 3977 ae03: a1 13                  dw      cmem                ; 97h
 3978 ae05: a1 2a                  dw      cdo                 ; 98h
 3979 ae07: a1 5b                  dw      cloop               ; 99h
 3980 ae09: a1 9d                  dw      cploop              ; 9ah
 3981 ae0b: a4 19                  dw      cequal              ; 9bh
 3982 ae0d: a1 fe                  dw      cunequal            ; 9ch
 3983 ae0f: a2 2a                  dw      cless               ; 9dh [GDJ]
 3984 ae11: a2 66                  dw      culess              ; 9eh [GDJ]
 3985 ae13: a1 b6                  dw      cbegin              ; 9fh
 3986 ae15: a1 c5                  dw      cuntil              ; a0h
 3987 ae17: a1 ec                  dw      crgt                ; a1h
 3988 ae19: a1 f2                  dw      cgtr                ; a2h
 3989 ae1b: a9 9c                  dw      crat                ; a3h [GDJ]
 3990 ae1d: a2 99                  dw      cwords              ; a4h
 3991 ae1f: a3 1c                  dw      cemit               ; a5h
 3992 ae21: a3 29                  dw      cemitp              ; a6h [GDJ]
 3993 ae23: a4 45                  dw      cdepth              ; a7h
 3994 ae25: a4 60                  dw      crot                ; a8h
 3995 ae27: a4 93                  dw      cmrot               ; a9h
 3996 ae29: a4 c6                  dw      cover               ; aah
 3997 ae2b: a4 eb                  dw      cat                 ; abh
 3998 ae2d: a4 fc                  dw      cexcl               ; ach
 3999 ae2f: a5 14                  dw      ccat                ; adh
 4000 ae31: a5 26                  dw      ccexcl              ; aeh
 4001 ae33: a9 3f                  dw      ccmove              ; afh [GDJ]
 4002 ae35: a7 17                  dw      cdotqt              ; b0h
 4003 ae37: a7 40                  dw      ckey                ; b1h
 4004 ae39: a7 4a                  dw      ckeyq               ; b2h [GDJ]
 4005 ae3b: a7 5b                  dw      callot              ; b3h
 4006 ae3d: a8 58                  dw      cerror              ; b4h
 4007 ae3f: a5 aa                  dw      csee                ; b5h
 4008 ae41: a7 e4                  dw      cforget             ; b6h
 4009 ae43: a8 7b                  dw      cout                ; b7h
 4010 ae45: a8 d3                  dw      cinp                ; b8h
 4011 ae47: a8 62                  dw      cef                 ; b9h
 4012 ae49: a9 72                  dw      csetq               ; bah [GDJ]
 4013 ae4b: aa d3                  dw      csave               ; bbh
 4014 ae4d: ab 24                  dw      cload               ; bch
 4015 ae4f: ab 67                  dw      cbye                ; bdh
 4016 ae51: a9 1d                  dw      cspat               ; beh [GDJ]
 4017 ae53: a9 84                  dw      cdecimal            ; bfh [GDJ]
 4018 ae55: a9 90                  dw      chex                ; c0h [GDJ]
 4019 ae57: aa 05                  dw      clshift             ; c1h [GDJ]
 4020 ae59: aa 30                  dw      crshift             ; c2h [GDJ]
 4021 ae5b: aa 5b                  dw      cdelay              ; c3h [GDJ]
 4022 ae5d: aa 97                  dw      cbload              ; c4h [GDJ]
 4023 ae5f: a9 b0                  dw      cgotoxy             ; c5h [GDJ]
 4024 ae61: a9 a5                  dw      crand               ; c6h [GDJ]
 4025 ae63: aa 79       	   dw      cexec               ; c7h [gnr]
 4026 ae65: ac 71       	   dw	   clist	       ; c8h [gnr]
 4027 ae67:             
 4028 ae67:             
 4029 ae67:             ; this precompiled BASE variable is loaded at startup freemem
 4030 ae67:             ; important to zero next word else 'words' may interpret
 4031 ae67:             ; startup random data as valid (rarely) which will type garbage 
            #else
 4038 ae67: 03 18       basev:  db 003h, 018h,					   ; this must be basen+1 word
 4039 ae69: 7c ff c0 29 
            40 03 18 86         db 07ch, 0ffh, 0c0h, 029h, 040h, 003h, 018h, 086h, ; next word address + VARIABLE
 4040 ae71: fe 42 41 53 
            45 00 00 0a         db 0feh, 042h, 041h, 053h, 045h, 000h, 000h, 00ah, ; T_NUM 'BASE' VALUE
 4041 ae79: 00 00 00 00 
            00 00 00 00         db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h  ; zero next word
            #endif
 4043 ae81:             	
 4044 ae81:             
            #ifdef STGROM
 4046 ae81:             extblock:
 4047 ae81: 7e ff 7d ff 
            7c ff 07 c8             db  07eh, 0ffh, 07dh, 0ffh, 07ch, 0ffh, 007h, 0c8h, 
 4048 ae89: 7c ff c0 2f 
            1b 03 18 86             db  07ch, 0ffh, 0c0h, 02fh, 01bh, 003h, 018h, 086h, 
 4049 ae91: fe 42 41 53 
            45 00 00 0a             db  0feh, 042h, 041h, 053h, 045h, 000h, 000h, 00ah, 
 4050 ae99: 03 24 87 fe 
            4e 49 50 00             db  003h, 024h, 087h, 0feh, 04eh, 049h, 050h, 000h, 
 4051 aea1: 8b 8a 88 00 
            03 31 87 fe             db  08bh, 08ah, 088h, 000h, 003h, 031h, 087h, 0feh, 
 4052 aea9: 54 55 43 4b 
            00 8b aa 88             db  054h, 055h, 043h, 04bh, 000h, 08bh, 0aah, 088h, 
 4053 aeb1: 00 03 47 87 
            fe 50 49 43             db  000h, 003h, 047h, 087h, 0feh, 050h, 049h, 043h, 
 4054 aeb9: 4b 00 ff 00 
            02 8e ff 00             db  04bh, 000h, 0ffh, 000h, 002h, 08eh, 0ffh, 000h, 
 4055 aec1: 02 8c be 8c 
            ab 88 00 03             db  002h, 08ch, 0beh, 08ch, 0abh, 088h, 000h, 003h, 
 4056 aec9: 54 87 fe 32 
            44 55 50 00             db  054h, 087h, 0feh, 032h, 044h, 055h, 050h, 000h, 
 4057 aed1: aa aa 88 00 
            03 62 87 fe             db  0aah, 0aah, 088h, 000h, 003h, 062h, 087h, 0feh, 
 4058 aed9: 32 44 52 4f 
            50 00 8a 8a             db  032h, 044h, 052h, 04fh, 050h, 000h, 08ah, 08ah, 
 4059 aee1: 88 00 03 80 
            87 fe 32 4f             db  088h, 000h, 003h, 080h, 087h, 0feh, 032h, 04fh, 
 4060 aee9: 56 45 52 00 
            ff 00 03 fe             db  056h, 045h, 052h, 000h, 0ffh, 000h, 003h, 0feh, 
 4061 aef1: 50 49 43 4b 
            00 ff 00 03             db  050h, 049h, 043h, 04bh, 000h, 0ffh, 000h, 003h, 
 4062 aef9: fe 50 49 43 
            4b 00 88 00             db  0feh, 050h, 049h, 043h, 04bh, 000h, 088h, 000h, 
 4063 af01: 03 90 87 fe 
            32 53 57 41             db  003h, 090h, 087h, 0feh, 032h, 053h, 057h, 041h, 
 4064 af09: 50 00 a2 a9 
            a1 a9 88 00             db  050h, 000h, 0a2h, 0a9h, 0a1h, 0a9h, 088h, 000h, 
 4065 af11: 03 9e 87 fe 
            54 52 55 45             db  003h, 09eh, 087h, 0feh, 054h, 052h, 055h, 045h, 
 4066 af19: 00 ff 00 01 
            88 00 03 ad             db  000h, 0ffh, 000h, 001h, 088h, 000h, 003h, 0adh, 
 4067 af21: 87 fe 46 41 
            4c 53 45 00             db  087h, 0feh, 046h, 041h, 04ch, 053h, 045h, 000h, 
 4068 af29: ff 00 00 88 
            00 03 b6 87             db  0ffh, 000h, 000h, 088h, 000h, 003h, 0b6h, 087h, 
 4069 af31: fe 4a 00 a3 
            88 00 03 c3             db  0feh, 04ah, 000h, 0a3h, 088h, 000h, 003h, 0c3h, 
 4070 af39: 87 fe 31 2b 
            00 ff 00 01             db  087h, 0feh, 031h, 02bh, 000h, 0ffh, 000h, 001h, 
 4071 af41: 8c 88 00 03 
            d0 87 fe 31             db  08ch, 088h, 000h, 003h, 0d0h, 087h, 0feh, 031h, 
 4072 af49: 2d 00 ff 00 
            01 8d 88 00             db  02dh, 000h, 0ffh, 000h, 001h, 08dh, 088h, 000h, 
 4073 af51: 03 dd 87 fe 
            32 2b 00 ff             db  003h, 0ddh, 087h, 0feh, 032h, 02bh, 000h, 0ffh, 
 4074 af59: 00 02 8c 88 
            00 03 ea 87             db  000h, 002h, 08ch, 088h, 000h, 003h, 0eah, 087h, 
 4075 af61: fe 32 2d 00 
            ff 00 02 8d             db  0feh, 032h, 02dh, 000h, 0ffh, 000h, 002h, 08dh, 
 4076 af69: 88 00 03 f7 
            87 fe 30 3d             db  088h, 000h, 003h, 0f7h, 087h, 0feh, 030h, 03dh, 
 4077 af71: 00 ff 00 00 
            9b 88 00 04             db  000h, 0ffh, 000h, 000h, 09bh, 088h, 000h, 004h, 
 4078 af79: 05 87 fe 4e 
            4f 54 00 fe             db  005h, 087h, 0feh, 04eh, 04fh, 054h, 000h, 0feh, 
 4079 af81: 30 3d 00 88 
            00 04 10 87             db  030h, 03dh, 000h, 088h, 000h, 004h, 010h, 087h, 
 4080 af89: fe 55 3e 00 
            8b 9e 88 00             db  0feh, 055h, 03eh, 000h, 08bh, 09eh, 088h, 000h, 
 4081 af91: 04 28 87 fe 
            55 3e 3d 00             db  004h, 028h, 087h, 0feh, 055h, 03eh, 03dh, 000h, 
 4082 af99: fe 32 44 55 
            50 00 fe 55             db  0feh, 032h, 044h, 055h, 050h, 000h, 0feh, 055h, 
 4083 afa1: 3e 00 a2 9b 
            a1 94 88 00             db  03eh, 000h, 0a2h, 09bh, 0a1h, 094h, 088h, 000h, 
 4084 afa9: 04 3c 87 fe 
            55 3c 3d 00             db  004h, 03ch, 087h, 0feh, 055h, 03ch, 03dh, 000h, 
 4085 afb1: fe 55 3e 3d 
            00 fe 4e 4f             db  0feh, 055h, 03eh, 03dh, 000h, 0feh, 04eh, 04fh, 
 4086 afb9: 54 00 88 00 
            04 46 87 fe             db  054h, 000h, 088h, 000h, 004h, 046h, 087h, 0feh, 
 4087 afc1: 3e 00 8b 9d 
            88 00 04 57             db  03eh, 000h, 08bh, 09dh, 088h, 000h, 004h, 057h, 
 4088 afc9: 87 fe 3c 3d 
            00 fe 3e 00             db  087h, 0feh, 03ch, 03dh, 000h, 0feh, 03eh, 000h, 
 4089 afd1: fe 4e 4f 54 
            00 88 00 04             db  0feh, 04eh, 04fh, 054h, 000h, 088h, 000h, 004h, 
 4090 afd9: 66 87 fe 3e 
            3d 00 9d fe             db  066h, 087h, 0feh, 03eh, 03dh, 000h, 09dh, 0feh, 
 4091 afe1: 4e 4f 54 00 
            88 00 04 75             db  04eh, 04fh, 054h, 000h, 088h, 000h, 004h, 075h, 
 4092 afe9: 87 fe 30 3e 
            00 ff 00 00             db  087h, 0feh, 030h, 03eh, 000h, 0ffh, 000h, 000h, 
 4093 aff1: fe 3e 00 88 
            00 04 82 87             db  0feh, 03eh, 000h, 088h, 000h, 004h, 082h, 087h, 
 4094 aff9: fe 30 3c 00 
            ff 00 00 9d             db  0feh, 030h, 03ch, 000h, 0ffh, 000h, 000h, 09dh, 
 4095 b001: 88 00 04 90 
            87 fe 46 52             db  088h, 000h, 004h, 090h, 087h, 0feh, 046h, 052h, 
 4096 b009: 45 45 00 97 
            91 96 88 00             db  045h, 045h, 000h, 097h, 091h, 096h, 088h, 000h, 
 4097 b011: 04 9f 87 fe 
            2b 21 00 8b             db  004h, 09fh, 087h, 0feh, 02bh, 021h, 000h, 08bh, 
 4098 b019: aa ab 8c 8b 
            ac 88 00 04             db  0aah, 0abh, 08ch, 08bh, 0ach, 088h, 000h, 004h, 
 4099 b021: af 87 fe 2d 
            21 00 8b aa             db  0afh, 087h, 0feh, 02dh, 021h, 000h, 08bh, 0aah, 
 4100 b029: ab 8b 8d 8b 
            ac 88 00 04             db  0abh, 08bh, 08dh, 08bh, 0ach, 088h, 000h, 004h, 
 4101 b031: be 87 fe 2a 
            21 00 8b aa             db  0beh, 087h, 0feh, 02ah, 021h, 000h, 08bh, 0aah, 
 4102 b039: ab 8e 8b ac 
            88 00 04 ce             db  0abh, 08eh, 08bh, 0ach, 088h, 000h, 004h, 0ceh, 
 4103 b041: 87 fe 2f 21 
            00 8b aa ab             db  087h, 0feh, 02fh, 021h, 000h, 08bh, 0aah, 0abh, 
 4104 b049: 8b 8f 8b ac 
            88 00 04 de             db  08bh, 08fh, 08bh, 0ach, 088h, 000h, 004h, 0deh, 
 4105 b051: 87 fe 43 2b 
            21 00 89 a2             db  087h, 0feh, 043h, 02bh, 021h, 000h, 089h, 0a2h, 
 4106 b059: ad 8c a1 ae 
            88 00 04 ef             db  0adh, 08ch, 0a1h, 0aeh, 088h, 000h, 004h, 0efh, 
 4107 b061: 87 fe 43 2d 
            21 00 89 a2             db  087h, 0feh, 043h, 02dh, 021h, 000h, 089h, 0a2h, 
 4108 b069: ad 8b 8d a1 
            ae 88 00 05             db  0adh, 08bh, 08dh, 0a1h, 0aeh, 088h, 000h, 005h, 
 4109 b071: 00 87 fe 40 
            2b 00 89 ab             db  000h, 087h, 0feh, 040h, 02bh, 000h, 089h, 0abh, 
 4110 b079: 8b ff 00 02 
            8c 8b 88 00             db  08bh, 0ffh, 000h, 002h, 08ch, 08bh, 088h, 000h, 
 4111 b081: 05 0a 87 fe 
            3f 00 ab 91             db  005h, 00ah, 087h, 0feh, 03fh, 000h, 0abh, 091h, 
 4112 b089: 88 00 05 19 
            87 fe 4e 45             db  088h, 000h, 005h, 019h, 087h, 0feh, 04eh, 045h, 
 4113 b091: 47 00 ff 00 
            00 8b 8d 88             db  047h, 000h, 0ffh, 000h, 000h, 08bh, 08dh, 088h, 
 4114 b099: 00 05 30 87 
            fe 4d 49 4e             db  000h, 005h, 030h, 087h, 0feh, 04dh, 049h, 04eh, 
 4115 b0a1: 00 fe 32 44 
            55 50 00 fe             db  000h, 0feh, 032h, 044h, 055h, 050h, 000h, 0feh, 
 4116 b0a9: 3e 00 83 8b 
            85 8a 88 00             db  03eh, 000h, 083h, 08bh, 085h, 08ah, 088h, 000h, 
 4117 b0b1: 05 45 87 fe 
            4d 41 58 00             db  005h, 045h, 087h, 0feh, 04dh, 041h, 058h, 000h, 
 4118 b0b9: fe 32 44 55 
            50 00 9d 83             db  0feh, 032h, 044h, 055h, 050h, 000h, 09dh, 083h, 
 4119 b0c1: 8b 85 8a 88 
            00 05 5e 87             db  08bh, 085h, 08ah, 088h, 000h, 005h, 05eh, 087h, 
 4120 b0c9: fe 55 4d 49 
            4e 00 fe 32             db  0feh, 055h, 04dh, 049h, 04eh, 000h, 0feh, 032h, 
 4121 b0d1: 44 55 50 00 
            fe 55 3e 00             db  044h, 055h, 050h, 000h, 0feh, 055h, 03eh, 000h, 
 4122 b0d9: 83 8b 85 8a 
            88 00 05 74             db  083h, 08bh, 085h, 08ah, 088h, 000h, 005h, 074h, 
 4123 b0e1: 87 fe 55 4d 
            41 58 00 fe             db  087h, 0feh, 055h, 04dh, 041h, 058h, 000h, 0feh, 
 4124 b0e9: 32 44 55 50 
            00 9e 83 8b             db  032h, 044h, 055h, 050h, 000h, 09eh, 083h, 08bh, 
 4125 b0f1: 85 8a 88 00 
            05 83 87 fe             db  085h, 08ah, 088h, 000h, 005h, 083h, 087h, 0feh, 
 4126 b0f9: 3f 44 55 50 
            00 89 83 89             db  03fh, 044h, 055h, 050h, 000h, 089h, 083h, 089h, 
 4127 b101: 85 88 00 05 
            99 87 fe 41             db  085h, 088h, 000h, 005h, 099h, 087h, 0feh, 041h, 
 4128 b109: 42 53 00 89 
            fe 30 3c 00             db  042h, 053h, 000h, 089h, 0feh, 030h, 03ch, 000h, 
 4129 b111: 83 ff 00 00 
            8b 8d 85 88             db  083h, 0ffh, 000h, 000h, 08bh, 08dh, 085h, 088h, 
 4130 b119: 00 05 a5 87 
            fe 42 4c 00             db  000h, 005h, 0a5h, 087h, 0feh, 042h, 04ch, 000h, 
 4131 b121: ff 00 20 88 
            00 05 b5 87             db  0ffh, 000h, 020h, 088h, 000h, 005h, 0b5h, 087h, 
 4132 b129: fe 53 50 41 
            43 45 00 ff             db  0feh, 053h, 050h, 041h, 043h, 045h, 000h, 0ffh, 
 4133 b131: 00 20 a5 88 
            00 05 cb 87             db  000h, 020h, 0a5h, 088h, 000h, 005h, 0cbh, 087h, 
 4134 b139: fe 53 50 41 
            43 45 53 00             db  0feh, 053h, 050h, 041h, 043h, 045h, 053h, 000h, 
 4135 b141: ff 00 00 98 
            ff 00 20 a5             db  0ffh, 000h, 000h, 098h, 0ffh, 000h, 020h, 0a5h, 
 4136 b149: 99 88 00 05 
            f1 87 fe 43             db  099h, 088h, 000h, 005h, 0f1h, 087h, 0feh, 043h, 
 4137 b151: 4c 53 00 ff 
            00 1b a5 ff             db  04ch, 053h, 000h, 0ffh, 000h, 01bh, 0a5h, 0ffh, 
 4138 b159: 00 5b a5 ff 
            00 32 a5 ff             db  000h, 05bh, 0a5h, 0ffh, 000h, 032h, 0a5h, 0ffh, 
 4139 b161: 00 4a a5 ff 
            00 1b a5 ff             db  000h, 04ah, 0a5h, 0ffh, 000h, 01bh, 0a5h, 0ffh, 
 4140 b169: 00 5b a5 ff 
            00 48 a5 88             db  000h, 05bh, 0a5h, 0ffh, 000h, 048h, 0a5h, 088h, 
 4141 b171: 00 06 0d 87 
            fe 4c 53 48             db  000h, 006h, 00dh, 087h, 0feh, 04ch, 053h, 048h, 
 4142 b179: 49 46 54 00 
            89 81 8b ff             db  049h, 046h, 054h, 000h, 089h, 081h, 08bh, 0ffh, 
 4143 b181: 00 02 8e 8b 
            ff 00 01 8d             db  000h, 002h, 08eh, 08bh, 0ffh, 000h, 001h, 08dh, 
 4144 b189: 89 82 8a 88 
            00 06 29 87             db  089h, 082h, 08ah, 088h, 000h, 006h, 029h, 087h, 
 4145 b191: fe 52 53 48 
            49 46 54 00             db  0feh, 052h, 053h, 048h, 049h, 046h, 054h, 000h, 
 4146 b199: 89 81 8b ff 
            00 02 8f 8b             db  089h, 081h, 08bh, 0ffh, 000h, 002h, 08fh, 08bh, 
 4147 b1a1: ff 00 01 8d 
            89 82 8a 88             db  0ffh, 000h, 001h, 08dh, 089h, 082h, 08ah, 088h, 
 4148 b1a9: 00 06 3a 87 
            fe 49 4e 56             db  000h, 006h, 03ah, 087h, 0feh, 049h, 04eh, 056h, 
 4149 b1b1: 45 52 54 00 
            ff ff ff 95             db  045h, 052h, 054h, 000h, 0ffh, 0ffh, 0ffh, 095h, 
 4150 b1b9: 88 00 06 54 
            87 fe 53 47             db  088h, 000h, 006h, 054h, 087h, 0feh, 053h, 047h, 
 4151 b1c1: 4e 00 89 83 
            ff 80 00 93             db  04eh, 000h, 089h, 083h, 0ffh, 080h, 000h, 093h, 
 4152 b1c9: 83 ff ff ff 
            84 ff 00 01             db  083h, 0ffh, 0ffh, 0ffh, 084h, 0ffh, 000h, 001h, 
 4153 b1d1: 85 85 88 00 
            06 66 87 fe             db  085h, 085h, 088h, 000h, 006h, 066h, 087h, 0feh, 
 4154 b1d9: 4d 4f 44 00 
            89 a8 89 a8             db  04dh, 04fh, 044h, 000h, 089h, 0a8h, 089h, 0a8h, 
 4155 b1e1: 8f a8 8e 8d 
            88 00 06 7a             db  08fh, 0a8h, 08eh, 08dh, 088h, 000h, 006h, 07ah, 
 4156 b1e9: 87 fe 2f 4d 
            4f 44 00 aa             db  087h, 0feh, 02fh, 04dh, 04fh, 044h, 000h, 0aah, 
 4157 b1f1: aa fe 4d 4f 
            44 00 a9 8f             db  0aah, 0feh, 04dh, 04fh, 044h, 000h, 0a9h, 08fh, 
 4158 b1f9: 88 00 06 8c 
            87 fe 47 45             db  088h, 000h, 006h, 08ch, 087h, 0feh, 047h, 045h, 
 4159 b201: 54 42 49 54 
            00 c2 ff 00             db  054h, 042h, 049h, 054h, 000h, 0c2h, 0ffh, 000h, 
 4160 b209: 01 93 88 00 
            06 9f 87 fe             db  001h, 093h, 088h, 000h, 006h, 09fh, 087h, 0feh, 
 4161 b211: 53 45 54 42 
            49 54 00 ff             db  053h, 045h, 054h, 042h, 049h, 054h, 000h, 0ffh, 
 4162 b219: 00 01 8b c1 
            94 88 00 06             db  000h, 001h, 08bh, 0c1h, 094h, 088h, 000h, 006h, 
 4163 b221: b6 87 fe 43 
            4c 52 42 49             db  0b6h, 087h, 0feh, 043h, 04ch, 052h, 042h, 049h, 
 4164 b229: 54 00 ff 00 
            01 8b c1 ff             db  054h, 000h, 0ffh, 000h, 001h, 08bh, 0c1h, 0ffh, 
 4165 b231: ff ff 95 93 
            88 00 06 c9             db  0ffh, 0ffh, 095h, 093h, 088h, 000h, 006h, 0c9h, 
 4166 b239: 87 fe 54 47 
            4c 42 49 54             db  087h, 0feh, 054h, 047h, 04ch, 042h, 049h, 054h, 
 4167 b241: 00 ff 00 01 
            8b c1 95 88             db  000h, 0ffh, 000h, 001h, 08bh, 0c1h, 095h, 088h, 
 4168 b249: 00 06 e7 87 
            fe 42 59 54             db  000h, 006h, 0e7h, 087h, 0feh, 042h, 059h, 054h, 
 4169 b251: 45 53 57 41 
            50 00 89 ff             db  045h, 053h, 057h, 041h, 050h, 000h, 089h, 0ffh, 
 4170 b259: 00 08 c2 8b 
            ff 00 ff 93             db  000h, 008h, 0c2h, 08bh, 0ffh, 000h, 0ffh, 093h, 
 4171 b261: ff 00 08 c1 
            94 88 00 07             db  0ffh, 000h, 008h, 0c1h, 094h, 088h, 000h, 007h, 
 4172 b269: 01 87 fe 46 
            49 4c 4c 00             db  001h, 087h, 0feh, 046h, 049h, 04ch, 04ch, 000h, 
 4173 b271: 8b a2 aa ae 
            89 fe 31 2b             db  08bh, 0a2h, 0aah, 0aeh, 089h, 0feh, 031h, 02bh, 
 4174 b279: 00 a1 fe 31 
            2d 00 af 88             db  000h, 0a1h, 0feh, 031h, 02dh, 000h, 0afh, 088h, 
 4175 b281: 00 07 16 87 
            fe 45 52 41             db  000h, 007h, 016h, 087h, 0feh, 045h, 052h, 041h, 
 4176 b289: 53 45 00 ff 
            00 00 fe 46             db  053h, 045h, 000h, 0ffh, 000h, 000h, 0feh, 046h, 
 4177 b291: 49 4c 4c 00 
            88 00 07 27             db  049h, 04ch, 04ch, 000h, 088h, 000h, 007h, 027h, 
 4178 b299: 87 fe 43 4c 
            45 41 52 00             db  087h, 0feh, 043h, 04ch, 045h, 041h, 052h, 000h, 
 4179 b2a1: a7 81 8a a7 
            82 88 00 07             db  0a7h, 081h, 08ah, 0a7h, 082h, 088h, 000h, 007h, 
 4180 b2a9: 60 87 fe 2e 
            53 00 b0 fe             db  060h, 087h, 0feh, 02eh, 053h, 000h, 0b0h, 0feh, 
 4181 b2b1: 3c 20 22 00 
            a7 ff 00 08             db  03ch, 020h, 022h, 000h, 0a7h, 0ffh, 000h, 008h, 
 4182 b2b9: a5 90 ff 00 
            08 a5 b0 fe             db  0a5h, 090h, 0ffh, 000h, 008h, 0a5h, 0b0h, 0feh, 
 4183 b2c1: 3e 20 22 00 
            a7 fe 3f 44             db  03eh, 020h, 022h, 000h, 0a7h, 0feh, 03fh, 044h, 
 4184 b2c9: 55 50 00 83 
            89 ff 00 00             db  055h, 050h, 000h, 083h, 089h, 0ffh, 000h, 000h, 
 4185 b2d1: 98 89 92 8d 
            fe 50 49 43             db  098h, 089h, 092h, 08dh, 0feh, 050h, 049h, 043h, 
 4186 b2d9: 4b 00 90 99 
            8a 85 88 00             db  04bh, 000h, 090h, 099h, 08ah, 085h, 088h, 000h, 
 4187 b2e1: 07 7d 87 fe 
            54 59 50 45             db  007h, 07dh, 087h, 0feh, 054h, 059h, 050h, 045h, 
 4188 b2e9: 00 89 83 ff 
            00 00 98 89             db  000h, 089h, 083h, 0ffh, 000h, 000h, 098h, 089h, 
 4189 b2f1: ad a6 ff 00 
            01 8c 99 84             db  0adh, 0a6h, 0ffh, 000h, 001h, 08ch, 099h, 084h, 
 4190 b2f9: 8a 85 8a 88 
            00 07 c8 87             db  08ah, 085h, 08ah, 088h, 000h, 007h, 0c8h, 087h, 
 4191 b301: fe 44 55 4d 
            50 00 96 ff             db  0feh, 044h, 055h, 04dh, 050h, 000h, 096h, 0ffh, 
 4192 b309: 00 05 fe 53 
            50 41 43 45             db  000h, 005h, 0feh, 053h, 050h, 041h, 043h, 045h, 
 4193 b311: 53 00 ff 00 
            10 ff 00 00             db  053h, 000h, 0ffh, 000h, 010h, 0ffh, 000h, 000h, 
 4194 b319: 98 92 90 99 
            ff 00 00 98             db  098h, 092h, 090h, 099h, 0ffh, 000h, 000h, 098h, 
 4195 b321: 96 89 90 ff 
            00 10 ff 00             db  096h, 089h, 090h, 0ffh, 000h, 010h, 0ffh, 000h, 
 4196 b329: 00 98 89 ad 
            90 fe 31 2b             db  000h, 098h, 089h, 0adh, 090h, 0feh, 031h, 02bh, 
 4197 b331: 00 99 89 ff 
            00 10 8d ff             db  000h, 099h, 089h, 0ffh, 000h, 010h, 08dh, 0ffh, 
 4198 b339: 00 10 fe 54 
            59 50 45 00             db  000h, 010h, 0feh, 054h, 059h, 050h, 045h, 000h, 
 4199 b341: ff 00 10 9a 
            8a 96 88 00             db  0ffh, 000h, 010h, 09ah, 08ah, 096h, 088h, 000h, 
 4200 b349: 00 00 00 00 
            00 00 00 00             db  000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h, 
 4201 b351: 00 00 00 00 
            00 00 00 00             db  000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h, 
 4202 b359: 00 00 00 00 
            00 00 00 00             db  000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h, 
 4203 b361: 00 00 00 00 
            00 00 00 00             db  000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h, 
 4204 b369: 00 00 00 00 
            00 00 00 00             db  000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h, 
 4205 b371: 00 00 00 00 
            00 00 00 00             db  000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h, 
 4206 b379: 00 00 00 00 
            00 00 00 00             db  000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
 4207 b381:             endextblock:
            #endif
 4209 b381:             
 4210 b381:             endrom:    equ     $
 4211 b381:             
            #endif
 4224 b381:             
 4225 b381:                        end     start
 4226 b381:             
 4227 b381:             
 4228 b381:                        
 4229 b381:             

9fdfh: ASCERR           - <  1385>   1397 
9fe8h: ASCNOERR         - <  1390>   1384 
0317h: BASEN            - <   103>   1099   1276   3180   3185   3651   3668 
ae67h: BASEV            - <  4038>    427 
aab5h: BLOADLP          - <  3374>   3379   3381 
0200h: BUFFER           - <    95>    508    510    521    963    965   3223 
         3228   3238   3244   3409   3419   3503   3507   3673   3685   3699 
ffe0h: CALL             - <   142> 
a75bh: CALLOT           - <  2784>   4005 
a761h: CALLOTLP1        - <  2788>   2804 
a773h: CALLOTNO         - <  2800>   2796   2798 
a77ah: CALLOTYES        - <  2805>   2799 
a085h: CAND             - <  1513>   3973 
a4ebh: CAT              - <  2332>   3997 
a1b6h: CBEGIN           - <  1757>   3985 
aa97h: CBLOAD           - <  3362>   4022 
ab67h: CBYE             - <  3595>   4015 
a514h: CCAT             - <  2363>   3999 
a526h: CCEXCL           - <  2377>   4000 
a93fh: CCMOVE           - <  3141>   4001 
a56fh: CCOLON           - <  2435>   3961 
a0dfh: CCR              - <  1584>   3976 
a984h: CDECIMAL         - <  3180>   4017 
aa5bh: CDELAY           - <  3318>   4021 
a445h: CDEPTH           - <  2198>   3993 
a7c4h: CDIV             - <  2863>   3969 
a12ah: CDO              - <  1644>   3978 
a06bh: CDOT             - <  1491>   3970 
a717h: CDOTQT           - <  2738>   4002 
a738h: CDOTQTDN         - <  2760>   2752 
a727h: CDOTQTLP         - <  2751>   2754   2759 
a026h: CDROP            - <  1437>   3964 
a015h: CDUP             - <  1425>   3963 
a862h: CEF              - <  3001>   4011 
a868h: CEF1             - <  3004>   3002 
a86ch: CEF2             - <  3006>   3004 
a870h: CEF3             - <  3008>   3006 
a874h: CEF4             - <  3010>   3008 
a3ech: CELSE            - <  2135>   3958 
a31ch: CEMIT            - <  1994>   3991 
a329h: CEMITP           - <  2003>   3992 
a419h: CEQUAL           - <  2167>   3981 
a858h: CERROR           - <  2989>   4006 
a4fch: CEXCL            - <  2346>   3998 
aa79h: CEXEC            - <  3339>   4025 
aa94h: CEXEC0           - <  3355>   3352 
a7e4h: CFORGET          - <  2887>   4008 
a9b0h: CGOTOXY          - <  3208>   4023 
a1f2h: CGTR             - <  1802>   3988 
a990h: CHEX             - <  3185>   4018 
a10ah: CI               - <  1616>   3972 
a3a3h: CIF              - <  2090>   3957 
a8d3h: CINP             - <  3065>   4010 
a8e3h: CINP2            - <  3073>   3070 
a8ech: CINP3            - <  3077>   3074 
a8f5h: CINP4            - <  3081>   3078 
a8feh: CINP5            - <  3085>   3082 
a907h: CINP6            - <  3089>   3086 
a910h: CINP7            - <  3093>   3090 
a916h: CINPD            - <  3096>   3072   3076   3080   3084   3088   3092 
a740h: CKEY             - <  2767>   4003 
a74ah: CKEYQ            - <  2775>   4004 
a22ah: CLESS            - <  1843>   3983 
ac71h: CLIST            - <  3792>   4026 
ac77h: CLIST0           - <  3793>   3815 
ac8ah: CLIST1           - <  3802>   3796   3799 
ab24h: CLOAD            - <  3498>   4014 
a15bh: CLOOP            - <  1684>   3979 
a197h: CLOOPDN          - <  1734>   1702 
ac4ch: CLRMEMLP         - <  3754>   3759   3761 
ac40h: CLRSTACKS        - <  3751>    437 
aa05h: CLSHIFT          - <  3259>   4019 
9e13h: CMDEND           - <  1037>   1008 
9de6h: CMDLOOP          - <   999>   1032 
acedh: CMDTABLE         - <  3881>    990    992   1924   1926   2710   2712 
add7h: CMDVECS          - <  3955>   1323   1326 
a113h: CMEM             - <  1622>   3977 
a04dh: CMINUS           - <  1467>   3967 
a95dh: CMOVELP          - <  3156>   3165 
a96fh: CMOVERTN         - <  3166>   3160 
a968h: CMOVESTR         - <  3161>   3157   3159 
a493h: CMROT            - <  2263>   3995 
a7aeh: CMUL             - <  2848>   3968 
a57fh: COLONLP1         - <  2448>   2450 
a0a3h: COR              - <  1537>   3974 
a87bh: COUT             - <  3017>   4009 
a897h: COUT2            - <  3034>   3030 
a8a1h: COUT3            - <  3039>   3035 
a8abh: COUT4            - <  3044>   3040 
a8b5h: COUT5            - <  3049>   3045 
a8bfh: COUT6            - <  3054>   3050 
a8c9h: COUT7            - <  3059>   3055 
a8d0h: COUT8            - <  3063>   3060 
a4c6h: COVER            - <  2303>   3996 
a19dh: CPLOOP           - <  1737>   3980 
a02fh: CPLUS            - <  1442>   3966 
a9a5h: CRAND            - <  3197>   4024 
a99ch: CRAT             - <  3190>   3989 
a393h: CREPEAT          - <  2076>   3956 
a1ech: CRGT             - <  1797>   3987 
acd2h: CRLF             - <  3877>    542    544 
9c17h: CRLFOUT          - <   540>    520   1585   1951   1954   1968   1990 
         2545   2664 
a460h: CROT             - <  2223>   3994 
aa30h: CRSHIFT          - <  3288>   4020 
aad3h: CSAVE            - <  3393>   4013 
a5aah: CSEE             - <  2484>   4007 
a6aah: CSEEFUNC         - <  2666>   2530 
a5d5h: CSEE_SUB         - <  2523>   2506 
a5cbh: CSEE_SUB0        - <  2513>   3806 
a5a7h: CSEMI            - <  2481>   3962 
a972h: CSETQ            - <  3169>   4012 
a91dh: CSPAT            - <  3109>   4016 
a5d1h: CSUB0            - <  2520>   2522 
a0e5h: CSWAP            - <  1588>   3965 
a416h: CTHEN            - <  2165>   3959 
a07ah: CUDOT            - <  1506>   3971 
a266h: CULESS           - <  1890>   3984 
a1feh: CUNEQUAL         - <  1809>   3982 
a1c5h: CUNTIL           - <  1771>   3986 
a53bh: CVARIABLE        - <  2391>   3960 
a347h: CWHILE           - <  2024>   3955 
a299h: CWORDS           - <  1924>   3990 
a2d4h: CWORDSDN         - <  1953>   1930 
a2eeh: CWORDSDN1        - <  1967> 
a2b6h: CWORDSF          - <  1938>   1933 
a2a5h: CWORDSLP         - <  1929>   1937   1948   1952 
a2e3h: CWORDSLP2        - <  1960>   1987   1991 
a2f4h: CWORDSNOT        - <  1970>   1964   1966 
a0c1h: CXOR             - <  1560>   3975 
9d5fh: D16LP1           - <   880>    873    875    895 
9e70h: DECNUM           - <  1104>   1096 
aa65h: DELAYLP1         - <  3326>   3333   3335 
aa67h: DELAYLP2         - <  3327>   3329 
9c2ah: DISP             - <   559>   1936   1941   1944   1975   1979   1999 
         2020   2541   2606   2611   2657   2668   2672   2681   2729   2735 
         2758   3650   3660 
9d47h: DIV16            - <   863>   2877 
9d8bh: DIVGO            - <   911>    897    899 
9db1h: DIVNO            - <   945>    932 
9d8ah: DIVRET           - <   910>    902 
9d74h: DIVST            - <   896>    882    957 
9da5h: DIVYES           - <   933>    927 
a3ffh: ELSECNT          - <  2150>   2154   2157 
a3f8h: ELSELP1          - <  2146>   2151 
a403h: ELSENIF          - <  2152>   2148 
a341h: EMITPOUT         - <  2019>   2015 
b381h: ENDEXTBLOCK      - <  4207>   3372 
b381h: ENDROM           - <  4210> 
ac1eh: ERR              - <  3724> 
a010h: ERROR            - <  1421>   1427   1439   1444   1451   1469   1476 
         1493   1508   1515   1522   1539   1546   1562   1569   1590   1597 
         1646   1653   1746   1773   1804   1811   1818   1845   1852   1892 
         1899   1996   2005   2026   2092   2169   2176   2225   2232   2239 
         2265   2272   2279   2305   2312   2334   2348   2355   2365   2379 
         2386   2402   2446   2495   2499   2749   2808   2811   2850   2857 
         2865   2872   2898   2902   2991   3019   3024   3067   3094   3143 
         3147   3151   3171   3210   3214   3261   3267   3290   3296   3320 
         3341 
9f76h: EXEC             - <  1306>    536   1348   1376   1404   1410   1417 
9fd4h: EXECASCII        - <  1377>   1312 
a688h: EXECDN           - <  2636>   1307 
9fc1h: EXECNUM          - <  1361>   1309 
9fadh: EXECRET          - <  1340>   1422   1434   2993 
9fbeh: EXECRMSG         - <  1353>   1389 
a006h: EXECVAR          - <  1411>   1394 
8003h: EXITADDR         - <   106>   3595 
ae81h: EXTBLOCK         - <  4046>   3366   3372 
ac1ah: FAILS            - <  3720>   3715   3717   3738   3743   3746 
00b3h: FALLOT           - <   289>    290 
0093h: FAND             - <   257>    258 
00abh: FAT              - <   281>    282 
009fh: FBEGIN           - <   269>    270 
00adh: FCAT             - <   283>    284 
00aeh: FCEXCL           - <   284>    285 
00afh: FCMOVE           - <   285>    286 
0087h: FCOLON           - <   245>    246 
0096h: FCR              - <   260>    261 
00a7h: FDEPTH           - <   277>    278 
008fh: FDIV             - <   253>    254 
0098h: FDO              - <   262>    263 
0090h: FDOT             - <   254>    255 
00b0h: FDOTQT           - <   286>    287   1054 
008ah: FDROP            - <   248>    249 
0089h: FDUP             - <   247>    248 
0084h: FELSE            - <   242>    243 
00a5h: FEMIT            - <   275>    276 
00a6h: FEMITP           - <   276>    277 
009bh: FEQUAL           - <   265>    266 
00b4h: FERROR           - <   290>    291 
00ach: FEXCL            - <   282>    283 
00b7h: FEXEC            - <   293>    294 
00b6h: FFORGET          - <   292>    293 
00a2h: FGTR             - <   272>    273 
0092h: FI               - <   256>    257 
0083h: FIF              - <   241>    242 
9cc3h: FINDCHK          - <   744>    753 
9cd3h: FINDFOUND        - <   754>    750 
9cbch: FINDGO           - <   737>    731    733 
9cach: FINDLP           - <   726>    769 
9ca5h: FINDNAME         - <   721>   1383   2498   2901 
9cdch: FINDNEXT         - <   760>    748 
a361h: FINDREP          - <  2042>   2047 
9cbah: FINDRET          - <   735>    759 
00b1h: FKEY             - <   287>    288 
00b2h: FKEYQ            - <   288>    289 
009dh: FLESS            - <   267>    268 
00b8h: FLIST            - <   294> 
0099h: FLOOP            - <   263>    264 
0097h: FMEM             - <   261>    262 
008dh: FMINUS           - <   251>    252 
00a9h: FMROT            - <   279>    280 
008eh: FMUL             - <   252>    253 
a37ah: FNDREP           - <  2055>   2052 
0094h: FOR              - <   258>    259 
a82ah: FORGETD1         - <  2948>   2930 
a842h: FORGETLP         - <  2972>   2977   2979 
a80fh: FORGETLP1        - <  2924>   2946 
00aah: FOVER            - <   280>    281 
009ah: FPLOOP           - <   264>    265 
008ch: FPLUS            - <   250>    251 
00a3h: FRAT             - <   273>    274 
0306h: FREEMEM          - <    99>    356    428    527    967   1623   2408 
         2454   2835   2954   3397 
0082h: FREPEAT          - <   240>    241 
00a1h: FRGT             - <   271>    272 
00a8h: FROT             - <   278>    279 
00b5h: FSEE             - <   291>    292 
0088h: FSEMI            - <   246>    247 
0308h: FSTACK           - <   100>    403    486    601    627    640    652 
         1629   2199   3109 
008bh: FSWAP            - <   249>    250 
0085h: FTHEN            - <   243>    244 
0091h: FUDOT            - <   255>    256 
009eh: FULESS           - <   268>    269 
009ch: FUNEQUAL         - <   266>    267 
00a0h: FUNTIL           - <   270>    271 
0086h: FVARIABLE        - <   244>    245   2807 
0081h: FWHILE           - <   239>    240 
00a4h: FWORDS           - <   274>    275 
0095h: FXOR             - <   259>    260 
f830h: F_ASTODT         - <   211> 
f833h: F_ASTOTM         - <   212> 
ff5dh: F_ATOI           - <   177> 
ff00h: F_BOOT           - <   146> 
ff42h: F_BOOTIDE        - <   168> 
f800h: F_BREAD          - <   195> 
ff6ch: F_BRKTEST        - <   182> 
f806h: F_BTEST          - <   197> 
f803h: F_BTYPE          - <   196> 
ff33h: F_DIV16          - <   163> 
ff2ah: F_DRIVE          - <   160> 
f827h: F_DTTOAS         - <   209> 
ff6fh: F_FINDTKN        - <   183> 
ff57h: F_FREEMEM        - <   175>    352 
ff81h: F_GETDEV         - <   189> 
f815h: F_GETTOD         - <   202> 
ff45h: F_HEXIN          - <   169> 
ff48h: F_HEXOUT2        - <   170>   3692 
ff4bh: F_HEXOUT4        - <   171>   3689 
f824h: F_IDEID          - <   207> 
ff3ch: F_IDEREAD        - <   166> 
ff36h: F_IDERESET       - <   164> 
f821h: F_IDESIZE        - <   206> 
ff39h: F_IDEWRITE       - <   165> 
ff7bh: F_IDNUM          - <   187> 
ff3fh: F_INITCALL       - <   167>    313    316 
ff66h: F_INMSG          - <   180>   2532   2577   2624   2661   3219 
ff0fh: F_INPUT          - <   151>    516 
ff69h: F_INPUTL         - <   181> 
ff63h: F_INTOUT         - <   179>   3677 
ff78h: F_ISALNUM        - <   186> 
ff72h: F_ISALPHA        - <   184> 
ff75h: F_ISHEX          - <   185> 
ff5ah: F_ISNUM          - <   176> 
ff7eh: F_ISTERM         - <   188> 
ff15h: F_LTRIM          - <   153> 
ff1bh: F_MEMCPY         - <   155> 
ff54h: F_MINIMON        - <   174> 
ff51h: F_MOVER          - <   173> 
ff09h: F_MSG            - <   149>    338    506    550   1357   3230   3246 
         3701 
ff30h: F_MUL16          - <   162> 
f836h: F_NVRCCHK        - <   213> 
f81bh: F_RDNVR          - <   204> 
ff21h: F_RDSEC          - <   157> 
ff06h: F_READ           - <   148>    582 
f82dh: F_RTCTEST        - <   210> 
ff27h: F_SEEK           - <   159> 
ff24h: F_SEEK0          - <   158> 
ff2dh: F_SETBD          - <   161> 
f818h: F_SETTOD         - <   203> 
ff12h: F_STRCMP         - <   152> 
ff18h: F_STRCPY         - <   154> 
f82ah: F_TMTOAS         - <   208> 
ff4eh: F_TTY            - <   172>   3235   3251 
ff03h: F_TYPE           - <   147>    327    563 
ff0ch: F_TYPEX          - <   150> 
ff60h: F_UINTOUT        - <   178>   3225   3241   3680 
f80ch: F_UREAD          - <   199> 
f812h: F_USETBD         - <   201> 
f80fh: F_UTEST          - <   200> 
f809h: F_UTYPE          - <   198> 
fff9h: F_VERSION        - <   191> 
f81eh: F_WRNVR          - <   205> 
ff1eh: F_WRTSEC         - <   156> 
9c2eh: GETKEY           - <   578>   2768 
a021h: GOOD             - <  1433>   1440   1504   1586   1614   1681   1733 
         1736   1768   1780   1795   1807   1969   2000   2021   2061   2074 
         2088   2125   2133   2163   2165   2361   2389   2433   2479   2481 
         2507   2765   2846   2987   3033   3038   3043   3048   3053   3058 
         3063   3166   3175   3177   3183   3188   3253   3336   3431   3801 
a01eh: GOODPUSH         - <  1430>   1463   1488   1534   1558   1581   1620 
         1640   1799   1832   1838   1882   1884   1919   1921   2191   2195 
         2220   2260   2300   2329   2343   2374   2772   2782   2860   2885 
         3013   3099   3135   3194   3203   3285   3314   3354 
acc6h: HELLO            - <  3876>    330    332 
abf3h: HEXBYTE          - <  3691>   3687 
9efah: HEXNUM           - <  1212>   1095   1102 
0300h: HIMEM            - <    96>    319    378    460    462   3424   3512 
a3c4h: IFCNT            - <  2112>   2118   2128   2131 
a3bdh: IFLP1            - <  2108>   2113 
a3e9h: IFNO             - <  2133>   2094   2096 
a3dbh: IFNOTELSE        - <  2126>   2116 
a3c8h: IFNOTIF          - <  2114>   2110 
a3d3h: IFSAVE           - <  2120>   2132 
ac5ah: INKEY            - <  3772>   2777 
ac21h: ISHEX            - <  3733>   1264 
ac0ch: ISNUM            - <  3713>   3734 
9e94h: ISNUMBER         - <  1128> 
030ah: JUMP             - <   101>   1313   1339   3342   3355 
a25dh: LESS1            - <  1883>   1880 
a15fh: LOOPCNT          - <  1687>   1755 
aa1eh: LSHIFTLP         - <  3274>   3271   3282 
aa29h: LSHIFTRET        - <  3284>   3272 
9be7h: MAINLP           - <   498>    458    538   3386   3527 
9d20h: MDNORM           - <   827>    864 
9d37h: MDNORM2          - <   845>    837 
9d45h: MDNORM3          - <   855>    847 
9b43h: MEMDONE          - <   378> 
acd9h: MSEMPTY          - <  3879>   1349   1351 
ace7h: MSGERR           - <  3880>   1385   1387 
9ce8h: MUL16            - <   774>   2859 
9cfch: MULCONT          - <   789>    781    783 
9d17h: MULCONT2         - <   812>    795 
9cefh: MULLOOP          - <   780>    818 
9b12h: NEW              - <   314>    309 
9b8dh: NEXTBASE         - <   429>    434 
ac6dh: NOKEY            - <  3787>   3778 
9e00h: NOMTCH1          - <  1024>   1028 
9e0ah: NOMTCH2          - <  1029>   1026 
9f4ah: NONNUMBER        - <  1275>   1117   1120   1187   1223   1229   1232 
9f5ch: NONNUMBER1       - <  1283>   1279   1281 
9dddh: NONWHITE         - <   990>    983 
9f46h: NOTHEXNUM        - <  1269> 
9b03h: NOTNEW           - <   310> 
9e47h: NOTOKEN          - <  1079>   1033 
9e88h: NOTOKEN1         - <  1115>   1110 
9e64h: NOTOKENBASE      - <  1098>   1083 
9e63h: NOTOKENBASEADJ   - <  1097>   1090 
9f5eh: NOTOKENLP        - <  1285>   1292 
9e5bh: NOTOKEN_0        - <  1091>   1087 
9f6bh: NOTOKWHT         - <  1293>   1290 
a33fh: NOTPRINT         - <  2017>   2009   2012 
a368h: NOTREP           - <  2046>   2050   2054 
a36ch: NOTWHILE         - <  2048>   2044 
9ee0h: NUMBERDN         - <  1188>   1175 
9eedh: NUMBERDN1        - <  1197>   1189   1258 
9ed9h: NUMBERERR        - <  1183>   1178   1181 
9e99h: NUMBERLP         - <  1132>   1182 
9bbdh: OLD              - <   460>    312 
ac17h: PASSES           - <  3718>   3736   3740   3745 
9c32h: POP              - <   600>   1426   1438   1443   1450   1468   1475 
         1492   1507   1514   1521   1538   1545   1561   1568   1589   1596 
         1645   1652   1745   1772   1803   1810   1817   1844   1851   1891 
         1898   1995   2004   2025   2091   2168   2175   2224   2231   2238 
         2264   2271   2278   2304   2311   2333   2347   2354   2364   2378 
         2385   2810   2849   2856   2864   2871   2990   3018   3023   3066 
         3142   3146   3150   3170   3209   3213   3260   3266   3289   3295 
         3319   3340 
9c4dh: POPRET           - <   620>    635 
acd5h: PROMPT           - <  3878>    498    500 
9c61h: PUSH             - <   640>   1371   1412   1429   1432   1607   1613 
         2249   2255   2289   2295   2318   2324 
aca5h: RANDBYTE         - <  3843>   3198 
fff1h: RET              - <   143> 
9c77h: RPOP             - <   666>   1617   1685   1692   1708   1735   1738 
         1779   1782   1798   2077   3191 
9c8fh: RPUSH            - <   691>   1619   1668   1674   1680   1710   1726 
         1732   1767   1784   1806   2073   3193 
02f0h: RSEED            - <   104>    442    450   3843 
aa49h: RSHIFTLP         - <  3303>   3300   3311 
aa54h: RSHIFTRET        - <  3313>   3301 
0302h: RSTACK           - <    97>    387    470    667    678    691    703 
0004h: SCALL            - <   139>    323    334    351    502    512    519 
          522    524    535    546    559    578    863   1263   1370   1382 
         1403   1411   1425   1428   1431   1437   1442   1449   1467   1474 
         1491   1497   1506   1513   1520   1537   1544   1560   1567   1584 
         1588   1595   1606   1612   1616   1618   1644   1651   1667   1673 
         1679   1684   1691   1707   1709   1725   1731   1734   1737   1744 
         1766   1771   1778   1781   1783   1797   1802   1805   1809   1816 
         1843   1850   1890   1897   1935   1940   1943   1950   1953   1967 
         1974   1978   1989   1994   1998   2003   2019   2024   2072   2076 
         2090   2167   2174   2223   2230   2237   2248   2254   2263   2270 
         2277   2288   2294   2303   2310   2317   2323   2332   2346   2353 
         2363   2377   2384   2497   2505   2531   2540   2544   2573   2576 
         2594   2605   2610   2618   2623   2649   2656   2660   2663   2667 
         2671   2680   2702   2728   2734   2757   2767   2776   2809   2848 
         2855   2858   2863   2870   2876   2900   2989   3017   3022   3065 
         3141   3145   3149   3169   3190   3192   3197   3208   3212   3218 
         3224   3229   3234   3240   3245   3250   3259   3265   3288   3294 
         3318   3339   3351   3395   3417   3425   3427   3501   3505   3513 
         3649   3659   3676   3679   3688   3691   3700   3733   3805 
a6a6h: SEEEXIT          - <  2663>   2674 
a6b0h: SEEFUNCLP        - <  2670>   2685 
a6f7h: SEELP3           - <  2720>   2723 
a6cah: SEENEXT          - <  2684>   2679   2709   2736 
a6ceh: SEENOTA          - <  2686>   2676 
a6e8h: SEENOTN          - <  2710>   2688 
a6f2h: SEENOTNLP        - <  2717>   2722 
a633h: SEESTO           - <  2586>   2632   2634 
a6bfh: SEESTRLP         - <  2678>   2683 
a70eh: SEETKLAST        - <  2732>   2726 
a700h: SEETOKEN         - <  2724>   2719   2731 
a610h: SEEVALLOT        - <  2564> 
a65bh: SEEVDATA         - <  2608>   2604 
a5fch: SEEVEQ           - <  2543>   2539 
a6a0h: SEEVEQ1          - <  2659>   2655 
a5f1h: SEEVNAME         - <  2536>   2542 
a697h: SEEVNAME1        - <  2652>   2658 
a652h: SEEVNAMEA        - <  2601>   2607 
a689h: SEEVNOA          - <  2638>   2563 
a980h: SETQNO           - <  3176>   3173 
0005h: SRET             - <   140>    553    565    584    621    659    686 
          710    736    788    856    879    910   1299   2636   2665   3636 
         3703   3722   3725 
01ffh: STACK            - <   105>    311    314 
9c4fh: STACKOK          - <   622>    613    618 
9b21h: START            - <   319>    315   4225   4225 
030dh: STORAGE          - <   102>    358    361    411    413    721    723 
         1955   1957   2784   2786   3792 
9e3ch: TDOTQTDN         - <  1065>   1062 
9e30h: TDOTQTLP         - <  1058>   1064 
9dc0h: TKNIZER          - <   963>    525 
9f23h: TOHEX            - <  1237>   1233 
9f26h: TOHEXAD          - <  1239>   1236 
9f2ah: TOHEXAL          - <  1242>   1250 
9f1dh: TOHEXD           - <  1234>   1226 
9f02h: TOHEXLP          - <  1221>   1265 
9f72h: TOKENDN          - <  1297>    981 
9dd0h: TOKENLP          - <   980>    985   1055   1072   1206   1296 
9deah: TOKLOOP          - <  1006>   1016 
9dfch: TOKNOMTCH        - <  1020>   1013   1042   1046 
0304h: TOS              - <    98>    395    478    607   2205 
ab6ah: TOUC             - <  3622>    523   3635   3641 
ab86h: TOUC_DN          - <  3636>   3626   3639 
ab82h: TOUC_NXT         - <  3634>   3628   3630 
ab88h: TOUC_QLP         - <  3638>   3642 
ab87h: TOUC_QT          - <  3637>   3624 
a074h: TYPEGOOD         - <  1496>   1511 
abdfh: TYPEHEX          - <  3683>   3671 
abb5h: TYPENUM          - <  3665>   1498 
ab94h: TYPENUMIND       - <  3646>   2574   2595   2619   2650   2703 
ababh: TYPENUMINDDEC    - <  3657>   3654 
abd9h: TYPENUMU         - <  3679>   3675 
abb9h: TYPENUMX         - <  3667>   3663 
abf6h: TYPEOUT          - <  3694>   3678   3681   3690 
00feh: T_ASCII          - <   297>   1057   1284   1311   2401   2445   2494 
         2675   2748   2897 
00ffh: T_NUM            - <   296>   1197   1308   2687 
a290h: ULESS1           - <  1920>   1917 
a222h: UNEQUAL          - <  1834>   1824   1829 
a43eh: UNEQUAL2         - <  2192>   2182   2187 
a1d3h: UNTILNO          - <  1778>   1775 
a1d9h: UNTILYES         - <  1781>   1777 
a54bh: VARLP1           - <  2404>   2405 
a383h: WHILENO          - <  2062>   2028   2030 
a2f6h: WORDSNOTL        - <  1972>   1976 
a300h: WORDSNXT         - <  1977>   1973 
ed0fh: XCLOSER          - <    94> 
ed0ch: XCLOSEW          - <    93>   3428 
ed03h: XOPENR           - <    90>   3502 
ed00h: XOPENW           - <    89>   3396 
ed06h: XREAD            - <    91>   3506   3514 
ed09h: XWRITE           - <    92>   3418   3426 

4229 Lines assembled
0 Errors
431 Labels
Object Code:6273 bytes

