1802 -> Native
2 Classes read.
186 Patterns read.
    1 0000:             ; *******************************************************************
    2 0000:             ; *** This software is copyright 2006-2020 by Michael H Riley     ***
    3 0000:             ; *** You have permission to use, modify, copy, and distribute    ***
    4 0000:             ; *** this software so long as this copyright notice is retained. ***
    5 0000:             ; *** This software may not be used in commercial applications    ***
    6 0000:             ; *** without express written permission from the author.         ***
    7 0000:             ; *******************************************************************
    8 0000:             
    9 0000:             ;[RLA] These are defined on the rcasm command line!
   10 0000:             ;[RLA] #define ELFOS            ; build the version that runs under Elf/OS
   11 0000:             ;[RLA] #define STGROM           ; build the STG EPROM version
   12 0000:             ;[RLA] #define PICOROM          ; define for Mike's PIcoElf version
   13 0000:             
   14 0000:             ;[RLA]   rcasm doesn't have any way to do a logical "OR" of assembly
   15 0000:             ;[RLA] options, so define a master "ANYROM" option that's true for
   16 0000:             ;[RLA] any of the ROM conditions...
   17 0000:             
            #endif
   32 0000:             
            #endif
   47 0000:             
            #ifdef STGROM
            #define ANYROM
   50 0000:             ;[RLA] STG ROM addresses and options
   51 0000:             include config.inc
   52 0000:             ; DO NOT EDIT THIS FILE - EDIT CONFIG. INSTEAD!!
            #define BOOTS	 08000H
            #define WARMB	 (08000H+3)
            #define HELP	 09400H
            #define RAMPAGE	 07F00H
            #define BIOS	 0FF00H
            #define EBIOS	 0F800H
            #define FORTH	 0D700H
            #define EDTASM	 09C00H
            #define BASIC	 0BA00H
            #define VISUAL	 0A900H
            #define XMODEM	 0D400H
            #define CODE     EDTASM
            #define DATA     01000h
   66 0000:             ;[RLA] XMODEM entry vectors for the STG EPROM ...
   67 0000:             xopenw:    equ     XMODEM + 0*3
   68 0000:             xopenr:    equ     XMODEM + 1*3
   69 0000:             xread:     equ     XMODEM + 2*3
   70 0000:             xwrite:    equ     XMODEM + 3*3
   71 0000:             xclosew:   equ     XMODEM + 4*3
   72 0000:             xcloser:   equ     XMODEM + 5*3
   73 0000:             exitaddr:  equ     08003h
   74 0000:             ;[RLA]   The symbol "visual" defines the entry point to Visual/02 in the EPROM.
   75 0000:             ;[RLA] With the STG ROM we don't have to worry about this, because the config
   76 0000:             ;[RLA] defines this entry.  Actually there's a minor kludge - config actually
   77 0000:             ;[RLA] defines "VISUAL" (upper case) and EDTASM wants "visual" (lower case) but
   78 0000:             ;[RLA] the rcasm preprocessor is case insensitive.  If that ever changes,
   79 0000:             ;[RLA] uncomment the following line ...
   80 0000:             ;;visual:    equ     VISUAL
   81 0000:             ;[RLA]   "visualds" is the address of the Visual/02 data segment.  It's always
   82 0000:             ;[RLA] the page just below the STGROM monitor's page ..
   83 0000:             visualds:  equ     RAMPAGE-0100h
            #endif
   85 0000:             
   86 0000:             include    bios.inc
   87 0000:             ; *******************************************************************
   88 0000:             ; *** This software is copyright 2006 by Michael H Riley          ***
   89 0000:             ; *** You have permission to use, modify, copy, and distribute    ***
   90 0000:             ; *** this software so long as this copyright notice is retained. ***
   91 0000:             ; *** This software may not be used in commercial applications    ***
   92 0000:             ; *** without express written permission from the author.         ***
   93 0000:             ; *******************************************************************
   94 0000:             
            #endif
   98 0000:             
   99 0000:             ; Define address for standard BIOS vectors
            #endif
  103 0000:             
  104 0000:             ; Define address for extended BIOS vectors
            #endif
  108 0000:             
            #ifndef TASM
  110 0000:             scall:      equ  r4                    ; register for SCALL
  111 0000:             sret:       equ  r5                    ; register for SRET
  112 0000:             
  113 0000:             call:       equ  0ffe0h                ; depricated
  114 0000:             ret:        equ  0fff1h                ; depricated
            #endif
  116 0000:             
  117 0000:             f_boot:     equ  (BIOS+00h)            ; boot from ide device
  118 0000:             f_type:     equ  (BIOS+03h)            ; type 1 character to console
  119 0000:             f_read:     equ  (BIOS+06h)            ; read 1 character from console
  120 0000:             f_msg:      equ  (BIOS+09h)            ; type asciiz string to console
  121 0000:             f_typex:    equ  (BIOS+0ch)            ; depricated, just returns now
  122 0000:             f_input:    equ  (BIOS+0fh)            ; read asciiz from console
  123 0000:             f_strcmp:   equ  (BIOS+12h)            ; compare 2 strings
  124 0000:             f_ltrim:    equ  (BIOS+15h)            ; trim leading spaces
  125 0000:             f_strcpy:   equ  (BIOS+18h)            ; copy an asciiz string
  126 0000:             f_memcpy:   equ  (BIOS+1bh)            ; copy memory
  127 0000:             f_wrtsec:   equ  (BIOS+1eh)            ; write floppy sector (depricated)
  128 0000:             f_rdsec:    equ  (BIOS+21h)            ; read floppy sector (depricated)
  129 0000:             f_seek0:    equ  (BIOS+24h)            ; floppy seek to track 0 (depricated)
  130 0000:             f_seek:     equ  (BIOS+27h)            ; floopy track seek (depricated)
  131 0000:             f_drive:    equ  (BIOS+2ah)            ; select floppy drive (depricated)
  132 0000:             f_setbd:    equ  (BIOS+2dh)            ; set console baud rate
  133 0000:             f_mul16:    equ  (BIOS+30h)            ; 16-bit multiply
  134 0000:             f_div16:    equ  (BIOS+33h)            ; 16-bit division
  135 0000:             f_idereset: equ  (BIOS+36h)            ; reset ide device
  136 0000:             f_idewrite: equ  (BIOS+39h)            ; write ide sector
  137 0000:             f_ideread:  equ  (BIOS+3ch)            ; read ide sector
  138 0000:             f_initcall: equ  (BIOS+3fh)            ; initialize R4 and R5
  139 0000:             f_bootide:  equ  (BIOS+42h)            ; boot from ide device
  140 0000:             f_hexin:    equ  (BIOS+45h)            ; convert ascii number to hex
  141 0000:             f_hexout2:  equ  (BIOS+48h)            ; convert hex to 2-digit ascii
  142 0000:             f_hexout4:  equ  (BIOS+4bh)            ; convert hex to 4-digit ascii
  143 0000:             f_tty:      equ  (BIOS+4eh)            ; type character to console
  144 0000:             f_mover:    equ  (BIOS+51h)            ; program relocator
  145 0000:             f_minimon:  equ  (BIOS+54h)            ; mini monitor
  146 0000:             f_freemem:  equ  (BIOS+57h)            ; determine memory size
  147 0000:             F_isnum:    equ  (BIOS+5ah)            ; determine if D is numeric
  148 0000:             f_atoi:     equ  (BIOS+5dh)            ; convert ascii to integer
  149 0000:             f_uintout:  equ  (BIOS+60h)            ; convert unsigned integer to ascii
  150 0000:             f_intout:   equ  (BIOS+63h)            ; convert signed integer to ascii
  151 0000:             f_inmsg:    equ  (BIOS+66h)            ; type in-line message
  152 0000:             f_inputl:   equ  (BIOS+69h)            ; read limited line from console
  153 0000:             f_brktest:  equ  (BIOS+6ch)            ; check for serial break
  154 0000:             f_findtkn:  equ  (BIOS+6fh)            ; find token in a token table
  155 0000:             f_isalpha:  equ  (BIOS+72h)            ; determine if D is alphabetic
  156 0000:             f_ishex:    equ  (BIOS+75h)            ; determine if D is hexadecimal
  157 0000:             f_isalnum:  equ  (BIOS+78h)            ; determine if D is alpha or numeric
  158 0000:             f_idnum:    equ  (BIOS+7bh)            ; determine type of ascii number
  159 0000:             f_isterm:   equ  (BIOS+7eh)            ; determine if D is a termination char
  160 0000:             f_getdev:   equ  (BIOS+81h)            ; get supported devices
  161 0000:             
  162 0000:             f_version:  equ  (BIOS+0f9h)           ; 3 bytes holding bios version number
  163 0000:             
  164 0000:             ; "Extended" BIOS vectors
  165 0000:             
  166 0000:             f_bread:     equ  (EBIOS+00h)        ; read from onboard serial port
  167 0000:             f_btype:     equ  (EBIOS+03h)        ; write to onboard serial port
  168 0000:             f_btest:     equ  (EBIOS+06h)        ; test onboard serial port
  169 0000:             f_utype:     equ  (EBIOS+09h)        ; write to disk board UART
  170 0000:             f_uread:     equ  (EBIOS+0ch)        ; read from disk board UART
  171 0000:             f_utest:     equ  (EBIOS+0fh)        ; test disk board UART
  172 0000:             f_usetbd:    equ  (EBIOS+12h)        ; set disk board UART baud rate and format
  173 0000:             f_gettod:    equ  (EBIOS+15h)        ; read time of day clock
  174 0000:             f_settod:    equ  (EBIOS+18h)        ; set time of day clock
  175 0000:             f_rdnvr:     equ  (EBIOS+1bh)        ; read non volatile RAM
  176 0000:             f_wrnvr:     equ  (EBIOS+1eh)        ; write non volatile RAM
  177 0000:             f_idesize:   equ  (EBIOS+21h)        ; return size of attached IDE drive(s)
  178 0000:             f_ideid:     equ  (EBIOS+24h)        ; return device data for IDE drive(s)
  179 0000:             f_tmtoas:    equ  (EBIOS+2ah)        ; time to ASCII string
  180 0000:             f_dttoas:    equ  (EBIOS+27h)        ; date to ASCII string
  181 0000:             f_rtctest:   equ  (EBIOS+2dh)        ; test size and presence of RTC/NVR
  182 0000:             f_astodt:    equ  (EBIOS+30h)        ; convert ASCII string to date
  183 0000:             f_astotm:    equ  (EBIOS+33h)        ; convert ASCII string to time
  184 0000:             f_nvrcchk:   equ  (EBIOS+36h)	    ; [RLA] compute NVR checksum
  185 0000:             
  186 0000:             
  187 0000:             
  188 0000:             ; RA - text buffer pointer
  189 0000:             ; R8 - Reg1 (line number)
  190 0000:             ; R9 - Reg2 (count)
  191 0000:             
  192 0000:                        org     CODE
  193 9c00:             
            #ifdef ANYROM
  195 9c00: c0 9c 06               lbr     pico1
  196 9c03: c0 9c 0f               lbr     pico2
  197 9c06: f8 f9 af f8 
            11 bf       pico1:     mov     rf,textbuf          ; zero edit buffer
  198 9c0c: f8 00                  ldi     0
  199 9c0e: 5f                     str     rf
  200 9c0f: f8 04 af f8 
            10 bf       pico2:     mov     rf,curline
  201 9c15: f8 00                  ldi     0
  202 9c17: 5f                     str     rf
  203 9c18: 1f                     inc     rf
  204 9c19: 5f                     str     rf
  205 9c1a: f8 00 af f8 
            10 bf                  mov     rf,baud             ; need to write baud constant
  206 9c20: 9e                     ghi     re                  ; get baud constant
  207 9c21: 5f                     str     rf                  ; and store it
  208 9c22: f8 f0 a6 f8 
            9c b6                  mov     r6,restart          ; restart address
  209 9c28: f8 f7 a2 f8 
            11 b2                  mov     r2,stack            ; set stack
  210 9c2e: e2                     sex     r2                  ; point x to stack
  211 9c2f: c0 ff 3f               lbr     f_initcall          ; and setup SCALL/SRET
            #endif
  226 9c32:             
  227 9c32: f8 9c       cold:      ldi     high start          ; get start address
  228 9c34: b6                     phi     r6
  229 9c35: f8 d5                  ldi     low start
  230 9c37: a6                     plo     r6
  231 9c38: f8 11                  ldi     high stack          ; set initial stack frame
  232 9c3a: b2                     phi     r2
  233 9c3b: f8 f7                  ldi     low stack
  234 9c3d: a2                     plo     r2
  235 9c3e: e2                     sex     r2
  236 9c3f: c0 ff 3f               lbr     f_initcall
  237 9c42:             
  238 9c42: f8 a0       docrlf:    ldi     high crlf           ; display a crlf
  239 9c44: bf                     phi     rf
  240 9c45: f8 37                  ldi     low crlf
  241 9c47: af                     plo     rf
  242 9c48: d4                     sep     scall
  243 9c49: ff 09                  dw      f_msg
  244 9c4b: d5                     sep     sret
  245 9c4c:             
  246 9c4c:             ; *** Check if character is uppercase alpha
  247 9c4c:             ; *** D - char to check
  248 9c4c:             ; *** Returns DF=1 if numeric
  249 9c4c:             ; ***         DF=0 if not
  250 9c4c: e2          isuc:      sex     r2                  ; be sure x points to stack
  251 9c4d: 73                     stxd                        ; save number
  252 9c4e: ff 41                  smi     'A'                 ; check for bottom of numbers
  253 9c50: 3b 59                  bnf     isnotuc             ; jump if not a number
  254 9c52: ff 1b                  smi     27                  ; check high end
  255 9c54: 33 59                  bdf     isnotuc             ; jump if not a number
  256 9c56: f8 01                  ldi     1                   ; numer is numeric
  257 9c58: c8                     lskp
  258 9c59: f8 00       isnotuc:   ldi     0                   ; signal not a number
  259 9c5b: f6                     shr                         ; shift result into DF
  260 9c5c: 60                     irx                         ; recover original value
  261 9c5d: f0                     ldx
  262 9c5e: d5                     sep     sret                ; and return to caller
  263 9c5f:             
  264 9c5f:             ; *** Check if character is lowercase alpha
  265 9c5f:             ; *** D - char to check
  266 9c5f:             ; *** Returns DF=1 if numeric
  267 9c5f:             ; ***         DF=0 if not
  268 9c5f: e2          islc:      sex     r2                  ; be sure x points to stack
  269 9c60: 73                     stxd                        ; save number
  270 9c61: ff 61                  smi     'a'                 ; check for bottom of numbers
  271 9c63: 3b 6c                  bnf     isnotlc             ; jump if not a number
  272 9c65: ff 1b                  smi     27                  ; check high end
  273 9c67: 33 6c                  bdf     isnotlc             ; jump if not a number
  274 9c69: f8 01                  ldi     1                   ; numer is numeric
  275 9c6b: c8                     lskp
  276 9c6c: f8 00       isnotlc:   ldi     0                   ; signal not a number
  277 9c6e: f6                     shr                         ; shift result into DF
  278 9c6f: 60                     irx                         ; recover original value
  279 9c70: f0                     ldx
  280 9c71: d5                     sep     sret                ; and return to caller
  281 9c72:             
  282 9c72:             
  283 9c72:             ; *** rf - pointer to ascii string
  284 9c72:             ; *** returns: rf - first non-numeric character
  285 9c72:             ; ***          RD - number
  286 9c72:             ; ***          DF = 1 if first character non-numeric
  287 9c72: f8 00       atoi:      ldi     0                   ; clear answer
  288 9c74: bd                     phi     rd
  289 9c75: ad                     plo     rd
  290 9c76: 0f                     ldn     rf                  ; get first value
  291 9c77: d4                     sep     scall               ; check if numeric
  292 9c78: a1 da                  dw      isnum
  293 9c7a: 3b 84                  bnf     atoicnt             ; jump if so
  294 9c7c: fb 2d                  xri     '-'                 ; check for minus
  295 9c7e: 32 84                  bz      atoicnt             ; jump if so
  296 9c80: f8 01                  ldi     1                   ; signal number error
  297 9c82: f6                     shr
  298 9c83: d5                     sep     sret                ; return to caller
  299 9c84: e2          atoicnt:   sex     r2                  ; make sure x points to stack
  300 9c85: 8c                     glo     rc                  ; save consumed registers
  301 9c86: 73                     stxd
  302 9c87: 9c                     ghi     rc
  303 9c88: 73                     stxd
  304 9c89: 8e                     glo     re
  305 9c8a: 73                     stxd
  306 9c8b: ae                     plo     re                  ; signify positive number
  307 9c8c: 0f                     ldn     rf                  ; get first bytr
  308 9c8d: fb 2d                  xri     '-'                 ; check for negative
  309 9c8f: 3a 95                  bnz     atoilp              ; jump if not negative
  310 9c91: f8 01                  ldi     1                   ; signify negative number
  311 9c93: ae                     plo     re
  312 9c94: 1f                     inc     rf                  ; move past - sign
  313 9c95: 0f          atoilp:    ldn     rf                  ; get byte from input
  314 9c96: ff 30                  smi     '0'                 ; convert to binary
  315 9c98: 3b c9                  bnf     atoidn              ; jump if below numbers
  316 9c9a: ff 0a                  smi     10                  ; check for above numbers
  317 9c9c: 33 c9                  bdf     atoidn              ; jump if above numbers
  318 9c9e: 8d                     glo     rd                  ; multiply by 2
  319 9c9f: ac                     plo     rc                  ; keep a copy
  320 9ca0: fe                     shl
  321 9ca1: ad                     plo     rd
  322 9ca2: 9d                     ghi     rd
  323 9ca3: bc                     phi     rc
  324 9ca4: 7e                     shlc
  325 9ca5: bd                     phi     rd
  326 9ca6: 8d                     glo     rd                  ; multiply by 4
  327 9ca7: fe                     shl
  328 9ca8: ad                     plo     rd
  329 9ca9: 9d                     ghi     rd
  330 9caa: 7e                     shlc
  331 9cab: bd                     phi     rd
  332 9cac: 8c                     glo     rc                  ; multiply by 5
  333 9cad: 52                     str     r2
  334 9cae: 8d                     glo     rd
  335 9caf: f4                     add
  336 9cb0: ad                     plo     rd
  337 9cb1: 9c                     ghi     rc
  338 9cb2: 52                     str     r2
  339 9cb3: 9d                     ghi     rd
  340 9cb4: f4                     add
  341 9cb5: bd                     phi     rd
  342 9cb6: 8d                     glo     rd                  ; multiply by 10
  343 9cb7: fe                     shl
  344 9cb8: ad                     plo     rd
  345 9cb9: 9d                     ghi     rd
  346 9cba: 7e                     shlc
  347 9cbb: bd                     phi     rd
  348 9cbc: 4f                     lda     rf                  ; get byte from buffer
  349 9cbd: ff 30                  smi     '0'                 ; convert to binary
  350 9cbf: 52                     str     r2                  ; prepare for addition
  351 9cc0: 8d                     glo     rd                  ; add in new digit
  352 9cc1: f4                     add
  353 9cc2: ad                     plo     rd
  354 9cc3: 9d                     ghi     rd
  355 9cc4: 7c 00                  adci    0
  356 9cc6: bd                     phi     rd
  357 9cc7: 30 95                  br      atoilp              ; loop back for next character
  358 9cc9: c4          atoidn:    nop
  359 9cca: 60                     irx                         ; recover consumed registers
  360 9ccb: 72                     ldxa
  361 9ccc: ae                     plo     re
  362 9ccd: 72                     ldxa
  363 9cce: bc                     phi     rc
  364 9ccf: f0                     ldx
  365 9cd0: ac                     plo     rc
  366 9cd1: f8 00                  ldi     0                   ; signal valid number
  367 9cd3: f6                     shr
  368 9cd4: d5                     sep     sret                ; return to caller
  369 9cd5:             
            #else
  380 9cd5: f8 11       start:     ldi     high stack          ; set initial stack frame
  381 9cd7: b2                     phi     r2
  382 9cd8: f8 f7                  ldi     low stack
  383 9cda: a2                     plo     r2
            #endif
  385 9cdb: f8 a6                  ldi     high hello          ; display startup message
  386 9cdd: bf                     phi     rf
  387 9cde: f8 50                  ldi     low hello
  388 9ce0: af                     plo     rf
  389 9ce1: d4                     sep     scall
  390 9ce2: ff 09                  dw      f_msg
  391 9ce4: f8 11                  ldi     high textbuf        ; point to text buffer
  392 9ce6: bf                     phi     rf
  393 9ce7: f8 f9                  ldi     low textbuf
  394 9ce9: af                     plo     rf
  395 9cea: f8 00                  ldi     0                   ; need terminator
  396 9cec: 5f                     str     rf
  397 9ced: c0 9f bc               lbr     newfile             ; jump if file does not exist
  398 9cf0:             
            #else
  411 9cf0: f8 11       restart:   ldi     high stack          ; set initial stack frame
  412 9cf2: b2                     phi     r2
  413 9cf3: f8 f7                  ldi     low stack
  414 9cf5: a2                     plo     r2
  415 9cf6: c0 9c f9               lbr     mainlp              ; back to editor
            #endif
  417 9cf9: d4          mainlp:    sep     scall               ; get current line number
  418 9cfa: 9f 90                  dw      getcurln
  419 9cfc: 18                     inc     r8
  420 9cfd: d4                     sep     scall               ; show current line
  421 9cfe: a0 15                  dw      printnum
  422 9d00: f8 a0                  ldi     high prompt         ; display the prompt
  423 9d02: bf                     phi     rf
  424 9d03: f8 5a                  ldi     low prompt
  425 9d05: af                     plo     rf
  426 9d06: d4                     sep     scall
  427 9d07: ff 09                  dw      f_msg
  428 9d09: f8 10                  ldi     high buffer         ; get input from user
  429 9d0b: bf                     phi     rf
  430 9d0c: f8 25                  ldi     low buffer
  431 9d0e: af                     plo     rf
  432 9d0f: d4                     sep     scall
  433 9d10: ff 0f                  dw      f_input
  434 9d12: d4                     sep     scall               ; do a cr/lf
  435 9d13: 9c 42                  dw      docrlf
  436 9d15: f8 00                  ldi     0                   ; clear registers
  437 9d17: b8                     phi     r8
  438 9d18: a8                     plo     r8 
  439 9d19: b9                     phi     r9
  440 9d1a: a9                     plo     r9
  441 9d1b: 19                     inc     r9                  ; set count to 1
  442 9d1c: d4                     sep     scall               ; set R8 to current line number
  443 9d1d: 9f 90                  dw      getcurln
  444 9d1f: f8 10                  ldi     high buffer         ; point back to buffer
  445 9d21: bf                     phi     rf
  446 9d22: f8 25                  ldi     low buffer
  447 9d24: af                     plo     rf
  448 9d25: d4                     sep     scall               ; try to get a number
  449 9d26: 9c 72                  dw      atoi
  450 9d28: c3 9d 30               lbdf    arg1non             ; jump if not numeric
  451 9d2b: 9d                     ghi     rd                  ; transfer to reg1
  452 9d2c: b8                     phi     r8
  453 9d2d: 8d                     glo     rd
  454 9d2e: a8                     plo     r8
  455 9d2f: 28                     dec     r8                  ; origin to zero
  456 9d30: 0f          arg1non:   ldn     rf                  ; get character in buffer
  457 9d31: fb 2c                  xri     ','                 ; look for a comma
  458 9d33: ca 9d 41               lbnz    noarg2              ; jump if no second arg
  459 9d36: 1f                     inc     rf                  ; point to next character
  460 9d37: d4                     sep     scall               ; and convert argument
  461 9d38: 9c 72                  dw      atoi
  462 9d3a: c3 9d 41               lbdf    noarg2              ; jump if no number supplied
  463 9d3d: 9d                     ghi     rd                  ; transfer argument to reg 2
  464 9d3e: b9                     phi     r9
  465 9d3f: 8d                     glo     rd
  466 9d40: a9                     plo     r9
  467 9d41: 0f          noarg2:    ldn     rf                  ; get command
  468 9d42: d4                     sep     scall               ; check if lc
  469 9d43: 9c 5f                  dw      islc
  470 9d45: cb 9d 4c               lbnf    noarg2_1            ; jump if not
  471 9d48: 0f                     ldn     rf                  ; convert to uppercase
  472 9d49: ff 20                  smi     32
  473 9d4b: 5f                     str     rf
  474 9d4c: 0f          noarg2_1:  ldn     rf                  ; get command
  475 9d4d: ff 41                  smi     'A'                 ; check for assemble command
  476 9d4f: c2 9d dd               lbz     doasm
  477 9d52: 0f                     ldn     rf
  478 9d53: ff 52                  smi     'R'                 ; check for run command
  479 9d55: c2 9d e3               lbz     run
  480 9d58: 0f                     ldn     rf
  481 9d59: ff 44                  smi     'D'                 ; check for down command
  482 9d5b: c2 9f 46               lbz     down
  483 9d5e: 0f                     ldn     rf                  ; get command
  484 9d5f: ff 4e                  smi     'N'                 ; check for new command
  485 9d61: c2 9d c6               lbz     new
  486 9d64: 0f                     ldn     rf                  ; get command
  487 9d65: ff 55                  smi     'U'                 ; check for up command
  488 9d67: c2 9f 19               lbz     up
  489 9d6a: 0f                     ldn     rf                  ; get command
  490 9d6b: ff 50                  smi     'P'                 ; check for print command
  491 9d6d: c2 9f 06               lbz     print
  492 9d70: 0f                     ldn     rf                  ; get command
  493 9d71: ff 49                  smi     'I'                 ; check for insert command
  494 9d73: c2 9e 50               lbz     insert
  495 9d76: 0f                     ldn     rf
  496 9d77: ff 54                  smi     'T'                 ; check for top command
  497 9d79: c2 9e 43               lbz     top
  498 9d7c: 0f                     ldn     rf                  ; get command
  499 9d7d: ff 42                  smi     'B'                 ; check for bottom command
  500 9d7f: c2 9e 3d               lbz     bottom
  501 9d82: 0f                     ldn     rf                  ; get command
  502 9d83: ff 4b                  smi     'K'                 ; check for kill command
  503 9d85: c2 9e 06               lbz     kill
  504 9d88: 0f                     ldn     rf                  ; get command
  505 9d89: ff 47                  smi     'G'                 ; check for go command
  506 9d8b: c2 9d f1               lbz     go
  507 9d8e: 0f                     ldn     rf                  ; quit command
  508 9d8f: ff 51                  smi     'Q'                 ; check for quit command
            #ifdef ANYROM
  510 9d91: c2 80 03               lbz     exitaddr
  511 9d94: 0f                     ldn     rf                  ; recover command
  512 9d95: ff 56                  smi     'V'                 ; check for visual/02
  513 9d97: c2 9d b2               lbz     visual02            ; jump if so
  514 9d9a: 0f                     ldn     rf                  ; recover command
  515 9d9b: ff 53                  smi     'S'                 ; see if save
  516 9d9d: c2 a5 b2               lbz     save                ; jump if so
  517 9da0: 0f                     ldn     rf                  ; recover command
  518 9da1: ff 4c                  smi     'L'                 ; see if save
  519 9da3: c2 a5 fb               lbz     load                ; jump if so
            #endif
  523 9da6:             
  524 9da6:             
  525 9da6: f8 a6                  ldi     high errmsg         ; display error
  526 9da8: bf                     phi     rf
  527 9da9: f8 9a                  ldi     low errmsg
  528 9dab: af                     plo     rf
  529 9dac: d4                     sep     scall               ; display message
  530 9dad: ff 09                  dw      f_msg
  531 9daf: c0 9c f9               lbr     mainlp
  532 9db2:               
            #ifdef ANYROM
  534 9db2: f8 10 a7 f8 
            10 b7       visual02:  mov     r7,startaddr        ; point to start address
  535 9db8: f8 00 af f8 
            7e bf                  mov     rf,visualds         ; point to visual/02 data segment
  536 9dbe: 47                     lda     r7                  ; retrieve high byte of start address
  537 9dbf: 5f                     str     rf                  ; store into visual/02 R[0]
  538 9dc0: 1f                     inc     rf
  539 9dc1: 47                     lda     r7                  ; get low byte
  540 9dc2: 5f                     str     rf
  541 9dc3: c0 a9 03               lbr     visual+3
            #endif
  543 9dc6: f8 11       new:       ldi     high textbuf        ; need to set terminator in text buffer
  544 9dc8: bf                     phi     rf
  545 9dc9: f8 f9                  ldi     low textbuf
  546 9dcb: af                     plo     rf
  547 9dcc: f8 00                  ldi     0
  548 9dce: 5f                     str     rf
  549 9dcf: f8 10                  ldi     high curline        ; point to current line
  550 9dd1: bf                     phi     rf
  551 9dd2: f8 04                  ldi     low curline
  552 9dd4: af                     plo     rf
  553 9dd5: f8 00                  ldi     0                   ; set at beginning
  554 9dd7: 5f                     str     rf
  555 9dd8: 1f                     inc     rf
  556 9dd9: 5f                     str     rf
  557 9dda: c0 9f bc               lbr     newfile             ; then display as new
  558 9ddd:             
  559 9ddd: d4          doasm:     sep     scall               ; invoke the assembler
  560 9dde: a0 5e                  dw      assemble
  561 9de0: c0 9c f9               lbr     mainlp              ; then back to main loop
  562 9de3:             
  563 9de3: f8 10       run:       ldi     high startaddr      ; get start address of program
  564 9de5: bf                     phi     rf
  565 9de6: f8 10                  ldi     low startaddr
  566 9de8: af                     plo     rf
  567 9de9: 4f                     lda     rf                  ; set start address in R0
  568 9dea: b0                     phi     r0
  569 9deb: 4f                     lda     rf
  570 9dec: a0                     plo     r0
  571 9ded: d0                     sep     r0                  ; transfer control to program
  572 9dee: c0 9c f9               lbr     mainlp              ; back to main
  573 9df1:             
  574 9df1:             ; ****************************
  575 9df1:             ; *** Go to specified line ***
  576 9df1:             ; *** R8 - line to go to   ***
  577 9df1:             ; ****************************
  578 9df1: d4          go:        sep     scall               ; set line number
  579 9df2: 9f 9b                  dw      setcurln
  580 9df4: d4                     sep     scall               ; find line 
  581 9df5: 9f cf                  dw      findline
  582 9df7: cb 9e 00               lbnf    gocont              ; jump if a valid line
  583 9dfa: d4                     sep     scall               ; find end of buffer
  584 9dfb: 9f f9                  dw      findend
  585 9dfd: d4                     sep     scall               ; set as current line
  586 9dfe: 9f 9b                  dw      setcurln
  587 9e00: d4          gocont:    sep     scall               ; print the line
  588 9e01: 9f 65                  dw      printit
  589 9e03: c0 9c f9               lbr     mainlp              ; return to main loop
  590 9e06:             
  591 9e06:             ; ***************************************
  592 9e06:             ; *** Delete current line from buffer ***
  593 9e06:             ; ***************************************
  594 9e06: d4          kill:      sep     scall               ; check if exists
  595 9e07: 9f cf                  dw      findline
  596 9e09: c3 9e 34               lbdf    killquit
  597 9e0c: 9a                     ghi     ra                  ; save dest pointer
  598 9e0d: bd                     phi     rd
  599 9e0e: 8a                     glo     ra
  600 9e0f: ad                     plo     rd
  601 9e10: d4                     sep     scall               ; move to specified line
  602 9e11: 9f 9b                  dw      setcurln
  603 9e13: 89                     glo     r9                  ; calc source pointer
  604 9e14: 52                     str     r2
  605 9e15: 88                     glo     r8
  606 9e16: f4                     add
  607 9e17: a8                     plo     r8
  608 9e18: 99                     ghi     r9
  609 9e19: 52                     str     r2
  610 9e1a: 98                     ghi     r8
  611 9e1b: 7c 00                  adci    0
  612 9e1d: b8                     phi     r8
  613 9e1e: d4                     sep     scall               ; get address for line
  614 9e1f: 9f cf                  dw      findline
  615 9e21: 0a          killline:  ldn     ra                  ; get length to next line
  616 9e22: c2 9e 33               lbz     killdone
  617 9e25: fc 01                  adi     1
  618 9e27: ac                     plo     rc
  619 9e28: 4a          killloop:  lda     ra                  ; get source byte
  620 9e29: 5d                     str     rd                  ; place into destintion
  621 9e2a: 1d                     inc     rd
  622 9e2b: 2c                     dec     rc                  ; decrement count
  623 9e2c: 8c                     glo     rc                  ; get count
  624 9e2d: ca 9e 28               lbnz    killloop            ; loop until line is done
  625 9e30: c0 9e 21               lbr     killline            ; and loop for next line
  626 9e33: 5d          killdone:  str     rd
  627 9e34: d4          killquit:  sep     scall               ; move to specified line
  628 9e35: 9f 90                  dw      getcurln
  629 9e37: d4                     sep     scall               ; display new line
  630 9e38: 9f 65                  dw      printit
  631 9e3a: c0 9c f9               lbr     mainlp              ; and back to main
  632 9e3d:             
  633 9e3d:             ; ********************
  634 9e3d:             ; *** Return to OS ***
  635 9e3d:             ; ********************
  636 9e3d:             
  637 9e3d:             ; ********************************
  638 9e3d:             ; *** Move to bottom of buffer ***
  639 9e3d:             ; ********************************
  640 9e3d: d4          bottom:    sep     scall               ; get last line number
  641 9e3e: 9f f9                  dw      findend
  642 9e40: c0 9e 47               lbr     topset              ; and set it
  643 9e43:             
  644 9e43:             ; *****************************
  645 9e43:             ; *** Move to top of buffer ***
  646 9e43:             ; *****************************
  647 9e43: f8 00       top:       ldi     0                   ; set line couunter to first line
  648 9e45: b8                     phi     r8
  649 9e46: a8                     plo     r8
  650 9e47: d4          topset:    sep     scall
  651 9e48: 9f 9b                  dw      setcurln
  652 9e4a: d4                     sep     scall               ; display top line
  653 9e4b: 9f 65                  dw      printit
  654 9e4d: c0 9c f9               lbr     mainlp              ; then back to main loop
  655 9e50:             
  656 9e50:             ; *******************************
  657 9e50:             ; *** Insert text into buffer ***
  658 9e50:             ; *******************************
  659 9e50: 1f          insert:    inc     rf                  ; point to text to insert
  660 9e51: d4                     sep     scall               ; set current line
  661 9e52: 9f 9b                  dw      setcurln
  662 9e54: 0f                     ldn     rf                  ; see if multi-line insert
  663 9e55: ca 9e 84               lbnz    insert1             ; only 1 line to insert
  664 9e58: d4          insertm:   sep     scall               ; get current line number
  665 9e59: 9f 90                  dw      getcurln
  666 9e5b: 18                     inc     r8
  667 9e5c: d4                     sep     scall               ; show current line
  668 9e5d: a0 15                  dw      printnum
  669 9e5f: f8 3a                  ldi     ':'                 ; print a colon
  670 9e61: d4                     sep     scall 
  671 9e62: ff 03                  dw      f_type
  672 9e64: f8 10                  ldi     high buffer         ; get input from user
  673 9e66: bf                     phi     rf
  674 9e67: f8 25                  ldi     low buffer
  675 9e69: af                     plo     rf
  676 9e6a: d4                     sep     scall
  677 9e6b: ff 0f                  dw      f_input
  678 9e6d: 7e                     shlc                        ; save return flag
  679 9e6e: 73                     stxd
  680 9e6f: d4                     sep     scall               ; do a cr/lf
  681 9e70: 9c 42                  dw      docrlf
  682 9e72: 60                     irx                         ; recover return flag
  683 9e73: f0                     ldx
  684 9e74: f6                     shr
  685 9e75: c3 9c f9               lbdf    mainlp              ; back to main of <CTRL><C> pressed
  686 9e78: f8 10                  ldi     high buffer         ; point to input
  687 9e7a: bf                     phi     rf
  688 9e7b: f8 25                  ldi     low buffer
  689 9e7d: af                     plo     rf
  690 9e7e: d4                     sep     scall               ; insert the line
  691 9e7f: 9e 8a                  dw      insertln
  692 9e81: c0 9e 58               lbr     insertm
  693 9e84:             
  694 9e84: d4          insert1:   sep     scall               ; insert the line
  695 9e85: 9e 8a                  dw      insertln
  696 9e87: c0 9c f9               lbr     mainlp              ; back to main loop
  697 9e8a:             
  698 9e8a:             
  699 9e8a: f8 00       insertln:  ldi     0                   ; setup count
  700 9e8c: ac                     plo     rc
  701 9e8d: bc                     phi     rc
  702 9e8e: 8f                     glo     rf                  ; save buffer position
  703 9e8f: 73                     stxd
  704 9e90: 9f                     ghi     rf
  705 9e91: 73                     stxd
  706 9e92: 1c          insertlp1: inc     rc                  ; increment count
  707 9e93: 4f          	   lda     rf                  ; get next byte
  708 9e94: ff 09       	   smi     9                   ; allow tab
  709 9e96: 32 92       	   bz      insertlp1
  710 9e98: 2f          	   dec     rf
  711 9e99: 4f          	   lda     rf
  712 9e9a: ff 20       	   smi     32                  ; look for anything less than a space
  713 9e9c:             
  714 9e9c: c3 9e 92               lbdf    insertlp1
  715 9e9f: 8c                     glo     rc                  ; get count
  716 9ea0: 73                     stxd                        ; and save it
  717 9ea1: 1c                     inc     rc
  718 9ea2: 1c                     inc     rc
  719 9ea3: d4                     sep     scall               ; find end of buffer
  720 9ea4: 9f f9                  dw      findend
  721 9ea6: 8c                     glo     rc                  ; add in count to get destination
  722 9ea7: 52                     str     r2
  723 9ea8: 8a                     glo     ra
  724 9ea9: a9                     plo     r9
  725 9eaa: f4                     add
  726 9eab: ad                     plo     rd
  727 9eac: 9c                     ghi     rc
  728 9ead: 52                     str     r2
  729 9eae: 9a                     ghi     ra
  730 9eaf: b9                     phi     r9
  731 9eb0: 74                     adc
  732 9eb1: bd                     phi     rd
  733 9eb2: 9d                     ghi     rd
  734 9eb3: fc 01                  adi     1
  735 9eb5: bd                     phi     rd
  736 9eb6: 99                     ghi     r9
  737 9eb7: fc 01                  adi     1
  738 9eb9: b9                     phi     r9
  739 9eba: d4                     sep     scall               ; get current line number
  740 9ebb: 9f 90                  dw      getcurln
  741 9ebd: d4                     sep     scall               ; find address of line
  742 9ebe: 9f cf                  dw      findline
  743 9ec0: 09          insertlp2: ldn     r9                  ; read source byte
  744 9ec1: 5d                     str     rd                  ; place into destination
  745 9ec2: 8a                     glo     ra                  ; check for completion
  746 9ec3: 52                     str     r2
  747 9ec4: 89                     glo     r9
  748 9ec5: f7                     sm
  749 9ec6: ca 9e d3               lbnz    inslp2c
  750 9ec9: 9a                     ghi     ra                  ; check for completion
  751 9eca: 52                     str     r2
  752 9ecb: 99                     ghi     r9
  753 9ecc: f7                     sm
  754 9ecd: ca 9e d3               lbnz    inslp2c
  755 9ed0: c0 9e d8               lbr     inslp2d
  756 9ed3: 29          inslp2c:   dec     r9                  ; decrement positions
  757 9ed4: 2d                     dec     rd
  758 9ed5: c0 9e c0               lbr     insertlp2
  759 9ed8: d4          inslp2d:   sep     scall               ; get current line number
  760 9ed9: 9f 90                  dw      getcurln
  761 9edb: d4                     sep     scall               ; find address of line
  762 9edc: 9f cf                  dw      findline
  763 9ede: 60                     irx                         ; recover count
  764 9edf: 72                     ldxa
  765 9ee0: fc 01                  adi     1
  766 9ee2: 5a                     str     ra                  ; store into buffer
  767 9ee3: ff 01                  smi     1
  768 9ee5: 1a                     inc     ra
  769 9ee6: ac                     plo     rc                  ; put into count
  770 9ee7: 2c                     dec     rc                  ; subract out length byte
  771 9ee8: 72                     ldxa                        ; recover input buffer
  772 9ee9: bf                     phi     rf
  773 9eea: f0                     ldx
  774 9eeb: af                     plo     rf
  775 9eec: 8c          insertlp3: glo     rc                  ; get count
  776 9eed: c2 9e f7               lbz     insertdn            ; jump if done
  777 9ef0: 4f                     lda     rf                  ; get byte from input
  778 9ef1: 5a                     str     ra                  ; store into text buffer
  779 9ef2: 1a                     inc     ra
  780 9ef3: 2c                     dec     rc                  ; decrement count
  781 9ef4: c0 9e ec               lbr     insertlp3           ; loop back until done
  782 9ef7: f8 0d       insertdn:  ldi     13                  ; place in a cr/lf
  783 9ef9: 5a                     str     ra
  784 9efa: 1a                     inc     ra
  785 9efb: f8 0a                  ldi     10
  786 9efd: 5a                     str     ra
  787 9efe: d4                     sep     scall               ; get current line number
  788 9eff: 9f 90                  dw      getcurln
  789 9f01: 18                     inc     r8                  ; increment it
  790 9f02: d4                     sep     scall               ; and write it back
  791 9f03: 9f 9b                  dw      setcurln
  792 9f05: d5                     sep     sret                ; return to caller
  793 9f06:             
  794 9f06:             ; *******************************
  795 9f06:             ; *** Print lines from buffer ***
  796 9f06:             ; *******************************
  797 9f06: 89          print:     glo     r9                  ; check count
  798 9f07: ca 9f 11               lbnz    printgo             ; jump if more lines
  799 9f0a: 99                     ghi     r9                  ; check high byte as well
  800 9f0b: ca 9f 11               lbnz    printgo
  801 9f0e: c0 9c f9               lbr     mainlp              ; done, so return to main loop
  802 9f11: d4          printgo:   sep     scall               ; print current line
  803 9f12: 9f 65                  dw      printit
  804 9f14: 18                     inc     r8                  ; increment line number
  805 9f15: 29                     dec     r9                  ; decrement count
  806 9f16: c0 9f 06               lbr     print               ; loop back for more
  807 9f19:                       
  808 9f19:             ; *****************************
  809 9f19:             ; *** Move up in the buffer ***
  810 9f19:             ; *****************************
  811 9f19: 89          up:        glo     r9                  ; check count
  812 9f1a: ca 9f 27               lbnz    upgo1
  813 9f1d: 99                     ghi     r9
  814 9f1e: ca 9f 27               lbnz    upgo1
  815 9f21: d4                     sep     scall               ; print new line
  816 9f22: 9f 65                  dw      printit
  817 9f24: c0 9c f9               lbr     mainlp
  818 9f27: d4          upgo1:     sep     scall               ; get current line number
  819 9f28: 9f 90                  dw      getcurln
  820 9f2a: 88                     glo     r8                  ; make sure it is not already 0
  821 9f2b: ca 9f 3e               lbnz    upgo                ; jump if good
  822 9f2e: 98                     ghi     r8
  823 9f2f: ca 9f 3e               lbnz    upgo
  824 9f32: f8 a0                  ldi     high topmsg         ; display top of buffer message
  825 9f34: bf                     phi     rf
  826 9f35: f8 4a                  ldi     low topmsg
  827 9f37: af                     plo     rf
  828 9f38: d4                     sep     scall               ; display message
  829 9f39: ff 09                  dw      f_msg
  830 9f3b: c0 9c f9               lbr     mainlp
  831 9f3e: 28          upgo:      dec     r8                  ; decrement line count
  832 9f3f: d4                     sep     scall               ; write new line number
  833 9f40: 9f 9b                  dw      setcurln
  834 9f42: 29                     dec     r9                  ; decrement count
  835 9f43: c0 9f 19               lbr     up                  ; and loop back for more
  836 9f46:             
  837 9f46:             ; *******************************
  838 9f46:             ; *** Move down in the buffer ***
  839 9f46:             ; *******************************
  840 9f46: 89          down:      glo     r9                  ; check count
  841 9f47: ca 9f 54               lbnz    downgo
  842 9f4a: 99                     ghi     r9
  843 9f4b: ca 9f 54               lbnz    downgo
  844 9f4e: d4                     sep     scall               ; print new line
  845 9f4f: 9f 65                  dw      printit
  846 9f51: c0 9c f9               lbr     mainlp
  847 9f54: d4          downgo:    sep     scall               ; get current line number
  848 9f55: 9f 90                  dw      getcurln
  849 9f57: 18                     inc     r8                  ; add 1 to count
  850 9f58: d4                     sep     scall               ; see if it is valid
  851 9f59: 9f cf                  dw      findline
  852 9f5b: c3 9f b0               lbdf    eoberror            ; jump if it moves past end
  853 9f5e: d4                     sep     scall               ; write new line number
  854 9f5f: 9f 9b                  dw      setcurln
  855 9f61: 29                     dec     r9                  ; decrement count
  856 9f62: c0 9f 46               lbr     down                ; loop back for more
  857 9f65:             
  858 9f65:             ; *********************************
  859 9f65:             ; *** Print specified line      ***
  860 9f65:             ; *** R8 - Line number to print ***
  861 9f65:             ; *********************************
  862 9f65: d4          printit:   sep     scall               ; set buffer position
  863 9f66: 9f cf                  dw      findline
  864 9f68: cb 9f 6c               lbnf    printitgo           ; jump if line exists
  865 9f6b: d5                     sep     sret                ; otherwise just return
  866 9f6c: 18          printitgo: inc     r8                  ; output origin is 1
  867 9f6d: d4                     sep     scall               ; print the line number
  868 9f6e: a0 15                  dw      printnum
  869 9f70: 28                     dec     r8                  ; reorigin to zero
  870 9f71: f8 a0                  ldi     high colon          ; now the colon after the number
  871 9f73: bf                     phi     rf
  872 9f74: f8 5c                  ldi     low colon
  873 9f76: af                     plo     rf
  874 9f77: d4                     sep     scall
  875 9f78: ff 09                  dw      f_msg
  876 9f7a: 4a                     lda     ra                  ; get byte count
  877 9f7b: ac                     plo     rc                  ; place into count register
  878 9f7c: c2 9f 8c               lbz     printend            ; jump if have last line of buffer
  879 9f7f: 8c          printlp:   glo     rc                  ; see if done
  880 9f80: c2 9f 8b               lbz     printdn             ; jump if so
  881 9f83: 4a                     lda     ra                  ; otherwise get byte
  882 9f84: d4                     sep     scall               ; and display it
  883 9f85: ff 03                  dw      f_type
  884 9f87: 2c                     dec     rc                  ; decrement count
  885 9f88: c0 9f 7f               lbr     printlp
  886 9f8b: d5          printdn:   sep     sret                ; return to caller
  887 9f8c: d4          printend:  sep     scall               ; print a final CR/LF
  888 9f8d: 9c 42                  dw      docrlf
  889 9f8f: d5                     sep     sret                ; and return to caller
  890 9f90:             
  891 9f90:             ; *****************************************
  892 9f90:             ; *** Get current line number           ***
  893 9f90:             ; *** Returns: R8 - current line number ***
  894 9f90:             ; *****************************************
  895 9f90: f8 10       getcurln:  ldi     high curline        ; point to current line
  896 9f92: bf                     phi     rf
  897 9f93: f8 04                  ldi     low curline
  898 9f95: af                     plo     rf
  899 9f96: 4f                     lda     rf                  ; get current line number
  900 9f97: b8                     phi     r8
  901 9f98: 4f                     lda     rf
  902 9f99: a8                     plo     r8
  903 9f9a: d5                     sep     sret                ; and return
  904 9f9b:             
  905 9f9b:             ; *******************************************
  906 9f9b:             ; *** Set current line to specified value ***
  907 9f9b:             ; *** R8 - Line number to set as current  ***
  908 9f9b:             ; *******************************************
  909 9f9b: 8f          setcurln:  glo     rf                  ; save consumed register
  910 9f9c: 73                     stxd
  911 9f9d: 9f                     ghi     rf
  912 9f9e: 73                     stxd
  913 9f9f: f8 10                  ldi     high curline        ; point to current line
  914 9fa1: bf                     phi     rf
  915 9fa2: f8 04                  ldi     low curline
  916 9fa4: af                     plo     rf
  917 9fa5: 98                     ghi     r8                  ; write new current line
  918 9fa6: 5f                     str     rf
  919 9fa7: 1f                     inc     rf
  920 9fa8: 88                     glo     r8
  921 9fa9: 5f                     str     rf
  922 9faa: 60                     irx                         ; recover consumed register
  923 9fab: 72                     ldxa
  924 9fac: bf                     phi     rf
  925 9fad: f0                     ldx
  926 9fae: af                     plo     rf
  927 9faf: d5                     sep     sret                ; and return
  928 9fb0:              
  929 9fb0:             ; ***********************************
  930 9fb0:             ; *** Display end of buffer error ***
  931 9fb0:             ; ***********************************
  932 9fb0: f8 a0       eoberror:  ldi     high endmsg         ; point to end of buffer message
  933 9fb2: bf                     phi     rf
  934 9fb3: f8 3a                  ldi     low endmsg
  935 9fb5: af                     plo     rf
  936 9fb6: d4                     sep     scall               ; display it
  937 9fb7: ff 09                  dw      f_msg
  938 9fb9: c0 9c f9               lbr     mainlp              ; then back to main loop
  939 9fbc:             
  940 9fbc:             ; ********************************
  941 9fbc:             ; *** Display new file message ***
  942 9fbc:             ; ********************************
  943 9fbc: f8 a0       newfile:   ldi     high newmsg         ; display message indicating new file
  944 9fbe: bf                     phi     rf
  945 9fbf: f8 2f                  ldi     low newmsg
  946 9fc1: af                     plo     rf
  947 9fc2: d4                     sep     scall               ; display the message
  948 9fc3: ff 09                  dw      f_msg
  949 9fc5: f8 00                  ldi     0                   ; set initial line number
  950 9fc7: a8                     plo     r8
  951 9fc8: b8                     phi     r8
  952 9fc9: d4                     sep     scall
  953 9fca: 9f 9b                  dw      setcurln
  954 9fcc: c0 9c f9               lbr     mainlp              ; branch to main loop
  955 9fcf:             
  956 9fcf:             ; *************************************
  957 9fcf:             ; *** Find line in text buffer      ***
  958 9fcf:             ; *** R8 - line number              ***
  959 9fcf:             ; *** Returns: RA - pointer to line ***
  960 9fcf:             ; *************************************
  961 9fcf: f8 11       findline:  ldi     high textbuf        ; point to text buffer
  962 9fd1: ba                     phi     ra
  963 9fd2: f8 f9                  ldi     low textbuf
  964 9fd4: aa                     plo     ra
  965 9fd5: 98                     ghi     r8                  ; get line number
  966 9fd6: bc                     phi     rc
  967 9fd7: 88                     glo     r8
  968 9fd8: ac                     plo     rc
  969 9fd9: 9c          findlp:    ghi     rc
  970 9fda: ca 9f e1               lbnz    notfound
  971 9fdd: 8c                     glo     rc                  ; see if count is zero
  972 9fde: c2 9f f1               lbz     found               ; jump if there
  973 9fe1: 4a          notfound:  lda     ra
  974 9fe2: c2 9f f5               lbz     fnderr              ; jump if end of buffer was reached
  975 9fe5: 52                     str     r2                  ; prepare for add
  976 9fe6: 8a                     glo     ra                  ; add to address
  977 9fe7: f4                     add
  978 9fe8: aa                     plo     ra
  979 9fe9: 9a                     ghi     ra
  980 9fea: 7c 00                  adci    0
  981 9fec: ba                     phi     ra
  982 9fed: 2c                     dec     rc                  ; decrement count
  983 9fee: c0 9f d9               lbr     findlp              ; and check line
  984 9ff1: fc 00       found:     adi     0                   ; signal line found
  985 9ff3: f6                     shr
  986 9ff4: d5                     sep     sret                ; and return to caller
  987 9ff5: 2a          fnderr:    dec     ra
  988 9ff6: ff 00                  smi     0                   ; signal end of buffer reached
  989 9ff8: d5                     sep     sret                ; return to caller
  990 9ff9:             
  991 9ff9:             ; *************************************
  992 9ff9:             ; *** Find end of buffer            ***
  993 9ff9:             ; *** Returns: R8 - Line number     ***
  994 9ff9:             ; ***          RA - pointer to line ***
  995 9ff9:             ; *************************************
  996 9ff9: f8 11       findend:   ldi     high textbuf        ; get text buffer
  997 9ffb: ba                     phi     ra
  998 9ffc: f8 f9                  ldi     low textbuf
  999 9ffe: aa                     plo     ra
 1000 9fff: f8 00                  ldi     0                   ; setup count
 1001 a001: b8                     phi     r8
 1002 a002: a8                     plo     r8
 1003 a003: 4a          findendlp: lda     ra                  ; get count
 1004 a004: c2 a0 13               lbz     findenddn           ; jump if end was found
 1005 a007: 52                     str     r2
 1006 a008: 8a                     glo     ra
 1007 a009: f4                     add
 1008 a00a: aa                     plo     ra
 1009 a00b: 9a                     ghi     ra
 1010 a00c: 7c 00                  adci    0
 1011 a00e: ba                     phi     ra
 1012 a00f: 18                     inc     r8                  ; increment count
 1013 a010: c0 a0 03               lbr     findendlp
 1014 a013: 2a          findenddn: dec     ra                  ; move back to count byte
 1015 a014: d5                     sep     sret                ; and return
 1016 a015:             
 1017 a015:             ; ****************************
 1018 a015:             ; *** Print number         ***
 1019 a015:             ; *** R8 - Number to print ***
 1020 a015:             ; ****************************
 1021 a015: 98          printnum:  ghi     r8                  ; transfer number to RD
 1022 a016: bd                     phi     rd
 1023 a017: 88                     glo     r8
 1024 a018: ad                     plo     rd
 1025 a019: f8 10                  ldi     high numbuf         ; setup buffer
 1026 a01b: bf                     phi     rf
 1027 a01c: f8 15                  ldi     low numbuf
 1028 a01e: af                     plo     rf
 1029 a01f: d4                     sep     scall               ; convert number
 1030 a020: ff 60                  dw      f_uintout
 1031 a022: f8 00                  ldi     0                   ; terminate the string
 1032 a024: 5f                     str     rf
 1033 a025: f8 10                  ldi     high numbuf         ; point back to number
 1034 a027: bf                     phi     rf
 1035 a028: f8 15                  ldi     low numbuf
 1036 a02a: af                     plo     rf
 1037 a02b: d4                     sep     scall               ; display the number
 1038 a02c: ff 09                  dw      f_msg
 1039 a02e: d5                     sep     sret                ; and return to caller
 1040 a02f:             
 1041 a02f:             
 1042 a02f: 4e 65 77 20 
            66 69 6c 65 newmsg:    db      'New file'
 1043 a037: 0d 0a 00    crlf:      db      13,10,0
 1044 a03a: 45 6e 64 20 
            6f 66 20 62 
            75 66 66 65 
            72 0a 0d 00 endmsg:    db      'End of buffer',10,13,0
 1045 a04a: 54 6f 70 20 
            6f 66 20 62 
            75 66 66 65 
            72 0a 0d 00 topmsg:    db      'Top of buffer',10,13,0
 1046 a05a: 3e 00       prompt:    db      '>',0
 1047 a05c: 3a 00       colon:     db      ':',0
 1048 a05e:             
 1049 a05e:             
 1050 a05e:             ; ******************************
 1051 a05e:             ; *** Now the assembler code ***
 1052 a05e:             ; ******************************
 1053 a05e:             
 1054 a05e: d4          assemble:  sep     scall               ; find end of text buffer
 1055 a05f: 9f f9                  dw      findend
 1056 a061: 1a                     inc     ra                  ; 1 byte beyond end
 1057 a062: f8 10                  ldi     high symtab         ; point to symbol table pointer
 1058 a064: bf                     phi     rf
 1059 a065: f8 0e                  ldi     low symtab
 1060 a067: af                     plo     rf
 1061 a068: 9a                     ghi     ra                  ; store symbol table address
 1062 a069: 5f                     str     rf
 1063 a06a: 1f                     inc     rf
 1064 a06b: 8a                     glo     ra
 1065 a06c: 5f                     str     rf
 1066 a06d: f8 00                  ldi     0                   ; set symbol table end
 1067 a06f: 5a                     str     ra
 1068 a070: f8 10                  ldi     high lastsym        ; set last symbol address
 1069 a072: bf                     phi     rf
 1070 a073: f8 0a                  ldi     low lastsym
 1071 a075: af                     plo     rf
 1072 a076: 9a                     ghi     ra
 1073 a077: 5f                     str     rf
 1074 a078: 1f                     inc     rf
 1075 a079: 8a                     glo     ra
 1076 a07a: 5f                     str     rf
 1077 a07b: f8 10                  ldi     high pass           ; set pass to 0
 1078 a07d: bf                     phi     rf
 1079 a07e: f8 02                  ldi     low pass
 1080 a080: af                     plo     rf
 1081 a081: f8 00                  ldi     0
 1082 a083: 5f                     str     rf
 1083 a084: ba                     phi     ra                  ; set starting address
 1084 a085: aa                     plo     ra
 1085 a086:             ; *** Have to setup to read lines from editor ***
 1086 a086:             ; *** RD will point to editor lines           ***
 1087 a086: f8 11                  ldi     high textbuf
 1088 a088: bd                     phi     rd
 1089 a089: f8 f9                  ldi     low textbuf
 1090 a08b: ad                     plo     rd
 1091 a08c: d4                     sep     scall               ; process the file
 1092 a08d: a4 2f                  dw      asmloop
 1093 a08f:             
 1094 a08f: f8 10                  ldi     high pass           ; need to set pass to 1
 1095 a091: bf                     phi     rf
 1096 a092: f8 02                  ldi     low pass
 1097 a094: af                     plo     rf
 1098 a095: f8 01                  ldi     1
 1099 a097: 5f                     str     rf
 1100 a098: f8 00                  ldi     0                   ; set starting address
 1101 a09a: ba                     phi     ra
 1102 a09b: aa                     plo     ra
 1103 a09c:             
 1104 a09c:             ; *** Have to setup to read lines from editor ***
 1105 a09c:             ; *** RD will point to editor lines           ***
 1106 a09c: f8 11                  ldi     high textbuf
 1107 a09e: bd                     phi     rd
 1108 a09f: f8 f9                  ldi     low textbuf
 1109 a0a1: ad                     plo     rd
 1110 a0a2: d4                     sep     scall               ; perform second pass
 1111 a0a3: a4 2f                  dw      asmloop
 1112 a0a5:             
 1113 a0a5:             ; *** Need to return control to editor ***
 1114 a0a5: d5                     sep     sret                ; and return to caller
 1115 a0a6:             
 1116 a0a6:             ; ****************************
 1117 a0a6:             ; *** Move past whitespace ***
 1118 a0a6:             ; ****************************
 1119 a0a6: 4f          trim:      lda     rf                  ; get byte from buffer
 1120 a0a7: c2 a0 af               lbz     ltrim0              ; jump if it was zero
 1121 a0aa: ff 21                  smi     33                  ; get rid of anything space or lower
 1122 a0ac: cb a0 a6               lbnf    trim
 1123 a0af: 2f          ltrim0:    dec     rf                  ; point back to character
 1124 a0b0: d5                     sep     sret                ; and return
 1125 a0b1:             
 1126 a0b1:             ; Codes:
 1127 a0b1:             ;     1 - 1 byte code
 1128 a0b1:             ;     2 - 2 byte code
 1129 a0b1:             ;     3 - 3 byte code
 1130 a0b1:             ;     4 - special handling, 
 1131 a0b1:             ;     5 - nybble mode
 1132 a0b1:             
 1133 a0b1:             ; **************************
 1134 a0b1:             ; *** Process END opcode ***
 1135 a0b1:             ; **************************
 1136 a0b1: d4          opend:     sep     scall               ; get argument
 1137 a0b2: a2 91                  dw      getarg
 1138 a0b4: f8 10                  ldi     high startaddr      ; get address for start
 1139 a0b6: b8                     phi     r8
 1140 a0b7: f8 10                  ldi     low startaddr
 1141 a0b9: a8                     plo     r8
 1142 a0ba: 9d                     ghi     rd                  ; write start address
 1143 a0bb: 58                     str     r8
 1144 a0bc: 18                     inc     r8
 1145 a0bd: 8d                     glo     rd
 1146 a0be: 58                     str     r8
 1147 a0bf: c0 a1 40               lbr     opgood              ; done
 1148 a0c2:             
 1149 a0c2:             ; **************************
 1150 a0c2:             ; *** Process ORG opcode ***
 1151 a0c2:             ; **************************
 1152 a0c2: d4          oporg:     sep     scall               ; get argument
 1153 a0c3: a2 91                  dw      getarg
 1154 a0c5: 9d                     ghi     rd                  ; set as addres
 1155 a0c6: ba                     phi     ra
 1156 a0c7: 8d                     glo     rd
 1157 a0c8: aa                     plo     ra
 1158 a0c9: c0 a1 40               lbr     opgood
 1159 a0cc:              
 1160 a0cc:             ; *************************
 1161 a0cc:             ; *** Process DB opcode ***
 1162 a0cc:             ; *************************
 1163 a0cc: d4          opdb:      sep     scall               ; move past whitespace
 1164 a0cd: a1 74                  dw      ltrim
 1165 a0cf: 0f                     ldn     rf                  ; get next byte
 1166 a0d0: ff 27                  smi     27h                 ; check for open quote
 1167 a0d2: c2 a0 ec               lbz     opdbqt              ; jump if so
 1168 a0d5: d4                     sep     scall               ; get argument
 1169 a0d6: a2 91                  dw      getarg
 1170 a0d8: 8d                     glo     rd                  ; and output low byte
 1171 a0d9: d4                     sep     scall
 1172 a0da: a1 7f                  dw      output
 1173 a0dc: d4          opdbclqt:  sep     scall               ; move past whitespace
 1174 a0dd: a1 74                  dw      ltrim
 1175 a0df: 0f                     ldn     rf                  ; check for a comma
 1176 a0e0: ff 2c                  smi     ','
 1177 a0e2: ca a0 e9               lbnz    opdbdn              ; jump if not
 1178 a0e5: 1f                     inc     rf                  ; move past comma
 1179 a0e6: c0 a0 cc               lbr     opdb                ; process next byte
 1180 a0e9: c0 a1 40    opdbdn:    lbr     opgood
 1181 a0ec: 1f          opdbqt:    inc     rf                  ; move to next character
 1182 a0ed: 4f          opdbqtlp:  lda     rf                  ; get byte
 1183 a0ee: c2 a0 e9               lbz     opdbdn              ; jump if terminator found
 1184 a0f1: ae                     plo     re                  ; save a copy
 1185 a0f2: ff 27                  smi     27h                 ; see if closing quote
 1186 a0f4: c2 a0 dc               lbz     opdbclqt            ; jump if so
 1187 a0f7: 8e                     glo     re                  ; get byte
 1188 a0f8: d4                     sep     scall               ; and output it
 1189 a0f9: a1 7f                  dw      output
 1190 a0fb: c0 a0 ed               lbr     opdbqtlp            ; keep walking through
 1191 a0fe:              
 1192 a0fe:             ; *************************
 1193 a0fe:             ; *** Process DW opcode ***
 1194 a0fe:             ; *************************
 1195 a0fe: d4          opdw:      sep     scall               ; move past whitespace
 1196 a0ff: a1 74                  dw      ltrim
 1197 a101: 0f                     ldn     rf                  ; get next byte
 1198 a102: ff 27                  smi     27h                 ; check for open quote
 1199 a104: c2 a1 22               lbz     opdwqt              ; jump if so
 1200 a107: d4                     sep     scall               ; get argument
 1201 a108: a2 91                  dw      getarg
 1202 a10a: 9d                     ghi     rd                  ; and output high byte
 1203 a10b: d4                     sep     scall
 1204 a10c: a1 7f                  dw      output
 1205 a10e: 8d                     glo     rd                  ; and output low byte
 1206 a10f: d4                     sep     scall
 1207 a110: a1 7f                  dw      output
 1208 a112: d4          opdwclqt:  sep     scall               ; move past whitespace
 1209 a113: a1 74                  dw      ltrim
 1210 a115: 0f                     ldn     rf                  ; check for a comma
 1211 a116: ff 2c                  smi     ','
 1212 a118: ca a1 1f               lbnz    opdwdn              ; jump if not
 1213 a11b: 1f                     inc     rf                  ; move past comma
 1214 a11c: c0 a0 fe               lbr     opdw                ; process next byte
 1215 a11f: c0 a1 40    opdwdn:    lbr     opgood
 1216 a122: 1f          opdwqt:    inc     rf                  ; move to next character
 1217 a123: 4f          opdwqtlp:  lda     rf                  ; get byte
 1218 a124: c2 a1 1f               lbz     opdwdn              ; jump if terminator found
 1219 a127: ae                     plo     re                  ; save a copy
 1220 a128: ff 27                  smi     27h                 ; see if closing quote
 1221 a12a: c2 a1 12               lbz     opdwclqt            ; jump if so
 1222 a12d: 8e                     glo     re                  ; get byte
 1223 a12e: d4                     sep     scall               ; and output it
 1224 a12f: a1 7f                  dw      output
 1225 a131: c0 a1 23               lbr     opdwqtlp            ; keep walking through
 1226 a134:             
 1227 a134:             ; **************************
 1228 a134:             ; *** Process LDN opcode ***
 1229 a134:             ; **************************
 1230 a134: d4          opldn:     sep     scall               ; get argument
 1231 a135: a2 91                  dw      getarg
 1232 a137: 8d                     glo     rd                  ; get low value
 1233 a138: fa 0f                  ani     0fh                 ; want only low byte
 1234 a13a: c2 a1 44               lbz     opldner             ; zero is not allowed
 1235 a13d: d4                     sep     scall               ; output the byte
 1236 a13e: a1 7f                  dw      output
 1237 a140: f8 00       opgood:    ldi     0                   ; signal success
 1238 a142: f6                     shr
 1239 a143: d5                     sep     sret                ; return to caller
 1240 a144: f8 01       opldner:   ldi     1                   ; signal an error
 1241 a146: f6                     shr
 1242 a147: d5                     sep     sret                ; and return to caller
 1243 a148:             
 1244 a148:             ; **************************
 1245 a148:             ; *** Process OUT opcode ***
 1246 a148:             ; **************************
 1247 a148: d4          opout:     sep     scall               ; get argument
 1248 a149: a2 91                  dw      getarg
 1249 a14b: 8d                     glo     rd
 1250 a14c: c2 a1 44               lbz     opldner             ; cannot be zero
 1251 a14f: ff 08                  smi     8                   ; or greater than 7
 1252 a151: c3 a1 44               lbdf    opldner
 1253 a154: 8d                     glo     rd
 1254 a155: f9 60                  ori     060h                ; convert to out instruction
 1255 a157: d4                     sep     scall               ; output the byte
 1256 a158: a1 7f                  dw      output
 1257 a15a: c0 a1 40               lbr     opgood              ; then signal good
 1258 a15d:             
 1259 a15d:             ; **************************
 1260 a15d:             ; *** Process INP opcode ***
 1261 a15d:             ; **************************
 1262 a15d: d4          opinp:     sep     scall               ; get argument
 1263 a15e: a2 91                  dw      getarg
 1264 a160: 8d                     glo     rd
 1265 a161: c2 a1 44               lbz     opldner             ; cannot be zero
 1266 a164: ff 08                  smi     8                   ; or greater than 7
 1267 a166: c3 a1 44               lbdf    opldner
 1268 a169: 8d                     glo     rd
 1269 a16a: fc 08                  adi     8                   ; move to input range
 1270 a16c: f9 60                  ori     060h                ; convert to out instruction
 1271 a16e: d4                     sep     scall               ; output the byte
 1272 a16f: a1 7f                  dw      output
 1273 a171: c0 a1 40               lbr     opgood              ; then signal good
 1274 a174:             
 1275 a174: 4f          ltrim:     lda     rf                  ; get byte from buffer
 1276 a175: c2 a1 7d               lbz     ltrimdn             ; jump if end of string found
 1277 a178: ff 21                  smi     33                  ; check for space or less
 1278 a17a: cb a1 74               lbnf    ltrim               ; loop back if space or less
 1279 a17d: 2f          ltrimdn:   dec     rf                  ; move back to prev char
 1280 a17e: d5                     sep     sret                ; and return
 1281 a17f:             
 1282 a17f:             ; *****************************
 1283 a17f:             ; *** Output assembled byte ***
 1284 a17f:             ; *****************************
 1285 a17f: 5a          output:    str     ra                  ; store value
 1286 a180: f8 10                  ldi     high pass           ; find out which pass
 1287 a182: b8                     phi     r8
 1288 a183: f8 02                  ldi     low pass
 1289 a185: a8                     plo     r8
 1290 a186: 08                     ldn     r8                  ; get current pass
 1291 a187: c2 a1 d8               lbz     outputps0           ; jump if pass 0
 1292 a18a: 8d                     glo     rd                  ; save consumed registers
 1293 a18b: 73                     stxd
 1294 a18c: 9d                     ghi     rd
 1295 a18d: 73                     stxd
 1296 a18e: 8f                     glo     rf
 1297 a18f: 73                     stxd
 1298 a190: 9f                     ghi     rf
 1299 a191: 73                     stxd
 1300 a192: f8 10                  ldi     high bytecnt        ; need to check byte counter
 1301 a194: bf                     phi     rf
 1302 a195: f8 03                  ldi     low bytecnt
 1303 a197: af                     plo     rf
 1304 a198: 0f                     ldn     rf
 1305 a199: ff 04                  smi     4                   ; have 4 bytes already been output
 1306 a19b: ca a1 aa               lbnz    outputgo            ; jump if not
 1307 a19e: f8 00                  ldi     0                   ; reset count
 1308 a1a0: 5f                     str     rf
 1309 a1a1: f8 a6                  ldi     high nxtline        ; move pointer to next line
 1310 a1a3: bf                     phi     rf
 1311 a1a4: f8 a2                  ldi     low nxtline
 1312 a1a6: af                     plo     rf
 1313 a1a7: d4                     sep     scall
 1314 a1a8: ff 09                  dw      f_msg
 1315 a1aa: 0a          outputgo:  ldn     ra                  ; recover byte
 1316 a1ab: ad                     plo     rd                  ; prepare to convert
 1317 a1ac: f8 10                  ldi     high outbuffer      ; point to output buffer
 1318 a1ae: bf                     phi     rf
 1319 a1af: f8 a6                  ldi     low outbuffer
 1320 a1b1: af                     plo     rf 
 1321 a1b2: d4                     sep     scall               ; convert the value
 1322 a1b3: ff 48                  dw      f_hexout2
 1323 a1b5: f8 20                  ldi     32                  ; need a space
 1324 a1b7: 5f                     str     rf
 1325 a1b8: 1f                     inc     rf
 1326 a1b9: f8 00                  ldi     0                   ; terminate string
 1327 a1bb: 5f                     str     rf
 1328 a1bc: f8 10                  ldi     high outbuffer      ; point to output buffer
 1329 a1be: bf                     phi     rf
 1330 a1bf: f8 a6                  ldi     low outbuffer
 1331 a1c1: af                     plo     rf 
 1332 a1c2: d4                     sep     scall               ; display the byte
 1333 a1c3: ff 09                  dw      f_msg
 1334 a1c5: f8 10                  ldi     high bytecnt        ; need to increment byte counter
 1335 a1c7: bf                     phi     rf
 1336 a1c8: f8 03                  ldi     low bytecnt
 1337 a1ca: af                     plo     rf
 1338 a1cb: 0f                     ldn     rf
 1339 a1cc: fc 01                  adi     1
 1340 a1ce: 5f                     str     rf
 1341 a1cf: 60                     irx                         ; recover consumed registers
 1342 a1d0: 72                     ldxa
 1343 a1d1: bf                     phi     rf
 1344 a1d2: 72                     ldxa
 1345 a1d3: af                     plo     rf
 1346 a1d4: 72                     ldxa
 1347 a1d5: bd                     phi     rd
 1348 a1d6: f0                     ldx
 1349 a1d7: ad                     plo     rd
 1350 a1d8: 1a          outputps0: inc     ra                  ; point to next memory location
 1351 a1d9: d5                     sep     sret                ; and return to caller
 1352 a1da:             
 1353 a1da:             ; **********************************
 1354 a1da:             ; *** check D if numeric         ***
 1355 a1da:             ; *** Returns DF=0 - numeric     ***
 1356 a1da:             ; ***         DF=1 - non-numeric ***
 1357 a1da:             ; **********************************
 1358 a1da: ae          isnum:     plo     re                  ; save original D
 1359 a1db: ff 30                  smi     '0'                 ; check for below zero
 1360 a1dd: cb a1 e9               lbnf    isnumno             ; jump if not
 1361 a1e0: ff 0a                  smi     10                  ; see if above
 1362 a1e2: c3 a1 e9               lbdf    isnumno             ; jump if so
 1363 a1e5: fc 00                  adi     0                   ; signal is numeric
 1364 a1e7: 8e                     glo     re                  ; recover D
 1365 a1e8: d5                     sep     sret
 1366 a1e9: ff 00       isnumno:   smi     0                   ; signal nonnumber
 1367 a1eb: 8e                     glo     re                  ; recover D
 1368 a1ec: d5                     sep     sret                ; and return
 1369 a1ed:             
 1370 a1ed:             
 1371 a1ed:             ; **********************************
 1372 a1ed:             ; *** check D if hex             ***
 1373 a1ed:             ; *** Returns DF=0 - hex         ***
 1374 a1ed:             ; ***         DF=1 - non-hex     ***
 1375 a1ed:             ; **********************************
 1376 a1ed: 73          ishex:     stxd                        ; keep a copy of the number
 1377 a1ee: d4                     sep     scall               ; see if it is numeric
 1378 a1ef: a1 da                  dw      isnum
 1379 a1f1: cb a2 15               lbnf    ishexyes            ; jump if it is numeric
 1380 a1f4: 60                     irx                         ; retrieve value
 1381 a1f5: f0                     ldx
 1382 a1f6: 73                     stxd                        ; and keep on stack 
 1383 a1f7: ff 41                  smi     'A'                 ; check for below uppercase a
 1384 a1f9: cb a2 10               lbnf    ishexno             ; value is not hex
 1385 a1fc: ff 06                  smi     6                   ; check for less then 'G'
 1386 a1fe: cb a2 15               lbnf    ishexyes            ; jump if so
 1387 a201: 60                     irx                         ; retrieve value
 1388 a202: f0                     ldx
 1389 a203: ff 61                  smi     'a'                 ; check for lowercase a
 1390 a205: cb a2 11               lbnf    ishexno2            ; jump if not
 1391 a208: ff 06                  smi     6                   ; check for less than 'g'
 1392 a20a: cb a2 16               lbnf    ishexyes2           ; jump if so
 1393 a20d: c0 a2 11               lbr     ishexno2            ; value is not hex
 1394 a210: 60          ishexno:   irx                         ; remove value from stack
 1395 a211: f8 01       ishexno2:  ldi     1                   ; signal not hex
 1396 a213: f6                     shr
 1397 a214: d5                     sep     sret                ; and return to caller
 1398 a215: 60          ishexyes:  irx                         ; remove value from stack 
 1399 a216: f8 00       ishexyes2: ldi     0                   ; indicate a yes
 1400 a218: f6                     shr
 1401 a219: d5                     sep     sret                ; and return to caller
 1402 a21a:             
 1403 a21a:             ; *******************************
 1404 a21a:             ; *** Convert hex D to binary ***
 1405 a21a:             ; *** Returns: D - value      ***
 1406 a21a:             ; *******************************
 1407 a21a: 73          hexbin:    stxd                        ; save value
 1408 a21b: d4                     sep     scall               ; see if numeric
 1409 a21c: a1 da                  dw      isnum
 1410 a21e: c3 a2 26               lbdf    hexbin2             ; jump if alpha
 1411 a221: 60                     irx                         ; recover value
 1412 a222: f0                     ldx
 1413 a223: ff 30                  smi     '0'                 ; convert to binary
 1414 a225: d5                     sep     sret                ; and return to caller
 1415 a226: 60          hexbin2:   irx                         ; recover value
 1416 a227: f0                     ldx
 1417 a228: fa df                  ani     0dfh                ; force to uppercase
 1418 a22a: ff 37                  smi     55                  ; convert to binary
 1419 a22c: d5                     sep     sret                ; and return to caller
 1420 a22d:             
 1421 a22d:             ; ***********************************************
 1422 a22d:             ; *** identify symbol as decimal, hex, or non ***
 1423 a22d:             ; *** RF - pointer to symbol                  ***
 1424 a22d:             ; *** Returns: D=0 - decimal number           ***
 1425 a22d:             ; ***          D=1 - hex number               ***
 1426 a22d:             ; ***          D=3 - non numeric              *** 
 1427 a22d:             ; ***          RD  - number                   ***
 1428 a22d:             ; ***          RF  - first char after symbol  ***
 1429 a22d:             ; ***********************************************
 1430 a22d: 8f          identify:  glo     rf                  ; save position in case of label
 1431 a22e: 73                     stxd
 1432 a22f: 9f                     ghi     rf
 1433 a230: 73                     stxd
 1434 a231: 0f          idlp1:     ldn     rf                  ; get byte from buffer
 1435 a232: ff 21                  smi     33                  ; check for whitspace
 1436 a234: 0f                     ldn     rf                  ; also check for comma
 1437 a235: ff 2c                  smi     ','
 1438 a237: c2 a2 86               lbz     isdec               ; still a valid number
 1439 a23a: cb a2 86               lbnf    isdec               ; number is a decimal
 1440 a23d: 0f                     ldn     rf                  ; recover byet
 1441 a23e: d4                     sep     scall               ; see if it is numeric
 1442 a23f: a1 da                  dw      isnum
 1443 a241: c3 a2 48               lbdf    idlp2               ; jump if not, hex routine
 1444 a244: 1f                     inc     rf                  ; point to next position
 1445 a245: c0 a2 31               lbr     idlp1               ; loop until done
 1446 a248: 0f          idlp2:     ldn     rf                  ; get byte from buffer
 1447 a249: ff 21                  smi     33                  ; check for whitspace
 1448 a24b: cb a2 7e               lbnf    iderr               ; failed to find 'h' character
 1449 a24e: 0f                     ldn     rf                  ; check for H
 1450 a24f: ff 48                  smi     'H'
 1451 a251: c2 a2 65               lbz     idhex               ; jump if found
 1452 a254: 0f                     ldn     rf                  ; check for h
 1453 a255: ff 68                  smi     'h'
 1454 a257: c2 a2 65               lbz     idhex
 1455 a25a: 0f                     ldn     rf                  ; recover byet
 1456 a25b: d4                     sep     scall               ; see if it is numeric
 1457 a25c: a1 ed                  dw      ishex
 1458 a25e: c3 a2 7e               lbdf    iderr               ; jump if not, hex routine
 1459 a261: 1f                     inc     rf                  ; point to next position
 1460 a262: c0 a2 48               lbr     idlp2               ; loop until done
 1461 a265: 1f          idhex:     inc     rf                  ; need to check byte following h
 1462 a266: 0f                     ldn     rf
 1463 a267: ff 2c                  smi     ','
 1464 a269: c2 a2 72               lbz     hexisgood           ; jump if it is
 1465 a26c: 0f                     ldn     rf                  ; comma is valid character
 1466 a26d: ff 21                  smi     33                  ; must be space or less
 1467 a26f: c3 a2 7e               lbdf    iderr               ; otherwise error
 1468 a272: 60          hexisgood: irx                         ; recover beginning of number
 1469 a273: 72                     ldxa
 1470 a274: bf                     phi     rf
 1471 a275: f0                     ldx
 1472 a276: af                     plo     rf
 1473 a277: d4                     sep     scall               ; convert ascii hex to binary
 1474 a278: ff 45                  dw      f_hexin
 1475 a27a: 1f                     inc     rf                  ; move past h
 1476 a27b: f8 01                  ldi     1                   ; signal number was hex
 1477 a27d: d5                     sep     sret                ; and return to caller
 1478 a27e: 60          iderr:     irx                         ; number is an error, recover RF
 1479 a27f: 72                     ldxa
 1480 a280: bf                     phi     rf
 1481 a281: f0                     ldx
 1482 a282: af                     plo     rf
 1483 a283: f8 03                  ldi     3                   ; signal non-numeric
 1484 a285: d5                     sep     sret                ; return to caller
 1485 a286: 60          isdec:     irx                         ; recover beginning of number
 1486 a287: 72                     ldxa
 1487 a288: bf                     phi     rf
 1488 a289: f0                     ldx
 1489 a28a: af                     plo     rf
 1490 a28b: d4                     sep     scall               ; convert ascii decimal to binary
 1491 a28c: ff 5d                  dw      f_atoi
 1492 a28e: f8 00                  ldi     0                   ; signal number was decimal
 1493 a290: d5                     sep     sret                ; and return to caller
 1494 a291:             
 1495 a291:             ; ***************************************
 1496 a291:             ; *** Get argument from assembly line ***
 1497 a291:             ; *** RF - line after opcode          ***
 1498 a291:             ; *** RB - pointer to symbol table    ***
 1499 a291:             ; *** Returns: RD - value of arg      ***
 1500 a291:             ; ***          DF=0 - no error        ***
 1501 a291:             ; ***          DF=1 - error           ***
 1502 a291:             ; ***             D=1 - no arg        ***
 1503 a291:             ; ***             D=2 - inv number    ***
 1504 a291:             ; ***             D=3 - inv label     ***
 1505 a291:             ; ***************************************
 1506 a291: d4          getarg:    sep     scall               ; move past whitespace
 1507 a292: a1 74                  dw      ltrim
 1508 a294: 0f                     ldn     rf                  ; get first argument byte
 1509 a295: c2 a2 ea               lbz     getarg1             ; jump if at terminator
 1510 a298: d4                     sep     scall               ; see if it is numeric
 1511 a299: a1 da                  dw      isnum
 1512 a29b: cb a2 da               lbnf    argnum              ; jump if argument is numeric
 1513 a29e: 0f                     ldn     rf                  ; check for possible register
 1514 a29f: ff 52                  smi     'R'
 1515 a2a1: c2 a2 bc               lbz     argreg              ; might be
 1516 a2a4: 0f                     ldn     rf                  ; check lowercase r as well
 1517 a2a5: ff 72                  smi     'r'
 1518 a2a7: c2 a2 bc               lbz     argreg
 1519 a2aa: d4          notreg:    sep     scall               ; search for symbol
 1520 a2ab: a4 dc                  dw      getsymbol
 1521 a2ad: c3 a2 b4               lbdf    getnolab            ; jump if label was not valid
 1522 a2b0: f8 00                  ldi     0                   ; signal success
 1523 a2b2: f6                     shr
 1524 a2b3: d5                     sep     sret                ; return to caller
 1525 a2b4: f8 00       getnolab:  ldi     0                   ; invalid labels are zero
 1526 a2b6: bd                     phi     rd
 1527 a2b7: ad                     plo     rd
 1528 a2b8: f8 07                  ldi     7                   ; signal invalid label
 1529 a2ba: f6                     shr
 1530 a2bb: d5                     sep     sret                ; and return to caller
 1531 a2bc:             
 1532 a2bc: 1f          argreg:    inc     rf                  ; point to next byte
 1533 a2bd: 0f                     ldn     rf                  ; retrieve it
 1534 a2be: d4                     sep     scall               ; see if is hex
 1535 a2bf: a1 ed                  dw      ishex
 1536 a2c1: c3 a2 d6               lbdf    argno               ; jump if not hex
 1537 a2c4: 1f                     inc     rf                  ; get following byte
 1538 a2c5: 0f                     ldn     rf
 1539 a2c6: 2f                     dec     rf                  ; keep pointer pointing at 2nd byte
 1540 a2c7: ff 21                  smi     33                  ; must be a space or less
 1541 a2c9: c3 a2 d6               lbdf    argno               ; nope, it was not a register
 1542 a2cc: 0f                     ldn     rf                  ; retrieve register number
 1543 a2cd: d4                     sep     scall              
 1544 a2ce: a2 1a                  dw      hexbin              ; convert to binary
 1545 a2d0: ad                     plo     rd                  ; place into return register
 1546 a2d1: f8 00                  ldi     0                   ; high byte is zero
 1547 a2d3: bd                     phi     rd
 1548 a2d4: f6                     shr                         ; signal success
 1549 a2d5: d5                     sep     sret                ; return to caller
 1550 a2d6: 2f          argno:     dec     rf                  ; point back to first byte
 1551 a2d7: c0 a2 aa               lbr     notreg              ; and process as a label
 1552 a2da:             
 1553 a2da: d4          argnum:    sep     scall               ; identify number
 1554 a2db: a2 2d                  dw      identify
 1555 a2dd: ff 03                  smi     3                   ; was it non-numeric
 1556 a2df: c2 a2 e6               lbz     argnumer            ; jump if non-numeric
 1557 a2e2: f8 00                  ldi     0                   ; signal valid
 1558 a2e4: f6                     shr
 1559 a2e5: d5                     sep     sret                ; and return to caller
 1560 a2e6: f8 05       argnumer:  ldi     5                   ; signal invalid number
 1561 a2e8: f6                     shr
 1562 a2e9: d5                     sep     sret                ; and return to caller
 1563 a2ea:                       
 1564 a2ea:             
 1565 a2ea: f8 00       getarg1:   ldi     0                   ; not found, set value as zero
 1566 a2ec: bd                     phi     rd
 1567 a2ed: ad                     plo     rd
 1568 a2ee: f8 03                  ldi     3                   ; set no arg error
 1569 a2f0: f6                     shr
 1570 a2f1: d5                     sep     sret                ; return to caller
 1571 a2f2:             
 1572 a2f2:             ; ************************************
 1573 a2f2:             ; *** Assemble next line           ***
 1574 a2f2:             ; *** RF - line to assemble        ***
 1575 a2f2:             ; *** RA - Current address         ***
 1576 a2f2:             ; *** RB - pointer to symbol table ***
 1577 a2f2:             ; *** Returns: DF=0 - success      ***
 1578 a2f2:             ; ***          DF=1 - failed       ***
 1579 a2f2:             ; ************************************
 1580 a2f2: f8 10       asm:       ldi     high curaddr        ; set current address
 1581 a2f4: b8                     phi     r8
 1582 a2f5: f8 0c                  ldi     low curaddr
 1583 a2f7: a8                     plo     r8
 1584 a2f8: 9a                     ghi     ra
 1585 a2f9: 58                     str     r8
 1586 a2fa: 18                     inc     r8
 1587 a2fb: 8a                     glo     ra
 1588 a2fc: 58                     str     r8
 1589 a2fd: f8 10                  ldi     high pass           ; get current pass
 1590 a2ff: b8                     phi     r8
 1591 a300: f8 02                  ldi     low pass
 1592 a302: a8                     plo     r8
 1593 a303: 08                     ldn     r8
 1594 a304: c2 a3 36               lbz     asmpass0            ; can only get on second pass
 1595 a307: 8f                     glo     rf                  ; save line position
 1596 a308: 73                     stxd
 1597 a309: 9f                     ghi     rf
 1598 a30a: 73                     stxd
 1599 a30b: f8 10                  ldi     high bytecnt        ; zero byte count for line
 1600 a30d: bf                     phi     rf
 1601 a30e: f8 03                  ldi     low bytecnt
 1602 a310: af                     plo     rf
 1603 a311: f8 00                  ldi     0
 1604 a313: 5f                     str     rf
 1605 a314: 9a                     ghi     ra                  ; transfer address to RD
 1606 a315: bd                     phi     rd
 1607 a316: 8a                     glo     ra
 1608 a317: ad                     plo     rd
 1609 a318: f8 10                  ldi     high outbuffer      ; get address of buffer
 1610 a31a: bf                     phi     rf
 1611 a31b: f8 a6                  ldi     low outbuffer
 1612 a31d: af                     plo     rf
 1613 a31e: d4                     sep     scall               ; convert address
 1614 a31f: ff 4b                  dw      f_hexout4
 1615 a321: f8 20                  ldi     32                  ; need a space
 1616 a323: 5f                     str     rf
 1617 a324: 1f                     inc     rf
 1618 a325: f8 00                  ldi     0                   ; place terminator
 1619 a327: 5f                     str     rf
 1620 a328: f8 10                  ldi     high outbuffer      ; get address of buffer
 1621 a32a: bf                     phi     rf
 1622 a32b: f8 a6                  ldi     low outbuffer
 1623 a32d: af                     plo     rf
 1624 a32e: d4                     sep     scall               ; display the address
 1625 a32f: ff 09                  dw      f_msg
 1626 a331: 60                     irx                         ; recover line buffer
 1627 a332: 72                     ldxa
 1628 a333: bf                     phi     rf
 1629 a334: f0                     ldx
 1630 a335: af                     plo     rf
 1631 a336: 0f          asmpass0:  ldn     rf                  ; get first byte from line
 1632 a337: ff 21                  smi     33                  ; check for space or less
 1633 a339: cb a3 67               lbnf    asm2                ; jump if no labels
 1634 a33c: 9f                     ghi     rf                  ; make a copy
 1635 a33d: b9                     phi     r9
 1636 a33e: 8f                     glo     rf
 1637 a33f: a9                     plo     r9
 1638 a340: 0f          asmlbl1:   ldn     rf                  ; get byte from label
 1639 a341: ff 3a                  smi     ':'                 ; check for end of label
 1640 a343: c2 a3 50               lbz     asmlble             ; found end
 1641 a346: 0f                     ldn     rf                  ; get another byte
 1642 a347: ff 21                  smi     33                  ; check for space or less
 1643 a349: cb a3 50               lbnf    asmlble             ; found end
 1644 a34c: 1f                     inc     rf                  ; point to next byte
 1645 a34d: c0 a3 40               lbr     asmlbl1             ; and keep looking
 1646 a350: f8 00       asmlble:   ldi     0                   ; terminate the label
 1647 a352: 5f                     str     rf
 1648 a353: 8f                     glo     rf                  ; save positoin
 1649 a354: 73                     stxd
 1650 a355: 9f                     ghi     rf
 1651 a356: 73                     stxd
 1652 a357: 99                     ghi     r9                  ; get start of label
 1653 a358: bf                     phi     rf
 1654 a359: 89                     glo     r9
 1655 a35a: af                     plo     rf
 1656 a35b: d4                     sep     scall               ; add the symbol
 1657 a35c: a5 73                  dw      addsym
 1658 a35e: 60                     irx                         ; recover line pointer
 1659 a35f: 72                     ldxa
 1660 a360: bf                     phi     rf
 1661 a361: f0                     ldx
 1662 a362: af                     plo     rf
 1663 a363: f8 3a                  ldi     ':'
 1664 a365: 5f                     str     rf
 1665 a366: 1f                     inc     rf
 1666 a367: f8 a6       asm2:      ldi     high insttab        ; point to opcode table
 1667 a369: b9                     phi     r9
 1668 a36a: f8 aa                  ldi     low insttab
 1669 a36c: a9                     plo     r9
 1670 a36d: d4                     sep     scall               ; move past leading spaces
 1671 a36e: a1 74                  dw      ltrim
 1672 a370: d4          asmlp1:    sep     scall               ; check for opcode match
 1673 a371: a3 f9                  dw      chkentry
 1674 a373: cb a3 86               lbnf    asmfnd              ; jump if entry was found
 1675 a376: 19                     inc     r9                  ; point to next opcode entry
 1676 a377: 19                     inc     r9
 1677 a378: 19                     inc     r9
 1678 a379: 09                     ldn     r9                  ; get byte from table
 1679 a37a: ca a3 70               lbnz    asmlp1              ; loop back if not end of table
 1680 a37d: f8 01                  ldi     1                   ; signal an error
 1681 a37f: f6          asmret:    shr
 1682 a380: d5                     sep     sret                ; and return to caller
 1683 a381: f8 00       asmgood:   ldi     0                   ; signal success
 1684 a383: c0 a3 7f               lbr     asmret
 1685 a386: 49          asmfnd:    lda     r9                  ; get instruction type
 1686 a387: ff 01                  smi     1                   ; see if 1 byte code
 1687 a389: ca a3 93               lbnz    asmnot1             ; jump if not
 1688 a38c: 49                     lda     r9                  ; get opcode
 1689 a38d: d4                     sep     scall               ; output the byte
 1690 a38e: a1 7f                  dw      output
 1691 a390: c0 a3 81               lbr     asmgood             ; then return
 1692 a393: ff 01       asmnot1:   smi     1                   ; check for 2 byte instruction
 1693 a395: ca a3 a9               lbnz    asmnot2             ; jump if not
 1694 a398: 49                     lda     r9                  ; get opcode
 1695 a399: d4                     sep     scall               ; and output it
 1696 a39a: a1 7f                  dw      output
 1697 a39c: d4                     sep     scall               ; get argument
 1698 a39d: a2 91                  dw      getarg
 1699 a39f: c3 a3 ec               lbdf    asmerror            ; jump if error in argument
 1700 a3a2: 8d                     glo     rd                  ; get low value
 1701 a3a3: d4                     sep     scall               ; and output it
 1702 a3a4: a1 7f                  dw      output
 1703 a3a6: c0 a3 81               lbr     asmgood             ; then return
 1704 a3a9: ff 01       asmnot2:   smi     1                   ; check for 3 byte instruction
 1705 a3ab: ca a3 c3               lbnz    asmnot3             ; jump if not
 1706 a3ae: 49                     lda     r9                  ; get opcode
 1707 a3af: d4                     sep     scall               ; and output it
 1708 a3b0: a1 7f                  dw      output
 1709 a3b2: d4                     sep     scall               ; get argument
 1710 a3b3: a2 91                  dw      getarg
 1711 a3b5: c3 a3 ec               lbdf    asmerror            ; jump if error in argument
 1712 a3b8: 9d                     ghi     rd                  ; get high value
 1713 a3b9: d4                     sep     scall               ; and output it
 1714 a3ba: a1 7f                  dw      output
 1715 a3bc: 8d                     glo     rd                  ; get low value
 1716 a3bd: d4                     sep     scall               ; and output it
 1717 a3be: a1 7f                  dw      output
 1718 a3c0: c0 a3 81               lbr     asmgood             ; then return
 1719 a3c3: ff 01       asmnot3:   smi     1                   ; check for special handling
 1720 a3c5: ca a3 da               lbnz    asmnot4             ; jump if not
 1721 a3c8: f8 10                  ldi     high jump           ; get jump vector
 1722 a3ca: b7                     phi     r7
 1723 a3cb: f8 12                  ldi     low jump
 1724 a3cd: a7                     plo     r7
 1725 a3ce: f8 c0                  ldi     0c0h
 1726 a3d0: 57                     str     r7
 1727 a3d1: 17                     inc     r7                  ; point to jump destination
 1728 a3d2: 49                     lda     r9                  ; get handler
 1729 a3d3: 57                     str     r7                  ; and write into jump address
 1730 a3d4: 17                     inc     r7
 1731 a3d5: 09                     ldn     r9
 1732 a3d6: 57                     str     r7
 1733 a3d7: c0 10 12               lbr     jump                ; jump to jump address
 1734 a3da: d4          asmnot4:   sep     scall               ; get argument
 1735 a3db: a2 91                  dw      getarg
 1736 a3dd: c3 a3 ec               lbdf    asmerror            ; jump if error in argument
 1737 a3e0: 8d                     glo     rd                  ; get low value
 1738 a3e1: fa 0f                  ani     0fh                 ; keep only low nybble
 1739 a3e3: 52                     str     r2                  ; store into memory
 1740 a3e4: 49                     lda     r9                  ; get opcode
 1741 a3e5: f1                     or                          ; and or with register nybble
 1742 a3e6: d4                     sep     scall               ; and output it
 1743 a3e7: a1 7f                  dw      output
 1744 a3e9: c0 a3 81               lbr     asmgood             ; then return
 1745 a3ec: f8 a6       asmerror:  ldi     high errmsg         ; point to error message
 1746 a3ee: bf                     phi     rf
 1747 a3ef: f8 9a                  ldi     low errmsg
 1748 a3f1: af                     plo     rf
 1749 a3f2: d4                     sep     scall
 1750 a3f3: ff 09                  dw      f_msg
 1751 a3f5: f8 00                  ldi     0
 1752 a3f7: f6                     shr
 1753 a3f8: d5                     sep     sret
 1754 a3f9:                        
 1755 a3f9:             
 1756 a3f9:             
 1757 a3f9:             ; ***********************************************
 1758 a3f9:             ; *** Check to see if a table entry matches   ***
 1759 a3f9:             ; *** RF - buffer                             ***
 1760 a3f9:             ; *** R9 - table entry                        ***
 1761 a3f9:             ; *** Returns: R9 - first byte following name ***
 1762 a3f9:             ; ***          DF=0 - entry found             ***
 1763 a3f9:             ; ***          DF=1 - entry not foune         ***
 1764 a3f9:             ; ***          RF=orig on failure             ***
 1765 a3f9:             ; ***          otherwise first byte after     ***
 1766 a3f9:             ; ***********************************************
 1767 a3f9: 8f          chkentry:  glo      rf                 ; save buffer position
 1768 a3fa: 73                     stxd
 1769 a3fb: 9f                     ghi      rf
 1770 a3fc: 73                     stxd
 1771 a3fd: 49          chkloop:   lda      r9                 ; get byte from table entry
 1772 a3fe: ae                     plo      re                 ; keep a copy
 1773 a3ff: fa 80                  ani      128                ; see if high bit is set
 1774 a401: ca a4 1a               lbnz     chklst             ; jump if last character
 1775 a404: 4f                     lda      rf                 ; get byte from buffer
 1776 a405: 52                     str      r2                 ; put in memory for compare
 1777 a406: 8e                     glo      re                 ; recover table byte
 1778 a407: f7                     sm                          ; compare values
 1779 a408: c2 a3 fd               lbz      chkloop            ; loop back if a match
 1780 a40b: 49          chklp2:    lda      r9                 ; need to find end of entry
 1781 a40c: fa 80                  ani      128
 1782 a40e: c2 a4 0b               lbz      chklp2             ; loop until end found
 1783 a411: f8 01       chkno:     ldi      1                  ; signal entry not found
 1784 a413: f6          chkend:    shr
 1785 a414: 60                     irx                         ; recover buffer position
 1786 a415: 72                     ldxa
 1787 a416: bf                     phi      rf
 1788 a417: f0                     ldx
 1789 a418: af                     plo      rf
 1790 a419: d5                     sep      sret               ; and return to caller
 1791 a41a: 4f          chklst:    lda      rf                 ; get byte from buffer
 1792 a41b: 52                     str      r2                 ; put in memory for compare
 1793 a41c: 8e                     glo      re                 ; recover table byte
 1794 a41d: fa 7f                  ani      07fh               ; strip high bit
 1795 a41f: f7                     sm                          ; compare with buffer byte
 1796 a420: ca a4 11               lbnz     chkno              ; jump if no match
 1797 a423: 0f                     ldn      rf                 ; load next byte from buffer
 1798 a424: ff 21                  smi      33                 ; must be space or less
 1799 a426: c3 a4 11               lbdf     chkno              ; jump if not space or less
 1800 a429: f8 00                  ldi      0                  ; signal success
 1801 a42b: f6                     shr
 1802 a42c: 60                     irx                         ; remove RF from stack
 1803 a42d: 60                     irx
 1804 a42e: d5                     sep      sret               ; and return to caller
 1805 a42f:             
 1806 a42f:             ; ***********************************
 1807 a42f:             ; *** Process over the input file ***
 1808 a42f:             ; *** RD - file descriptor        ***
 1809 a42f:             ; ***********************************
 1810 a42f: f8 10       asmloop:   ldi     high buffer         ; point to buffer
 1811 a431: bf                     phi     rf
 1812 a432: f8 25                  ldi     low buffer
 1813 a434: af                     plo     rf
 1814 a435: d4                     sep     scall               ; read next line
 1815 a436: a4 b8                  dw      readln
 1816 a438: c3 a4 b7               lbdf    asmloopdn           ; jump if end of file reached
 1817 a43b: 8c                     glo     rc                  ; get character count
 1818 a43c: c2 a4 2f               lbz     asmloop             ; jump if at end of file
 1819 a43f: f8 25 af f8 
            10 bf                  mov     rf,buffer           ; conver to upper case
 1820 a445: d4                     sep     scall
 1821 a446: a6 26                  dw      touc
 1822 a448: f8 10       asmnodsp:  ldi     high buffer         ; point back to input line
 1823 a44a: bf                     phi     rf
 1824 a44b: f8 25                  ldi     low buffer
 1825 a44d: af                     plo     rf
 1826 a44e: 8d                     glo     rd                  ; save descriptor
 1827 a44f: 73                     stxd
 1828 a450: 9d                     ghi     rd
 1829 a451: 73                     stxd
 1830 a452: d4                     sep     scall               ; assemble the line
 1831 a453: a2 f2                  dw      asm
 1832 a455: f8 10                  ldi     high pass           ; get pass
 1833 a457: bf                     phi     rf
 1834 a458: f8 02                  ldi     low pass
 1835 a45a: af                     plo     rf
 1836 a45b: 0f                     ldn     rf
 1837 a45c: c2 a4 a3               lbz     asmlpps0            ; jump if on first pass
 1838 a45f: 76                     shrc                        ; save DF
 1839 a460: 73                     stxd
 1840 a461: f8 10                  ldi     high bytecnt        ; need output byte count
 1841 a463: bf                     phi     rf
 1842 a464: f8 03                  ldi     low bytecnt
 1843 a466: af                     plo     rf
 1844 a467: 0f                     ldn     rf
 1845 a468: 73          outbloop:  stxd                        ; save copy of count
 1846 a469: ff 04                  smi     4                   ; have 4 bytes been output
 1847 a46b: c2 a4 8e               lbz     outlpdn             ; jump if so
 1848 a46e: f8 10                  ldi     high outbuffer      ; point back to input line
 1849 a470: bf                     phi     rf
 1850 a471: f8 a6                  ldi     low outbuffer
 1851 a473: af                     plo     rf
 1852 a474: f8 20                  ldi     32                  ; need 3 spaces
 1853 a476: 5f                     str     rf
 1854 a477: 1f                     inc     rf
 1855 a478: 5f                     str     rf
 1856 a479: 1f                     inc     rf
 1857 a47a: 5f                     str     rf
 1858 a47b: 1f                     inc     rf
 1859 a47c: f8 00                  ldi     0                   ; and a terminator
 1860 a47e: 5f                     str     rf
 1861 a47f: 1f                     inc     rf
 1862 a480: 2f                     dec     rf                  ; back to beginning of buffer
 1863 a481: 2f                     dec     rf
 1864 a482: 2f                     dec     rf
 1865 a483: 2f                     dec     rf
 1866 a484: d4                     sep     scall               ; display the blanks
 1867 a485: ff 09                  dw      f_msg
 1868 a487: 60                     irx                         ; recover count
 1869 a488: f0                     ldx
 1870 a489: fc 01                  adi     1                   ; add 1
 1871 a48b: c0 a4 68               lbr     outbloop            ; loop back til done
 1872 a48e: 60          outlpdn:   irx                         ; remove D from stack
 1873 a48f: f8 10                  ldi     high buffer         ; point back to input line
 1874 a491: bf                     phi     rf
 1875 a492: f8 25                  ldi     low buffer
 1876 a494: af                     plo     rf
 1877 a495: d4                     sep     scall               ; display it
 1878 a496: ff 09                  dw      f_msg
 1879 a498: f8 a0                  ldi     high crlf           ; display a cr/lf
 1880 a49a: bf                     phi     rf
 1881 a49b: f8 37                  ldi     low crlf
 1882 a49d: af                     plo     rf
 1883 a49e: d4                     sep     scall               ; display it
 1884 a49f: ff 09                  dw      f_msg
 1885 a4a1: 60                     irx                         ; recover DF
 1886 a4a2: fe                     shl
 1887 a4a3: cb a4 af    asmlpps0:  lbnf    asmnoerr            ; jump if no error happened
 1888 a4a6: f8 a6                  ldi     high errmsg         ; otherwise display error message
 1889 a4a8: bf                     phi     rf
 1890 a4a9: f8 9a                  ldi     low errmsg
 1891 a4ab: af                     plo     rf
 1892 a4ac: d4                     sep     scall
 1893 a4ad: ff 09                  dw      f_msg
 1894 a4af: 60          asmnoerr:  irx                         ; recover descripter
 1895 a4b0: 72                     ldxa
 1896 a4b1: bd                     phi     rd
 1897 a4b2: f0                     ldx
 1898 a4b3: ad                     plo     rd
 1899 a4b4: c0 a4 2f               lbr     asmloop             ; loop back for next line
 1900 a4b7: d5          asmloopdn: sep     sret                ; return to caller
 1901 a4b8:             
 1902 a4b8:             ; *** Modify this routine to read from the editor ***
 1903 a4b8:             ; *** Use RD as editor pointer                    ***
 1904 a4b8: f8 00       readln:     ldi     0                   ; set byte count
 1905 a4ba: bc                      phi     rc
 1906 a4bb: ac                      plo     rc
 1907 a4bc: 0d                      ldn     rd                  ; get byte from edit buffer
 1908 a4bd: c2 a4 d8                lbz     readeof             ; jump if at end
 1909 a4c0: ff 02                   smi     2                   ; prevent copy of CR LF
 1910 a4c2: ae                      plo     re                  ; write count byte
 1911 a4c3: 1d                      inc     rd                  ; move past count byte
 1912 a4c4: 8e          readlnlp:   glo     re                  ; see if done
 1913 a4c5: c2 a4 d0                lbz     doneline            ; jump if end of line
 1914 a4c8: 4d                      lda     rd                  ; read byte from edit buffer
 1915 a4c9: 5f                      str     rf                  ; store into output buffer
 1916 a4ca: 1f                      inc     rf
 1917 a4cb: 1c                      inc     rc                  ; increment byte count
 1918 a4cc: 2e                      dec     re                  ; decrement character count
 1919 a4cd: c0 a4 c4                lbr     readlnlp            ; loop until done
 1920 a4d0: f8 00       doneline:   ldi     0                   ; write terminator
 1921 a4d2: 5f                      str     rf
 1922 a4d3: 1d                      inc     rd                  ; move past CR LF
 1923 a4d4: 1d                      inc     rd
 1924 a4d5: fc 00                   adi     0                   ; signal valid read
 1925 a4d7: d5                      sep     sret                ; and return
 1926 a4d8: ff 00       readeof:    smi     0                   ; signal eof by setting DF
 1927 a4da: 5f                      str     rf                  ; place terminator into buffer
 1928 a4db: d5                      sep     sret                ; and then return
 1929 a4dc:             
 1930 a4dc:             ; **************************************
 1931 a4dc:             ; *** Scan symbol table for a symbol ***
 1932 a4dc:             ; *** RF - symbol to search for      ***
 1933 a4dc:             ; *** Returns: RD - value            ***
 1934 a4dc:             ; ***          DF=0 - entry found    ***
 1935 a4dc:             ; ***          DF=1 - not found      ***
 1936 a4dc:             ; **************************************
 1937 a4dc: 0f          getsymbol: ldn     rf                  ; get first byte
 1938 a4dd: ff 24                  smi     '$'                 ; check for dollar sign
 1939 a4df: ca a4 f2               lbnz    notdollar           ; jump if not
 1940 a4e2: f8 10                  ldi     high curaddr        ; point to current address
 1941 a4e4: bd                     phi     rd
 1942 a4e5: f8 0c                  ldi     low curaddr
 1943 a4e7: ad                     plo     rd
 1944 a4e8: 4d                     lda     rd                  ; get high byte
 1945 a4e9: ae                     plo     re                  ; set aside
 1946 a4ea: 0d                     ldn     rd                  ; get low byte
 1947 a4eb: ad                     plo     rd                  ; set rd to current address
 1948 a4ec: 8e                     glo     re
 1949 a4ed: bd                     phi     rd
 1950 a4ee: f8 00                  ldi     0                   ; signal success
 1951 a4f0: f6                     shr
 1952 a4f1: d5                     sep     sret                ; return to caller
 1953 a4f2: f8 10       notdollar: ldi     high pass           ; get current pass
 1954 a4f4: b8                     phi     r8
 1955 a4f5: f8 02                  ldi     low pass
 1956 a4f7: a8                     plo     r8
 1957 a4f8: 08                     ldn     r8
 1958 a4f9: ca a5 02               lbnz    getsym1             ; can only get on second pass
 1959 a4fc: f8 00                  ldi     0                   ; first pass symbol is zero
 1960 a4fe: bd                     phi     rd
 1961 a4ff: ad                     plo     rd
 1962 a500: f6                     shr                         ; and symbol is assumed to exist
 1963 a501: d5                     sep     sret                ; otherwise return to caller
 1964 a502: f8 10       getsym1:   ldi     high symtab         ; point to symbol table
 1965 a504: b8                     phi     r8
 1966 a505: f8 0e                  ldi     low symtab
 1967 a507: a8                     plo     r8
 1968 a508: 48                     lda     r8                  ; high byte of symbol table
 1969 a509: ae                     plo     re                  ; save for a momenht
 1970 a50a: 08                     ldn     r8                  ; get low byte
 1971 a50b: a8                     plo     r8                  ; set R8 to symbol table
 1972 a50c: 8e                     glo     re
 1973 a50d: b8                     phi     r8
 1974 a50e: 08          getsymlp:  ldn     r8                  ; get byte from symbol table
 1975 a50f: ca a5 16               lbnz    getsymgo            ; go if still valid symbols
 1976 a512: f8 01                  ldi     1                   ; signal not found
 1977 a514: f6                     shr
 1978 a515: d5                     sep     sret                ; and return to caller
 1979 a516: 8f          getsymgo:  glo     rf                  ; save user search
 1980 a517: 73                     stxd
 1981 a518: 9f                     ghi     rf
 1982 a519: 73                     stxd
 1983 a51a: 48          getsymlp2: lda     r8                  ; get byte from symbol table
 1984 a51b: 52                     str     r2                  ; keep a copy
 1985 a51c: fa 80                  ani     128                 ; is high bit set
 1986 a51e: ca a5 36               lbnz    getsymlst           ; jump if so
 1987 a521: 4f                     lda     rf                  ; get byte from search
 1988 a522: f7                     sm                          ; compare
 1989 a523: c2 a5 1a               lbz     getsymlp2           ; jump if a match
 1990 a526: 48          getsymnxt: lda     r8                  ; get byte from sybol table
 1991 a527: fa 80                  ani     128                 ; check for final byte
 1992 a529: c2 a5 26               lbz     getsymnxt           ; loop back if not
 1993 a52c: 18          getsymnls: inc     r8                  ; point to next symbol
 1994 a52d: 18                     inc     r8
 1995 a52e: 60                     irx                         ; recover user search
 1996 a52f: 72                     ldxa
 1997 a530: bf                     phi     rf
 1998 a531: f0                     ldx
 1999 a532: af                     plo     rf
 2000 a533: c0 a5 0e               lbr     getsymlp            ; and check next symbol
 2001 a536: 02          getsymlst: ldn     r2                  ; recover byte
 2002 a537: fa 7f                  ani     07fh                ; strip high bit 
 2003 a539: 52                     str     r2                  ; put back in memory
 2004 a53a: 4f                     lda     rf                  ; get byte from user search
 2005 a53b: f7                     sm                          ; are they the same
 2006 a53c: ca a5 2c               lbnz    getsymnls           ; jump if not
 2007 a53f: 4f                     lda     rf                  ; get next byte
 2008 a540: ae                     plo     re                  ; keep a copy
 2009 a541: ff 2e                  smi     '.'                 ; see if it is a dot
 2010 a543: c2 a5 69               lbz     getsymdot           ; jump if so
 2011 a546: 8e                     glo     re                  ; recover byte
 2012 a547: ff 21                  smi     33                  ; must be space or less
 2013 a549: c3 a5 2c               lbdf    getsymnls           ; jump if not
 2014 a54c: 60                     irx                         ; recover user search
 2015 a54d: 72                     ldxa
 2016 a54e: bf                     phi     rf
 2017 a54f: f0                     ldx
 2018 a550: af                     plo     rf
 2019 a551: f8 00                  ldi     0                   ; indicate use symbol as is
 2020 a553: ae                     plo     re
 2021 a554: 48          getsymcnt: lda     r8                  ; get symbol value
 2022 a555: bd                     phi     rd
 2023 a556: 48                     lda     r8
 2024 a557: ad                     plo     rd
 2025 a558: 8e                     glo     re                  ; see if need high in low
 2026 a559: ff 31                  smi     '1'
 2027 a55b: c2 a5 62               lbz     getsymsw            ; yep
 2028 a55e: f8 00                  ldi     0                   ; signal success
 2029 a560: f6                     shr
 2030 a561: d5                     sep     sret                ; and return to caller
 2031 a562: 9d          getsymsw:  ghi     rd                  ; move high value to low
 2032 a563: ad                     plo     rd
 2033 a564: f8 00                  ldi     0                   ; zero high byte
 2034 a566: f6                     shr
 2035 a567: bd                     phi     rd
 2036 a568: d5                     sep     sret                ; return to caller
 2037 a569: 0f          getsymdot: ldn     rf                  ; get byte following dot
 2038 a56a: ae                     plo     re                  ; store into re
 2039 a56b: 60                     irx                         ; recover user search
 2040 a56c: 72                     ldxa
 2041 a56d: bf                     phi     rf
 2042 a56e: f0                     ldx
 2043 a56f: af                     plo     rf
 2044 a570: c0 a5 54               lbr     getsymcnt           ; then continue
 2045 a573:             
 2046 a573:             ; *******************
 2047 a573:             ; *** Add symbol  ***
 2048 a573:             ; *** RF - symbol ***
 2049 a573:             ; *** RA - value  ***
 2050 a573:             ; *******************
 2051 a573: f8 10       addsym:    ldi     high pass           ; get current pass
 2052 a575: b8                     phi     r8
 2053 a576: f8 02                  ldi     low pass
 2054 a578: a8                     plo     r8
 2055 a579: 08                     ldn     r8
 2056 a57a: c2 a5 7e               lbz     addsym1             ; can only add on first pass
 2057 a57d: d5                     sep     sret                ; otherwise return to caller
 2058 a57e: f8 10       addsym1:   ldi     high lastsym        ; get address of last symbol
 2059 a580: b8                     phi     r8
 2060 a581: f8 0a                  ldi     low lastsym
 2061 a583: a8                     plo     r8
 2062 a584: 48                     lda     r8                  ; get high byte for next symbol
 2063 a585: ae                     plo     re                  ; keep it
 2064 a586: 08                     ldn     r8                  ; get low byte
 2065 a587: a8                     plo     r8                  ; set r8 to next symbol address
 2066 a588: 8e                     glo     re
 2067 a589: b8                     phi     r8
 2068 a58a: 4f          addsymlp:  lda     rf                  ; get byte from symbol
 2069 a58b: ae                     plo     re                  ; keep a copy
 2070 a58c: ff 21                  smi     33                  ; check for space or less
 2071 a58e: cb a5 97               lbnf    addsym2             ; jump if end of symbol reached
 2072 a591: 8e                     glo     re                  ; recover byte
 2073 a592: 58                     str     r8                  ; store into symbol table
 2074 a593: 18                     inc     r8                  ; point to next position
 2075 a594: c0 a5 8a               lbr     addsymlp            ; loop until done copying name
 2076 a597: 28          addsym2:   dec     r8                  ; point back to previous char
 2077 a598: 08                     ldn     r8                  ; retrieve it
 2078 a599: f9 80                  ori     128                 ; set high bit
 2079 a59b: 58                     str     r8                  ; and put back
 2080 a59c: 18                     inc     r8                  ; point to value field
 2081 a59d: 9a                     ghi     ra                  ; store value
 2082 a59e: 58                     str     r8
 2083 a59f: 18                     inc     r8
 2084 a5a0: 8a                     glo     ra
 2085 a5a1: 58                     str     r8
 2086 a5a2: 18                     inc     r8
 2087 a5a3: f8 00                  ldi     0                   ; end of table marker
 2088 a5a5: 58                     str     r8
 2089 a5a6: f8 10                  ldi     high lastsym        ; need to store new end value
 2090 a5a8: bf                     phi     rf
 2091 a5a9: f8 0a                  ldi     low lastsym
 2092 a5ab: af                     plo     rf
 2093 a5ac: 98                     ghi     r8
 2094 a5ad: 5f                     str     rf
 2095 a5ae: 1f                     inc     rf
 2096 a5af: 88                     glo     r8
 2097 a5b0: 5f                     str     rf
 2098 a5b1: d5                     sep     sret                ; return to caller
 2099 a5b2:                        
 2100 a5b2: d4          save:      sep     scall               ; open XMODEM channel
 2101 a5b3: d4 00                  dw      xopenw
 2102 a5b5: f8 f9 ac f8 
            11 bc                  mov     rc,textbuf          ; point to edit buffer
 2103 a5bb: 4c          savelp:    lda     rc                  ; get size next line
 2104 a5bc: c2 a5 ca               lbz     save1               ; jump if end of buffer
 2105 a5bf: 52                     str     r2                  ; store for add
 2106 a5c0: 8c                     glo     rc                  ; get current address
 2107 a5c1: f4                     add                         ; add offset
 2108 a5c2: ac                     plo     rc
 2109 a5c3: 9c                     ghi     rc                  ; propagate carry
 2110 a5c4: 7c 00                  adci    0
 2111 a5c6: bc                     phi     rc
 2112 a5c7: c0 a5 bb               lbr     savelp              ; look at next line
 2113 a5ca: 9c          save1:     ghi     rc                  ; get high byte of address
 2114 a5cb: ff 10                  smi     baud.1              ; offset from base
 2115 a5cd: bc                     phi     rc                  ; rc now has count
 2116 a5ce: f8 25 af f8 
            10 bf                  mov     rf, buffer          ; point to buffer
 2117 a5d4: 9c                     ghi     rc                  ; write byte count
 2118 a5d5: 5f                     str     rf
 2119 a5d6: 1f                     inc     rf
 2120 a5d7: 8c                     glo     rc
 2121 a5d8: 5f                     str     rf
 2122 a5d9: 2f                     dec     rf                  ; move back to beginning of buffer
 2123 a5da: 8c 73 9c 73            push    rc                  ; save count
 2124 a5de: f8 02 ac f8 
            00 bc                  mov     rc,2                ; two bytes to write
 2125 a5e4: d4                     sep     scall               ; send to XMODEM channel
 2126 a5e5: d4 09                  dw      xwrite
 2127 a5e7: f8 00 af f8 
            10 bf                  mov     rf,baud             ; point to base
 2128 a5ed: 60 72 bc f0 
            ac                     pop     rc                  ; recover count
 2129 a5f2: d4                     sep     scall               ; write text buffer to XMODEM channel
 2130 a5f3: d4 09                  dw      xwrite
 2131 a5f5: d4                     sep     scall               ; close XMODEM channel
 2132 a5f6: d4 0c                  dw      xclosew
 2133 a5f8: c0 9c f9               lbr     mainlp              ; then back to main loop
 2134 a5fb:                
 2135 a5fb: d4          load:      sep     scall               ; open XMODEM channel
 2136 a5fc: d4 03                  dw      xopenr
 2137 a5fe: f8 25 af f8 
            10 bf                  mov     rf,buffer           ; where to put count
 2138 a604: f8 02 ac f8 
            00 bc                  mov     rc,2                ; need to read two bytes
 2139 a60a: d4                     sep     scall               ; read them
 2140 a60b: d4 06                  dw      xread
 2141 a60d: f8 25 af f8 
            10 bf                  mov     rf,buffer           ; need to retrieve count
 2142 a613: 4f                     lda     rf                  ; get high byte
 2143 a614: bc                     phi     rc                  ; put into count
 2144 a615: 0f                     ldn     rf                  ; get low byte
 2145 a616: ac                     plo     rc                  ; rc now has count
 2146 a617: f8 00 af f8 
            10 bf                  mov     rf,baud             ; beginning of data
 2147 a61d: d4                     sep     scall               ; read data from XMODEM channel
 2148 a61e: d4 06                  dw      xread
 2149 a620: d4                     sep     scall               ; close XMODEM channel
 2150 a621: d4 0f                  dw      xcloser
 2151 a623: c0 9c f9               lbr     mainlp              ; and return to main loop
 2152 a626:             
 2153 a626:             ; **********************************************************
 2154 a626:             ; ***** Convert string to uppercase, honor quoted text *****
 2155 a626:             ; **********************************************************
 2156 a626: 0f          touc:      ldn     rf                  ; check for quote
 2157 a627: ff 27                  smi     027h
 2158 a629: c2 a6 43               lbz     touc_qt             ; jump if quote
 2159 a62c: 0f                     ldn     rf                  ; get byte from string
 2160 a62d: c2 a6 42               lbz     touc_dn             ; jump if done
 2161 a630: ff 61                  smi     'a'                 ; check if below lc
 2162 a632: cb a6 3e               lbnf    touc_nxt            ; jump if so
 2163 a635: ff 1b                  smi     27                  ; check upper rage
 2164 a637: c3 a6 3e               lbdf    touc_nxt            ; jump if above lc
 2165 a63a: 0f                     ldn     rf                  ; otherwise convert character to lc
 2166 a63b: ff 20                  smi     32
 2167 a63d: 5f                     str     rf
 2168 a63e: 1f          touc_nxt:  inc     rf                  ; point to next character
 2169 a63f: c0 a6 26               lbr     touc                ; loop to check rest of string
 2170 a642: d5          touc_dn:   sep     sret                ; return to caller
 2171 a643: 1f          touc_qt:   inc     rf                  ; move past quote
 2172 a644: 4f          touc_qlp:  lda     rf                  ; get next character
 2173 a645: c2 a6 42               lbz     touc_dn             ; exit if terminator found
 2174 a648: ff 27                  smi     027h                ; check for quote charater
 2175 a64a: c2 a6 26               lbz     touc                ; back to main loop if quote
 2176 a64d: c0 a6 44               lbr     touc_qlp            ; otherwise keep looking
 2177 a650:             
 2178 a650: 45 64 74 2f 
            41 73 6d 20 
            28 30 32 2f 
            32 31 2f 30 
            36 29 0a 0d hello:     db      'Edt/Asm (02/21/06)',10,13
 2179 a664: 28 63 29 20 
            43 6f 70 79 
            72 69 67 68 
            74 20 32 30 
            30 36 20 62 
            79 20 4d 69 
            63 68 61 65 
            6c 20 48 2e 
            20 52 69 6c 
            65 79 0a 0d 
            00                     db      '(c) Copyright 2006 by Michael H. Riley',10,13,0
 2180 a68d: 46 69 6c 65 
            20 45 72 72 
            6f 72 0a 0d 
            00          fileerr:   db      'File Error',10,13,0
 2181 a69a: 45 72 72 6f 
            72 0a 0d 00 errmsg:    db      'Error',10,13,0
 2182 a6a2: 0a 0d 20 20 
            20 20 20 00 nxtline:   db      10,13,'     ',0
 2183 a6aa:             
 2184 a6aa: 41 44 c4 01 
            f4 00       insttab:   db      'AD',('D'+80h),1,0f4h,0
 2185 a6b0: 41 44 c3 01 
            74 00                  db      'AD',('C'+80h),1,074h,0
 2186 a6b6: 41 44 43 c9 
            02 7c 00               db      'ADC',('I'+80h),2,07ch,0
 2187 a6bd: 41 44 c9 02 
            fc 00                  db      'AD',('I'+80h),2,0fch,0
 2188 a6c3: 41 4e c4 01 
            f2 00                  db      'AN',('D'+80h),1,0f2h,0
 2189 a6c9: 41 4e c9 02 
            fa 00                  db      'AN',('I'+80h),2,0fah,0
 2190 a6cf: 42 b1 02 34 
            00                     db      'B',('1'+80h),2,034h,0
 2191 a6d4: 42 b2 02 35 
            00                     db      'B',('2'+80h),2,035h,0
 2192 a6d9: 42 b3 02 36 
            00                     db      'B',('3'+80h),2,036h,0
 2193 a6de: 42 b4 02 37 
            00                     db      'B',('4'+80h),2,037h,0
 2194 a6e3: 42 44 c6 02 
            33 00                  db      'BD',('F'+80h),2,033h,0
 2195 a6e9: 42 4e b1 02 
            3c 00                  db      'BN',('1'+80h),2,03ch,0
 2196 a6ef: 42 4e b2 02 
            3d 00                  db      'BN',('2'+80h),2,03dh,0
 2197 a6f5: 42 4e b3 02 
            3e 00                  db      'BN',('3'+80h),2,03eh,0
 2198 a6fb: 42 4e b4 02 
            3f 00                  db      'BN',('4'+80h),2,03fh,0
 2199 a701: 42 4e c6 02 
            3b 00                  db      'BN',('F'+80h),2,03bh,0
 2200 a707: 42 4e d1 02 
            39 00                  db      'BN',('Q'+80h),2,039h,0
 2201 a70d: 42 d1 02 31 
            00                     db      'B',('Q'+80h),2,031h,0
 2202 a712: 42 d2 02 30 
            00                     db      'B',('R'+80h),2,030h,0
 2203 a717: 42 da 02 32 
            00                     db      'B',('Z'+80h),2,032h,0
 2204 a71c: 42 4e da 02 
            3a 00                  db      'BN',('Z'+80h),2,03ah,0
 2205 a722: 44 45 c3 05 
            20 00                  db      'DE',('C'+80h),5,020h,0
 2206 a728: 44 49 d3 01 
            71 00                  db      'DI',('S'+80h),1,071h,0
 2207 a72e: 47 48 c9 05 
            90 00                  db      'GH',('I'+80h),5,090h,0
 2208 a734: 47 4c cf 05 
            80 00                  db      'GL',('O'+80h),5,080h,0
 2209 a73a: 49 44 cc 01 
            00 00                  db      'ID',('L'+80h),1,000h,0
 2210 a740: 49 4e c3 05 
            10 00                  db      'IN',('C'+80h),5,010h,0
 2211 a746: 49 4e d0 04            db      'IN',('P'+80h),4
 2212 a74a: a1 5d                  dw           opinp
 2213 a74c: 49 52 d8 01 
            60 00                  db      'IR',('X'+80h),1,060h,0
 2214 a752: 4c 42 44 c6 
            03 c3 00               db      'LBD',('F'+80h),3,0c3h,0
 2215 a759: 4c 42 4e c6 
            03 cb 00               db      'LBN',('F'+80h),3,0cbh,0
 2216 a760: 4c 42 4e d1 
            03 c9 00               db      'LBN',('Q'+80h),3,0c9h,0
 2217 a767: 4c 42 4e da 
            03 ca 00               db      'LBN',('Z'+80h),3,0cah,0
 2218 a76e: 4c 42 d1 03 
            c1 00                  db      'LB',('Q'+80h),3,0c1h,0
 2219 a774: 4c 42 d2 03 
            c0 00                  db      'LB',('R'+80h),3,0c0h,0
 2220 a77a: 4c 42 da 03 
            c2 00                  db      'LB',('Z'+80h),3,0c2h,0
 2221 a780: 4c 44 c1 05 
            40 00                  db      'LD',('A'+80h),5,040h,0
 2222 a786: 4c 44 c9 02 
            f8 00                  db      'LD',('I'+80h),2,0f8h,0
 2223 a78c: 4c 44 ce 04            db      'LD',('N'+80h),4
 2224 a790: a1 34                  dw           opldn
 2225 a792: 4c 44 d8 01 
            f0 00                  db      'LD',('X'+80h),1,0f0h,0
 2226 a798: 4c 44 58 c1 
            01 72 00               db      'LDX',('A'+80h),1,072h,0
 2227 a79f: 4c 53 44 c6 
            01 cf 00               db      'LSD',('F'+80h),1,0cfh,0
 2228 a7a6: 4c 53 49 c5 
            01 cc 00               db      'LSI',('E'+80h),1,0cch,0
 2229 a7ad: 4c 53 4e c6 
            01 c7 00               db      'LSN',('F'+80h),1,0c7h,0
 2230 a7b4: 4c 53 4e d1 
            01 c5 00               db      'LSN',('Q'+80h),1,0c5h,0
 2231 a7bb: 4c 53 4e da 
            01 c6 00               db      'LSN',('Z'+80h),1,0c6h,0
 2232 a7c2: 4c 53 d1 01 
            cd 00                  db      'LS',('Q'+80h),1,0cdh,0
 2233 a7c8: 4c 53 da 01 
            ce 00                  db      'LS',('Z'+80h),1,0ceh,0
 2234 a7ce: 4d 41 52 cb 
            01 79 00               db      'MAR',('K'+80h),1,079h,0
 2235 a7d5: 4e 42 d2 01 
            38 00                  db      'NB',('R'+80h),1,038h,0
 2236 a7db: 4e 4c 42 d2 
            01 c8 00               db      'NLB',('R'+80h),1,0c8h,0
 2237 a7e2: 4e 4f d0 01 
            c4 00                  db      'NO',('P'+80h),1,0c4h,0
 2238 a7e8: 4f d2 01 f1 
            00                     db      'O',('R'+80h),1,0f1h,0
 2239 a7ed: 4f 52 c9 02 
            f9 00                  db      'OR',('I'+80h),2,0f9h,0
 2240 a7f3: 4f 55 d4 04            db      'OU',('T'+80h),4
 2241 a7f7: a1 48                  dw           opout
 2242 a7f9: 50 48 c9 05 
            b0 00                  db      'PH',('I'+80h),5,0b0h,0
 2243 a7ff: 50 4c cf 05 
            a0 00                  db      'PL',('O'+80h),5,0a0h,0
 2244 a805: 52 45 d4 01 
            70 00                  db      'RE',('T'+80h),1,070h,0
 2245 a80b: 52 45 d1 01 
            7a 00                  db      'RE',('Q'+80h),1,07ah,0
 2246 a811: 53 c4 01 f5 
            00                     db      'S',('D'+80h),1,0f5h,0
 2247 a816: 53 41 d6 01 
            78 00                  db      'SA',('V'+80h),1,078h,0
 2248 a81c: 53 44 c2 01 
            75 00                  db      'SD',('B'+80h),1,075h,0
 2249 a822: 53 44 42 c9 
            02 7d 00               db      'SDB',('I'+80h),2,07dh,0
 2250 a829: 53 44 c9 02 
            fd 00                  db      'SD',('I'+80h),2,0fdh,0
 2251 a82f: 53 45 d0 05 
            d0 00                  db      'SE',('P'+80h),5,0d0h,0
 2252 a835: 53 45 d1 01 
            7b 00                  db      'SE',('Q'+80h),1,07bh,0
 2253 a83b: 53 45 d8 05 
            e0 00                  db      'SE',('X'+80h),5,0e0h,0
 2254 a841: 53 48 cc 01 
            fe 00                  db      'SH',('L'+80h),1,0feh,0
 2255 a847: 53 48 d2 01 
            f6 00                  db      'SH',('R'+80h),1,0f6h,0
 2256 a84d: 53 48 4c c3 
            01 7e 00               db      'SHL',('C'+80h),1,07eh,0
 2257 a854: 53 48 52 c3 
            01 76 00               db      'SHR',('C'+80h),1,076h,0
 2258 a85b: 53 cd 01 f7 
            00                     db      'S',('M'+80h),1,0f7h,0
 2259 a860: 53 4d c2 01 
            77 00                  db      'SM',('B'+80h),1,077h,0
 2260 a866: 53 4d 42 c9 
            02 7f 00               db      'SMB',('I'+80h),2,07fh,0
 2261 a86d: 53 4d c9 02 
            ff 00                  db      'SM',('I'+80h),2,0ffh,0
 2262 a873: 53 54 d2 05 
            50 00                  db      'ST',('R'+80h),5,050h,0
 2263 a879: 53 54 58 c4 
            01 73 00               db      'STX',('D'+80h),1,073h,0
 2264 a880: 58 4f d2 01 
            f3 00                  db      'XO',('R'+80h),1,0f3h,0
 2265 a886: 58 52 c9 02 
            fb 00                  db      'XR',('I'+80h),2,0fbh,0
 2266 a88c: 45 4e c4 04            db      'EN',('D'+80h),4
 2267 a890: a0 b1                  dw           opend
 2268 a892: 4f 52 c7 04            db      'OR',('G'+80h),4
 2269 a896: a0 c2                  dw           oporg
 2270 a898: 44 c2 04               db      'D',('B'+80h),4
 2271 a89b: a0 cc                  dw           opdb
 2272 a89d: 44 d7 04               db      'D',('W'+80h),4
 2273 a8a0: a0 fe                  dw           opdw
 2274 a8a2: 00                     db      0
 2275 a8a3:             
 2276 a8a3:             
 2277 a8a3:             
 2278 a8a3:             
 2279 a8a3:             
 2280 a8a3:                        org     DATA
 2281 1000:             baud:      equ     $
 2282 1000:             char:      equ     $+1
 2283 1000:             pass:      equ     $+2
 2284 1000:             bytecnt:   equ     $+3
 2285 1000:             curline:   equ     $+4
 2286 1000:             reg1:      equ     $+6
 2287 1000:             reg2:      equ     $+8
 2288 1000:             lastsym:   equ     $+0ah
 2289 1000:             curaddr:   equ     $+0ch
 2290 1000:             symtab:    equ     $+0eh
 2291 1000:             startaddr: equ     $+010h
 2292 1000:             jump:      equ     $+012h
 2293 1000:             numbuf:    equ     $+015h
 2294 1000:             buffer:    equ     $+025h
 2295 1000:             outbuffer: equ     $+0a6h
 2296 1000:             stack:     equ     $+1f7h
 2297 1000:             ; text buffer format
 2298 1000:             ; byte size of line (0 if end of buffer)
 2299 1000:             textbuf:   equ     $+1f9
 2300 1000:             

a573h: ADDSYM           - <  2051>   1657 
a57eh: ADDSYM1          - <  2058>   2056 
a597h: ADDSYM2          - <  2076>   2071 
a58ah: ADDSYMLP         - <  2068>   2075 
9d30h: ARG1NON          - <   456>    450 
a2d6h: ARGNO            - <  1550>   1536   1541 
a2dah: ARGNUM           - <  1553>   1512 
a2e6h: ARGNUMER         - <  1560>   1556 
a2bch: ARGREG           - <  1532>   1515   1518 
a2f2h: ASM              - <  1580>   1831 
a367h: ASM2             - <  1666>   1633 
a3ech: ASMERROR         - <  1745>   1699   1711   1736 
a386h: ASMFND           - <  1685>   1674 
a381h: ASMGOOD          - <  1683>   1691   1703   1718   1744 
a340h: ASMLBL1          - <  1638>   1645 
a350h: ASMLBLE          - <  1646>   1640   1643 
a42fh: ASMLOOP          - <  1810>   1092   1111   1818   1899 
a4b7h: ASMLOOPDN        - <  1900>   1816 
a370h: ASMLP1           - <  1672>   1679 
a4a3h: ASMLPPS0         - <  1887>   1837 
a448h: ASMNODSP         - <  1822> 
a4afh: ASMNOERR         - <  1894>   1887 
a393h: ASMNOT1          - <  1692>   1687 
a3a9h: ASMNOT2          - <  1704>   1693 
a3c3h: ASMNOT3          - <  1719>   1705 
a3dah: ASMNOT4          - <  1734>   1720 
a336h: ASMPASS0         - <  1631>   1594 
a37fh: ASMRET           - <  1681>   1684 
a05eh: ASSEMBLE         - <  1054>    560 
9c72h: ATOI             - <   287>    449    461 
9c84h: ATOICNT          - <   299>    293    295 
9cc9h: ATOIDN           - <   358>    315    317 
9c95h: ATOILP           - <   313>    309    357 
1000h: BAUD             - <  2281>    205   2114   2127   2146 
9e3dh: BOTTOM           - <   640>    500 
1025h: BUFFER           - <  2294>    428    430    444    446    672    674 
          686    688   1810   1812   1819   1822   1824   1873   1875   2116 
         2137   2141 
1003h: BYTECNT          - <  2284>   1300   1302   1334   1336   1599   1601 
         1840   1842 
ffe0h: CALL             - <   113> 
1001h: CHAR             - <  2282> 
a413h: CHKEND           - <  1784> 
a3f9h: CHKENTRY         - <  1767>   1673 
a3fdh: CHKLOOP          - <  1771>   1779 
a40bh: CHKLP2           - <  1780>   1782 
a41ah: CHKLST           - <  1791>   1774 
a411h: CHKNO            - <  1783>   1796   1799 
9c32h: COLD             - <   227> 
a05ch: COLON            - <  1047>    870    872 
a037h: CRLF             - <  1043>    238    240   1879   1881 
100ch: CURADDR          - <  2289>   1580   1582   1940   1942 
1004h: CURLINE          - <  2285>    200    549    551    895    897    913 
          915 
9dddh: DOASM            - <   559>    476 
9c42h: DOCRLF           - <   238>    435    681    888 
a4d0h: DONELINE         - <  1920>   1913 
9f46h: DOWN             - <   840>    482    856 
9f54h: DOWNGO           - <   847>    841    843 
a03ah: ENDMSG           - <  1044>    932    934 
9fb0h: EOBERROR         - <   932>    852 
a69ah: ERRMSG           - <  2181>    525    527   1745   1747   1888   1890 
8003h: EXITADDR         - <    73>    510 
a68dh: FILEERR          - <  2180> 
9ff9h: FINDEND          - <   996>    584    641    720   1055 
a013h: FINDENDDN        - <  1014>   1004 
a003h: FINDENDLP        - <  1003>   1013 
9fcfh: FINDLINE         - <   961>    581    595    614    742    762    851 
          863 
9fd9h: FINDLP           - <   969>    983 
9ff5h: FNDERR           - <   987>    974 
9ff1h: FOUND            - <   984>    972 
f830h: F_ASTODT         - <   182> 
f833h: F_ASTOTM         - <   183> 
ff5dh: F_ATOI           - <   148>   1491 
ff00h: F_BOOT           - <   117> 
ff42h: F_BOOTIDE        - <   139> 
f800h: F_BREAD          - <   166> 
ff6ch: F_BRKTEST        - <   153> 
f806h: F_BTEST          - <   168> 
f803h: F_BTYPE          - <   167> 
ff33h: F_DIV16          - <   134> 
ff2ah: F_DRIVE          - <   131> 
f827h: F_DTTOAS         - <   180> 
ff6fh: F_FINDTKN        - <   154> 
ff57h: F_FREEMEM        - <   146> 
ff81h: F_GETDEV         - <   160> 
f815h: F_GETTOD         - <   173> 
ff45h: F_HEXIN          - <   140>   1474 
ff48h: F_HEXOUT2        - <   141>   1322 
ff4bh: F_HEXOUT4        - <   142>   1614 
f824h: F_IDEID          - <   178> 
ff3ch: F_IDEREAD        - <   137> 
ff36h: F_IDERESET       - <   135> 
f821h: F_IDESIZE        - <   177> 
ff39h: F_IDEWRITE       - <   136> 
ff7bh: F_IDNUM          - <   158> 
ff3fh: F_INITCALL       - <   138>    211    236 
ff66h: F_INMSG          - <   151> 
ff0fh: F_INPUT          - <   122>    433    677 
ff69h: F_INPUTL         - <   152> 
ff63h: F_INTOUT         - <   150> 
ff78h: F_ISALNUM        - <   157> 
ff72h: F_ISALPHA        - <   155> 
ff75h: F_ISHEX          - <   156> 
ff5ah: F_ISNUM          - <   147> 
ff7eh: F_ISTERM         - <   159> 
ff15h: F_LTRIM          - <   124> 
ff1bh: F_MEMCPY         - <   126> 
ff54h: F_MINIMON        - <   145> 
ff51h: F_MOVER          - <   144> 
ff09h: F_MSG            - <   120>    243    390    427    530    829    875 
          937    948   1038   1314   1333   1625   1750   1867   1878   1884 
         1893 
ff30h: F_MUL16          - <   133> 
f836h: F_NVRCCHK        - <   184> 
f81bh: F_RDNVR          - <   175> 
ff21h: F_RDSEC          - <   128> 
ff06h: F_READ           - <   119> 
f82dh: F_RTCTEST        - <   181> 
ff27h: F_SEEK           - <   130> 
ff24h: F_SEEK0          - <   129> 
ff2dh: F_SETBD          - <   132> 
f818h: F_SETTOD         - <   174> 
ff12h: F_STRCMP         - <   123> 
ff18h: F_STRCPY         - <   125> 
f82ah: F_TMTOAS         - <   179> 
ff4eh: F_TTY            - <   143> 
ff03h: F_TYPE           - <   118>    671    883 
ff0ch: F_TYPEX          - <   121> 
ff60h: F_UINTOUT        - <   149>   1030 
f80ch: F_UREAD          - <   170> 
f812h: F_USETBD         - <   172> 
f80fh: F_UTEST          - <   171> 
f809h: F_UTYPE          - <   169> 
fff9h: F_VERSION        - <   162> 
f81eh: F_WRNVR          - <   176> 
ff1eh: F_WRTSEC         - <   127> 
a291h: GETARG           - <  1506>   1137   1153   1169   1201   1231   1248 
         1263   1698   1710   1735 
a2eah: GETARG1          - <  1565>   1509 
9f90h: GETCURLN         - <   895>    418    443    628    665    740    760 
          788    819    848 
a2b4h: GETNOLAB         - <  1525>   1521 
a502h: GETSYM1          - <  1964>   1958 
a4dch: GETSYMBOL        - <  1937>   1520 
a554h: GETSYMCNT        - <  2021>   2044 
a569h: GETSYMDOT        - <  2037>   2010 
a516h: GETSYMGO         - <  1979>   1975 
a50eh: GETSYMLP         - <  1974>   2000 
a51ah: GETSYMLP2        - <  1983>   1989 
a536h: GETSYMLST        - <  2001>   1986 
a52ch: GETSYMNLS        - <  1993>   2006   2013 
a526h: GETSYMNXT        - <  1990>   1992 
a562h: GETSYMSW         - <  2031>   2027 
9df1h: GO               - <   578>    506 
9e00h: GOCONT           - <   587>    582 
a650h: HELLO            - <  2178>    385    387 
a21ah: HEXBIN           - <  1407>   1544 
a226h: HEXBIN2          - <  1415>   1410 
a272h: HEXISGOOD        - <  1468>   1464 
a22dh: IDENTIFY         - <  1430>   1554 
a27eh: IDERR            - <  1478>   1448   1458   1467 
a265h: IDHEX            - <  1461>   1451   1454 
a231h: IDLP1            - <  1434>   1445 
a248h: IDLP2            - <  1446>   1443   1460 
9e50h: INSERT           - <   659>    494 
9e84h: INSERT1          - <   694>    663 
9ef7h: INSERTDN         - <   782>    776 
9e8ah: INSERTLN         - <   699>    691    695 
9e92h: INSERTLP1        - <   706>    709    714 
9ec0h: INSERTLP2        - <   743>    758 
9eech: INSERTLP3        - <   775>    781 
9e58h: INSERTM          - <   664>    692 
9ed3h: INSLP2C          - <   756>    749    754 
9ed8h: INSLP2D          - <   759>    755 
a6aah: INSTTAB          - <  2184>   1666   1668 
a286h: ISDEC            - <  1485>   1438   1439 
a1edh: ISHEX            - <  1376>   1457   1535 
a210h: ISHEXNO          - <  1394>   1384 
a211h: ISHEXNO2         - <  1395>   1390   1393 
a215h: ISHEXYES         - <  1398>   1379   1386 
a216h: ISHEXYES2        - <  1399>   1392 
9c5fh: ISLC             - <   268>    469 
9c6ch: ISNOTLC          - <   276>    271    273 
9c59h: ISNOTUC          - <   258>    253    255 
a1dah: ISNUM            - <  1358>    292   1378   1409   1442   1511 
a1e9h: ISNUMNO          - <  1366>   1360   1362 
9c4ch: ISUC             - <   250> 
1012h: JUMP             - <  2292>   1721   1723   1733 
9e06h: KILL             - <   594>    503 
9e33h: KILLDONE         - <   626>    616 
9e21h: KILLLINE         - <   615>    625 
9e28h: KILLLOOP         - <   619>    624 
9e34h: KILLQUIT         - <   627>    596 
100ah: LASTSYM          - <  2288>   1068   1070   2058   2060   2089   2091 
a5fbh: LOAD             - <  2135>    519 
a174h: LTRIM            - <  1275>   1164   1174   1196   1209   1278   1507 
         1671 
a0afh: LTRIM0           - <  1123>   1120 
a17dh: LTRIMDN          - <  1279>   1276 
9cf9h: MAINLP           - <   417>    415    531    561    572    589    631 
          654    685    696    801    817    830    846    938    954   2133 
         2151 
9dc6h: NEW              - <   543>    485 
9fbch: NEWFILE          - <   943>    397    557 
a02fh: NEWMSG           - <  1042>    943    945 
9d41h: NOARG2           - <   467>    458    462 
9d4ch: NOARG2_1         - <   474>    470 
a4f2h: NOTDOLLAR        - <  1953>   1939 
9fe1h: NOTFOUND         - <   973>    970 
a2aah: NOTREG           - <  1519>   1551 
1015h: NUMBUF           - <  2293>   1025   1027   1033   1035 
a6a2h: NXTLINE          - <  2182>   1309   1311 
a0cch: OPDB             - <  1163>   1179   2271 
a0dch: OPDBCLQT         - <  1173>   1186 
a0e9h: OPDBDN           - <  1180>   1177   1183 
a0ech: OPDBQT           - <  1181>   1167 
a0edh: OPDBQTLP         - <  1182>   1190 
a0feh: OPDW             - <  1195>   1214   2273   2273 
a112h: OPDWCLQT         - <  1208>   1221 
a11fh: OPDWDN           - <  1215>   1212   1218 
a122h: OPDWQT           - <  1216>   1199 
a123h: OPDWQTLP         - <  1217>   1225 
a0b1h: OPEND            - <  1136>   2267 
a140h: OPGOOD           - <  1237>   1147   1158   1180   1215   1257   1273 
a15dh: OPINP            - <  1262>   2212 
a134h: OPLDN            - <  1230>   2224 
a144h: OPLDNER          - <  1240>   1234   1250   1252   1265   1267 
a0c2h: OPORG            - <  1152>   2269 
a148h: OPOUT            - <  1247>   2241 
a468h: OUTBLOOP         - <  1845>   1871 
10a6h: OUTBUFFER        - <  2295>   1317   1319   1328   1330   1609   1611 
         1620   1622   1848   1850 
a48eh: OUTLPDN          - <  1872>   1847 
a17fh: OUTPUT           - <  1285>   1172   1189   1204   1207   1224   1236 
         1256   1272   1690   1696   1702   1708   1714   1717   1743 
a1aah: OUTPUTGO         - <  1315>   1306 
a1d8h: OUTPUTPS0        - <  1350>   1291 
1002h: PASS             - <  2283>   1077   1079   1094   1096   1286   1288 
         1589   1591   1832   1834   1953   1955   2051   2053 
9c06h: PICO1            - <   197>    195 
9c0fh: PICO2            - <   200>    196 
9f06h: PRINT            - <   797>    491    806 
9f8bh: PRINTDN          - <   886>    880 
9f8ch: PRINTEND         - <   887>    878 
9f11h: PRINTGO          - <   802>    798    800 
9f65h: PRINTIT          - <   862>    588    630    653    803    816    845 
9f6ch: PRINTITGO        - <   866>    864 
9f7fh: PRINTLP          - <   879>    885 
a015h: PRINTNUM         - <  1021>    421    668    868 
a05ah: PROMPT           - <  1046>    422    424 
a4d8h: READEOF          - <  1926>   1908 
a4b8h: READLN           - <  1904>   1815 
a4c4h: READLNLP         - <  1912>   1919 
1006h: REG1             - <  2286> 
1008h: REG2             - <  2287> 
9cf0h: RESTART          - <   411>    208 
fff1h: RET              - <   114> 
9de3h: RUN              - <   563>    479 
a5b2h: SAVE             - <  2100>    516 
a5cah: SAVE1            - <  2113>   2104 
a5bbh: SAVELP           - <  2103>   2112 
0004h: SCALL            - <   110>    242    291    389    417    420    426 
          432    434    442    448    460    468    529    559    578    580 
          583    585    587    594    601    613    627    629    640    650 
          652    660    664    667    670    676    680    690    694    719 
          739    741    759    761    787    790    802    815    818    828 
          832    844    847    850    853    862    867    874    882    887 
          936    947    952   1029   1037   1054   1091   1110   1136   1152 
         1163   1168   1171   1173   1188   1195   1200   1203   1206   1208 
         1223   1230   1235   1247   1255   1262   1271   1313   1321   1332 
         1377   1408   1441   1456   1473   1490   1506   1510   1519   1534 
         1543   1553   1613   1624   1656   1670   1672   1689   1695   1697 
         1701   1707   1709   1713   1716   1734   1742   1749   1814   1820 
         1830   1866   1877   1883   1892   2100   2125   2129   2131   2135 
         2139   2147   2149 
9f9bh: SETCURLN         - <   909>    579    586    602    651    661    791 
          833    854    953 
0005h: SRET             - <   111>    244    262    280    298    368    792 
          865    886    889    903    927    986    989   1015   1039   1114 
         1124   1239   1242   1280   1351   1365   1368   1397   1401   1414 
         1419   1477   1484   1493   1524   1530   1549   1559   1562   1570 
         1682   1753   1790   1804   1900   1925   1928   1952   1963   1978 
         2030   2036   2057   2098   2170 
11f7h: STACK            - <  2296>    209    231    233    380    382    411 
          413 
9cd5h: START            - <   380>    227    229 
1010h: STARTADDR        - <  2291>    534    563    565   1138   1140 
100eh: SYMTAB           - <  2290>   1057   1059   1964   1966 
11f9h: TEXTBUF          - <  2299>    197    391    393    543    545    961 
          963    996    998   1087   1089   1106   1108   2102 
9e43h: TOP              - <   647>    497 
a04ah: TOPMSG           - <  1045>    824    826 
9e47h: TOPSET           - <   650>    642 
a626h: TOUC             - <  2156>   1821   2169   2175 
a642h: TOUC_DN          - <  2170>   2160   2173 
a63eh: TOUC_NXT         - <  2168>   2162   2164 
a644h: TOUC_QLP         - <  2172>   2176 
a643h: TOUC_QT          - <  2171>   2158 
a0a6h: TRIM             - <  1119>   1122 
9f19h: UP               - <   811>    488    835 
9f3eh: UPGO             - <   831>    821    823 
9f27h: UPGO1            - <   818>    812    814 
9db2h: VISUAL02         - <   534>    513 
7e00h: VISUALDS         - <    83>    535 
d40fh: XCLOSER          - <    72>   2150 
d40ch: XCLOSEW          - <    71>   2132 
d403h: XOPENR           - <    68>   2136 
d400h: XOPENW           - <    67>   2101 
d406h: XREAD            - <    69>   2140   2148 
d409h: XWRITE           - <    70>   2126   2130 

2300 Lines assembled
0 Errors
276 Labels
Object Code:3235 bytes

