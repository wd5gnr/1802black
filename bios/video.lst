0001   0000             	.TITLE	 "VIDEO -- COSMAC Elf 2000 Video Terminal Module"
0002   0000             ;	 Bob Armstrong [14-Jun-82]
0003   0000             
0004   0000             ;       Copyright (C) 2005 By Spare Time Gizmos, Milpitas CA.
0005   0000             
0006   0000             ;   This program is free software; you can redistribute it and/or modify
0007   0000             ; it under the terms of the GNU General Public License as published by
0008   0000             ; the Free Software Foundation; either version 2 of the License, or
0009   0000             ; (at your option) any later version.
0010   0000             ;
0011   0000             ;   This program is distributed in the hope that it will be useful, but
0012   0000             ; WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
0013   0000             ; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
0014   0000             ; for more details.
0015   0000             ;
0016   0000             ;   You should have received a copy of the GNU General Public License along
0017   0000             ; with this program; if not, write to the Free Software Foundation, Inc.,
0018   0000             ; 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
0019   0000             ;
0020   0000             ; DESCRIPTION
0021   0000             ;   This piece of software is an addition to the standard Spare Time Gizmos
0022   0000             ; COSMAC Elf 2000 EPROM; this addition emulates a simple VT52 style video
0023   0000             ; terminal using the ElfVideo option card.  The ElfVideo card uses an Intel
0024   0000             ; 8275 CRT controller chip and is capable of displaying 80 x 24 text using an
0025   0000             ; 8 by 10 font on a standard CGA monitor.
0026   0000             ;
0027   0000             ;   Note that this firmware is strictly "ouptut only" - it handles the display
0028   0000             ; side of the terminal, but not the keyboard input.  The input is handled by
0029   0000             ; a completely separate PS/2 to parallel ASCII gizmo, which is independent of
0030   0000             ; this module.
0031   0000             ;
0032   0000             ;   This software is designed to emulate the DEC VT52 terminal as closely as
0033   0000             ; possible. In particular, the following features of the VT52 are fully
0034   0000             ; supported:
0035   0000             ;
0036   0000             ;	 * Cursor Up, Down, Left, Right, Home (ESC A, B, C, D, H)
0037   0000             ;	 * Scroll Up/Down		      (LF, ESC I)
0038   0000             ;	 * Erase to End of Line/Screen	      (ESC K, J)
0039   0000             ;	 * Direct Cursor Addressing	      (ESC Y line column)
0040   0000             ;	 * Enter/Exit Graphics Mode	      (ESC F, G)
0041   0000             ;
0042   0000             ;   The only VT52 command sequences which are not supported by this software
0043   0000             ; are enter/exit alternate keypad mode (ESC  =, >) and identify (ESC Z).
0044   0000             ; Neither of these have any meaning since this is a display only type device
0045   0000             ; and the keyboard is an entirely seperate device.  In addition to all normal
0046   0000             ; VT52 functions, this  terminal also implements these extensions:
0047   0000             ;
0048   0000             ;	 * Erase Screen / Raster Test	      (ESC E, R)
0049   0000             ;	 * Write Field Attribute Code	      (ESC N)
0050   0000             ;	 * Write Line Drawing Code	      (ESC O)
0051   0000             ; 	 * Display test screen		      (ESC T)
0052   0000             ;
0053   0000             ; WARNING
0054   0000             ;   With the exception of the INIT75 and VIDISR routines, _everything_ else
0055   0000             ; in this module is called via the VTPUTC function, and VTPUTC is called by
0056   0000             ; the BIOS F_TYPE function.  The issue is that pretty much all code everywhere
0057   0000             ; expects F_TYPE to preserve all the registers, so that means (with the two
0058   0000             ; exceptions previously mentioned) every routine in this module is expected to
0059   0000             ; save and restore any registers it uses.
0060   0000             ;
0061   0000             ;   Because they're used so often VTPUTC takes care of saving and restoring
0062   0000             ; P1 and DP - any other registers (e.g. T1 or P2) need to be saved in the
0063   0000             ; individual routines!
0064   0000             ;--
0065   0000             
0066   0000             ;0000000001111111111222222222233333333334444444444555555555566666666667777777777
0067   0000             ;1234567890123456789012345678901234567890123456789012345678901234567890123456789
0068   0000             
0069   0000             	.MSFIRST \ .PAGE \ .CODES
0069   0000             
TASM 1802 Assembler.              video.asm                        page 1
VIDEO -- COSMAC Elf 2000 Video Terminal Module

0069   0000             
0070   0000             
0075   0000             	.LIST
0076   0000             
TASM 1802 Assembler.              video.asm                        page 12
VIDEO -- COSMAC Elf 2000 Video Terminal Module

0077   0000             	.EJECT
0078   0000             ;++
0079   0000             ; REVISION HISTORY
0080   0000             ; 
0081   0000             ; 001	-- New file (gotta start somewhere!)...
0082   0000             ;
0083   0000             ; 002	-- We need to use parenthesis in LINTAB - SCREEN+(3*MAXX) !!
0084   0000             ;
0085   0000             ; 003	-- LDA missing an argument in WHERE: (should be "LDA DP")...
0086   0000             ;
0087   0000             ; 004	-- RIGHT and DOWN are missing a SEX DP, but instead of fixing that
0088   0000             ;	   I just decided to rewrite them...
0089   0000             ;
0090   0000             ; 005	-- Use the standard include files - CONFIG, ELF2K and BOOTS - for all
0091   0000             ;	   hardware and software definitions shared with BOOTS.ASM
0092   0000             ;
0093   0000             ; 006	-- Parameterize the code and screen buffer locations.
0094   0000             ;
0095   0000             ; 007	-- Make VTPUTC save P1, T1 and DP.
0096   0000             ;
0097   0000             ; 008	-- Save P2 in the few places (FILL, EEOS) where it is used.
0098   0000             ;
0099   0000             ; 009	-- Rewrite SCRUP so it doesn't use T1.  Make CLRLIN, EEOL and FILL save
0100   0000             ;	   T1.  Now VTPUTC doesn't need to save/restore T1.
0101   0000             ;
0102   0000             ; 010	-- Swap around EEOS and CLRLIN to avoid off page errors...
0103   0000             ;
0104   0000             ; 011	-- There was a nasty bug in CLRMEM: such that it didn't actually zero
0105   0000             ;	   memory, but rather scribbled garbage all over it!
0106   0000             ;
0107   0000             ; 012	-- Implement LBRI to handle control character, escape character and
0108   0000             ;	   escape state tables.  Implement control table, but leave the rest
0109   0000             ;	   for later.
0110   0000             ;
0111   0000             ; 013	-- Implement rudimentary escape processing.
0112   0000             ;
0113   0000             ; 014	-- A BNF in ESCAP1 should have been a BDF...
0114   0000             ;
0115   0000             ; 015	-- Fix a misplaced label that causes EEOL <ESC>K to fail...
0116   0000             ;
0117   0000             ; 016	-- Implement direct cursor addressing (<ESC> Y <row> <col>)
0118   0000             ;
0119   0000             ; 017	-- Implement the graphics character set and the <ESC>F (select GCS)
0120   0000             ;	   and <ESC>G (deselect GCS) escape sequences.  Also implement the
0121   0000             ; 	   SI (shift in) and SO (shift out) ASCII control characters to do
0122   0000             ;	   the same thing (all of this is just as a real VT52 would have done).
0123   0000             ;
0124   0000             ; 018	-- Implement <ESC>N <attr> write 8275 field attributes escape sequence.
0125   0000             ;
0126   0000             ; 019	-- Add ^G (BEL) support using the speaker on the GPIO card...
0127   0000             ;
0128   0000             ; 020	-- Add line wrapping at the right margin.  A real VT52 didn't do this,
0129   0000             ;	   but it's really more useful this way!
0130   0000             ;
0131   0000             ; 021	-- Add the local copyright notice...
0132   0000             ;
0133   0000             ; 022	-- Add the screen adjustment/test function, <ESC>T ...
0134   0000             ;
0135   0000             ; 023	-- Rewrite the ISR to take advantage of new hardware design.
TASM 1802 Assembler.              video.asm                        page 13
VIDEO -- COSMAC Elf 2000 Video Terminal Module

0136   0000             ;	   This reduces the interrupt overhead significantly...
0137   0000             ;
0138   0000             ; 024	-- a "SEP PC" is missing from INIT75 during the 8275 presence test!
0139   0000             ; 	   Thanks go to Ian May, fps16xn3@yahoo.com, for figuring this out.
0140   0000             ;--
0141   0000             VIDVER	.EQU	24
0142   0000             
TASM 1802 Assembler.              video.asm                        page 14
VIDEO -- COSMAC Elf 2000 Video Terminal Module

0143   0000             	.EJECT
0144   0000             ;	.SBTTL	Frame Buffer and RAM Storage Map
0145   0000             
0146   0000             ;   A 80x24 terminal requires 1,920 bytes for the display buffer alone, plus
0147   0000             ; whatever local storage the terminal emulator requires.  To make things 
0148   0000             ; simple, and to allow for a possible expansion to an 80x25 format, we round
0149   0000             ; this off to an even 2K bytes.  Since the monitor already reserves the last
0150   0000             ; page of RAM, $7F00..$7FFF, for its use, we're left with reserving $7700 to
0151   0000             ; $7EFF for the video system.
0152   0000             
0153   7700             	.ORG	SCREEN
0154   7700             
0155   7700             ;   ASCII frame buffer...   Note that there is a table at LINTAB: which must
0156   7700             ; contain at least MAXY entries.  If you change MAXY, it might be a good idea
0157   7700             ; to check that table too!
0158   7700             MAXX	.EQU	80		; number of characters per line
0159   7700             MAXY	.EQU	24		; number of lines per screen
0160   7700             	.BLOCK	MAXX * MAXY	; the whole screen lives here!
0161   7E80             SCREND	.EQU	$
0162   7E80             
0163   7E80             ; Other random VT52 emulator context variables...
0164   7E80             ;   WARNING!! DO NOT CHANGE THE ORDER OF TOPLIN, CURSX and CURSY!  The code
0165   7E80             ; DEPENDS on these three bytes being in this particular order!!!
0166   7E80             TOPLIN: .BLOCK	1		; the number of the top line on the screen
0167   7E81             CURSX:	.BLOCK	1		; the column number of the cursor
0168   7E82             CURSY:	.BLOCK	1		; the row number of the cursor
0169   7E83             GCSMOD:	.BLOCK	1		; != 0 for graphics character set mode
0170   7E84             ; DON'T CHANGE THE GROUPING OF ESCSTA, CURCHR AND SAVCHR!!
0171   7E84             ESCSTA:	.BLOCK	1		; current ESCape state machine state
0172   7E85             CURCHR:	.BLOCK	1		; character we're trying to output
0173   7E86             SAVCHR:	.BLOCK	1		; save one character for escape sequences
0174   7E87             ; DON'T CHANGE THE GROUPING OF FRAME AND BELCNT!!
0175   7E87             FRAME:	.BLOCK	1		; incremented by the end of frame ISR
0176   7E88             BELCNT:	.BLOCK	1		; timer for ^G bell beeper
0177   7E89             DTALEN	.EQU	$-SCREEN	; total size of our RAM space
0178   7E89             
TASM 1802 Assembler.              video.asm                        page 15
VIDEO -- COSMAC Elf 2000 Video Terminal Module

0179   7E89             	.EJECT
0180   7E89             ;	.SBTTL	Entry Vectors
0181   7E89             
0182   7E89             ;   Like most of the other EPROM components, the VT52 emulator has a standard
0183   7E89             ; set of entry vectors located at the start of its ROM space.  These vectors
0184   7E89             ; are the only standard entry points to this module, and should be used by all
0185   7E89             ; other modules to invoke us.  This allows code in the VT52 emulator to change
0186   7E89             ; and move around without affecting anything else...
0187   7E89             ;
0188   7E89             ;   With the exception of the version, all entry points should be CALLed
0189   7E89             ; using SCRT and the standard BOOTS/BIOS register assignments!
0190   9800             	.ORG	VIDEO
0191   9800 C0 98 66    	LBR	INIT75_		; initialize the video card
0192   9803 C0 9C 90    	LBR	VTPUTC_		; output a character to the virtual VT52
0193   9806 00          	.DB 0 \ .DW RIGHTS	; dummy vector for the copyright notice
0193   9807 98 09       
0194   9809             
0195   9809             ; Copyright notice, in plain ASCII...
0196   9809 56 54 31 38 RIGHTS:	.TEXT	"VT1802 Video Card Firmware V"
0196   980D 30 32 20 56 
0196   9811 69 64 65 6F 
0196   9815 20 43 61 72 
0196   9819 64 20 46 69 
0196   981D 72 6D 77 61 
0196   9821 72 65 20 56 
0197   9825 32 34 00    	.DB	(VIDVER/10)+'0', (VIDVER%10)+'0', 0
0198   9828 43 6F 70 79 	.TEXT	"Copyright (C) 2006 by Spare Time Gizmos. All rights reserved."
0198   982C 72 69 67 68 
0198   9830 74 20 28 43 
0198   9834 29 20 32 30 
0198   9838 30 36 20 62 
0198   983C 79 20 53 70 
0198   9840 61 72 65 20 
0198   9844 54 69 6D 65 
0198   9848 20 47 69 7A 
0198   984C 6D 6F 73 2E 
0198   9850 20 41 6C 6C 
0198   9854 20 72 69 67 
0198   9858 68 74 73 20 
0198   985C 72 65 73 65 
0198   9860 72 76 65 64 
0198   9864 2E 
0199   9865 00          	.DB	0
0200   9866             
TASM 1802 Assembler.              video.asm                        page 16
VIDEO -- COSMAC Elf 2000 Video Terminal Module

0201   9866             	.EJECT
0202   9866             ;	.SBTTL	8275 Initialization and POST ...
0203   9866             
0204   9866             ;  This code will figure out whether the 80 column video card is installed and,
0205   9866             ; if it finds one, will initialize the 8275 CRT controller and clears the
0206   9866             ; screen buffer.  As an inseparable part of this it also does the POST of the
0207   9866             ; video card, including displaying the POST codes on the LEDs.  It's normally
0208   9866             ; called only once, during SYSINI.
0209   9866             ;
0210   9866             ;   If the video card is installed it'll be left running, with a blank screen
0211   9866             ; and only the cursor displayed.  After that, text can be displayed by calling
0212   9866             ; VTPUTC.  If no video card is installed, then it doesn't touch any of the
0213   9866             ; RAM allocated to the screen buffer - this is critical, because this memory
0214   9866             ; can be reused for other purposes if the video isn't present.
0215   9866             ;
0216   9866             ;  It returns with DF=1 if the video card is installed and working, and DF=0
0217   9866             ; if it isn't installed or isn't working...
0218   9866             ;
0219   9866             ;  One final note - unlike most other POST routines, this one is called after
0220   9866             ; SCRT is initialized.  That means we have P=3 here, rather than the usual P=0.
0221   9866             ; That's a necessary evil, because we need R0 and R1 in order to start up the
0222   9866             ; CRTC DMA and interrupts...
0223   9866             INIT75_:
0224   9866             
0225   9866             ;   One nasty problem with the 8275 is that it doesn't have a RESET input, so
0226   9866             ; it's possible for it to power up doing almost anything.  Worse, if the 8275
0227   9866             ; is already running and you press the RESET button on the Elf 2000, the 8275
0228   9866             ; keeps right on going!  This is especially a problem for the 1802, which has
0229   9866             ; no way to inhibit DMA requests.
0230   9866             ;
0231   9866             ;  To solve this problem, the ElfVideo hardware inhibits the 8275 interrupt and
0232   9866             ; DMA requests, as well as the sync outputs to the monitor, until the status
0233   9866             ; register is read for the first time.  I'm telling you all this because it's
0234   9866             ; critical that we don't do anything to read the status register until we've
0235   9866             ; initialized the CRTC!
0236   9866             
0237   9866             ;   Just blindly (since we don't yet know whether it's there or not!) send
0238   9866             ; a RESET command to the 8275.  This command requires four parameter bytes
0239   9866             ; which set the format, timing, cursor type, etc for the display.  After
0240   9866             ; this, the 8275 will be in a known state and it will be stay stopped (i.e.
0241   9866             ; no DMA and no IRQs) until we issue a START DISPLAY command.
0242   9866 E3          	SEX	PC			; set X=P
0243   9867 65          	OUT	CRTCC			; write the command register
0244   9868 00          	.DB	CRTC_RESET		;  ... reset the 8275
0245   9869 61          	OUT	CRTCP			; write the parameters
0246   986A 4F          	.DB	$00 + (MAXX-1)		;  ... P1 -> characters per row
0247   986B 61          	OUT	CRTCP			;  ...
0248   986C 57          	.DB	(2-1)<<6 + (MAXY-1)	;  ... P2 -> rows per VRTC,
0249   986D             					;	     rows per screen
0250   986D 61          	OUT	CRTCP			;  ...
0251   986E 89          	.DB	$89			;  ... P3 -> scan line for underline,
0252   986F             					;	     total scan lines per font
0253   986F 61          	OUT	CRTCP			;  ...
0254   9870 C7          	.DB	$C0 + (0<<4) + (16>>1)-1;  ... P4 -> offset line counter,
0255   9871             					;      non-transparent field attributes
0256   9871             					;      blinking block cursor
0257   9871             					;      characters per HRTC
0258   9871             
0259   9871             ;   Ok, now it's safe to read the 8275 status register.  We actually have to
TASM 1802 Assembler.              video.asm                        page 17
VIDEO -- COSMAC Elf 2000 Video Terminal Module

0260   9871             ; read it twice (because RESET doesn't clear all the status bits, and there
0261   9871             ; may be some garbage left over), but the second time should return with
0262   9871             ; all status bits cleared...
0263   9871 E3          	OUTI(LEDS,$39)		; start of video subsytem test
0263   9872 64          
0263   9873 39          
0263   9874 E2          
0264   9875 E2          	SEX	SP		; (OUTI leaves X==SP!)
0265   9876 6D          	INP	CRTCS		; read status and enable video
0266   9877 C4          	NOP			; (small delay in case the 8275 needs it)
0267   9878 6D          	INP	CRTCS		; then read it again
0268   9879 3A DD       	BNZ	NO8275		; there's no 8275 if it is non-zero
0269   987B             
0270   987B             ;   Now we intentionally issue a bad command sequence - a LOAD CURSOR followed
0271   987B             ; by a STOP DISPLAY, with no parameters for the LOAD CURSOR.  If the 8275 is
0272   987B             ; really present this should make it set the IMPROPER COMMAND status bit.
0273   987B E3          	OUTI(LEDS,$38)		; command/status register test
0273   987C 64          
0273   987D 38          
0273   987E E2          
0274   987F E3          	SEX	PC		; [024] output bytes inline
0275   9880 65          	OUT	CRTCC		; write the command register
0276   9881 80          	.DB	CRTC_LDCURS	;  ... load cursor address
0277   9882 65          	OUT	CRTCC		; then do it again
0278   9883 40          	.DB	CRTC_STOP	;  ... stop video command
0279   9884 E2          	SEX	SP		; back to the regular stack
0280   9885 6D          	INP	CRTCS		; and read the status
0281   9886 FB 08       	XRI	CRTC_IC		; it'd better say "IMPROPER COMMAND"...
0282   9888 3A DD       	BNZ	NO8275		; there's no 8275 if it doesn't
0283   988A             
0284   988A             ;   Ok - we know that there's an 8275 present, so it's fair to take over the
0285   988A             ; chunk of RAM that belongs to us and initialize our own local data and the
0286   988A             ; frame buffer...
0287   988A E3          	OUTI(LEDS,$37)		; initialize screen buffer
0287   988B 64          
0287   988C 37          
0287   988D E2          
0288   988E F8 77       	RLDI(P1,SCREEN)		; point P1 at the start of our RAM area
0288   9890 BF          
0288   9891 F8 00       
0288   9893 AF          
0289   9894 F8 07       	RLDI(P2,DTALEN)		; and load the length of that area
0289   9896 BD          
0289   9897 F8 89       
0289   9899 AD          
0290   989A F8 00       CLRMEM:	LDI	0		; fill everything with zeros
0291   989C 5F          	STR	P1		; clear a byte
0292   989D 1F          	INC	P1		; and keep count
0293   989E 2D          	DEC	P2		; ...
0294   989F 8D          	GLO	P2		; have we done them all?
0295   98A0 3A 9A       	BNZ	CLRMEM		;  ... nope
0296   98A2 9D          	GHI	P2		; gotta check both bytes
0297   98A3 3A 9A       	BNZ	CLRMEM		;  ... nope - keep going
0298   98A5 D4          	CALL(ERASE)		; yes - now clear the screen and load the cursor
0298   98A6 9B 40       
0299   98A8             
0300   98A8             ; Now start up the display...
0301   98A8 E3          	OUTI(LEDS,$36)		; initialize display, interrupts on
0301   98A9 64          
TASM 1802 Assembler.              video.asm                        page 18
VIDEO -- COSMAC Elf 2000 Video Terminal Module

0301   98AA 36          
0301   98AB E2          
0302   98AC F8 77       	RLDI(DMAPTR,SCREEN)	; preload the DMA and
0302   98AE B0          
0302   98AF F8 00       
0302   98B1 A0          
0303   98B2 F8 99       	RLDI(INTPC,VIDISR)	;  .... interrupt registers
0303   98B4 B1          
0303   98B5 F8 3B       
0303   98B7 A1          
0304   98B8 E3          	SEX	PC		; back to X=P
0305   98B9 65          	OUT	CRTCC		; Enable CRTC interrupts
0306   98BA A0          	.DB	CRTC_EI		;  ...
0307   98BB 65          	OUT	CRTCC		; Preload the counters
0308   98BC E0          	.DB	CRTC_PRESET	;  ...
0309   98BD 65          	OUT	CRTCC		; Finally, turn on the video
0310   98BE 23          	.DB	CRTC_START+3	;  ... (use maximum DMA rate)
0311   98BF E3          	INT_ON			; what a big leap of faith this is!
0311   98C0 70          
0311   98C1 23          
0312   98C2             
0313   98C2             ;   Now make sure that both the DMA and the end-of-frame interrupts are actually
0314   98C2             ; happening.  That's easy enough to do simply by watching for the DMA pointer
0315   98C2             ; (R0) and the frame counter (FRAME:) to change - if they don't change, then
0316   98C2             ; we'll just spin here forever with the appropriate POST code displayed...
0317   98C2 E3          	OUTI(LEDS,$35)		; no DMA
0317   98C3 64          
0317   98C4 35          
0317   98C5 E2          
0318   98C6 80          TSTDMA:	GLO	DMAPTR		; get the current DMA pointer
0319   98C7 32 C6       	BZ	TSTDMA		; and wait for it to change
0320   98C9 E3          	OUTI(LEDS,$34)		; no end of frame interrupt
0320   98CA 64          
0320   98CB 34          
0320   98CC E2          
0321   98CD F8 7E       	RLDI(P1,FRAME)		; point at the frame counter
0321   98CF BF          
0321   98D0 F8 87       
0321   98D2 AF          
0322   98D3 0F          TSTEOF:	LDN	P1		; get the current count
0323   98D4 FF 3C       	SMI	60		; wait for a full second to go by
0324   98D6 3B D3       	BNF	TSTEOF		; ...
0325   98D8             
0326   98D8             ;  That's it - the video card is alive and ready...
0327   98D8 FF 00       	SDF			; DF=1 for success
0328   98DA F8 18       	LDI	VIDVER		; and return our version number in D
0329   98DC D5          	RETURN
0330   98DD             
0331   98DD             ; Here if no video card is installed...
0332   98DD FC 00       NO8275:	CDF			; return DF=0
0333   98DF F8 00       	LDI	0		;  and D=0
0334   98E1 D5          	RETURN
0335   98E2             
TASM 1802 Assembler.              video.asm                        page 19
VIDEO -- COSMAC Elf 2000 Video Terminal Module

0336   98E2             	.EJECT
0337   9938             	.ORG	VIDEO+256+$30-2+10;; TEMPORARY - for alignment only!
TASM 1802 Assembler.              video.asm                        page 20
VIDEO -- COSMAC Elf 2000 Video Terminal Module

0338   9938             	.EJECT
0339   9938             ;	.SBTTL	8275 Interrupt Service
0340   9938             
0341   9938             ;   The ElfVideo card interrupts the 1802 CPU at the end of every display row
0342   9938             ; and once again at the end of each frame.  For a 24 line display, that's a
0343   9938             ; total of 25 interrupts per frame!  We'd like to do away with with interrupt
0344   9938             ; per character row, but it's essential to the way scrolling is handled that
0345   9938             ; we check the DMA pointer at the end of each row...
0346   9938             
0347   9938             ; Here to exit from the interrupt (and leave the PC pointing to VIDISR!)...
0348   9938 12          VIDRET:	INC	SP		; [2] point SP back to the saved D register
0349   9939 72          VIDRE1:	LDXA			; [2] restore the D register from the stack
0350   993A 70          	RET			; [2] and return from the interrupt
0351   993B             
0352   993B             ;   Here is the video interrupt service routine.  Note that the only context
0353   993B             ; this saves is X, P and D - be very, very careful not to change anything else,
0354   993B             ; especially DF!!!
0355   993B 22          VIDISR:	DEC	SP		; [2] make a space on the stack
0356   993C 78          	SAV			; [2] and push T (the saved X,P)
0357   993D 22          	DEC	SP		; [2] make another spot
0358   993E 73          	STXD			; [2] and now save the D register too
0359   993F 34 53       	B1	EOFISR		; [2] branch for end of frame interrupt
0360   9941             
0361   9941             ;   At the end of each chararacter row we have to check the DMA pointer to
0362   9941             ; see if it's reached the end of the screen buffer and, if it has, wrap it
0363   9941             ; around back to the start of the buffer.  The scrolling depends on this, and
0364   9941             ; it's the reason why we need interrupts at the end of each row...
0365   9941 90          ROWEND:	GHI	DMAPTR		; [2] get the high byte of the DMA pointer
0366   9942 FB 7E       	XRI	HIGH(SCREND)	; [2] compare to the end of the screen buffer
0367   9944 3A 38       	BNZ	VIDRET		; [2] not the same - just return
0368   9946 80          	GLO	DMAPTR		; [2] do the same for the low byte
0369   9947 FB 80       	XRI	LOW(SCREND)	; [2] ...
0370   9949 3A 38       	BNZ	VIDRET		; [2] return if not the end of the buffer
0371   994B             
0372   994B             ; We've reached the end of the screen buffer - wrap around...
0373   994B F8 77       	RLDI(DMAPTR,SCREEN)	; [8] reset the DMA pointer back to the start
0373   994D B0          
0373   994E F8 00       
0373   9950 A0          
0374   9951 30 38       	BR	VIDRET		; [2] and return from interrupt
0375   9953             
0376   9953             
0377   9953             ;   Here for the end of frame interrupt.  In this case we need to compute the
0378   9953             ; address of the first line on the screen, based on TOPLIN, and initialize
0379   9953             ; the DMA pointer to that row in the screen buffer.  BTW, since this interrupt
0380   9953             ; occurs only once per frame we don't have to be quite so careful about speed.
0381   9953 8F          EOFISR:	PUSHR(P1)		; [8] save a temporary register
0381   9954 73          
0381   9955 9F          
0381   9956 73          
0382   9957 6D          	INP	CRTCS		; [2] read the status register to clear the IRQ
0383   9958 7E          	SHLC			; [2] and save DF
0384   9959 52          	STR	SP		; [2] ...
0385   995A F8 7E       	RLDI(P1,TOPLIN)		; [8] point to TOPLIN
0385   995C BF          
0385   995D F8 80       
0385   995F AF          
0386   9960 0F          	LDN	P1		; [2] load the value of TOPLIN
0387   9961 FE          	SHL			; [2] multiply it by two
TASM 1802 Assembler.              video.asm                        page 21
VIDEO -- COSMAC Elf 2000 Video Terminal Module

0388   9962 FC A1       	ADI	LOW(LINTAB)	; [2] index into the line pointer table
0389   9964 AF          	PLO	P1		; [2] save that
0390   9965 F8 99       	LDI	HIGH(LINTAB)	; [2] compute the high byte
0391   9967 7C 00       	ADCI	0		; [2] with carry
0392   9969 BF          	PHI	P1		; [2] ...
0393   996A 4F          	LDA	P1		; [2] get the first byte of the line address
0394   996B B0          	PHI	DMAPTR		; [2] update the DMA pointer for the next frame
0395   996C 0F          	LDN	P1		; [2] next byte too
0396   996D A0          	PLO	DMAPTR		; [2] ...
0397   996E             
0398   996E             ;  Increment the frame counter - this is used by the POST to determine whether
0399   996E             ; the interrupts are working, and it's used to keep track of time (e.g. for
0400   996E             ; beeping the beeper) ...
0401   996E F8 7E       	RLDI(P1,FRAME)		; [8] point at FRAME
0401   9970 BF          
0401   9971 F8 87       
0401   9973 AF          
0402   9974 0F          	LDN	P1		; [2] get the current count
0403   9975 FC 01       	ADI	1		; [2] and increment it
0404   9977 5F          	STR	P1		; [2] ignoring any carry
0405   9978             
0406   9978             ;   If the bell timer (BELCNT, which is conveniently located at FRAME+1!) is
0407   9978             ; non-zero, then the GPIO beeper is turned on and we should decrement BELCNT.
0408   9978             ; When BELCNT reaches zero, we turn off the GPIO speaker.  This is used to
0409   9978             ; implement the ^G bell function of the VT52...
0410   9978 1F          	INC	P1		; [2] point to BELCNT
0411   9979 0F          	LDN	P1		; [2]  get the value now
0412   997A 32 85       	BZ	EOFIS1		; [2] just return now if it's zero
0413   997C FF 01       	SMI	1		; [2] otherwise decrement it
0414   997E 5F          	STR	P1		; [2] and update BELCNT
0415   997F 3A 85       	BNZ	EOFIS1		; [2] just keep going until it reaches zero
0416   9981 E0          	SEX	PC0		; [2] it's done - turn off the speaker now
0417   9982 67          	OUT	GPIO		; [2]  ...
0418   9983 20          	.DB	SPOFF		; [2] (speaker off function code)
0419   9984 E2          	SEX	SP		; [2]  ...
0420   9985             
0421   9985             ; Here to return from the frame interrupt...
0422   9985 72          EOFIS1:	LDXA			; [2] restore DF
0423   9986 76          	SHRC			; [2] ...
0424   9987 72          	POPR(P1)		; [8] restore P1
0424   9988 BF          
0424   9989 72          
0424   998A AF          
0425   998B 30 39       	BR	VIDRE1		; [2] and return
0426   998D             
TASM 1802 Assembler.              video.asm                        page 22
VIDEO -- COSMAC Elf 2000 Video Terminal Module

0427   998D             	.EJECT
0428   998D             ;	.SBTTL	Compute the Address of Any Line
0429   998D             
0430   998D             ;   This subroutine will calculate the address of any line on the screen.
0431   998D             ; The absolute number of the line (i.e. not relative to any scrolling) should
0432   998D             ; be passed in the D and the resulting address is returned in P1...  Uses
0433   998D             ; (but doesn't save!) DP...
0434   998D FF 18       LINADD:	SMI	MAXY		; if the line number is off the screen
0435   998F 33 8D       	BDF	LINADD		; reduce it modulo MAXY
0436   9991 FC 18       	ADI	MAXY		; until it's on the screen
0437   9993 FE          LINAD1: SHL			; now double the line number
0438   9994 FC A1       	ADI	LOW(LINTAB)	; and then point to the address table
0439   9996 A7          	PLO	DP		; save the low byte of the address
0440   9997 F8 99       	LDI	HIGH(LINTAB)	; now do the high byte
0441   9999 7C 00       	ADCI	0		; include any carry from the low byte
0442   999B B7          	PHI	DP		; ...
0443   999C 47          	LDA	DP		; now get the first byte from the table
0444   999D BF          	PHI	P1		; that's the line address
0445   999E 07          	LDN	DP		; and the second byte
0446   999F AF          	PLO	P1		; ...
0447   99A0 D5          	RETURN			; and then that's all there is to do
0448   99A1             
0449   99A1             ;   This table is used to translate character row numbers into actual screen
0450   99A1             ; buffer addresses.  It is indexed by twice the row number (0, 2, 4, ... 48) and
0451   99A1             ; contains the corresponding RAM address of that line. This address is stored in
0452   99A1             ; two bytes, with the low order bits of the address being first.  Needless to
0453   99A1             ; say, it should have at least MAXY entries!  More entries won't hurt, but too
0454   99A1             ; few is really bad...
0455   99A1 77 00       LINTAB:	.DW	SCREEN+( 0*MAXX)	; line #0
0456   99A3 77 50       	.DW	SCREEN+( 1*MAXX)	; line #1
0457   99A5 77 A0       	.DW	SCREEN+( 2*MAXX)	; line #2
0458   99A7 77 F0       	.DW	SCREEN+( 3*MAXX)	; line #3
0459   99A9 78 40       	.DW	SCREEN+( 4*MAXX)	; line #4
0460   99AB 78 90       	.DW	SCREEN+( 5*MAXX)	; line #5
0461   99AD 78 E0       	.DW	SCREEN+( 6*MAXX)	; line #6
0462   99AF 79 30       	.DW	SCREEN+( 7*MAXX)	; line #7
0463   99B1 79 80       	.DW	SCREEN+( 8*MAXX)	; line #8
0464   99B3 79 D0       	.DW	SCREEN+( 9*MAXX)	; line #9
0465   99B5 7A 20       	.DW	SCREEN+(10*MAXX)	; line #10
0466   99B7 7A 70       	.DW	SCREEN+(11*MAXX)	; line #11
0467   99B9 7A C0       	.DW	SCREEN+(12*MAXX)	; line #12
0468   99BB 7B 10       	.DW	SCREEN+(13*MAXX)	; line #13
0469   99BD 7B 60       	.DW	SCREEN+(14*MAXX)	; line #14
0470   99BF 7B B0       	.DW	SCREEN+(15*MAXX)	; line #15
0471   99C1 7C 00       	.DW	SCREEN+(16*MAXX)	; line #16
0472   99C3 7C 50       	.DW	SCREEN+(17*MAXX)	; line #17
0473   99C5 7C A0       	.DW	SCREEN+(18*MAXX)	; line #18
0474   99C7 7C F0       	.DW	SCREEN+(19*MAXX)	; line #19
0475   99C9 7D 40       	.DW	SCREEN+(20*MAXX)	; line #20
0476   99CB 7D 90       	.DW	SCREEN+(21*MAXX)	; line #21
0477   99CD 7D E0       	.DW	SCREEN+(22*MAXX)	; line #22
0478   99CF 7E 30       	.DW	SCREEN+(23*MAXX)	; line #23
0479   99D1 7E 80       	.DW	SCREEN+(24*MAXX)	; line #24
0480   99D3             
TASM 1802 Assembler.              video.asm                        page 23
VIDEO -- COSMAC Elf 2000 Video Terminal Module

0481   99D3             	.EJECT
0482   99D3             ;	.SBTTL	Cursor Primitives
0483   99D3             
0484   99D3             ;   This routine will update the 8275 cursor location so that it agrees with
0485   99D3             ; the software location.  This is called after most cursor motion functions
0486   99D3             ; to actually change the picture on the screen...  Uses (but doesn't save) DP!
0487   99D3 F8 7E       LDCURS:	RLDI(DP,CURSX)		; point to the cursor location
0487   99D5 B7          
0487   99D6 F8 81       
0487   99D8 A7          
0488   99D9 E3          	SEX	PC		; set X=P for a moment
0489   99DA 65          	OUT	CRTCC		; give the load cursor command
0490   99DB 80          	.DB	CRTC_LDCURS	; ...
0491   99DC E2          	SEX	SP		; back to the stack
0492   99DD 47          	LDA	DP		; get the X location
0493   99DE 52          	STR	SP		; save it on the stack for a moment
0494   99DF 61          	OUT	CRTCP		; and send it to the CRTC
0495   99E0 22          	DEC	SP		; (correct for the OUT instruction)
0496   99E1 47          	LDA	DP		; and get CURSY next
0497   99E2 52          	STR	SP		; do the same with it
0498   99E3 61          	OUT	CRTCP		; ...
0499   99E4 22          	DEC	SP		; ...
0500   99E5 D5          	RETURN			; that's all there is to it
0501   99E6             
0502   99E6             ;   This subroutine will compute the actual address of the character under the
0503   99E6             ; cursor.  This address depends on the cursor location (obviously) and also
0504   99E6             ; the value of TOPLIN (which represents the number of the top line on the
0505   99E6             ; screen after scrolling).  The address computed is returned in P1.
0506   99E6 F8 7E       WHERE:	RLDI(DP,TOPLIN)		; point to TOPLIN for starters
0506   99E8 B7          
0506   99E9 F8 80       
0506   99EB A7          
0507   99EC 47          	LDA	DP		; and get that value
0508   99ED 17          	INC	DP		; (skip over CURSX for a moment)
0509   99EE E7          	SEX	DP		; ...
0510   99EF F4          	ADD			; compute TOPLIN+CURSY
0511   99F0 D4          	CALL(LINADD)		; set P1 = address of the cursor line
0511   99F1 99 8D       
0512   99F3 F8 7E       	RLDI(DP,CURSX)		; (LINADD trashes DP anyway!)
0512   99F5 B7          
0512   99F6 F8 81       
0512   99F8 A7          
0513   99F9 8F          	GLO	P1		; get the low byte of the line address
0514   99FA E7          	SEX	DP		; and add CURSX
0515   99FB F4          	ADD			; ...
0516   99FC AF          	PLO	P1		; put it back
0517   99FD 9F          	GHI	P1		; and propagate the carry
0518   99FE 7C 00       	ADCI	0		; to the high byte
0519   9A00 BF          	PHI	P1		; ...
0520   9A01 D5          CURRET:	RETURN			; leave the address in P1 and we're done...
0521   9A02             
TASM 1802 Assembler.              video.asm                        page 24
VIDEO -- COSMAC Elf 2000 Video Terminal Module

0522   9A02             	.EJECT
0523   9A02             ;	.SBTTL	Basic Cursor Motions
0524   9A02             
0525   9A02             ;   This routine will implement the cursor left function. This will move the
0526   9A02             ; cursor left one character. If, however, the cursor is already against the
0527   9A02             ; left  margin of the screen, then no action occurs.
0528   9A02 F8 7E       LEFT:	RLDI(DP,CURSX)		; get the cursor column number
0528   9A04 B7          
0528   9A05 F8 81       
0528   9A07 A7          
0529   9A08 07          	LDN	DP		; ...
0530   9A09 FF 01       	SMI	1		; and move it left one space
0531   9A0B CB 9A 01    	LBNF	CURRET		; return now if the result is .LT. 0
0532   9A0E 57          	STR	DP		; no -- change the software location
0533   9A0F C0 99 D3    	LBR	LDCURS		; and go change the picture on the screen
0534   9A12             
0535   9A12             ;   This routine will implement the cursor right function. This will move the
0536   9A12             ; cursor right one character. If, however, the cursor is already against the
0537   9A12             ; right margin of the screen, then no action occurs.
0538   9A12 F8 7E       RIGHT:	RLDI(DP,CURSX) 		; get the cursor X location
0538   9A14 B7          
0538   9A15 F8 81       
0538   9A17 A7          
0539   9A18 07          	LDN	DP		; ...
0540   9A19 FB 4F       	XRI	MAXX-1		; don't allow it to move past this
0541   9A1B C2 9A 01    	LBZ	CURRET		; already at the right margin - quit now
0542   9A1E 07          RIGHT1:	LDN	DP		; nope - its safe to increment the cursor
0543   9A1F FC 01       	ADI	1		; ...
0544   9A21 57          	STR	DP		; update memory
0545   9A22 C0 99 D3    	LBR	LDCURS		; and tell the 8275 about the change
0546   9A25             
0547   9A25             ;   This routine will implement the cursor up function.  This will move the
0548   9A25             ; cursor up one character line. If, however, the cursor is already at the top
0549   9A25             ; of the screen, then no action occurs.;
0550   9A25 F8 7E       UP:	RLDI(DP,CURSY)		; get the row which contains the cursor
0550   9A27 B7          
0550   9A28 F8 82       
0550   9A2A A7          
0551   9A2B 07          	LDN	DP		; ...
0552   9A2C FF 01       	SMI	1		; and move it up one character row
0553   9A2E CB 9A 01    	LBNF	CURRET		; return now if the new position is .LT. 0
0554   9A31 57          	STR	DP		; no -- change the virtual location
0555   9A32 C0 99 D3    	LBR	LDCURS		; and change the picture
0556   9A35             
0557   9A35             ;   This routine will implement the cursor down function. This will move the
0558   9A35             ; cursor down one character line. If, however, the cursor is already at the
0559   9A35             ; bottom of the screen, then no action occurs.
0560   9A35 F8 7E       DOWN:	RLDI(DP,CURSY)		; get the row number where the cursor is
0560   9A37 B7          
0560   9A38 F8 82       
0560   9A3A A7          
0561   9A3B 07          	LDN	DP		; ...
0562   9A3C FB 17       	XRI	MAXY-1		; don't allow the Y position to exceed this
0563   9A3E C2 9A 01    	LBZ	CURRET		; return if we can't move any more
0564   9A41 07          	LDN	DP		; nope - its safe to increment the cursor
0565   9A42 FC 01       	ADI	1		; ...
0566   9A44 57          	STR	DP		; ...
0567   9A45 C0 99 D3    	LBR	LDCURS		; and go tell the 8275
0568   9A48             
TASM 1802 Assembler.              video.asm                        page 25
VIDEO -- COSMAC Elf 2000 Video Terminal Module

TASM 1802 Assembler.              video.asm                        page 26
VIDEO -- COSMAC Elf 2000 Video Terminal Module

0569   9A48             	.EJECT
0570   9A48             ;	.SBTTL	Screen Scrolling Routines
0571   9A48             
0572   9A48             ;   This routine will scroll the screen down one line. The new top line on the
0573   9A48             ; screen (which used to be the bottom line) is the cleared to all spaces.
0574   9A48             ; Note that this routine does not change the cursor location (normally it
0575   9A48             ; won't  need  to be changed).
0576   9A48 F8 7E       SCRDWN:	RLDI(DP,TOPLIN)		; get the line number of the top of the screen
0576   9A4A B7          
0576   9A4B F8 80       
0576   9A4D A7          
0577   9A4E 07          	LDN	DP		; ...
0578   9A4F FF 01       	SMI	1		; and move it down one line
0579   9A51 33 55       	BDF	SCRDW1		; jump if we don't need to wrap around
0580   9A53 F8 17       	LDI	MAXY-1		; wrap around to the other end of the screen
0581   9A55 57          SCRDW1: STR	DP		; update the top line on the screen
0582   9A56 D4          	CALL(LINADD)		; calculate the address of this line
0582   9A57 99 8D       
0583   9A59 C0 9A FE    	LBR	CLRLIN		; and then go clear it
0584   9A5C             
0585   9A5C             ;   This routine will scroll the screen up one line. The new bottom line on
0586   9A5C             ; the screen (which used to be the top line) is then cleared to	all spaces.
0587   9A5C             ; Note that this routine does not change the cursor location (normally it
0588   9A5C             ; won't need to be changed).
0589   9A5C F8 7E       SCRUP:	RLDI(DP,TOPLIN)		; get the current top line on the screen
0589   9A5E B7          
0589   9A5F F8 80       
0589   9A61 A7          
0590   9A62 07          	LDN	DP		; ...
0591   9A63 AF          	PLO	P1		; and remember that for later
0592   9A64 FC 01       	ADI	1		; then move the top line down to the next line
0593   9A66 57          	STR	DP		; ...
0594   9A67 FF 18       	SMI	MAXY		; do we need to wrap the line counter around ?
0595   9A69 3B 6E       	BNF	SCRUP1		; Jump if not
0596   9A6B F8 00       	LDI	0		; yes -- reset the counter back to the first
0597   9A6D 57          	STR	DP		; ... line on the screen
0598   9A6E 8F          SCRUP1:	GLO	P1		; then get back the number of the bottom line
0599   9A6F D4          	CALL(LINADD)		; calculate its address
0599   9A70 99 8D       
0600   9A72 C0 9A FE    	LBR	CLRLIN		; and then go clear it
0601   9A75             
TASM 1802 Assembler.              video.asm                        page 27
VIDEO -- COSMAC Elf 2000 Video Terminal Module

0602   9A75             	.EJECT
0603   9A75             ;	.SBTTL	Advanced Cursor Motions
0604   9A75             
0605   9A75             ;   This routine implements the tab function. This will move the cursor to
0606   9A75             ; the next tab stop.  Tabs stops are located in columns 9, 17, 25, 33, etc
0607   9A75             ; (i.e. column 8i+1, 0<=i<=9). But after column 73, a tab will only advance
0608   9A75             ; the cursor to the next character, and once the cursor reaches the right
0609   9A75             ; margin a tab will not advance it any further.
0610   9A75 F8 7E       TAB:	RLDI(DP,CURSX)		; get the current column of the cursor
0610   9A77 B7          
0610   9A78 F8 81       
0610   9A7A A7          
0611   9A7B 07          	LDN	DP		; ...
0612   9A7C FF 47       	SMI	MAXX-8-1	; are we close to the right edge of the screen?
0613   9A7E C3 9A 12    	LBDF	RIGHT		; just do a single right motion if we are
0614   9A81 07          	LDN	DP		; no - get the current column back again
0615   9A82 FA F8       	ANI	$F8		; and clear the low 3 bits of the address
0616   9A84 FC 08       	ADI	8		; advance to the next multiple of 8
0617   9A86 57          	STR	DP		; update the software cursor location
0618   9A87 C0 99 D3    	LBR	LDCURS		; and also change the picture on the screen
0619   9A8A             
0620   9A8A             ;   This routine will implement the carriage return function. This will move
0621   9A8A             ; the cursor back to the start of the current line.
0622   9A8A F8 7E       CRET:	RLDI(DP,CURSX)		; point to the X cursor location
0622   9A8C B7          
0622   9A8D F8 81       
0622   9A8F A7          
0623   9A90 F8 00       	LDI	0		; and set it to the first column
0624   9A92 57          	STR	DP		; just put the cursor there
0625   9A93 C0 99 D3    	LBR	LDCURS		; now go tell the 8275
0626   9A96             
0627   9A96             ;   This routine will implement the home function.  This will move the cursor
0628   9A96             ; to the upper left corner of the screen.
0629   9A96 F8 7E       HOME:	RLDI(DP,CURSX)		; (CURSX comes before CURSY)
0629   9A98 B7          
0629   9A99 F8 81       
0629   9A9B A7          
0630   9A9C F8 00       	LDI	0		; set both CURSX and CURSY to zero
0631   9A9E 57          	STR	DP		; CURSX...
0632   9A9F 17          	INC	DP		; ...
0633   9AA0 57          	STR	DP		; and CURSY...
0634   9AA1 C0 99 D3    	LBR	LDCURS		; then let the user see the change
0635   9AA4             
0636   9AA4             ;   This routine will implement the line feed function. This function will
0637   9AA4             ; move the cursor down one line, unless the cursor happens to be on the
0638   9AA4             ; bottom of the screen. In this case the screen is scrolled up one line and
0639   9AA4             ; the cursor remains in the same location (on the screen).
0640   9AA4 D4          AUTONL:	CALL(CRET)		; here for an auto carriage return/line feed
0640   9AA5 9A 8A       
0641   9AA7 F8 7E       LINEFD: RLDI(DP,CURSY)		; get the line location of the cursor
0641   9AA9 B7          
0641   9AAA F8 82       
0641   9AAC A7          
0642   9AAD 07          	LDN	DP		; ...
0643   9AAE FF 17       	SMI	MAXY-1		; is it on the bottom of the screen ?
0644   9AB0 CB 9A 35    	LBNF	DOWN		; just do a down operation if it is
0645   9AB3 C0 9A 5C    	LBR	SCRUP		; otherwise go scroll the screen up
0646   9AB6             
0647   9AB6             ;   This routine will implement the reverse line feed function.  This
TASM 1802 Assembler.              video.asm                        page 28
VIDEO -- COSMAC Elf 2000 Video Terminal Module

0648   9AB6             ; function will move the cursor up one line, unless the cursor happens to
0649   9AB6             ; be on the top of the screen. In this case the screen is scrolled down one
0650   9AB6             ; line and the cursor remains in the same location (on the screen).
0651   9AB6 F8 7E       RLF:	RLDI(DP,CURSY)		; load the current Y location of the cursor
0651   9AB8 B7          
0651   9AB9 F8 82       
0651   9ABB A7          
0652   9ABC 07          	LDN	DP		; is it on the top of the screen ?
0653   9ABD CA 9A 25    	LBNZ	UP		; just do an up operation if it isn't
0654   9AC0 C0 9A 48    	LBR	SCRDWN		; otherwise go scroll the screen down
0655   9AC3             
TASM 1802 Assembler.              video.asm                        page 29
VIDEO -- COSMAC Elf 2000 Video Terminal Module

0656   9AC3             	.EJECT
0657   9AC3             ;	.SBTTL	Screen Erase Functions
0658   9AC3             
0659   9AC3             ;   This routine will erase all characters from the current cursor location
0660   9AC3             ; to the end of the screen, including the character under the cursor.
0661   9AC3 8D          EEOS:	PUSHR(P2)		; save P2
0661   9AC4 73          
0661   9AC5 9D          
0661   9AC6 73          
0662   9AC7 F8 7E       	RLDI(DP,TOPLIN)		; find the line that's on the top of the screen
0662   9AC9 B7          
0662   9ACA F8 80       
0662   9ACC A7          
0663   9ACD 07          	LDN	DP		; ...
0664   9ACE D4          	CALL(LINADD)		; then calculate its address in P1
0664   9ACF 99 8D       
0665   9AD1 9F          	RCOPY(P2,P1)		; put that address in P1 for a while
0665   9AD2 BD          
0665   9AD3 8F          
0665   9AD4 AD          
0666   9AD5 D4          	CALL(WHERE)		; and find out where the cursor is
0666   9AD6 99 E6       
0667   9AD8 F8 20       EEOS1:	LDI	' '		; clear this character
0668   9ADA 5F          	STR	P1		; ...
0669   9ADB 1F          	INC	P1		; and increment the pointer
0670   9ADC 8F          	GLO	P1		; get the low bits of the address
0671   9ADD FB 80       	XRI	LOW(SCREND)	; have we reached the end of the screen space ?
0672   9ADF 3A EC       	BNZ	EEOS2		; jump if we haven't
0673   9AE1 9F          	GHI	P1		; yes -- check the high order bits too
0674   9AE2 FB 7E       	XRI	HIGH(SCREND)	; well, ???
0675   9AE4 3A EC       	BNZ	EEOS2		; again jump if we haven't
0676   9AE6 F8 77       	RLDI(P1,SCREEN)		; yes -- wrap around to the start of the screen
0676   9AE8 BF          
0676   9AE9 F8 00       
0676   9AEB AF          
0677   9AEC 8F          EEOS2:	GLO	P1		; get the low byte of the address (again!)
0678   9AED 52          	STR	SP		; ...
0679   9AEE 8D          	GLO	P2		; have we reached the top of the screen yet ?
0680   9AEF F3          	XOR			; ???
0681   9AF0 3A D8       	BNZ	EEOS1		; keep clearing if we haven't
0682   9AF2 9F          	GHI	P1		; maybe -- we need to check the high byte too
0683   9AF3 52          	STR	SP		; ...
0684   9AF4 9D          	GHI	P2		; ????
0685   9AF5 F3          	XOR			; ...
0686   9AF6 3A D8       	BNZ	EEOS1		; keep on going if we aren't there yet
0687   9AF8 60          	IRX			; return and restore P2
0688   9AF9 72          	POPRL(P2)		; ...
0688   9AFA BD          
0688   9AFB F0          
0688   9AFC AD          
0689   9AFD D5          	RETURN			; otherwise that's all there is to it
0690   9AFE             
0691   9AFE             ;   This routine will clear 80 characters in the display RAM.  This is normally
0692   9AFE             ; used to erase lines for scrolling purposes. It expects the address of the
0693   9AFE             ; first byte to be passed in P1; this byte and the next 79 are set to a space
0694   9AFE             ; character.
0695   9AFE 89          CLRLIN:	PUSHR(T1)		; save T1.0 so we can use it as a temporary
0695   9AFF 73          
0695   9B00 99          
TASM 1802 Assembler.              video.asm                        page 30
VIDEO -- COSMAC Elf 2000 Video Terminal Module

0695   9B01 73          
0696   9B02 F8 50       	LDI	MAXX		; get the number of characters per line
0697   9B04 A9          	PLO	T1		; and store that here
0698   9B05 F8 20       CLRLI1: LDI	' '		; set this byte to a space
0699   9B07 5F          	STR	P1		; ...
0700   9B08 1F          	INC	P1		; and advance to the next one
0701   9B09 29          	DEC	T1		; decrement the counter
0702   9B0A 89          	GLO	T1		; and loop if there are more bytes to be done
0703   9B0B 3A 05       	BNZ	CLRLI1		; ...
0704   9B0D 60          	IRX			; restore T1.0 before we return
0705   9B0E 72          	POPRL(T1)		;  ...
0705   9B0F B9          
0705   9B10 F0          
0705   9B11 A9          
0706   9B12 D5          	RETURN			; and that's all for now
0707   9B13             
0708   9B13             ;   This routine will erase all characters from the current cursor location to
0709   9B13             ; the end of the line, including the character under the cursor.
0710   9B13 89          EEOL:	PUSHR(T1)		; save T1 so we can use it as a temporary
0710   9B14 73          
0710   9B15 99          
0710   9B16 73          
0711   9B17 D4          	CALL(WHERE)		; set P1 = address of the cursor
0711   9B18 99 E6       
0712   9B1A F8 7E       	RLDI(DP,CURSX)		; get the current column of the cursor
0712   9B1C B7          
0712   9B1D F8 81       
0712   9B1F A7          
0713   9B20 07          	LDN	DP		; ... and then figure out how many characters
0714   9B21 FF 50       	SMI	MAXX		; ... remain until the end of the line
0715   9B23 A9          	PLO	T1		; and save that for later
0716   9B24 F8 20       EEOL1:	LDI	' '		; clear this character to a blank
0717   9B26 5F          	STR	P1		; ...
0718   9B27 1F          	INC	P1		; ... and advance to the next character
0719   9B28 19          	INC	T1		; count the number of characters cleared
0720   9B29 89          	GLO	T1		; have we reached the end of the line yet ??
0721   9B2A 3A 24       	BNZ	EEOL1		; nope - keep going
0722   9B2C 60          	IRX			; restore T1 before we return
0723   9B2D 72          	POPRL(T1)		; ...
0723   9B2E B9          
0723   9B2F F0          
0723   9B30 A9          
0724   9B31 D5          	RETURN			; then that's all there is
0725   9B32             
TASM 1802 Assembler.              video.asm                        page 31
VIDEO -- COSMAC Elf 2000 Video Terminal Module

0726   9B32             	.EJECT
0727   9B32             ;	.SBTTL	Bell (^G) Function
0728   9B32             
0729   9B32             ;   Just like a real terminal, we have a bell that can be sounded by the ^G
0730   9B32             ; character.  This is implemented using the speaker and fixed frequency tone
0731   9B32             ; generator on the GPIO card - all we have to do is turn it on (easy) and then
0732   9B32             ; turn it off again in a little bit (harder!).  To arrange for the speaker
0733   9B32             ; to be turned off, we set the location BELCNT to a non-zero value.  When ever
0734   9B32             ; BELCNT is non-zero the end of video frame ISR will decrement the counter
0735   9B32             ; and, when BELCNT makes the 1->0 transition, turns off the speaker.
0736   9B32             
0737   9B32 E3          BELL:	OUTI(GPIO,SPTONE)	; turn on the speaker
0737   9B33 67          
0737   9B34 28          
0737   9B35 E2          
0738   9B36 F8 7E       	RLDI(DP,BELCNT)		; point to BELCNT
0738   9B38 B7          
0738   9B39 F8 88       
0738   9B3B A7          
0739   9B3C             ;  The value we store into BELCNT determines the length of the tone, in frames.
0740   9B3C             ; About one sixth of a second sounds like a good value...
0741   9B3C F8 0A       	LDI	10		; ...
0742   9B3E 57          	STR	DP		; set BELCNT=30
0743   9B3F D5          	RETURN			; that's all we have to do!
0744   9B40             
TASM 1802 Assembler.              video.asm                        page 32
VIDEO -- COSMAC Elf 2000 Video Terminal Module

0745   9B40             	.EJECT
0746   9B40             ;	.SBTTL	Clear Screen (<ESC>E or ^L/FF) Function
0747   9B40             
0748   9B40             ;  This  routine will implement the erase function. This will move the cursor
0749   9B40             ; to the home position and fill the entire screen with blank characters.
0750   9B40 F8 20       ERASE:	LDI	' '		; fill the screen with a blank character
0751   9B42             				; and fall into the fill routine
0752   9B42             
0753   9B42             ;   This is a local routine to home the cursor and fill the screen with the
0754   9B42             ; character contained in D.
0755   9B42 AF          FILL:	PLO	P1		; save the fill character for a while
0756   9B43 89          	PUSHR(T1)		; save T1 for a temporary register
0756   9B44 73          
0756   9B45 99          
0756   9B46 73          
0757   9B47 8D          	PUSHR(P2)		; we need to use P2 also
0757   9B48 73          
0757   9B49 9D          
0757   9B4A 73          
0758   9B4B 8F          	GLO	P1		; now move the fill character to a safe
0759   9B4C A9          	PLO	T1		;  ... place
0760   9B4D D4          	CALL(HOME)		; go move the cursor to home
0760   9B4E 9A 96       
0761   9B50 F8 77       	RLDI(P1,SCREEN)		; then point to the start of the screen space
0761   9B52 BF          
0761   9B53 F8 00       
0761   9B55 AF          
0762   9B56 F8 07       	RLDI(P2,MAXX*MAXY)	; and load the number of characters here
0762   9B58 BD          
0762   9B59 F8 80       
0762   9B5B AD          
0763   9B5C 89          FILL1:	GLO	T1		; get the filler byte back
0764   9B5D 5F          	STR	P1		; put the fill character in this location
0765   9B5E 1F          	INC	P1		; and move to the next one
0766   9B5F 2D          	DEC	P2		; decrement the counter
0767   9B60 8D          	GLO	P2		; all done?
0768   9B61 3A 5C       	BNZ	FILL1		; nope - keep going
0769   9B63 9D          	GHI	P2		; check both halves
0770   9B64 3A 5C       	BNZ	FILL1		; ...
0771   9B66 60          	IRX			; restore T1 and P2 before we return
0772   9B67 72          	POPR(P2)		; ...
0772   9B68 BD          
0772   9B69 72          
0772   9B6A AD          
0773   9B6B 72          	POPRL(T1)		; ...
0773   9B6C B9          
0773   9B6D F0          
0773   9B6E A9          
0774   9B6F D5          	RETURN			; all done!
0775   9B70             
TASM 1802 Assembler.              video.asm                        page 33
VIDEO -- COSMAC Elf 2000 Video Terminal Module

0776   9B70             	.EJECT
0777   9B70             ;	.SBTTL	Write Characters to the Screen
0778   9B70             
0779   9B70             ;   This routine is called whenever a printing character is received.  This
0780   9B70             ; character will be written to the screen at the current cusror location.
0781   9B70             ; After this operation, the cursor will move right one character.  If the
0782   9B70             ; cursor is at the right edge of the screen, it will not 'wrap around' to the
0783   9B70             ; next line.  The character to be written should be passed in D.
0784   9B70             ;
0785   9B70             ;   Like the VT52, we have both a "normal" mode and an alternate (graphics)
0786   9B70             ; character set mode.  In graphics character set (aka GCS) mode, if we
0787   9B70             ; receive an ASCII character from 0x60..0x7E (i.e. a lower case character)
0788   9B70             ; then it's replaced with the corresponding character from the GCS instead.
0789   9B70             ; In our particular case, the GCS is stored in the character generator ROM
0790   9B70             ; locations corresponding to codes 0x00..0x1F, so we have to convert the
0791   9B70             ; 0x60..0x7E code into this range.
0792   9B70             ;
0793   9B70             ;   Note that upper case ASCII characters in the range 0x20..0x5F are not
0794   9B70             ; affected by the character set mode.  Also note that our graphics font
0795   9B70             ; isn't necessarily the same as the VT52!
0796   9B70 73          NORMAL:	PUSHD			; save the character for a minute
0797   9B71             
0798   9B71             ; Check the character set mode...
0799   9B71 FF 60       	SMI	$60		; is this even a lower case letter anyway?
0800   9B73 3B 83       	BNF	NORMA1		; nope - just continue normally
0801   9B75 F8 7E       	RLDI(DP,GCSMOD)		; yes - get the character set mode flag
0801   9B77 B7          
0801   9B78 F8 83       
0801   9B7A A7          
0802   9B7B 07          	LDN	DP		; ...
0803   9B7C 32 83       	BZ	NORMA1		; branch if normal mode
0804   9B7E 60          	IRX			; GCS mode - point to the original character
0805   9B7F F8 60       	LDI	$60		; and shift it down to 0x00..0x1F
0806   9B81 F5          	SD			; ...
0807   9B82 73          	STXD			; and store it back
0808   9B83             
0809   9B83             ; Now store the character in memory (finally!)
0810   9B83 D4          NORMA1:	CALL(WHERE)		; calculate the address of the cursor
0810   9B84 99 E6       
0811   9B86 60          	POPD			; ....
0811   9B87 F0          
0812   9B88 5F          	STR	P1		; then write the character there
0813   9B89             
0814   9B89             ;   After storing the character we want to move the cursor right.  This could
0815   9B89             ; be as simple as just calling RIGHT:, but but that will stop moving the cursor
0816   9B89             ; at the right margin.  We'd prefer to have autowrap, which means that we need
0817   9B89             ; to start a new line if we jsut wrote the 80th character on this line...
0818   9B89 F8 7E       	RLDI(DP,CURSX) 		; get the cursor X location
0818   9B8B B7          
0818   9B8C F8 81       
0818   9B8E A7          
0819   9B8F 07          	LDN	DP		; ...
0820   9B90 FB 4F       	XRI	MAXX-1		; are we at the right edge?
0821   9B92 CA 9A 1E    	LBNZ	RIGHT1		; nope - just move right and return
0822   9B95 C0 9A A4    	LBR	AUTONL		; yes - do an automatic new line
0823   9B98             
TASM 1802 Assembler.              video.asm                        page 34
VIDEO -- COSMAC Elf 2000 Video Terminal Module

0824   9B98             	.EJECT
0825   9B98             ;	.SBTTL	Interpret Escape Sequences
0826   9B98             
0827   9B98             ;   This routine is called whenever an escape character is detected and what
0828   9B98             ; happens depends, of course, on what comes next.  Unfortunately, that's
0829   9B98             ; something of a problem in this case - in a real terminal we could simply
0830   9B98             ; wait for the next character to arrive, but in this case nothing's going
0831   9B98             ; to happen until we return control to the application. 
0832   9B98             ;
0833   9B98             ;   The only solution is to keep a "flag" which lets us know that the last
0834   9B98             ; character was an ESCape, and then the next time we're called we process
0835   9B98             ; the current character differently.  Since many escape sequences interpret
0836   9B98             ; more than one character after the ESCape, we actually need a little state
0837   9B98             ; machine to keep track of what we shold do with the current character.
0838   9B98 F8 01       ESCAPE:	LDI	EFIRST		; next state is EFIRST (ESCAP1)
0839   9B9A 52          ESCNXT:	STR	SP		; save that for a second
0840   9B9B F8 7E       	RLDI(DP,ESCSTA)		; point to the escape state
0840   9B9D B7          
0840   9B9E F8 84       
0840   9BA0 A7          
0841   9BA1 02          	LDN	SP		; and get the next state back
0842   9BA2 57          	STR	DP		; store it for next time
0843   9BA3 D5          ESCRET:	RETURN			; and then wait for another character
0844   9BA4             
0845   9BA4             ;   Here for the first character after the <ESC> - this alone is enough
0846   9BA4             ; for most (but not all!) escape sequences.  To that end, we start off by
0847   9BA4             ; setting the next state to zero, so if this isn't changed by the action
0848   9BA4             ; routine this byte will by default be the last one in the escape sequence.
0849   9BA4 F8 00       ESCAP1:	LDI	0		; set the next state to zero
0850   9BA6 D4          	CALL(ESCNXT)		; because that's the most likely outcome
0850   9BA7 9B 9A       
0851   9BA9 F8 7E       	RLDI(DP,CURCHR)		; get the current character back again
0851   9BAB B7          
0851   9BAC F8 85       
0851   9BAE A7          
0852   9BAF 07          	LDN	DP		; ....
0853   9BB0 FF 41       	SMI	'A'		; is it less than 'A' ?
0854   9BB2 3B A3       	BNF	ESCRET		; bad sequence if it is
0855   9BB4 FF 1A       	SMI	'Z'-'A'+1	; check the other end of the sequence
0856   9BB6 33 A3       	BDF	ESCRET		; still bad
0857   9BB8 07          	LDN	DP		; get the escape character back again
0858   9BB9 FF 41       	SMI	'A'		; convert to a zero based index
0859   9BBB D4          	CALL(LBRI)		; and dispatch to the right routine
0859   9BBC 9C 79       
0860   9BBE 9D 40       	.DW	ESCCHR		; ...
0861   9BC0 D5          	RETURN			; just return
0862   9BC1             
TASM 1802 Assembler.              video.asm                        page 35
VIDEO -- COSMAC Elf 2000 Video Terminal Module

0863   9BC1             	.EJECT
0864   9BC1             ;	.SBTTL	Raster Test (<ESC>Q) Function
0865   9BC1             
0866   9BC1             ;   This routine will implement the raster test escape sequence.  The <ESC>Q
0867   9BC1             ; sequence is followed by a single printing character, and the cursor is then
0868   9BC1             ; moved to the home position and the entire screen is filled with this
0869   9BC1             ; character. If the next character after this function should happen to not be
0870   9BC1             ; a printing character, then the screen is filled with blanks...
0871   9BC1             ;
0872   9BC1             ;   Note that this is an extension to the VT52 command set!
0873   9BC1 F8 04       RTEST:	LDI	ERNEXT		; wait for the next byte
0874   9BC3 C0 9B 9A    	LBR	ESCNXT		; store ESCSTA and return
0875   9BC6             
0876   9BC6             ; Here with the raster test character in CURCUR...
0877   9BC6 F8 00       RTEST1:	LDI	0		; first set ESCSTA to zero
0878   9BC8 D4          	CALL(ESCNXT)		; so that this is the end of the sequence
0878   9BC9 9B 9A       
0879   9BCB F8 7E       	RLDI(DP,CURCHR)		; then get the current character
0879   9BCD B7          
0879   9BCE F8 85       
0879   9BD0 A7          
0880   9BD1 07          	LDN	DP		; ...
0881   9BD2 FF 20       	SMI	' '		; make sure it is a printing character
0882   9BD4 CB 9B 40    	LBNF	ERASE		; jump if it is .LT. 32
0883   9BD7 07          	LDN	DP		; get the character back again
0884   9BD8 FB 7F       	XRI	$7F		; make sure it isn't RUBOUT
0885   9BDA C2 9B 40    	LBZ	ERASE		; use space instead if it is
0886   9BDD 07          	LDN	DP		; nope - one more time
0887   9BDE C0 9B 42    	LBR	FILL		; and go fill the screen with it
0888   9BE1             
TASM 1802 Assembler.              video.asm                        page 36
VIDEO -- COSMAC Elf 2000 Video Terminal Module

0889   9BE1             	.EJECT
0890   9BE1             ;	.SBTTL	<ESC>Y - Direct Cursor Addressing
0891   9BE1             
0892   9BE1             ;  This routine implements the direct cursor addressing escape sequence.  The
0893   9BE1             ; <ESC>Y sequence is followed by two data bytes which indicate the line and
0894   9BE1             ; column (in that order) that the cursor is to move to. Both values are biased
0895   9BE1             ; by 32 so that they are appear as printing ASCII characters.  The line number
0896   9BE1             ; character should be in the range 32 to 55 (decimal), and the column number
0897   9BE1             ; character may range from 32 to 112 (decimal).  If either byte is out of
0898   9BE1             ; range, then the cursor will only move as far as the margin.
0899   9BE1             ;
0900   9BE1             ;   For example:
0901   9BE1             ;	<ESC>Y<SP><SP>	- move to (0,0) (i.e. home)
0902   9BE1             ;	<ESC>Y7o	- move to (79,23) (i.e. lower right)
0903   9BE1             
0904   9BE1             ; Here for part 1 - <ESC>Y has been received so far...
0905   9BE1 F8 02       DIRECT:	LDI	EYNEXT		; next state is get Y
0906   9BE3 C0 9B 9A    	LBR	ESCNXT		; update ESCSTA and continue
0907   9BE6             
0908   9BE6             ; Part 2 - the current character is Y, save it and wait for X...
0909   9BE6 F8 7E       DIRECY:	RLDI(DP,CURCHR)		; get the current character
0909   9BE8 B7          
0909   9BE9 F8 85       
0909   9BEB A7          
0910   9BEC 47          	LDA	DP		; load CURCHR, point to SAVCHR
0911   9BED 57          	STR	DP		; and save CURCHR in SAVCHR
0912   9BEE F8 03       	LDI	EXNEXT		; next state is "get X"
0913   9BF0 C0 9B 9A    	LBR	ESCNXT		; ...
0914   9BF3             
0915   9BF3             ; Part 3 - CURCHR is X and SAVCHR is Y.
0916   9BF3 F8 7E       DIRECX:	RLDI(P1,CURCHR)		; point P1 at CURCHR/SAVCHR
0916   9BF5 BF          
0916   9BF6 F8 85       
0916   9BF8 AF          
0917   9BF9 F8 7E       	RLDI(DP,CURSX)		; and DP at CURSX/CURSY
0917   9BFB B7          
0917   9BFC F8 81       
0917   9BFE A7          
0918   9BFF             
0919   9BFF             ;  First handle the X coordinate.  Remember that the cursor moves to the
0920   9BFF             ; corresponding margin if the coordinate give is less than 0 or greater than
0921   9BFF             ; MAXX-1!
0922   9BFF 0F          	LDN	P1		; get the current (X) addressing byte
0923   9C00 FF 20       	SMI	' '		; adjust for the ASCII bias
0924   9C02 33 08       	BDF	DIREC1		; branch if greater than zero
0925   9C04 F8 00       	LDI	0		; less than zero - use zero instead
0926   9C06 30 13       	BR	DIRE12		; change X and proceed
0927   9C08 FF 50       DIREC1:	SMI	MAXX		; would it be greater than MAXX-1?
0928   9C0A 3B 10       	BNF	DIRE11		; branch if not
0929   9C0C F8 4F       	LDI	MAXX-1		; yes - just use MAXX-1 instead
0930   9C0E 30 13       	BR	DIRE12		; rejoin the main code
0931   9C10 0F          DIRE11:	LDN	P1		; the original coordinate is OK
0932   9C11 FF 20       	SMI	' '		; readjust for the bias
0933   9C13 57          DIRE12:	STR	DP		; and update CURSX
0934   9C14             
0935   9C14             ; Now handle the Y coordinate (in SAVCHR) the same way...
0936   9C14 1F          	INC	P1		; point to SAVCHR
0937   9C15 17          	INC	DP		; and point to CURSY
0938   9C16 0F          	LDN	P1		; pretty much the same as before
TASM 1802 Assembler.              video.asm                        page 37
VIDEO -- COSMAC Elf 2000 Video Terminal Module

0939   9C17 FF 20       	SMI	' '		; adjust for ASCII bias
0940   9C19 33 1F       	BDF	DIREC2		; branch if greater than zero
0941   9C1B F8 00       	LDI	0		; nope - use zero instead
0942   9C1D 30 2A       	BR	DIRE22		; ...
0943   9C1F FF 18       DIREC2:	SMI	MAXY		; is it too big for the screen?
0944   9C21 3B 27       	BNF	DIRE21		; branch if not
0945   9C23 F8 17       	LDI	MAXY-1		; yes - use the bottom margin instead
0946   9C25 30 2A       	BR	DIRE22		; ...
0947   9C27 0F          DIRE21:	LDN	P1		; the value is OK - get it back again
0948   9C28 FF 20       	SMI	' '		; ...
0949   9C2A 57          DIRE22:	STR	DP		; and update CURSY
0950   9C2B             
0951   9C2B             ;   Finally, update the cursor on the screen and we're done.  DON'T FORGET to
0952   9C2B             ; change the next state (ESCSTA) to zero to mark the end of this sequence!
0953   9C2B D4          	CALL(LDCURS)		; load the cursor
0953   9C2C 99 D3       
0954   9C2E F8 00       	LDI	0		; next state is zero (back to normal)
0955   9C30 C0 9B 9A    	LBR	ESCNXT		; change ESCSTA and return
0956   9C33             
TASM 1802 Assembler.              video.asm                        page 38
VIDEO -- COSMAC Elf 2000 Video Terminal Module

0957   9C33             	.EJECT
0958   9C33             ;	.SBTTL	Select (<ESC>F) and Deselect (<ESC>G) Graphics Character Set
0959   9C33             
0960   9C33             ;   On the VT52, the <ESC>F command selects the alternate graphics character
0961   9C33             ; set, and the <ESC>G command deselects it.  The SI (Shift In) and SO (Shift
0962   9C33             ; Out) control characters do the same...
0963   9C33             
0964   9C33             ; Enable the graphics character set...
0965   9C33 F8 7E       ENAGCS:	RLDI(DP,GCSMOD)		; point to the GCS mode flag
0965   9C35 B7          
0965   9C36 F8 83       
0965   9C38 A7          
0966   9C39 F8 FF       	LDI	$FF		; set it to non-zero to enable
0967   9C3B 57          	STR	DP		; ...
0968   9C3C D5          	RETURN			; and we're done
0969   9C3D             
0970   9C3D             ; Disable the graphics character set...
0971   9C3D F8 7E       DSAGCS:	RLDI(DP,GCSMOD)		; same as before
0971   9C3F B7          
0971   9C40 F8 83       
0971   9C42 A7          
0972   9C43 F8 00       	LDI	0		; but set the GCS flag to zero
0973   9C45 57          	STR	DP		; ...
0974   9C46 D5          	RETURN			; ...
0975   9C47             
TASM 1802 Assembler.              video.asm                        page 39
VIDEO -- COSMAC Elf 2000 Video Terminal Module

0976   9C47             	.EJECT
0977   9C47             ;	.SBTTL	Write Field Attribute Code (<ESC>N)
0978   9C47             
0979   9C47             ;   This routine is called to processes the Write Field Attribute escape
0980   9C47             ; sequence.  The <ESC>N sequence is followed by a single parameter byte, the
0981   9C47             ; the lower 6 bits of which are written to screen memory as an 8275 field
0982   9C47             ; attribute code (refer to the 8275 data sheet for more information).  The
0983   9C47             ; 8275 is set up in non-transparent attribute mode, so each attribute byte
0984   9C47             ; requires a character location on the screen (which is blanked by the VSP
0985   9C47             ; output).
0986   9C47             ;
0987   9C47             ;   This allows us to get blinking, reverse video, and underline, as well as
0988   9C47             ; select any one of four alternate character sets stored in the EPROM.
0989   9C47             ; Needless to say, the VT52 didn't have this function!
0990   9C47 F8 05       WFAC:	LDI	EANEXT		; wait for the field attribute code
0991   9C49 C0 9B 9A    	LBR	ESCNXT		; set ESCSTA and return
0992   9C4C             
0993   9C4C             ; Here when we receive the next byte...
0994   9C4C F8 00       WFAC1:	LDI	0		; first, set ESCSTA to zero
0995   9C4E D4          	CALL(ESCNXT)		;  ... to end this escape sequence
0995   9C4F 9B 9A       
0996   9C51 F8 7E       	RLDI(DP,CURCHR)		; and then get the current character
0996   9C53 B7          
0996   9C54 F8 85       
0996   9C56 A7          
0997   9C57 07          	LDN	DP		; ...
0998   9C58 FA 3F       	ANI	$3F		; trim it to only six bits
0999   9C5A F9 80       	ORI	$80		; and make it into a field attribute code
1000   9C5C 73          	PUSHD			; save it on the stack for NORMA1
1001   9C5D C0 9B 83    	LBR	NORMA1		; and then go store it in screen memory
1002   9C60             
TASM 1802 Assembler.              video.asm                        page 40
VIDEO -- COSMAC Elf 2000 Video Terminal Module

1003   9C60             	.EJECT
1004   9C60             ;	.SBTTL	Write Line Drawing Code (<ESC>O)
1005   9C60             
1006   9C60             ;   This routine is called to processes the Write Line Drawing Code escape
1007   9C60             ; sequence.  It's pretty much the same "syntax" as the write field attribute
1008   9C60             ; function.  The <ESC>O sequence is followed by a single parameter byte, the
1009   9C60             ; the lower 6 bits of which are written to screen memory as an 8275 line
1010   9C60             ; attribute code.  There are actually only about ten line drawing codes (that's
1011   9C60             ; only four bits worth), but the lower two bits allow the blink and/or reverse
1012   9C60             ; video attributes to be applied to any line drawing character. Refer to the
1013   9C60             ; 8275 data sheet for more information.
1014   9C60 F8 06       WLINE:	LDI	ELNEXT		; wait for a line drawing code
1015   9C62 C0 9B 9A    	LBR	ESCNXT		; set ESCSTA and return
1016   9C65             
1017   9C65             ; Here when we receive the next byte...
1018   9C65 F8 00       WLINE1:	LDI	0		; first, set ESCSTA to zero
1019   9C67 D4          	CALL(ESCNXT)		;  ... to end this escape sequence
1019   9C68 9B 9A       
1020   9C6A F8 7E       	RLDI(DP,CURCHR)		; and then get the current character
1020   9C6C B7          
1020   9C6D F8 85       
1020   9C6F A7          
1021   9C70 07          	LDN	DP		; ...
1022   9C71 FA 3F       	ANI	$3F		; trim it to only six bits
1023   9C73 F9 C0       	ORI	$C0		; and make it into a line drawing code
1024   9C75 73          	PUSHD			; save it on the stack for NORMA1
1025   9C76 C0 9B 83    	LBR	NORMA1		; and then go store it in screen memory
1026   9C79             
TASM 1802 Assembler.              video.asm                        page 41
VIDEO -- COSMAC Elf 2000 Video Terminal Module

1027   9C79             	.EJECT
1028   9C79             ;	.SBTTL	Indirect Table Jump
1029   9C79             
1030   9C79             ;   This routine will take a table of two byte addresses, add the index passed
1031   9C79             ; in the D register, and then jump to the selected routine.  It's used to
1032   9C79             ; dispatch control characters, escape characters, and the next state for the
1033   9C79             ; escape sequence state machine.
1034   9C79             ;
1035   9C79             ; CALL:
1036   9C79             ;	 <put the jump index, 0..n, in D>
1037   9C79             ;	 CALL(LBRI)
1038   9C79             ;	 .DW	TABLE
1039   9C79             ;  	 .....
1040   9C79             ; TABLE: .DW	fptr0	; address of routine 0
1041   9C79             ;	 .DW	fptr1	;  "   "  "   "   "  1
1042   9C79             ;	 ....
1043   9C79             ;
1044   9C79             ;   Notice that the index starts with zero, not one, and that it's actually
1045   9C79             ; an index rather than a table offset.  The difference is that the former 
1046   9C79             ; is multiplied by two (since every table entry is a byte) and the latter
1047   9C79             ; wouldn't be!
1048   9C79             ;
1049   9C79             ;   Since this function is called by a CALL() and it actually jumps to the
1050   9C79             ; destination routine, that routine can simply execute a RETURN to return
1051   9C79             ; back to the original caller.  The inline table address will be automatically
1052   9C79             ; skipped.
1053   9C79 FE          LBRI:	SHL			; multiply the jump index by 2
1054   9C7A 52          	STR	SP		; and then save it on the stack for later
1055   9C7B 46          	LDA	A		; get the high byte of the table address
1056   9C7C B7          	PHI	DP		; and save that
1057   9C7D 46          	LDA	A		; then the low byte
1058   9C7E F4          	ADD			; add in the index
1059   9C7F A7          	PLO	DP		; store the low part
1060   9C80 97          	GHI	DP		; and then propagate the carry bit
1061   9C81 7C 00       	ADCI	0		; ...
1062   9C83 B7          	PHI	DP		; now DP points to the correct entry
1063   9C84 F8 9C       	RLDI(P1,LBRI1)		; then switch the PC to P1 
1063   9C86 BF          
1063   9C87 F8 8B       
1063   9C89 AF          
1064   9C8A DF          	SEP	P1		; ...
1065   9C8B             
1066   9C8B             ; Load the address pointed to by DP into the PC and continue
1067   9C8B 47          LBRI1:	LDA	DP		; get the high byte of the address
1068   9C8C B3          	PHI	PC		; ...
1069   9C8D 47          	LDA	DP		; and then the low byte
1070   9C8E A3          	PLO	PC		; ...
1071   9C8F D3          	SEP	PC		; and away we go!
1072   9C90             
TASM 1802 Assembler.              video.asm                        page 42
VIDEO -- COSMAC Elf 2000 Video Terminal Module

1073   9C90             	.EJECT
1074   9C90             ;	.SBTTL	Interpret Characters
1075   9C90             
1076   9C90             ;   This routine is called whenever a normal (i.e. non-escape sequence)
1077   9C90             ; character is to be sent to the terminal.  It handles both printing 
1078   9C90             ; characters and control characters...
1079   9C90 AE          VTPUTC_:PLO	BAUD		; save character in a safe place
1080   9C91             ;   This SEX SP may seem unnecessary.  After all, we just got here via SCRT
1081   9C91             ; CALL, right?  Well, not necessarily - some code simply LBRs here and doesn't
1082   9C91             ; guarantee the value of X...
1083   9C91 E2          	SEX	SP		; just in case
1084   9C92 87          	PUSHR(DP)		; save DP
1084   9C93 73          
1084   9C94 97          
1084   9C95 73          
1085   9C96 8F          	PUSHR(P1)		;  ... and P1
1085   9C97 73          
1085   9C98 9F          
1085   9C99 73          
1086   9C9A F8 7E       	RLDI(DP,CURCHR)		; point to our local storage
1086   9C9C B7          
1086   9C9D F8 85       
1086   9C9F A7          
1087   9CA0 E7          	SEX	DP		; ...
1088   9CA1 8E          	GLO	BAUD		; get the original character back
1089   9CA2 73          	STXD			; store it in CURCHR
1090   9CA3 72          	LDXA			; and then load ESCSTA
1091   9CA4 3A D4       	BNZ	VTPUT2		; jump if we're processing an escape sequence
1092   9CA6             
1093   9CA6             ; This character is not part of an escape sequence...
1094   9CA6 F0          	LDX			; get the original character back
1095   9CA7 FA 7F       	ANI	$7F		; and trim it to 7 bits
1096   9CA9 32 B8       	BZ	VTPUT9		; ignore null characters
1097   9CAB FB 7F       	XRI	$7F		; and ignore RUBOUTs too
1098   9CAD 32 B8       	BZ	VTPUT9		; ...
1099   9CAF F0          	LDX			; restore the original character
1100   9CB0 FF 20       	SMI	' '		; is this a control character ?
1101   9CB2 3B CC       	BNF	VTPUT1		; branch if yes
1102   9CB4             
1103   9CB4             ; This character is a normal, printing, character...
1104   9CB4 F0          	LDX			; get it back one more time
1105   9CB5 D4          	CALL(NORMAL)		; display it as a normal character
1105   9CB6 9B 70       
1106   9CB8             
1107   9CB8             ;   And return...  It's a bit of extra work, but it's really important that
1108   9CB8             ; we return the same value in D that we were originally called with.  Some
1109   9CB8             ; code, especially the part of the BIOS that echos terminal input, depends
1110   9CB8             ; on this!
1111   9CB8 F8 7E       VTPUT9:	RLDI(DP,CURCHR)		; gotta get back the original data
1111   9CBA B7          
1111   9CBB F8 85       
1111   9CBD A7          
1112   9CBE 07          	LDN	DP		; ...
1113   9CBF AE          	PLO	BAUD		; save it in a temporary location
1114   9CC0 E2          	SEX	SP		; just in case somebody changed it
1115   9CC1 60          	IRX			; now restore the registers we used
1116   9CC2 72          	POPR(P1)		; ...
1116   9CC3 BF          
1116   9CC4 72          
TASM 1802 Assembler.              video.asm                        page 43
VIDEO -- COSMAC Elf 2000 Video Terminal Module

1116   9CC5 AF          
1117   9CC6 72          	POPRL(DP)		; ...
1117   9CC7 B7          
1117   9CC8 F0          
1117   9CC9 A7          
1118   9CCA 8E          	GLO	BAUD		; get the character one more time
1119   9CCB D5          	RETURN			; and we're done!
1120   9CCC             
1121   9CCC             ; Here if this character is a control character...
1122   9CCC F0          VTPUT1:	LDX			; restore the original character
1123   9CCD D4          	CALL(LBRI)		; and dispatch to the correct routine
1123   9CCE 9C 79       
1124   9CD0 9C F1       	.DW	CTLTAB		; ...
1125   9CD2 30 B8       	BR	VTPUT9		; then return normally
1126   9CD4             
1127   9CD4             ; Here if this character is part of an escape sequence...
1128   9CD4 D4          VTPUT2:	CALL(LBRI)		; branch to the next state in escape processing
1128   9CD5 9C 79       
1129   9CD7 9D 32       	.DW	ESTATE		; table of escape states
1130   9CD9 30 B8       	BR	VTPUT9		; and return
1131   9CDB             
TASM 1802 Assembler.              video.asm                        page 44
VIDEO -- COSMAC Elf 2000 Video Terminal Module

1132   9CDB             	.EJECT
1133   9CDB             ;	.SBTTL	Output Text String
1134   9CDB             
1135   9CDB             ;   This little routine will pass an entire string of characters to VTPUTC.
1136   9CDB             ; The pointer to the string is passed inline after the CALL(VTPUTS), and the
1137   9CDB             ; the string should be terminated by a NULL byte.  It's actually only used
1138   9CDB             ; internally to this module...
1139   9CDB 8F          VTPUTS:	PUSHR(P1)		; save P1
1139   9CDC 73          
1139   9CDD 9F          
1139   9CDE 73          
1140   9CDF 46          	LDA	A		; get the address of the string
1141   9CE0 BF          	PHI	P1		; save it here
1142   9CE1 46          	LDA	A		; ...
1143   9CE2 AF          	PLO	P1		; ...
1144   9CE3             
1145   9CE3             ;   Remember that VTPUTC saves _all_ registers, so we conveniently don't have to
1146   9CE3             ; worry about saving P1!...
1147   9CE3 4F          PUTS1:	LDA	P1		; get the next byte
1148   9CE4 32 EB       	BZ	PUTS9		; quit when we find a NULL
1149   9CE6 D4          	CALL(VTPUTC)		; otherwise send it out
1149   9CE7 98 03       
1150   9CE9 30 E3       	BR	PUTS1		; and keep going
1151   9CEB             
1152   9CEB             ; Here when we reach the end of the string...
1153   9CEB 60          PUTS9:	IRX			; restore P1
1154   9CEC 72          	POPRL(P1)		;  ...
1154   9CED BF          
1154   9CEE F0          
1154   9CEF AF          
1155   9CF0 D5          	RETURN			; and we're done
1156   9CF1             	
TASM 1802 Assembler.              video.asm                        page 45
VIDEO -- COSMAC Elf 2000 Video Terminal Module

1157   9CF1             	.EJECT
1158   9CF1             ;	.SBTTL	Control Character Dispatch Table
1159   9CF1             
1160   9CF1             ;   This table is used by LBRI and VTPUTC to dispatch to the correct function
1161   9CF1             ; for any ASCII code .LT. 32.  Any unused control characters should just
1162   9CF1             ; point to NOOP, which simply executes a RETURN instruction.  Note that the
1163   9CF1             ; ASCII NUL code is trapped in VTPUTC and never gets here, but its table
1164   9CF1             ; entry is required anyway to make the rest of the offsets correct.
1165   9CF1 9D 31       CTLTAB:	.DW	NOOP		; 0x00 ^@ NUL
1166   9CF3 9D 31       	.DW	NOOP		; 0x01 ^A SOH
1167   9CF5 9D 31       	.DW	NOOP		; 0x02 ^B STX
1168   9CF7 9D 31       	.DW	NOOP		; 0x03 ^C ETX
1169   9CF9 9D 31       	.DW	NOOP		; 0x04 ^D EOT
1170   9CFB 9D 31       	.DW	NOOP		; 0x05 ^E ENQ
1171   9CFD 9D 31       	.DW	NOOP		; 0x06 ^F ACK
1172   9CFF 9B 32       	.DW	BELL		; 0x07 ^G BEL - ring the "bell" on the GPIO card
1173   9D01 9A 02       	.DW	LEFT		; 0x08 ^H BS  - cursor left (backspace)
1174   9D03 9A 75       	.DW	TAB		; 0x09 ^I HT  - move right to next tab stop
1175   9D05 9A A7       	.DW	LINEFD		; 0x0A ^J LF  - cursor down and scroll up
1176   9D07 9A A7       	.DW	LINEFD		; 0x0B ^K VT  - vertical tab is the same as LF
1177   9D09 9B 40       	.DW	ERASE		; 0x0C ^L FF  - form feed erases the screen
1178   9D0B 9A 8A       	.DW	CRET		; 0x0D ^M CR  - move cursor to left margin
1179   9D0D 9C 3D       	.DW	DSAGCS		; 0x0E ^N SO  - select normal character set
1180   9D0F 9C 33       	.DW	ENAGCS		; 0x0F ^O SI  - select graphics character set
1181   9D11 9D 31       	.DW	NOOP		; 0x10 ^P DLE
1182   9D13 9D 31       	.DW	NOOP		; 0x11 ^Q DC1
1183   9D15 9D 31       	.DW	NOOP		; 0x12 ^R DC2
1184   9D17 9D 31       	.DW	NOOP		; 0x13 ^S DC3
1185   9D19 9D 31       	.DW	NOOP		; 0x14 ^T DC4
1186   9D1B 9D 31       	.DW	NOOP		; 0x15 ^U NAK
1187   9D1D 9D 31       	.DW	NOOP		; 0x16 ^V SYN
1188   9D1F 9D 31       	.DW	NOOP		; 0x17 ^W ETB
1189   9D21 9D 31       	.DW	NOOP		; 0x18 ^X CAN
1190   9D23 9D 31       	.DW	NOOP		; 0x19 ^Y EM
1191   9D25 9D 31       	.DW	NOOP		; 0x1A ^Z SUB
1192   9D27 9B 98       	.DW	ESCAPE		; 0x1B ^[ ESC - introducer for escape sequences
1193   9D29 9D 31       	.DW	NOOP		; 0x1C ^\
1194   9D2B 9D 31       	.DW	NOOP		; 0x1D ^] GS
1195   9D2D 9D 31       	.DW	NOOP		; 0x1E ^^ RS
1196   9D2F 9D 31       	.DW	NOOP		; 0x1F ^_ US
1197   9D31             
1198   9D31 D5          NOOP:	RETURN
1199   9D32             
TASM 1802 Assembler.              video.asm                        page 46
VIDEO -- COSMAC Elf 2000 Video Terminal Module

1200   9D32             	.EJECT
1201   9D32             ;	.SBTTL	Escape Sequence State Table
1202   9D32             
1203   9D32             ;   Whenever we're processing an escape sequence, the index of the next
1204   9D32             ; state is stored in location ESCSTA.  When the next character arrives
1205   9D32             ; that value is used as an index into this table to call the next state.
1206   9D32             
1207   9D32             #define XX(n,r)	.dw r\n .equ ($-ESTATE-2)/2
1208   9D32             
1209   9D32 00 00       ESTATE:	.DW	0		; 0 - never used
1210   9D34 9B A4       	XX(EFIRST,ESCAP1)	; 1 - first character after <ESC>
1210   9D36             
1211   9D36 9B E6       	XX(EYNEXT,DIRECY)	; 2 - <ESC>Y, get first byte (Y)
1211   9D38             
1212   9D38 9B F3       	XX(EXNEXT,DIRECX)	; 3 - <ESC>Y, get second byte (X)
1212   9D3A             
1213   9D3A 9B C6       	XX(ERNEXT,RTEST1)	; 4 - <ESC>Q, get first byte
1213   9D3C             
1214   9D3C 9C 4C       	XX(EANEXT,WFAC1)	; 5 - <ESC>N, get attribute byte
1214   9D3E             
1215   9D3E 9C 65       	XX(ELNEXT,WLINE1)	; 6 - <ESC>O, get line drawing code
1215   9D40             
1216   9D40             
TASM 1802 Assembler.              video.asm                        page 47
VIDEO -- COSMAC Elf 2000 Video Terminal Module

1217   9D40             	.EJECT
1218   9D40             ;	.SBTTL	Escape Sequence Dispatch Table
1219   9D40             
1220   9D40             ;   This table is used to decode the first character in an escape sequence
1221   9D40             ; (not the ESCape, but the one right after the escape!).  It contains only
1222   9D40             ; letters - the code range checks and ignores anything else...
1223   9D40 9A 25       ESCCHR: .DW	UP		; <ESC>A -- Cursor Up
1224   9D42 9A 35       	.DW	DOWN		; <ESC>B -- Cursor Down
1225   9D44 9A 12       	.DW	RIGHT		; <ESC>C -- Cursor Right
1226   9D46 9A 02       	.DW	LEFT		; <ESC>D -- Cursor Left
1227   9D48 9B 40       	.DW	ERASE		; <ESC>E -- Erase Screen
1228   9D4A 9C 33       	.DW	ENAGCS		; <ESC>F -- Select Alternate Character Set
1229   9D4C 9C 3D       	.DW	DSAGCS		; <ESC>G -- Select ASCII Character Set
1230   9D4E 9A 96       	.DW	HOME		; <ESC>H -- Cursor Home
1231   9D50 9A B6       	.DW	RLF		; <ESC>I -- Reverse Line Feed
1232   9D52 9A C3       	.DW	EEOS		; <ESC>J -- Erase to end of Screen
1233   9D54 9B 13       	.DW	EEOL		; <ESC>K -- Erase to end of Line
1234   9D56 9D 31       	.DW	NOOP		; <ESC>L -- Unimplemented
1235   9D58 9D 31       	.DW	NOOP		; <ESC>M -- Unimplemented
1236   9D5A 9C 47       	.DW	WFAC		; <ESC>N -- Write Field Attribute Code
1237   9D5C 9C 60       	.DW	WLINE		; <ESC>O -- Write Line Drawing Code
1238   9D5E 9D 31       	.DW	NOOP		; <ESC>P -- Unimplemented
1239   9D60 9B C1       	.DW	RTEST		; <ESC>Q -- Unimplemented
1240   9D62 9B C1       	.DW	RTEST		; <ESC>R -- Raster Test
1241   9D64 9D 31       	.DW	NOOP		; <ESC>S -- Unimplemented
1242   9D66 9D 74       	.DW	TEST		; <ESC>T -- Unimplemented
1243   9D68 9D 31       	.DW	NOOP		; <ESC>U -- Unimplemented
1244   9D6A 9D 31       	.DW	NOOP		; <ESC>V -- Unimplemented
1245   9D6C 9D 31       	.DW	NOOP		; <ESC>W -- Unimplemented
1246   9D6E 9D 31       	.DW	NOOP		; <ESC>X -- Unimplemented
1247   9D70 9B E1       	.DW	DIRECT		; <ESC>Y -- Direct Cursor Addressing
1248   9D72 9D 31       	.DW	NOOP		; <ESC>Z -- Unimplemented
1249   9D74             
TASM 1802 Assembler.              video.asm                        page 48
VIDEO -- COSMAC Elf 2000 Video Terminal Module

1250   9D74             	.EJECT
1251   9D74             ;	.SBTTL	VT1802 Test/Calibrarion Function
1252   9D74             
1253   9D74             ;   This function fills the screen buffer with a test pattern.  Unlike the
1254   9D74             ; POST test in INIT75, this test is used to adjusting the monitor and checking
1255   9D74             ; out your character generator - it's not really a test of the VT1802 hardware.
1256   9D74             ; This function is normally invoked by an escape sequence and it returns as
1257   9D74             ; soon as the display buffer is filled - the test pattern will remain until
1258   9D74             ; the 1802 code writes something else to the display...
1259   9D74 F8 7F       TEST:	LDI	$7F		; first fill the screen 
1260   9D76 D4          	CALL(FILL)		;  ... with "pin cushion" symbols
1260   9D77 9B 42       
1261   9D79             
1262   9D79             ;   The only goal of all this code is to clear out a rectangle in the middle
1263   9D79             ; of the screen.  It takes more code then I'd like, but there's no other way!
1264   9D79 F8 7E       	RLDI(P1,CURSY)		; point to the Y location
1264   9D7B BF          
1264   9D7C F8 82       
1264   9D7E AF          
1265   9D7F F8 02       	LDI	2		; start on line 2
1266   9D81 5F          	STR	P1		; ...
1267   9D82 F8 7E       TEST10:	RLDI(P1,CURSX)		; reset X to our right margin
1267   9D84 BF          
1267   9D85 F8 81       
1267   9D87 AF          
1268   9D88 F8 04       	LDI	4		; ...
1269   9D8A 5F          	STR	P1		; ...
1270   9D8B             
1271   9D8B             ; Store 72 spaces in screen memory starting at the current cursor location..
1272   9D8B D4          	CALL(WHERE)		; get the screen buffer address in P1
1272   9D8C 99 E6       
1273   9D8E F8 00       	LDI	0		; count the characters stored
1274   9D90 A7          	PLO	DP		; here...
1275   9D91 F8 20       TEST11:	LDI	' '		; store spaces
1276   9D93 5F          	STR	P1		; ...
1277   9D94 1F          	INC	P1		; ...
1278   9D95 17          	INC	DP		; count the characters stored
1279   9D96 87          	GLO	DP		; ...
1280   9D97 FF 48       	SMI	72		; have we done a line?
1281   9D99 3B 91       	BL	TEST11		; nope - keep going
1282   9D9B             
1283   9D9B             ; Advance to the next line ...
1284   9D9B F8 7E       	RLDI(P1,CURSY)		; get the current Y location
1284   9D9D BF          
1284   9D9E F8 82       
1284   9DA0 AF          
1285   9DA1 0F          	LDN	P1		; ...
1286   9DA2 FC 01       	ADI	1		; increment the line number
1287   9DA4 5F          	STR	P1		; put it back
1288   9DA5 FF 16       	SMI	22		; have we done 18 lines?
1289   9DA7 3B 82       	BL	TEST10		; nope - go do more
1290   9DA9             
1291   9DA9             ;   Now we have a "frame" of pin cushion symbols with a blank rectangle in the
1292   9DA9             ; middle.  Let's fill all that in with demos of the various video attributes,
1293   9DA9             ; and the character sets...
1294   9DA9 D4          	CALL(VTPUTS)		; first a little self promotion
1294   9DAA 9C DB       
1295   9DAC 9D B9       	.DW	TSTMS1		;  ...
1296   9DAE D4          	CALL(VTPUTS)		; display the name and version number
TASM 1802 Assembler.              video.asm                        page 49
VIDEO -- COSMAC Elf 2000 Video Terminal Module

1296   9DAF 9C DB       
1297   9DB1 98 09       	.DW	RIGHTS		;  ... of this firmware
1298   9DB3 D4          	CALL(VTPUTS)		; then display everything else
1298   9DB4 9C DB       
1299   9DB6 9D E0       	.DW	TSTMS2		; ...
1300   9DB8 D5          	RETURN			; and we're done here!
1301   9DB9             
1302   9DB9             ; Messages...
1303   9DB9 1B 59 24 27 TSTMS1:	.TEXT	"\033Y$'Spare Time Gizmos COSMAC Elf 2000 \000"
1303   9DBD 53 70 61 72 
1303   9DC1 65 20 54 69 
1303   9DC5 6D 65 20 47 
1303   9DC9 69 7A 6D 6F 
1303   9DCD 73 20 43 4F 
1303   9DD1 53 4D 41 43 
1303   9DD5 20 45 6C 66 
1303   9DD9 20 32 30 30 
1303   9DDD 30 20 00 
1304   9DE0 1B 59 27 65 TSTMS2:	.TEXT	"\033Y'e\033N@\033Y')NORMAL TEXT\033N UNDERLINED TEXT"
1304   9DE4 1B 4E 40 1B 
1304   9DE8 59 27 29 4E 
1304   9DEC 4F 52 4D 41 
1304   9DF0 4C 20 54 45 
1304   9DF4 58 54 1B 4E 
1304   9DF8 20 55 4E 44 
1304   9DFC 45 52 4C 49 
1304   9E00 4E 45 44 20 
1304   9E04 54 45 58 54 
1305   9E08 1B 4E 50 52 	.TEXT	"\033NPREVERSE VIDEO TEXT\033NBBLINKING TEXT"
1305   9E0C 45 56 45 52 
1305   9E10 53 45 20 56 
1305   9E14 49 44 45 4F 
1305   9E18 20 54 45 58 
1305   9E1C 54 1B 4E 42 
1305   9E20 42 4C 49 4E 
1305   9E24 4B 49 4E 47 
1305   9E28 20 54 45 58 
1305   9E2C 54 
1306   9E2D 1B 59 2A 46 	.TEXT	"\033Y*F\033N@\033Y*&\033NP     GRAPHICS CHARACTER SET"
1306   9E31 1B 4E 40 1B 
1306   9E35 59 2A 26 1B 
1306   9E39 4E 50 20 20 
1306   9E3D 20 20 20 47 
1306   9E41 52 41 50 48 
1306   9E45 49 43 53 20 
1306   9E49 43 48 41 52 
1306   9E4D 41 43 54 45 
1306   9E51 52 20 53 45 
1306   9E55 54 
1307   9E56 1B 59 2B 27 	.TEXT	"\033Y+'\033F`abcdefghijklmnopqrstuvwxyz{|}~\033G"
1307   9E5A 1B 46 60 61 
1307   9E5E 62 63 64 65 
1307   9E62 66 67 68 69 
1307   9E66 6A 6B 6C 6D 
1307   9E6A 6E 6F 70 71 
1307   9E6E 72 73 74 75 
1307   9E72 76 77 78 79 
1307   9E76 7A 7B 7C 7D 
1307   9E7A 7E 1B 47 
TASM 1802 Assembler.              video.asm                        page 50
VIDEO -- COSMAC Elf 2000 Video Terminal Module

1308   9E7D 1B 59 2A 69 	.TEXT	"\033Y*i\033N@\033Y*H\033NP       DEFAULT CHARACTER SET"
1308   9E81 1B 4E 40 1B 
1308   9E85 59 2A 48 1B 
1308   9E89 4E 50 20 20 
1308   9E8D 20 20 20 20 
1308   9E91 20 44 45 46 
1308   9E95 41 55 4C 54 
1308   9E99 20 43 48 41 
1308   9E9D 52 41 43 54 
1308   9EA1 45 52 20 53 
1308   9EA5 45 54 
1309   9EA7 1B 59 2B 49 	.TEXT	"\033Y+I !\"#$%&'()*+,-./0123456789:;<=>?"
1309   9EAB 20 21 22 23 
1309   9EAF 24 25 26 27 
1309   9EB3 28 29 2A 2B 
1309   9EB7 2C 2D 2E 2F 
1309   9EBB 30 31 32 33 
1309   9EBF 34 35 36 37 
1309   9EC3 38 39 3A 3B 
1309   9EC7 3C 3D 3E 3F 
1310   9ECB 1B 59 2C 49 	.TEXT	"\033Y,I@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"
1310   9ECF 40 41 42 43 
1310   9ED3 44 45 46 47 
1310   9ED7 48 49 4A 4B 
1310   9EDB 4C 4D 4E 4F 
1310   9EDF 50 51 52 53 
1310   9EE3 54 55 56 57 
1310   9EE7 58 59 5A 5B 
1310   9EEB 5C 5D 5E 5F 
1311   9EEF 1B 59 2D 49 	.TEXT	"\033Y-I`abcdefghijklmnopqrstuvwxyz{|}~"
1311   9EF3 60 61 62 63 
1311   9EF7 64 65 66 67 
1311   9EFB 68 69 6A 6B 
1311   9EFF 6C 6D 6E 6F 
1311   9F03 70 71 72 73 
1311   9F07 74 75 76 77 
1311   9F0B 78 79 7A 7B 
1311   9F0F 7C 7D 7E 
1312   9F12 00          	.DB	0
1313   9F13             
TASM 1802 Assembler.              video.asm                        page 51
VIDEO -- COSMAC Elf 2000 Video Terminal Module

1314   9F13             	.EJECT
1315   9F13             	.END



Label        Value      Label        Value      Label        Value
------------------      ------------------      ------------------
ABTNONE       00FF      ABTADDR       005A      ABTDISK       00A5      
A             0006      AUTONL        9AA4      BAUD          000E      
BELCNT        7E88      BELL          9B32      CDP1861       0001      
CRTCP         0001      CRTCC         0005      CRTC_RESET    0000      
CRTC_START    0020      CRTC_STOP     0040      CRTC_LDCURS   0080      
CRTC_EI       00A0      CRTC_DI       00C0      CRTC_PRESET   00E0      
CRTCS         0005      CRTC_IE       0040      CRTC_IR       0020      
CRTC_LP       0010      CRTC_IC       0008      CRTC_VE       0004      
CRTC_DU       0002      CRTC_FO       0001      CALLPC        0004      
CHCTC         0003      CHBSP         0008      CHTAB         0009      
CHLFD         000A      CHCRT         000D      CHFFD         000C      
CHESC         001B      CHRUB         007F      CURSX         7E81      
CURSY         7E82      CURCHR        7E85      CLRMEM        989A      
CURRET        9A01      CRET          9A8A      CLRLIN        9AFE      
CLRLI1        9B05      CTLTAB        9CF1      DLL           0010      
DLH           0011      DLAB          0080      DR            0001      
DV2           0040      DV1           0020      DV0           0010      
DM            0004      DSE           0001      DMAPTR        0000      
DP            0007      DTALEN        0789      DOWN          9A35      
DIRECT        9BE1      DIRECY        9BE6      DIRECX        9BF3      
DIREC1        9C08      DIRE11        9C10      DIRE12        9C13      
DIREC2        9C1F      DIRE21        9C27      DIRE22        9C2A      
DSAGCS        9C3D      ESCSTA        7E84      EOFISR        9953      
EOFIS1        9985      EEOS          9AC3      EEOS1         9AD8      
EEOS2         9AEC      EEOL          9B13      EEOL1         9B24      
ERASE         9B40      ESCAPE        9B98      ESCNXT        9B9A      
ESCRET        9BA3      ESCAP1        9BA4      ENAGCS        9C33      
ESTATE        9D32      EFIRST        0001      EYNEXT        0002      
EXNEXT        0003      ERNEXT        0004      EANEXT        0005      
ELNEXT        0006      ESCCHR        9D40      FCR           0012      
FE            0008      FRAME         7E87      FILL          9B42      
FILL1         9B5C      GPIO          0007      GCSMOD        7E83      
HR24          0002      HOME          9A96      IDE_SELECT    0002      
IDE_DATA      0003      IER           0011      IIR           0012      
IDEDATA       0000      IDEERR        0001      IDESCT        0002      
IDELBA0       0003      IDELBA1       0004      IDELBA2       0005      
IDELBA3       0006      IDECMD        0007      IDESTS        0007      
INTPC         0001      INIT75_       9866      LEDS          0004      
LCR           0013      LSR           0015      LINADD        998D      
LINAD1        9993      LINTAB        99A1      LDCURS        99D3      
LEFT          9A02      LINEFD        9AA7      LBRI          9C79      
LBRI1         9C8B      MCR           0014      MSR           0016      
MAXX          0050      MAXY          0018      NVR_SELECT    0002      
NVR_DATA      0003      NVRA          008A      NVRB          008B      
NVRC          008C      NVRD          008D      NVRFREE       008E      
NVRBASE       0000      NVRBOOT       0000      NVRBAUD       0003      
NVRVERS       0005      NVRSIZE       0006      NO8275        98DD      
NORMAL        9B70      NORMA1        9B83      NOOP          9D31      
OE            0002      PE            0004      PF            0040      
PS2KBD        0007      PPI           0006      PPIEN         0004      
PPIA1         0002      PPIA0         0001      PPIPA         0004      
PPIPB         0005      PPIPC         0006      PPICTL        0007      
TASM 1802 Assembler.              video.asm                        page 52
VIDEO -- COSMAC Elf 2000 Video Terminal Module

PC0           0000      PC            0003      P1            000F      
P2            000D      P3            000C      P4            000B      
PUTS1         9CE3      PUTS9         9CEB      RBR           0010      
RETPC         0005      RIGHTS        9809      ROWEND        9941      
RIGHT         9A12      RIGHT1        9A1E      RLF           9AB6      
RTEST         9BC1      RTEST1        9BC6      SWITCHES      0004      
SCR           0017      SQWE          0008      SPEN          0020      
SP1           0010      SP0           0008      SPOFF         0020      
SPQ           0030      SPTONE        0028      SPON          0038      
SP            0002      SCREND        7E80      SAVCHR        7E86      
SCRDWN        9A48      SCRDW1        9A55      SCRUP         9A5C      
SCRUP1        9A6E      THR           0010      THRE          0020      
TEMT          0040      T1            0009      T2            000A      
TOPLIN        7E80      TSTDMA        98C6      TSTEOF        98D3      
TAB           9A75      TEST          9D74      TEST10        9D82      
TEST11        9D91      TSTMS1        9DB9      TSTMS2        9DE0      
UART_SELECT   0002      UART_DATA     0003      UIP           0080      
UP            9A25      VRT           0080      VIDVER        0018      
VIDRET        9938      VIDRE1        9939      VIDISR        993B      
VTPUTC_       9C90      VTPUT9        9CB8      VTPUT1        9CCC      
VTPUT2        9CD4      VTPUTS        9CDB      WHERE         99E6      
WFAC          9C47      WFAC1         9C4C      WLINE         9C60      
WLINE1        9C65      

tasm: Number of errors = 0
