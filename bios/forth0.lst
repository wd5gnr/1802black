1802 -> Native
2 Classes read.
186 Patterns read.
    1 0000:             ; *******************************************************************
    2 0000:             ; *** This software is copyright 2006 by Michael H Riley          ***
    3 0000:             ; *** You have permission to use, modify, copy, and distribute    ***
    4 0000:             ; *** this software so long as this copyright notice is retained. ***
    5 0000:             ; *** This software may not be used in commercial applications    ***
    6 0000:             ; *** without express written permission from the author.         ***
    7 0000:             ; *******************************************************************
    8 0000:             
    9 0000:             ;[RLA] These are defined on the rcasm command line!
   10 0000:             ;[RLA] #define ELFOS            ; build the version that runs under Elf/OS
   11 0000:             ;[RLA] #define STGROM           ; build the STG EPROM version
   12 0000:             ;[RLA] #define PICOROM          ; define for Mike's PIcoElf version
   13 0000:             
   14 0000:             ;[RLA]   rcasm doesn't have any way to do a logical "OR" of assembly
   15 0000:             ;[RLA} options, so define a master "ANYROM" option that's true for
   16 0000:             ;[RLA} any of the ROM conditions...
   17 0000:             	
   18 0000:             	;; [gnr] Bug fixes, assembler fixes,and the Exec word
   19 0000:             
            #endif
   42 0000:             
            #endif
   65 0000:             
   66 0000:             ; [GDJ] build: asm02 -i -L -DSTGROM forth.asm
            #ifdef STGROM
            #define    ANYROM 1
   69 0000:             	include config.inc
   70 0000:             ; DO NOT EDIT THIS FILE - EDIT CONFIG. INSTEAD!!
            #define BOOTS	 08000H
            #define WARMB	 (08000H+3)
            #define HELP	 09400H
            #define RAMPAGE	 07F00H
            #define BIOS	 0FF00H
            #define EBIOS	 0F800H
            #define FORTH	 09B00H
            #define EDTASM	 0B400H
            #define BASIC	 0D300H
            #define VISUAL	 0C100H
            #define XMODEM	 0ED00H
            #define CODE FORTH  		; [gnr] [GDG] says now bigger than 15 pages
   83 0000:             	; [gnr] The UART is used in inkey so when using bitbang, no inkey!
            #define    UART_SELECT   6             ; UART register select I/O port
            #define    UART_DATA     7             ; UART data I/O port
   86 0000:             
   87 0000:             
   88 0000:             ;[RLA] XMODEM entry vectors for the STG EPROM ...
   89 0000:             xopenw:    equ     XMODEM + 0*3
   90 0000:             xopenr:    equ     XMODEM + 1*3
   91 0000:             xread:     equ     XMODEM + 2*3
   92 0000:             xwrite:    equ     XMODEM + 3*3
   93 0000:             xclosew:   equ     XMODEM + 4*3
   94 0000:             xcloser:   equ     XMODEM + 5*3
   95 0000:             buffer:    equ     0200h
   96 0000:             himem:     equ     300h
   97 0000:             rstack:    equ     302h
   98 0000:             tos:       equ     304h
   99 0000:             freemem:   equ     306h
  100 0000:             fstack:    equ     308h
  101 0000:             jump:      equ     30ah
  102 0000:             storage:   equ     30dh
  103 0000:             basen:     equ     317h
  104 0000:             rseed:     equ     02f0h               ; note this limits size of buffer at 200h to 240 bytes
  105 0000:             stack:     equ     01ffh
  106 0000:             exitaddr:  equ     08003h
            #endif
  108 0000:             
            #endif
  114 0000:             
  115 0000:             include    bios.inc
  116 0000:             ; *******************************************************************
  117 0000:             ; *** This software is copyright 2006 by Michael H Riley          ***
  118 0000:             ; *** You have permission to use, modify, copy, and distribute    ***
  119 0000:             ; *** this software so long as this copyright notice is retained. ***
  120 0000:             ; *** This software may not be used in commercial applications    ***
  121 0000:             ; *** without express written permission from the author.         ***
  122 0000:             ; *******************************************************************
  123 0000:             
            #endif
  127 0000:             
  128 0000:             ; Define address for standard BIOS vectors
            #endif
  132 0000:             
  133 0000:             ; Define address for extended BIOS vectors
            #endif
  137 0000:             
            #ifndef TASM
  139 0000:             scall:      equ  r4                    ; register for SCALL
  140 0000:             sret:       equ  r5                    ; register for SRET
  141 0000:             
  142 0000:             call:       equ  0ffe0h                ; depricated
  143 0000:             ret:        equ  0fff1h                ; depricated
            #endif
  145 0000:             
  146 0000:             f_boot:     equ  (BIOS+00h)            ; boot from ide device
  147 0000:             f_type:     equ  (BIOS+03h)            ; type 1 character to console
  148 0000:             f_read:     equ  (BIOS+06h)            ; read 1 character from console
  149 0000:             f_msg:      equ  (BIOS+09h)            ; type asciiz string to console
  150 0000:             f_typex:    equ  (BIOS+0ch)            ; depricated, just returns now
  151 0000:             f_input:    equ  (BIOS+0fh)            ; read asciiz from console
  152 0000:             f_strcmp:   equ  (BIOS+12h)            ; compare 2 strings
  153 0000:             f_ltrim:    equ  (BIOS+15h)            ; trim leading spaces
  154 0000:             f_strcpy:   equ  (BIOS+18h)            ; copy an asciiz string
  155 0000:             f_memcpy:   equ  (BIOS+1bh)            ; copy memory
  156 0000:             f_wrtsec:   equ  (BIOS+1eh)            ; write floppy sector (depricated)
  157 0000:             f_rdsec:    equ  (BIOS+21h)            ; read floppy sector (depricated)
  158 0000:             f_seek0:    equ  (BIOS+24h)            ; floppy seek to track 0 (depricated)
  159 0000:             f_seek:     equ  (BIOS+27h)            ; floopy track seek (depricated)
  160 0000:             f_drive:    equ  (BIOS+2ah)            ; select floppy drive (depricated)
  161 0000:             f_setbd:    equ  (BIOS+2dh)            ; set console baud rate
  162 0000:             f_mul16:    equ  (BIOS+30h)            ; 16-bit multiply
  163 0000:             f_div16:    equ  (BIOS+33h)            ; 16-bit division
  164 0000:             f_idereset: equ  (BIOS+36h)            ; reset ide device
  165 0000:             f_idewrite: equ  (BIOS+39h)            ; write ide sector
  166 0000:             f_ideread:  equ  (BIOS+3ch)            ; read ide sector
  167 0000:             f_initcall: equ  (BIOS+3fh)            ; initialize R4 and R5
  168 0000:             f_bootide:  equ  (BIOS+42h)            ; boot from ide device
  169 0000:             f_hexin:    equ  (BIOS+45h)            ; convert ascii number to hex
  170 0000:             f_hexout2:  equ  (BIOS+48h)            ; convert hex to 2-digit ascii
  171 0000:             f_hexout4:  equ  (BIOS+4bh)            ; convert hex to 4-digit ascii
  172 0000:             f_tty:      equ  (BIOS+4eh)            ; type character to console
  173 0000:             f_mover:    equ  (BIOS+51h)            ; program relocator
  174 0000:             f_minimon:  equ  (BIOS+54h)            ; mini monitor
  175 0000:             f_freemem:  equ  (BIOS+57h)            ; determine memory size
  176 0000:             F_isnum:    equ  (BIOS+5ah)            ; determine if D is numeric
  177 0000:             f_atoi:     equ  (BIOS+5dh)            ; convert ascii to integer
  178 0000:             f_uintout:  equ  (BIOS+60h)            ; convert unsigned integer to ascii
  179 0000:             f_intout:   equ  (BIOS+63h)            ; convert signed integer to ascii
  180 0000:             f_inmsg:    equ  (BIOS+66h)            ; type in-line message
  181 0000:             f_inputl:   equ  (BIOS+69h)            ; read limited line from console
  182 0000:             f_brktest:  equ  (BIOS+6ch)            ; check for serial break
  183 0000:             f_findtkn:  equ  (BIOS+6fh)            ; find token in a token table
  184 0000:             f_isalpha:  equ  (BIOS+72h)            ; determine if D is alphabetic
  185 0000:             f_ishex:    equ  (BIOS+75h)            ; determine if D is hexadecimal
  186 0000:             f_isalnum:  equ  (BIOS+78h)            ; determine if D is alpha or numeric
  187 0000:             f_idnum:    equ  (BIOS+7bh)            ; determine type of ascii number
  188 0000:             f_isterm:   equ  (BIOS+7eh)            ; determine if D is a termination char
  189 0000:             f_getdev:   equ  (BIOS+81h)            ; get supported devices
  190 0000:             
  191 0000:             f_version:  equ  (BIOS+0f9h)           ; 3 bytes holding bios version number
  192 0000:             
  193 0000:             ; "Extended" BIOS vectors
  194 0000:             
  195 0000:             f_bread     equ  (EBIOS+00h)        ; read from onboard serial port
  196 0000:             f_btype     equ  (EBIOS+03h)        ; write to onboard serial port
  197 0000:             f_btest     equ  (EBIOS+06h)        ; test onboard serial port
  198 0000:             f_utype     equ  (EBIOS+09h)        ; write to disk board UART
  199 0000:             f_uread     equ  (EBIOS+0ch)        ; read from disk board UART
  200 0000:             f_utest     equ  (EBIOS+0fh)        ; test disk board UART
  201 0000:             f_usetbd    equ  (EBIOS+12h)        ; set disk board UART baud rate and format
  202 0000:             f_gettod    equ  (EBIOS+15h)        ; read time of day clock
  203 0000:             f_settod    equ  (EBIOS+18h)        ; set time of day clock
  204 0000:             f_rdnvr     equ  (EBIOS+1bh)        ; read non volatile RAM
  205 0000:             f_wrnvr     equ  (EBIOS+1eh)        ; write non volatile RAM
  206 0000:             f_idesize   equ  (EBIOS+21h)        ; return size of attached IDE drive(s)
  207 0000:             f_ideid     equ  (EBIOS+24h)        ; return device data for IDE drive(s)
  208 0000:             f_tmtoas    equ  (EBIOS+2ah)        ; time to ASCII string
  209 0000:             f_dttoas    equ  (EBIOS+27h)        ; date to ASCII string
  210 0000:             f_rtctest   equ  (EBIOS+2dh)        ; test size and presence of RTC/NVR
  211 0000:             f_astodt    equ  (EBIOS+30h)        ; convert ASCII string to date
  212 0000:             f_astotm    equ  (EBIOS+33h)        ; convert ASCII string to time
  213 0000:             f_nvrcchk   equ  (EBIOS+36h)	    ; [RLA] compute NVR checksum
  214 0000:             
  215 0000:             
  216 0000:             
            #endif
  229 0000:             
  230 0000:             ;  R2   - program stack
  231 0000:             ;  R3   - Main PC
  232 0000:             ;  R4   - standard call
  233 0000:             ;  R5   - standard ret
  234 0000:             ;  R6   - used by Scall/Sret linkage
  235 0000:             ;  R7   - general and command table pointer
  236 0000:             ;  R9   - Data segment
  237 0000:             ;  RB   - general SCRT return usage and token stream pointer
  238 0000:             
  239 0000:             FWHILE:    equ     81h
  240 0000:             FREPEAT:   equ     FWHILE+1
  241 0000:             FIF:       equ     FREPEAT+1
  242 0000:             FELSE:     equ     FIF+1
  243 0000:             FTHEN:     equ     FELSE+1
  244 0000:             FVARIABLE: equ     FTHEN+1
  245 0000:             FCOLON:    equ     FVARIABLE+1
  246 0000:             FSEMI:     equ     FCOLON+1
  247 0000:             FDUP:      equ     FSEMI+1
  248 0000:             FDROP:     equ     FDUP+1
  249 0000:             FSWAP:     equ     FDROP+1
  250 0000:             FPLUS:     equ     FSWAP+1
  251 0000:             FMINUS:    equ     FPLUS+1
  252 0000:             FMUL:      equ     FMINUS+1
  253 0000:             FDIV:      equ     FMUL+1
  254 0000:             FDOT:      equ     FDIV+1              ; 90h
  255 0000:             FUDOT:     equ     FDOT+1
  256 0000:             FI:        equ     FUDOT+1
  257 0000:             FAND:      equ     FI+1
  258 0000:             FOR:       equ     FAND+1
  259 0000:             FXOR:      equ     FOR+1
  260 0000:             FCR:       equ     FXOR+1
  261 0000:             FMEM:      equ     FCR+1
  262 0000:             FDO:       equ     FMEM+1
  263 0000:             FLOOP:     equ     FDO+1
  264 0000:             FPLOOP:    equ     FLOOP+1
  265 0000:             FEQUAL:    equ     FPLOOP+1
  266 0000:             FUNEQUAL:  equ     FEQUAL+1
  267 0000:             FLESS:     equ     FUNEQUAL+1          ; [GDJ]
  268 0000:             FULESS:    equ     FLESS+1             ; [GDJ]
  269 0000:             FBEGIN:    equ     FULESS+1
  270 0000:             FUNTIL:    equ     FBEGIN+1            ; a0h
  271 0000:             FRGT:      equ     FUNTIL+1
  272 0000:             FGTR:      equ     FRGT+1
  273 0000:             FRAT:      equ     FGTR+1              ; [GDJ]
  274 0000:             FWORDS:    equ     FRAT+1
  275 0000:             FEMIT:     equ     FWORDS+1
  276 0000:             FEMITP:    equ     FEMIT+1             ; [GDJ]
  277 0000:             FDEPTH:    equ     FEMITP+1
  278 0000:             FROT:      equ     FDEPTH+1
  279 0000:             FMROT:     equ     FROT+1
  280 0000:             FOVER:     equ     FMROT+1
  281 0000:             FAT:       equ     FOVER+1
  282 0000:             FEXCL:     equ     FAT+1
  283 0000:             FCAT:      equ     FEXCL+1
  284 0000:             FCEXCL:    equ     FCAT+1
  285 0000:             FCMOVE:    equ     FCEXCL+1            ; [GDJ]
  286 0000:             FDOTQT:    equ     FCMOVE+1            ; b0h
  287 0000:             FKEY:      equ     FDOTQT+1
  288 0000:             FKEYQ:     equ     FKEY+1              ; [GDJ]
  289 0000:             FALLOT:    equ     FKEYQ+1
  290 0000:             FERROR:    equ     FALLOT+1
  291 0000:             FSEE:      equ     FERROR+1
  292 0000:             FFORGET:   equ     FSEE+1
  293 0000:             FEXEC:	   equ     FFORGET+1
  294 0000:             FLIST:	   equ     FEXEC+1
  295 0000:             
  296 0000:             T_NUM:     equ     255
  297 0000:             T_ASCII:   equ     254
  298 0000:             
  299 0000:                        org     CODE
  300 9b00:             
            #endif
  307 9b00:             
            #ifdef     ANYROM
  309 9b00: c0 9b 12               lbr     new
  310 9b03:             notnew:	
  311 9b03: f8 ff a2 f8 
            01 b2                  mov     r2,stack
  312 9b09: f8 bd a6 f8 
            9b b6                  mov     r6,old
  313 9b0f: c0 ff 3f               lbr     f_initcall
  314 9b12: f8 ff a2 f8 
            01 b2       new:       mov     r2,stack
  315 9b18: f8 21 a6 f8 
            9b b6                  mov     r6,start
  316 9b1e: c0 ff 3f               lbr     f_initcall
            #endif
  318 9b21:             
  319 9b21: f8 03       start:     ldi     high himem          ; get page of data segment
  320 9b23: b9                     phi     r9                  ; place into r9
            #ifdef ANYROM
  322 9b24: f8 0c                  ldi     0ch                 ; form feed
  323 9b26: d4                     sep     scall               ; clear screen
            #else
  327 9b27: ff 03                  dw      f_type
            #endif
            #endif
  330 9b29: f8 ac                  ldi     high hello          ; address of signon message
  331 9b2b: bf                     phi     rf                  ; place into r6
  332 9b2c: f8 cf                  ldi     low hello
  333 9b2e: af                     plo     rf
  334 9b2f: d4                     sep     scall               ; call bios to display message
            #else
  338 9b30: ff 09                  dw      f_msg               ; function to display a message
            #endif
  340 9b32:             
  341 9b32:             ; ************************************************
  342 9b32:             ; **** Determine how much memory is installed ****
  343 9b32:             ; ************************************************
            #else
  351 9b32: d4                     sep     scall               ; ask BIOS for memory size
  352 9b33: ff 57                  dw      f_freemem
  353 9b35: 8f ab 9f bb            mov     rb,rf
            #endif
  355 9b39:             
  356 9b39: f8 06                  ldi     low freemem         ; free memory pointer
  357 9b3b: a9                     plo     r9                  ; place into data pointer
  358 9b3c: f8 03                  ldi     storage.1
  359 9b3e: 59                     str     r9
  360 9b3f: 19                     inc     r9
  361 9b40: f8 0d                  ldi     storage.0
  362 9b42: 59                     str     r9
  363 9b43:             
  364 9b43:             ;memlp:     ldi     0                   ; get a zero
  365 9b43:             ;           str     rb                  ; write to memory
  366 9b43:             ;           ldn     rb                  ; recover retrieved byte
  367 9b43:             ;           bnz     memdone             ; jump if not same
  368 9b43:             ;           ldi     255                 ; another value
  369 9b43:             ;           str     rb                  ; write to memory
  370 9b43:             ;           ldn     rb                  ; retrieve it
  371 9b43:             ;           smi     255                 ; compare against written
  372 9b43:             ;           bnz     memdone             ; jump if not same
  373 9b43:             ;           ghi     rb
  374 9b43:             ;           adi     1                   ; point to next page
  375 9b43:             ;           phi     rb                  ; and put it back
  376 9b43:             ;           smi     7fh                 ; prevent from going over 7f00h
  377 9b43:             ;           bnz     memlp
  378 9b43: f8 00       memdone:   ldi     low himem           ; memory pointer
  379 9b45: a9                     plo     r9                  ; place into r9
  380 9b46: 9b                     ghi     rb                  ; get high of last memory
  381 9b47: 59                     str     r9                  ; write to data
  382 9b48: b2                     phi     r2                  ; and to machine stack
  383 9b49: 19                     inc     r9                  ; point to low byte
  384 9b4a: 8b                     glo     rb                  ; get low of himem
  385 9b4b: 59                     str     r9                  ; and store
  386 9b4c: a2                     plo     r2
  387 9b4d: f8 02                  ldi     low rstack          ; get return stack address
  388 9b4f: a9                     plo     r9                  ; select in data segment
  389 9b50: 9b                     ghi     rb                  ; get hi memory
  390 9b51: ff 01                  smi     1                   ; 1 page lower for forth stack
  391 9b53: 59                     str     r9                  ; write to pointer
  392 9b54: 19                     inc     r9                  ; point to low byte
  393 9b55: 8b                     glo     rb                  ; get low byte
  394 9b56: 59                     str     r9                  ; and store
  395 9b57: f8 04                  ldi     low tos             ; get stack address
  396 9b59: a9                     plo     r9                  ; select in data segment
  397 9b5a: 9b                     ghi     rb                  ; get hi memory
  398 9b5b: ff 02                  smi     2                   ; 2 page lower for forth stack
  399 9b5d: 59                     str     r9                  ; write to pointer
  400 9b5e: 19                     inc     r9                  ; point to low byte
  401 9b5f: 8b                     glo     rb                  ; get low byte
  402 9b60: 59                     str     r9                  ; and store
  403 9b61: f8 08                  ldi     low fstack          ; get stack address
  404 9b63: a9                     plo     r9                  ; select in data segment
  405 9b64: 9b                     ghi     rb                  ; get hi memory
  406 9b65: ff 02                  smi     2                   ; 2 page lower for forth stack
  407 9b67: 59                     str     r9                  ; write to pointer
  408 9b68: 19                     inc     r9                  ; point to low byte
  409 9b69: 8b                     glo     rb                  ; get low byte
  410 9b6a: 59                     str     r9                  ; and store
  411 9b6b: f8 03                  ldi     high storage        ; point to storage
  412 9b6d: bf                     phi     rf
  413 9b6e: f8 0d                  ldi     low storage
  414 9b70: af                     plo     rf
  415 9b71: f8 00                  ldi     0
  416 9b73: 5f                     str     rf                  ; write zeroes as storage terminator
  417 9b74: 1f                     inc     rf
  418 9b75: 5f                     str     rf
  419 9b76: 1f                     inc     rf
  420 9b77: 5f                     str     rf
  421 9b78: 1f                     inc     rf
  422 9b79: 5f                     str     rf
  423 9b7a: 1f                     inc     rf
  424 9b7b:             
  425 9b7b:                        ; [GDJ] create and initialize BASE variable
  426 9b7b: f8 1a a7 f8 
            00 b7                  mov     r7, 26
  427 9b81: f8 70 ac f8 
            ae bc                  mov     rc, basev
  428 9b87: f8 06 ad f8 
            03 bd                  mov     rd, freemem
  429 9b8d: 4c          nextbase:  lda     rc
  430 9b8e: 5d                     str     rd
  431 9b8f: 1d                     inc     rd
  432 9b90: 27                     dec     r7
  433 9b91: 87                     glo     r7
  434 9b92: ca 9b 8d               lbnz    nextbase
  435 9b95:             
            #ifdef STGROM
  437 9b95: d4 ac 49               call    clrstacks           ; [GDJ]
            #endif
  439 9b98:             
  440 9b98:                        ; init 32 bit rng seed
  441 9b98: f8 a6 a7 f8 
            12 b7                  mov     r7, 012A6h
  442 9b9e: f8 f0 af f8 
            02 bf                  mov     rf, rseed
  443 9ba4: 97                     ghi     r7
  444 9ba5: 5f                     str     rf
  445 9ba6: 87                     glo     r7
  446 9ba7: 1f                     inc     rf
  447 9ba8: 5f                     str     rf
  448 9ba9:                        
  449 9ba9: f8 40 a7 f8 
            dc b7                  mov     r7, 0DC40h
  450 9baf: f8 f2 af f8 
            02 bf                  mov     rf, rseed+2
  451 9bb5: 97                     ghi     r7
  452 9bb6: 5f                     str     rf
  453 9bb7: 87                     glo     r7
  454 9bb8: 1f                     inc     rf
  455 9bb9: 5f                     str     rf
  456 9bba:             
  457 9bba:             
  458 9bba: c0 9b e7               lbr     mainlp
  459 9bbd:             
  460 9bbd: f8 03       old: 	   ldi     high himem	; [gnr] fix up r9 since this might be entry point
  461 9bbf: b9          	   phi     r9
  462 9bc0: f8 00       	   ldi     low himem           ; memory pointer
  463 9bc2: a9                     plo     r9                  ; place into r9
  464 9bc3: 49                     lda     r9                  ; retreive high memory
  465 9bc4: bb                     phi     rb
  466 9bc5: b2                     phi     r2                  ; and to machine stack
  467 9bc6: 49                     lda     r9
  468 9bc7: ab                     plo     rb
  469 9bc8: a2                     plo     r2
  470 9bc9: f8 02                  ldi     low rstack          ; get return stack address
  471 9bcb: a9                     plo     r9                  ; select in data segment
  472 9bcc: 9b                     ghi     rb                  ; get hi memory
  473 9bcd: ff 01                  smi     1                   ; 1 page lower for forth stack
  474 9bcf: 59                     str     r9                  ; write to pointer
  475 9bd0: 19                     inc     r9                  ; point to low byte
  476 9bd1: 8b                     glo     rb                  ; get low byte
  477 9bd2: 59                     str     r9                  ; and store
  478 9bd3: f8 04                  ldi     low tos             ; get stack address
  479 9bd5: a9                     plo     r9                  ; select in data segment
  480 9bd6: 9b                     ghi     rb                  ; get hi memory
  481 9bd7: ff 02                  smi     2                   ; 2 page lower for forth stack
  482 9bd9: 59                     str     r9                  ; write to pointer
  483 9bda: 19                     inc     r9                  ; point to low byte
  484 9bdb: 8b                     glo     rb                  ; get low byte
  485 9bdc: 59                     str     r9                  ; and store
  486 9bdd: f8 08                  ldi     low fstack          ; get stack address
  487 9bdf: a9                     plo     r9                  ; select in data segment
  488 9be0: 9b                     ghi     rb                  ; get hi memory
  489 9be1: ff 02                  smi     2                   ; 2 page lower for forth stack
  490 9be3: 59                     str     r9                  ; write to pointer
  491 9be4: 19                     inc     r9                  ; point to low byte
  492 9be5: 8b                     glo     rb                  ; get low byte
  493 9be6: 59                     str     r9                  ; and store
  494 9be7:             
  495 9be7:             ; *************************
  496 9be7:             ; *** Main program loop ***
  497 9be7:             ; *************************
  498 9be7: f8 ac       mainlp:    ldi     high prompt         ; address of prompt
  499 9be9: bf                     phi     rf                  ; place into r6
  500 9bea: f8 de                  ldi     low prompt
  501 9bec: af                     plo     rf
  502 9bed: d4                     sep     scall               ; display prompt
            #else
  506 9bee: ff 09                  dw      f_msg               ; function to display a message
            #endif
  508 9bf0: f8 02                  ldi     high buffer         ; point to input buffer
  509 9bf2: bf                     phi     rf
  510 9bf3: f8 00                  ldi     low buffer
  511 9bf5: af                     plo     rf
  512 9bf6: d4                     sep     scall               ; read a line
            #else
  516 9bf7: ff 0f                  dw      f_input             ; function to read a line
            #endif
  518 9bf9:             
  519 9bf9: d4          	   sep     scall
  520 9bfa: 9c 17       	   dw      crlfout
  521 9bfc: f8 00 af f8 
            02 bf                  mov     rf,buffer           ; convert to uppercase
  522 9c02: d4                     sep     scall
  523 9c03: ab 73                  dw      touc
  524 9c05: d4                     sep     scall               ; call tokenizer
  525 9c06: 9d c0                  dw      tknizer
  526 9c08:             
  527 9c08: f8 06                  ldi     low freemem         ; get free memory pointer
  528 9c0a: a9                     plo     r9                  ; place into data segment
  529 9c0b: 49                     lda     r9                  ; get free memory pointer
  530 9c0c: bb                     phi     rb                  ; place into rF
  531 9c0d: 09                     ldn     r9
  532 9c0e: ab                     plo     rb
  533 9c0f: 1b                     inc     rb
  534 9c10: 1b                     inc     rb
  535 9c11: d4                     sep     scall
  536 9c12: 9f 76                  dw      exec
  537 9c14:             
  538 9c14: c0 9b e7               lbr     mainlp              ; return to beginning of main loop
  539 9c17:             
  540 9c17:             crlfout:	
  541 9c17: 8f 73 9f 73 	   push rf
  542 9c1b: f8 ac                  ldi     high crlf           ; address of CR/LF
  543 9c1d: bf                     phi     rf                  ; place into r6
  544 9c1e: f8 db                  ldi     low crlf  
  545 9c20: af                     plo     rf
  546 9c21: d4                     sep     scall               ; call bios
            #else
  550 9c22: ff 09                  dw      f_msg               ; function to display a message
            #endif
  552 9c24: 60 72 bf f0 
            af          	  pop rf
  553 9c29: d5          	   sep sret
  554 9c2a:             
  555 9c2a:             ; **************************************
  556 9c2a:             ; *** Display a character, char in D ***
  557 9c2a:             ; **************************************
  558 9c2a: d4          disp:      sep     scall               ; call bios
            #else
  562 9c2b: ff 03                  dw      f_type              ; function to type a charactr
            #endif
  564 9c2d: d5                     sep     sret                ; return to caller
  565 9c2e:             
  566 9c2e:             ; ********************************
  567 9c2e:             ; *** Read a key, returns in D ***
  568 9c2e:             ; ********************************
  569 9c2e: d4          getkey:    sep     scall               ; call bios
            #else
  573 9c2f: ff 06                  dw      f_read              ; function to read a key
            #endif
  575 9c31: d5                     sep     sret                ; return to caller
  576 9c32:             
  577 9c32:             ; ***************************************************
  578 9c32:             ; *** Function to retrieve value from forth stack ***
  579 9c32:             ; *** Returns R[B] = value                        ***
  580 9c32:             ; ***         DF=0 no error, DF=1 error           ***
  581 9c32:             ; ***************************************************
  582 9c32: e2          pop:       sex     r2                  ; be sure x points to stack
  583 9c33: f8 08                  ldi     low fstack          ; get stack address
  584 9c35: a9                     plo     r9                  ; select in data segment
  585 9c36: 49                     lda     r9
  586 9c37: ba                     phi     ra
  587 9c38: 09                     ldn     r9
  588 9c39: aa                     plo     ra
  589 9c3a: f8 04                  ldi     low tos             ; pointer to maximum stack value
  590 9c3c: a9                     plo     r9                  ; put into data frame
  591 9c3d: 49                     lda     r9                  ; get high value
  592 9c3e: 52                     str     r2                  ; place into memory
  593 9c3f: 9a                     ghi     ra                  ; get high byte of forth stack
  594 9c40: f7                     sm                          ; check if same
  595 9c41: ca 9c 4f               lbnz    stackok             ; jump if ok
  596 9c44: 09                     ldn     r9                  ; get low byte of tos
  597 9c45: 52                     str     r2
  598 9c46: 8a                     glo     ra                  ; check low byte of stack pointer
  599 9c47: f7                     sm
  600 9c48: ca 9c 4f               lbnz    stackok             ; jump if ok
  601 9c4b: f8 01                  ldi     1                   ; signal error
  602 9c4d: f6          popret:    shr                         ; shift status into DF
  603 9c4e: d5                     sep     sret                ; return to caller
  604 9c4f: 1a          stackok:   inc     ra                  ; point to high byte
  605 9c50: 4a                     lda     ra                  ; get it
  606 9c51: bb                     phi     rb                  ; put into r6
  607 9c52: 0a                     ldn     ra                  ; get low byte
  608 9c53: ab                     plo     rb
  609 9c54: f8 08                  ldi     low fstack          ; get stack address
  610 9c56: a9                     plo     r9                  ; select in data segment
  611 9c57: 9a                     ghi     ra                  ; get hi memory
  612 9c58: 59                     str     r9                  ; write to pointer
  613 9c59: 19                     inc     r9                  ; point to low byte
  614 9c5a: 8a                     glo     ra                  ; get low byte
  615 9c5b: 59                     str     r9                  ; and store
  616 9c5c: f8 00                  ldi     0                   ; signal no error
  617 9c5e: c0 9c 4d               lbr     popret              ; and return to caller
  618 9c61:             
  619 9c61:             ; ********************************************************
  620 9c61:             ; *** Function to push value onto stack, value in R[B] ***
  621 9c61:             ; ********************************************************
  622 9c61: f8 08       push:      ldi     low fstack          ; get stack address
  623 9c63: a9                     plo     r9                  ; select in data segment
  624 9c64: 49                     lda     r9
  625 9c65: ba                     phi     ra
  626 9c66: 09                     ldn     r9
  627 9c67: aa                     plo     ra
  628 9c68: 8b                     glo     rb                  ; get low byte of value
  629 9c69: 5a                     str     ra                  ; store on forth stack
  630 9c6a: 2a                     dec     ra                  ; point to next byte
  631 9c6b: 9b                     ghi     rb                  ; get high value
  632 9c6c: 5a                     str     ra                  ; store on forth stack
  633 9c6d: 2a                     dec     ra                  ; point to next byte
  634 9c6e: f8 08                  ldi     low fstack          ; get stack address
  635 9c70: a9                     plo     r9                  ; select in data segment
  636 9c71: 9a                     ghi     ra                  ; get hi memory
  637 9c72: 59                     str     r9                  ; write to pointer
  638 9c73: 19                     inc     r9                  ; point to low byte
  639 9c74: 8a                     glo     ra                  ; get low byte
  640 9c75: 59                     str     r9                  ; and store
  641 9c76: d5                     sep     sret                ; return to caller
  642 9c77:             
  643 9c77:             ; ****************************************************
  644 9c77:             ; *** Function to retrieve value from return stack ***
  645 9c77:             ; *** Returns R[B] = value                         ***
  646 9c77:             ; ***         D=0 no error, D=1 error              ***
  647 9c77:             ; ****************************************************
  648 9c77: e2          rpop:      sex     r2                  ; be sure x points to stack
  649 9c78: f8 02                  ldi     low rstack          ; get stack address
  650 9c7a: a9                     plo     r9                  ; select in data segment
  651 9c7b: 49                     lda     r9
  652 9c7c: ba                     phi     ra
  653 9c7d: 09                     ldn     r9
  654 9c7e: aa                     plo     ra
  655 9c7f: 1a                     inc     ra                  ; point to high byte
  656 9c80: 4a                     lda     ra                  ; get it
  657 9c81: bb                     phi     rb                  ; put into r6
  658 9c82: 0a                     ldn     ra                  ; get low byte
  659 9c83: ab                     plo     rb
  660 9c84: f8 02                  ldi     low rstack          ; get stack address
  661 9c86: a9                     plo     r9                  ; select in data segment
  662 9c87: 9a                     ghi     ra                  ; get hi memory
  663 9c88: 59                     str     r9                  ; write to pointer
  664 9c89: 19                     inc     r9                  ; point to low byte
  665 9c8a: 8a                     glo     ra                  ; get low byte
  666 9c8b: 59                     str     r9                  ; and store
  667 9c8c: f8 00                  ldi     0                   ; signal no error
  668 9c8e: d5                     sep     sret                ; and return
  669 9c8f:             
  670 9c8f:             ; ***************************************************************
  671 9c8f:             ; *** Function to push value onto return stack, value in R[B] ***
  672 9c8f:             ; ***************************************************************
  673 9c8f: f8 02       rpush:     ldi     low rstack          ; get stack address
  674 9c91: a9                     plo     r9                  ; select in data segment
  675 9c92: 49                     lda     r9
  676 9c93: ba                     phi     ra
  677 9c94: 09                     ldn     r9
  678 9c95: aa                     plo     ra
  679 9c96: 8b                     glo     rb                  ; get low byte of value
  680 9c97: 5a                     str     ra                  ; store on forth stack
  681 9c98: 2a                     dec     ra                  ; point to next byte
  682 9c99: 9b                     ghi     rb                  ; get high value
  683 9c9a: 5a                     str     ra                  ; store on forth stack
  684 9c9b: 2a                     dec     ra                  ; point to next byte
  685 9c9c: f8 02                  ldi     low rstack          ; get stack address
  686 9c9e: a9                     plo     r9                  ; select in data segment
  687 9c9f: 9a                     ghi     ra                  ; get hi memory
  688 9ca0: 59                     str     r9                  ; write to pointer
  689 9ca1: 19                     inc     r9                  ; point to low byte
  690 9ca2: 8a                     glo     ra                  ; get low byte
  691 9ca3: 59                     str     r9                  ; and store
  692 9ca4: d5                     sep     sret                ; return to caller
  693 9ca5:             
  694 9ca5:             ;           org     200h 
  695 9ca5:             ; ********************************************
  696 9ca5:             ; *** Function to find stored name address ***
  697 9ca5:             ; ***  Needs: name to search in R[8]       ***
  698 9ca5:             ; ***  returns: R[B] first byte in data    ***
  699 9ca5:             ; ***           R[7] Address of descriptor ***
  700 9ca5:             ; ***           R[8] first addr after name ***
  701 9ca5:             ; ***           DF = 1 if not found        ***
  702 9ca5:             ; ********************************************
  703 9ca5: f8 03       findname:  ldi     high storage        ; get address of stored data
  704 9ca7: bb                     phi     rb                  ; put into r6
  705 9ca8: f8 0d                  ldi     low storage
  706 9caa: ab                     plo     rb
  707 9cab: e2                     sex     r2                  ; make sure X points to stack
  708 9cac: 9b          findlp:    ghi     rb                  ; copy address
  709 9cad: b7                     phi     r7
  710 9cae: 8b                     glo     rb
  711 9caf: a7                     plo     r7
  712 9cb0: 4b                     lda     rb                  ; get link address
  713 9cb1: ca 9c bc               lbnz    findgo              ; jump if nonzero
  714 9cb4: 0b                     ldn     rb                  ; get low byte
  715 9cb5: ca 9c bc               lbnz    findgo              ; jump if non zero
  716 9cb8: f8 01                  ldi     1                   ; not found
  717 9cba: f6          findret:   shr                         ; set DF
  718 9cbb: d5                     sep     sret                ; and return to caller
  719 9cbc: 1b          findgo:    inc     rb                  ; pointing now at type
  720 9cbd: 1b                     inc     rb                  ; pointing at ascii indicator
  721 9cbe: 1b                     inc     rb                  ; first byte of name
  722 9cbf: 88                     glo     r8                  ; save requested name
  723 9cc0: 73                     stxd
  724 9cc1: 98                     ghi     r8
  725 9cc2: 73                     stxd
  726 9cc3: 08          findchk:   ldn     r8                  ; get byte from requested name
  727 9cc4: 52                     str     r2                  ; place into memory
  728 9cc5: 0b                     ldn     rb                  ; get byte from descriptor
  729 9cc6: f7                     sm                          ; compare equality
  730 9cc7: ca 9c dc               lbnz    findnext            ; jump if not found
  731 9cca: 08                     ldn     r8                  ; get byte
  732 9ccb: c2 9c d3               lbz     findfound           ; entry is found
  733 9cce: 18                     inc     r8                  ; increment positions
  734 9ccf: 1b                     inc     rb
  735 9cd0: c0 9c c3               lbr     findchk             ; and keep looking
  736 9cd3: 1b          findfound: inc     rb                  ; r6 now points to data
  737 9cd4: 60                     irx                         ; remove r8 from stack
  738 9cd5: 60                     irx
  739 9cd6: 18                     inc     r8                  ; move past terminator in name
  740 9cd7: f8 00                  ldi     0                   ; signal success
  741 9cd9: c0 9c ba               lbr     findret             ; and return to caller
  742 9cdc: 60          findnext:  irx                         ; recover start of requested name
  743 9cdd: 72                     ldxa
  744 9cde: b8                     phi     r8
  745 9cdf: f0                     ldx
  746 9ce0: a8                     plo     r8
  747 9ce1: 47                     lda     r7                  ; get next link address
  748 9ce2: bb                     phi     rb
  749 9ce3: 07                     ldn     r7
  750 9ce4: ab                     plo     rb
  751 9ce5: c0 9c ac               lbr     findlp              ; and check next entry
  752 9ce8:             
  753 9ce8:             ; *********************************************
  754 9ce8:             ; *** Function to multiply 2 16 bit numbers ***
  755 9ce8:             ; *********************************************
  756 9ce8: f8 00       mul16:     ldi     0                   ; zero out total
  757 9cea: b8                     phi     r8
  758 9ceb: a8                     plo     r8
  759 9cec: bc                     phi     rc
  760 9ced: ac                     plo     rc
  761 9cee: e2                     sex     r2                  ; make sure X points to stack
  762 9cef: 87          mulloop:   glo     r7                  ; get low of multiplier
  763 9cf0: ca 9c fc               lbnz    mulcont             ; continue multiplying if nonzero
  764 9cf3: 97                     ghi     r7                  ; check hi byte as well
  765 9cf4: ca 9c fc               lbnz    mulcont
  766 9cf7: 98                     ghi     r8                  ; transfer answer
  767 9cf8: bb                     phi     rb
  768 9cf9: 88                     glo     r8
  769 9cfa: ab                     plo     rb
  770 9cfb: d5                     sep     sret                ; return to caller
  771 9cfc: 97          mulcont:   ghi     r7                  ; shift multiplier
  772 9cfd: f6                     shr
  773 9cfe: b7                     phi     r7
  774 9cff: 87                     glo     r7
  775 9d00: 76                     shrc
  776 9d01: a7                     plo     r7
  777 9d02: cb 9d 17               lbnf    mulcont2            ; loop if no addition needed
  778 9d05: 8b                     glo     rb                  ; add 6 to 8
  779 9d06: 52                     str     r2
  780 9d07: 88                     glo     r8
  781 9d08: f4                     add
  782 9d09: a8                     plo     r8
  783 9d0a: 9b                     ghi     rb
  784 9d0b: 52                     str     r2
  785 9d0c: 98                     ghi     r8
  786 9d0d: 74                     adc
  787 9d0e: b8                     phi     r8
  788 9d0f: 8c                     glo     rc                  ; carry into high word
  789 9d10: 7c 00                  adci    0
  790 9d12: ac                     plo     rc
  791 9d13: 9c                     ghi     rc
  792 9d14: 7c 00                  adci    0
  793 9d16: bc                     phi     rc
  794 9d17: 8b          mulcont2:  glo     rb                  ; shift first number
  795 9d18: fe                     shl
  796 9d19: ab                     plo     rb
  797 9d1a: 9b                     ghi     rb
  798 9d1b: 7e                     shlc
  799 9d1c: bb                     phi     rb
  800 9d1d: c0 9c ef               lbr     mulloop             ; loop until done
  801 9d20:             
  802 9d20:             ; ************************************
  803 9d20:             ; *** make both arguments positive ***
  804 9d20:             ; *** Arg1 RB                      ***
  805 9d20:             ; *** Arg2 R7                      ***
  806 9d20:             ; *** Returns D=0 - signs same     ***
  807 9d20:             ; ***         D=1 - signs difer    ***
  808 9d20:             ; ************************************
  809 9d20: 9b          mdnorm:    ghi     rb                  ; get high byte if divisor
  810 9d21: 52                     str     r2                  ; store for sign check
  811 9d22: 97                     ghi     r7                  ; get high byte of dividend
  812 9d23: f3                     xor                         ; compare
  813 9d24: fe                     shl                         ; shift into df
  814 9d25: f8 00                  ldi     0                   ; convert to 0 or 1
  815 9d27: 7e                     shlc                        ; shift into D
  816 9d28: ae                     plo     re                  ; store into sign flag
  817 9d29: 9b                     ghi     rb                  ; need to see if RB is negative
  818 9d2a: fe                     shl                         ; shift high byte to df
  819 9d2b: cb 9d 37               lbnf    mdnorm2             ; jump if not
  820 9d2e: 9b                     ghi     rb                  ; 2s compliment on RB
  821 9d2f: fb ff                  xri     0ffh
  822 9d31: bb                     phi     rb
  823 9d32: 8b                     glo     rb
  824 9d33: fb ff                  xri     0ffh
  825 9d35: ab                     plo     rb
  826 9d36: 1b                     inc     rb
  827 9d37: 97          mdnorm2:   ghi     r7                  ; now check r7 for negative
  828 9d38: fe                     shl                         ; shift sign bit into df
  829 9d39: cb 9d 45               lbnf    mdnorm3             ; jump if not
  830 9d3c: 97                     ghi     r7                  ; 2 compliment on R7
  831 9d3d: fb ff                  xri     0ffh
  832 9d3f: b7                     phi     r7
  833 9d40: 87                     glo     r7
  834 9d41: fb ff                  xri     0ffh
  835 9d43: a7                     plo     r7
  836 9d44: 17                     inc     r7
  837 9d45: 8e          mdnorm3:   glo     re                  ; recover sign flag
  838 9d46: d5                     sep     sret                ; and return to caller
  839 9d47:                         
  840 9d47:                        
  841 9d47:             
  842 9d47:             ; *** RC = RB/R7 
  843 9d47:             ; *** RB = remainder
  844 9d47:             ; *** uses R8 and R9
  845 9d47: d4          div16:     sep     scall               ; normalize numbers
  846 9d48: 9d 20                  dw      mdnorm
  847 9d4a: ae                     plo     re                  ; save sign comparison
  848 9d4b: f8 00                  ldi     0                   ; clear answer 
  849 9d4d: bc                     phi     rc
  850 9d4e: ac                     plo     rc
  851 9d4f: b8                     phi     r8                  ; set additive
  852 9d50: a8                     plo     r8
  853 9d51: 18                     inc     r8
  854 9d52: 87                     glo     r7                  ; check for divide by 0
  855 9d53: ca 9d 5f               lbnz    d16lp1
  856 9d56: 97                     ghi     r7
  857 9d57: ca 9d 5f               lbnz    d16lp1
  858 9d5a: f8 ff                  ldi     0ffh                ; return 0ffffh as div/0 error
  859 9d5c: bc                     phi     rc
  860 9d5d: ac                     plo     rc
  861 9d5e: d5                     sep     sret                ; return to caller
  862 9d5f: 97          d16lp1:    ghi     r7                  ; get high byte from r7
  863 9d60: fa 80                  ani     128                 ; check high bit 
  864 9d62: ca 9d 74               lbnz    divst               ; jump if set
  865 9d65: 87                     glo     r7                  ; lo byte of divisor
  866 9d66: fe                     shl                         ; multiply by 2
  867 9d67: a7                     plo     r7                  ; and put back
  868 9d68: 97                     ghi     r7                  ; get high byte of divisor
  869 9d69: 7e                     shlc                        ; continue multiply by 2
  870 9d6a: b7                     phi     r7                  ; and put back
  871 9d6b: 88                     glo     r8                  ; multiply additive by 2
  872 9d6c: fe                     shl     
  873 9d6d: a8                     plo     r8
  874 9d6e: 98                     ghi     r8
  875 9d6f: 7e                     shlc
  876 9d70: b8                     phi     r8
  877 9d71: c0 9d 5f               lbr     d16lp1              ; loop until high bit set in divisor
  878 9d74: 87          divst:     glo     r7                  ; get low of divisor
  879 9d75: ca 9d 8b               lbnz    divgo               ; jump if still nonzero
  880 9d78: 97                     ghi     r7                  ; check hi byte too
  881 9d79: ca 9d 8b               lbnz    divgo
  882 9d7c: 8e                     glo     re                  ; get sign flag
  883 9d7d: f6                     shr                         ; move to df
  884 9d7e: cb 9d 8a               lbnf    divret              ; jump if signs were the same
  885 9d81: 9c                     ghi     rc                  ; perform 2s compliment on answer
  886 9d82: fb ff                  xri     0ffh
  887 9d84: bc                     phi     rc
  888 9d85: 8c                     glo     rc
  889 9d86: fb ff                  xri     0ffh
  890 9d88: ac                     plo     rc
  891 9d89: 1c                     inc     rc
  892 9d8a: d5          divret:    sep     sret                ; jump if done
  893 9d8b: 9b          divgo:     ghi     rb                  ; copy dividend
  894 9d8c: b9                     phi     r9
  895 9d8d: 8b                     glo     rb
  896 9d8e: a9                     plo     r9
  897 9d8f: 87                     glo     r7                  ; get lo of divisor
  898 9d90: 73                     stxd                        ; place into memory
  899 9d91: 60                     irx                         ; point to memory
  900 9d92: 8b                     glo     rb                  ; get low byte of dividend
  901 9d93: f7                     sm                          ; subtract
  902 9d94: ab                     plo     rb                  ; put back into r6
  903 9d95: 97                     ghi     r7                  ; get hi of divisor
  904 9d96: 73                     stxd                        ; place into memory
  905 9d97: 60                     irx                         ; point to byte
  906 9d98: 9b                     ghi     rb                  ; get hi of dividend
  907 9d99: 77                     smb                         ; subtract
  908 9d9a: bb                     phi     rb                  ; and put back
  909 9d9b: c3 9d a5               lbdf    divyes              ; branch if no borrow happened
  910 9d9e: 99                     ghi     r9                  ; recover copy
  911 9d9f: bb                     phi     rb                  ; put back into dividend
  912 9da0: 89                     glo     r9
  913 9da1: ab                     plo     rb
  914 9da2: c0 9d b1               lbr     divno               ; jump to next iteration
  915 9da5: 88          divyes:    glo     r8                  ; get lo of additive
  916 9da6: 73                     stxd                        ; place in memory
  917 9da7: 60                     irx                         ; point to byte
  918 9da8: 8c                     glo     rc                  ; get lo of answer
  919 9da9: f4                     add                         ; and add
  920 9daa: ac                     plo     rc                  ; put back
  921 9dab: 98                     ghi     r8                  ; get hi of additive
  922 9dac: 73                     stxd                        ; place into memory
  923 9dad: 60                     irx                         ; point to byte
  924 9dae: 9c                     ghi     rc                  ; get hi byte of answer
  925 9daf: 74                     adc                         ; and continue addition
  926 9db0: bc                     phi     rc                  ; put back
  927 9db1: 97          divno:     ghi     r7                  ; get hi of divisor
  928 9db2: f6                     shr                         ; divide by 2
  929 9db3: b7                     phi     r7                  ; put back
  930 9db4: 87                     glo     r7                  ; get lo of divisor
  931 9db5: 76                     shrc                        ; continue divide by 2
  932 9db6: a7                     plo     r7
  933 9db7: 98                     ghi     r8                  ; get hi of divisor
  934 9db8: f6                     shr                         ; divide by 2
  935 9db9: b8                     phi     r8                  ; put back
  936 9dba: 88                     glo     r8                  ; get lo of divisor
  937 9dbb: 76                     shrc                        ; continue divide by 2
  938 9dbc: a8                     plo     r8
  939 9dbd: c0 9d 74               lbr     divst               ; next iteration
  940 9dc0:             
  941 9dc0:             ;           org     300h
  942 9dc0:             ; ***************************
  943 9dc0:             ; *** Setup for tokenizer ***
  944 9dc0:             ; ***************************
  945 9dc0: f8 02       tknizer:   ldi     high buffer         ; point to input buffer
  946 9dc2: bb                     phi     rb
  947 9dc3: f8 00                  ldi     low buffer
  948 9dc5: ab                     plo     rb
  949 9dc6: f8 06                  ldi     low freemem         ; get free memory pointer
  950 9dc8: a9                     plo     r9                  ; place into data segment
  951 9dc9: 49                     lda     r9                  ; get free memory pointer
  952 9dca: bf                     phi     rf                  ; place into rF
  953 9dcb: 09                     ldn     r9
  954 9dcc: af                     plo     rf
  955 9dcd: 1f                     inc     rf
  956 9dce: 1f                     inc     rf
  957 9dcf: e2                     sex     r2                  ; make sure x is pointing to stack
  958 9dd0:             
  959 9dd0:             ; ******************************
  960 9dd0:             ; *** Now the tokenizer loop ***
  961 9dd0:             ; ******************************
  962 9dd0: 0b          tokenlp:   ldn     rb                  ; get byte from buffer
  963 9dd1: c2 9f 72               lbz     tokendn             ; jump if found terminator
  964 9dd4: ff 21                  smi     (' '+1)             ; check for whitespace
  965 9dd6: c3 9d dd               lbdf    nonwhite            ; jump if not whitespace
  966 9dd9: 1b                     inc     rb                  ; move past white space
  967 9dda: c0 9d d0               lbr     tokenlp             ; and keep looking
  968 9ddd:             
  969 9ddd:             ; ********************************************
  970 9ddd:             ; *** Prepare to check against token table ***
  971 9ddd:             ; ********************************************
  972 9ddd: f8 ac       nonwhite:  ldi     high cmdTable       ; point to comand table
  973 9ddf: b7                     phi     r7                  ; r7 will be command table pointer
  974 9de0: f8 f6                  ldi     low cmdTable
  975 9de2: a7                     plo     r7
  976 9de3: f8 01                  ldi     1                   ; first command number
  977 9de5: a8                     plo     r8                  ; r8 will keep track of command number
  978 9de6:             ; **************************
  979 9de6:             ; *** Command check loop ***
  980 9de6:             ; **************************
  981 9de6: 9b          cmdloop:   ghi     rb                  ; save buffer address
  982 9de7: bc                     phi     rc
  983 9de8: 8b                     glo     rb
  984 9de9: ac                     plo     rc
  985 9dea:             ; ************************
  986 9dea:             ; *** Check next token ***
  987 9dea:             ; ************************
  988 9dea: 07          tokloop:   ldn     r7                  ; get byte from token table
  989 9deb: fa 80                  ani     128                 ; check if last byte of token
  990 9ded: ca 9e 13               lbnz    cmdend              ; jump if last byte
  991 9df0: 07                     ldn     r7                  ; reget token byte
  992 9df1: 52                     str     r2                  ; store to stack
  993 9df2: 0b                     ldn     rb                  ; get byte from buffer
  994 9df3: f7                     sm                          ; do bytes match?
  995 9df4: ca 9d fc               lbnz    toknomtch           ; jump if no match
  996 9df7: 17                     inc     r7                  ; incrment token pointer
  997 9df8: 1b                     inc     rb                  ; increment buffer pointer
  998 9df9: c0 9d ea               lbr     tokloop             ; and keep looking
  999 9dfc:             ; *********************************************************
 1000 9dfc:             ; *** Token failed match, move to next and reset buffer ***
 1001 9dfc:             ; *********************************************************
 1002 9dfc: 9c          toknomtch: ghi     rc                  ; recover saved address
 1003 9dfd: bb                     phi     rb
 1004 9dfe: 8c                     glo     rc
 1005 9dff: ab                     plo     rb
 1006 9e00: 07          nomtch1:   ldn     r7                  ; get byte from token
 1007 9e01: fa 80                  ani     128                 ; looking for last byte of token
 1008 9e03: ca 9e 0a               lbnz    nomtch2             ; jump if found
 1009 9e06: 17                     inc     r7                  ; point to next byte
 1010 9e07: c0 9e 00               lbr     nomtch1             ; and keep looking
 1011 9e0a: 17          nomtch2:   inc     r7                  ; point to next token
 1012 9e0b: 18                     inc     r8                  ; increment command number
 1013 9e0c: 07                     ldn     r7                  ; get next token byte
 1014 9e0d: ca 9d e6               lbnz    cmdloop             ; jump if more tokens to check
 1015 9e10: c0 9e 47               lbr     notoken             ; jump if no token found
 1016 9e13:             ; ***********************************************************
 1017 9e13:             ; *** Made it to last byte of token, check remaining byte ***
 1018 9e13:             ; ***********************************************************
 1019 9e13: 07          cmdend:    ldn     r7                  ; get byte fro token
 1020 9e14: fa 7f                  ani     07fh                ; strip off end code
 1021 9e16: 52                     str     r2                  ; save to stack
 1022 9e17: 0b                     ldn     rb                  ; get byte from buffer
 1023 9e18: f7                     sm                          ; do they match
 1024 9e19: ca 9d fc               lbnz    toknomtch           ; jump if not
 1025 9e1c: 1b                     inc     rb                  ; point to next byte
 1026 9e1d: 0b                     ldn     rb                  ; get it
 1027 9e1e: ff 21                  smi     (' '+1)             ; it must be whitespace
 1028 9e20: c3 9d fc               lbdf    toknomtch           ; otherwise no match
 1029 9e23:             ; *************************************************************
 1030 9e23:             ; *** Match found, store command number into command buffer ***
 1031 9e23:             ; *************************************************************
 1032 9e23: 88                     glo     r8                  ; get command number
 1033 9e24: f9 80                  ori     128                 ; set high bit
 1034 9e26: 5f                     str     rf                  ; write to command buffer
 1035 9e27: 1f                     inc     rf                  ; point to next position
 1036 9e28: ff b0                  smi     FDOTQT              ; check for ." function
 1037 9e2a: ca 9d d0               lbnz    tokenlp             ; jump if not
 1038 9e2d: 1b                     inc     rb                  ; move past first space
 1039 9e2e: f8 fe                  ldi     T_ASCII             ; need an ascii token
 1040 9e30: 5f          tdotqtlp:  str     rf                  ; write to command buffer
 1041 9e31: 1f                     inc     rf
 1042 9e32: 0b                     ldn     rb                  ; get next byte
 1043 9e33: ff 22                  smi     34                  ; check for end quote
 1044 9e35: c2 9e 3c               lbz     tdotqtdn            ; jump if found
 1045 9e38: 4b                     lda     rb                  ; transfer character to code
 1046 9e39: c0 9e 30               lbr     tdotqtlp            ; and keep looking
 1047 9e3c: 0b          tdotqtdn:  ldn     rb                  ; retrieve quote
 1048 9e3d: 5f                     str     rf                  ; put quote into output
 1049 9e3e: 1f                     inc     rf
 1050 9e3f: f8 00                  ldi     0                   ; need string terminator
 1051 9e41: 5f                     str     rf
 1052 9e42: 1f                     inc     rf
 1053 9e43: 1b                     inc     rb                  ; move past quote
 1054 9e44: c0 9d d0               lbr     tokenlp             ; then continue tokenizing
 1055 9e47:             
 1056 9e47:             
 1057 9e47:             ; ------------------------------------------------------------------------
 1058 9e47:             ;     DECIMAL handler  if not valid decimal then proceed to ascii        ; 
 1059 9e47:             ; ------------------------------------------------------------------------
 1060 9e47:             
 1061 9e47:             notoken:   ; get number BASE [GDJ]
 1062 9e47: 8b ac 9b bc 	mov rc,rb
 1063 9e4b: 0b          	ldn rb
 1064 9e4c: ff 30       	smi '0'
 1065 9e4e: 3a 64       	bnz notokenbase  	; if no leading 0 can't be 0x or 0#
 1066 9e50: 1b          	inc rb
 1067 9e51: 0b          	ldn rb
 1068 9e52: ff 58       	smi 'X'
 1069 9e54: 32 5b       	bz notoken_0   		; 0xHexNumber
 1070 9e56: 0b          	ldn rb
 1071 9e57: ff 23       	smi '#'
 1072 9e59: 3a 63       	bnz notokenbaseadj		; 0#DecNumber
 1073 9e5b:             notoken_0:
 1074 9e5b: 0b          	ldn rb
 1075 9e5c: 1b          	inc rb
 1076 9e5d: ff 58       	smi 'X'
 1077 9e5f: 32 fa       	bz hexnum
 1078 9e61: 30 70       	br decnum
 1079 9e63: 2b          notokenbaseadj:	  dec rb   	; point back at 0
 1080 9e64:             notokenbase:	
 1081 9e64: f8 17 ad f8 
            03 bd                  mov     rd, basen
 1082 9e6a: 0d                     ldn     rd
 1083 9e6b: ff 0a                  smi     10
 1084 9e6d: ca 9e fa               lbnz    hexnum
 1085 9e70:             
 1086 9e70: f8 00 ad f8 
            00 bd       decnum:    mov     rd, 0               ; temp flag for minus sign
 1087 9e76: 8b ac 9b bc            mov     rc,rb               ; save pointer in case of bad number
 1088 9e7a: f8 00                  ldi     0                   ; clear negative flag
 1089 9e7c: ae                     plo     re
 1090 9e7d: 0b                     ldn     rb                  ; get byte
 1091 9e7e: ff 2d                  smi     '-'                 ; is it negative
 1092 9e80: ca 9e 88               lbnz    notoken1            ; jump if not
 1093 9e83: 1b                     inc     rb                  ; move past negative
 1094 9e84: f8 01                  ldi     1                   ; set negative flag
 1095 9e86: ae                     plo     re
 1096 9e87: ad                     plo     rd
 1097 9e88: 0b          notoken1:  ldn     rb                  ; get byte
 1098 9e89: ff 30                  smi     '0'                 ; check for below numbers
 1099 9e8b: cb 9f 4a               lbnf    nonnumber           ; jump if not a number
 1100 9e8e: 0b                     ldn     rb
 1101 9e8f: ff 3a                  smi     ('9'+1)
 1102 9e91: c3 9f 4a               lbdf    nonnumber
 1103 9e94:                        ; ghi     rb                  ; save pointer in case of bad number
 1104 9e94:                        ; phi     rc
 1105 9e94:                        ; glo     rb
 1106 9e94:                        ; plo     rc
 1107 9e94:             ; **********************
 1108 9e94:             ; *** Found a number ***
 1109 9e94:             ; **********************
 1110 9e94: f8 00       isnumber:  ldi     0                   ; number starts out as zero
 1111 9e96: b7                     phi     r7                  ; use r7 to compile number
 1112 9e97: a7                     plo     r7
 1113 9e98: e2                     sex     r2                  ; make sure x is pointing to stack
 1114 9e99: 97          numberlp:  ghi     r7                  ; copy number to temp
 1115 9e9a: b8                     phi     r8
 1116 9e9b: 87                     glo     r7
 1117 9e9c: a8                     plo     r8
 1118 9e9d: 87                     glo     r7                  ; mulitply by 2
 1119 9e9e: fe                     shl
 1120 9e9f: a7                     plo     r7
 1121 9ea0: 97                     ghi     r7
 1122 9ea1: 7e                     shlc
 1123 9ea2: b7                     phi     r7
 1124 9ea3: 87                     glo     r7                  ; mulitply by 4
 1125 9ea4: fe                     shl
 1126 9ea5: a7                     plo     r7
 1127 9ea6: 97                     ghi     r7
 1128 9ea7: 7e                     shlc
 1129 9ea8: b7                     phi     r7
 1130 9ea9: 88                     glo     r8                  ; multiply by 5
 1131 9eaa: 52                     str     r2
 1132 9eab: 87                     glo     r7
 1133 9eac: f4                     add
 1134 9ead: a7                     plo     r7
 1135 9eae: 98                     ghi     r8
 1136 9eaf: 52                     str     r2
 1137 9eb0: 97                     ghi     r7
 1138 9eb1: 74                     adc
 1139 9eb2: b7                     phi     r7
 1140 9eb3: 87                     glo     r7                  ; mulitply by 10
 1141 9eb4: fe                     shl
 1142 9eb5: a7                     plo     r7
 1143 9eb6: 97                     ghi     r7
 1144 9eb7: 7e                     shlc
 1145 9eb8: b7                     phi     r7
 1146 9eb9: 4b                     lda     rb                  ; get byte from buffer
 1147 9eba: ff 30                  smi     '0'                 ; convert to numeric
 1148 9ebc: 52                     str     r2                  ; store it
 1149 9ebd: 87                     glo     r7                  ; add to number
 1150 9ebe: f4                     add
 1151 9ebf: a7                     plo     r7
 1152 9ec0: 97                     ghi     r7                  ; propagate through high byte
 1153 9ec1: 7c 00                  adci    0
 1154 9ec3: b7                     phi     r7
 1155 9ec4: 0b                     ldn     rb                  ; get byte
 1156 9ec5: ff 21                  smi     (' '+1)             ; check for space
 1157 9ec7: cb 9e e0               lbnf    numberdn            ; number also done
 1158 9eca: 0b                     ldn     rb
 1159 9ecb: ff 30                  smi     '0'                 ; check for below numbers
 1160 9ecd: cb 9e d9               lbnf    numbererr           ; jump if not a number
 1161 9ed0: 0b                     ldn     rb
 1162 9ed1: ff 3a                  smi     ('9'+1)
 1163 9ed3: c3 9e d9               lbdf    numbererr
 1164 9ed6: c0 9e 99               lbr     numberlp            ; get rest of number
 1165 9ed9: 9c          numbererr: ghi     rc                  ; recover address
 1166 9eda: bb                     phi     rb
 1167 9edb: 8c                     glo     rc
 1168 9edc: ab                     plo     rb
 1169 9edd: c0 9f 4a               lbr     nonnumber
 1170 9ee0: 8e          numberdn:  glo     re                  ; get negative flag
 1171 9ee1: c2 9e ed               lbz     numberdn1           ; jump if positive number
 1172 9ee4: 97                     ghi     r7                  ; negative, so 2s compliment number
 1173 9ee5: fb ff                  xri     0ffh
 1174 9ee7: b7                     phi     r7
 1175 9ee8: 87                     glo     r7
 1176 9ee9: fb ff                  xri     0ffh
 1177 9eeb: a7                     plo     r7
 1178 9eec: 17                     inc     r7
 1179 9eed: f8 ff       numberdn1: ldi     T_NUM               ; code to signify a number
 1180 9eef: 5f                     str     rf                  ; write to code buffer
 1181 9ef0: 1f                     inc     rf                  ; point to next position
 1182 9ef1: 97                     ghi     r7                  ; get high byte of number
 1183 9ef2: 5f                     str     rf                  ; write to code buffer
 1184 9ef3: 1f                     inc     rf                  ; point to next position
 1185 9ef4: 87                     glo     r7                  ; get lo byte of numbr
 1186 9ef5: 5f                     str     rf                  ; write to code buffer
 1187 9ef6: 1f                     inc     rf                  ; point to next position
 1188 9ef7: c0 9d d0               lbr     tokenlp             ; continue reading tokens
 1189 9efa:             
 1190 9efa:             ; ------------------------------------------------------------------------
 1191 9efa:             ;       HEX handler  if not valid decimal then proceed to ascii          ; 
 1192 9efa:             ; ------------------------------------------------------------------------
 1193 9efa:             				; [GDJ]
 1194 9efa: f8 00       hexnum:    ldi     0h                  ; clear return value
 1195 9efc: a7                     plo     r7
 1196 9efd: b7                     phi     r7
 1197 9efe: 8b ac 9b bc            mov     rc,rb               ; save pointer in case of bad number
 1198 9f02:             
 1199 9f02:                        ; for first pass we reject non hex chars
 1200 9f02:                        ; in next pass this check has already been done but we
 1201 9f02:                        ; have to deal with the different offsets here for ascii to binary
 1202 9f02:                        ; Note: all strings have been converted to upper case previously
 1203 9f02: 0b          tohexlp:   ldn     rb                  ; get next byte
 1204 9f03: ff 30                  smi     '0'                 ; check for bottom of range
 1205 9f05: cb 9f 4a               lbnf    nonnumber           ; jump if non-numeric
 1206 9f08: 0b                     ldn     rb                  ; recover byte
 1207 9f09: ff 3a                  smi     '9'+1               ; upper range of digits
 1208 9f0b: cb 9f 1d               lbnf    tohexd              ; jump if digit
 1209 9f0e: 0b                     ldn     rb                  ; recover character
 1210 9f0f: ff 41                  smi     'A'                 ; check below uc A
 1211 9f11: cb 9f 4a               lbnf    nonnumber           ; jump if not hex character
 1212 9f14: 0b                     ldn     rb                  ; recover character
 1213 9f15: ff 47                  smi     'F'+1               ; check for above uc F
 1214 9f17: c3 9f 4a               lbdf    nonnumber           ; jump if not hex character
 1215 9f1a: c0 9f 23               lbr     tohex
 1216 9f1d: 0b          tohexd:    ldn     rb                  ; recover character 0..9
 1217 9f1e: ff 30                  smi     030h                ; convert to binary       
 1218 9f20: c0 9f 26               lbr     tohexad
 1219 9f23: 0b          tohex:     ldn     rb                  ; recover character A..F
 1220 9f24: ff 37                  smi     55                  ; convert to binary
 1221 9f26: 52          tohexad:   str     r2                  ; store value to add
 1222 9f27: f8 04                  ldi     4                   ; need to shift 4 times
 1223 9f29: ae                     plo     re
 1224 9f2a: 87          tohexal:   glo     r7
 1225 9f2b: fe                     shl
 1226 9f2c: a7                     plo     r7
 1227 9f2d: 97                     ghi     r7
 1228 9f2e: 7e                     shlc
 1229 9f2f: b7                     phi     r7
 1230 9f30: 2e                     dec     re                  ; decrement count
 1231 9f31: 8e                     glo     re                  ; get count
 1232 9f32: ca 9f 2a               lbnz    tohexal             ; loop until done
 1233 9f35: 87                     glo     r7                  ; now add in new value
 1234 9f36: f1                     or                          ; or with stored byte
 1235 9f37: a7                     plo     r7
 1236 9f38:             
 1237 9f38: 1b                     inc     rb
 1238 9f39: 0b                     ldn     rb
 1239 9f3a: ff 21                  smi     (' '+1)             ; check for space
 1240 9f3c: cb 9e ed               lbnf    numberdn1           ; number is complete
 1241 9f3f:                        
 1242 9f3f:                        ; words that begin with valid hex chars but have
 1243 9f3f:                        ; embedded non hex characters get filtered out here
 1244 9f3f: 0b                     ldn     rb
 1245 9f40: d4                     sep     scall               ; check for hex character
 1246 9f41: ac 2a                  dw      ishex
 1247 9f43: c3 9f 02               lbdf    tohexlp             ; loop back if so else
 1248 9f46:                                                    ; we dont have a hex char
 1249 9f46:                        
 1250 9f46:                        ; we got here since this was not a valid hex number           
 1251 9f46: 8c ab 9c bb nothexnum: mov     rb,rc               ; retrieve pointer
 1252 9f4a:             
 1253 9f4a:             
 1254 9f4a:             ; *************************************************************
 1255 9f4a:             ; *** Neither token or number found, insert as ascii string ***
 1256 9f4a:             ; *************************************************************
 1257 9f4a: 2b          nonnumber: dec     rb                  ; account for first increment
 1258 9f4b: f8 17 ac f8 
            03 bc                  mov     rc, basen
 1259 9f51: 0c                     ldn     rc
 1260 9f52: ff 0a                  smi     10
 1261 9f54: ca 9f 5c               lbnz    nonnumber1
 1262 9f57: 8d                     glo     rd
 1263 9f58: c2 9f 5c               lbz     nonnumber1
 1264 9f5b: 2b                     dec     rb                  ; account for previous minus sign in DECIMAL mode
 1265 9f5c:             nonnumber1:
 1266 9f5c: f8 fe                  ldi     T_ASCII             ; indicate ascii to follow
 1267 9f5e: 5f          notokenlp: str     rf                  ; write to buffer
 1268 9f5f: 1f                     inc     rf                  ; advance to next position
 1269 9f60: 1b                     inc     rb                  ; point to next position
 1270 9f61: 0b                     ldn     rb                  ; get next byte
 1271 9f62: ff 21                  smi     (' '+1)             ; check for whitespace
 1272 9f64: cb 9f 6b               lbnf    notokwht            ; found whitespace
 1273 9f67: 0b                     ldn     rb                  ; get byte
 1274 9f68: c0 9f 5e               lbr     notokenlp           ; get characters til whitespace
 1275 9f6b: f8 00       notokwht:  ldi     0                   ; need ascii terminator
 1276 9f6d: 5f                     str     rf                  ; store into buffer
 1277 9f6e: 1f                     inc     rf                  ; point to next position
 1278 9f6f: c0 9d d0               lbr     tokenlp             ; and keep looking
 1279 9f72: f8 00       tokendn:   ldi     0                   ; need to terminate command string
 1280 9f74: 5f                     str     rf                  ; write to buffer
 1281 9f75: d5                     sep    sret                 ; return to caller
 1282 9f76:             
 1283 9f76:             
 1284 9f76:             ;           org     500h
 1285 9f76:             ; ****************************************************
 1286 9f76:             ; *** Execute forth byte codes, RB points to codes ***
 1287 9f76:             ; ****************************************************
 1288 9f76: 0b          exec:      ldn     rb                  ; get byte from codestream
 1289 9f77: c2 a0 11               lbz     execdn              ; jump if at end of stream
 1290 9f7a: ff ff                  smi     T_NUM               ; check for numbers
 1291 9f7c: c2 9f c2               lbz     execnum             ; code is numeric
 1292 9f7f: 0b                     ldn     rb                  ; recover byte
 1293 9f80: ff fe                  smi     T_ASCII             ; check for ascii data
 1294 9f82: c2 9f d5               lbz     execascii           ; jump if ascii
 1295 9f85: f8 0a a8 f8 
            03 b8                  mov     r8, jump            ; point to jump address
 1296 9f8b: f8 c0                  ldi     0c0h                ; need LBR
 1297 9f8d: 58                     str     r8                  ; store it
 1298 9f8e: 18                     inc     r8
 1299 9f8f: 0b                     ldn     rb                  ; recover byte
 1300 9f90: fa 7f                  ani     07fh                ; strip high bit
 1301 9f92: ff 01                  smi     1                   ; reset to origin
 1302 9f94: fe                     shl                         ; addresses are two bytes
 1303 9f95: e2                     sex     r2                  ; point X to stack
 1304 9f96: 52                     str     r2                  ; write offset for addtion
 1305 9f97: f8 e0                  ldi     low cmdvecs
 1306 9f99: f4                     add                         ; add offset
 1307 9f9a: a7                     plo     r7
 1308 9f9b: f8 ad                  ldi     high cmdvecs        ; high address of command vectors
 1309 9f9d: 7c 00                  adci    0                   ; propagate carry
 1310 9f9f: b7                     phi     r7                  ; r[7] now points to command vector
 1311 9fa0: 47                     lda     r7                  ; get high byte of vector
 1312 9fa1: 58                     str     r8
 1313 9fa2: 18                     inc     r8
 1314 9fa3: 47                     lda     r7                  ; get low byte of vector
 1315 9fa4: 58                     str     r8
 1316 9fa5: 1b                     inc     rb                  ; point rb to next command
 1317 9fa6: 8b                     glo     rb                  ; save rb
 1318 9fa7: 73                     stxd
 1319 9fa8: 9b                     ghi     rb
 1320 9fa9: 73                     stxd
 1321 9faa: c0 03 0a               lbr     jump
 1322 9fad: e2          execret:   sex     r2                  ; be sure X poits to stack
 1323 9fae: a7                     plo     r7                  ; save return code
 1324 9faf: 60                     irx                         ; recover rb
 1325 9fb0: 42                     lda     r2
 1326 9fb1: bb                     phi     rb
 1327 9fb2: 02                     ldn     r2
 1328 9fb3: ab                     plo     rb
 1329 9fb4: 87                     glo     r7                  ; get result code
 1330 9fb5: c2 9f 76               lbz     exec                ; jump if no error
 1331 9fb8: f8 ac                  ldi     high msempty        ; get error message
 1332 9fba: bf                     phi     rf
 1333 9fbb: f8 e2                  ldi     low msempty
 1334 9fbd: af                     plo     rf
 1335 9fbe: d4          execrmsg:  sep     scall
            #else
 1339 9fbf: ff 09                  dw      f_msg
            #endif
 1341 9fc1: d5                     sep     sret                ; return to caller
 1342 9fc2:             
 1343 9fc2: 1b          execnum:   inc     rb                  ; point to number
 1344 9fc3: 9b                     ghi     rb
 1345 9fc4: b7                     phi     r7
 1346 9fc5: 8b                     glo     rb
 1347 9fc6: a7                     plo     r7
 1348 9fc7: 47                     lda     r7
 1349 9fc8: bb                     phi     rb
 1350 9fc9: 47                     lda     r7
 1351 9fca: ab                     plo     rb
 1352 9fcb: d4                     sep     scall
 1353 9fcc: 9c 61                  dw      push
 1354 9fce: 97                     ghi     r7
 1355 9fcf: bb                     phi     rb
 1356 9fd0: 87                     glo     r7
 1357 9fd1: ab                     plo     rb
 1358 9fd2: c0 9f 76               lbr     exec                ; execute next code
 1359 9fd5: 1b          execascii: inc     rb                  ; move past ascii code
 1360 9fd6: 9b                     ghi     rb                  ; transfer name to R8
 1361 9fd7: b8                     phi     r8
 1362 9fd8: 8b                     glo     rb
 1363 9fd9: a8                     plo     r8
 1364 9fda: d4                     sep     scall               ; find entry
 1365 9fdb: 9c a5                  dw      findname
 1366 9fdd: cb 9f e9               lbnf    ascnoerr            ; jump if name was found
 1367 9fe0: f8 ac       ascerr:    ldi     high msgerr         ; get error message
 1368 9fe2: bf                     phi     rf
 1369 9fe3: f8 f0                  ldi     low msgerr
 1370 9fe5: af                     plo     rf
 1371 9fe6: c0 9f be               lbr     execrmsg
 1372 9fe9: 17          ascnoerr:  inc     r7                  ; point to type
 1373 9fea: 17                     inc     r7
 1374 9feb: 07                     ldn     r7                  ; get type
 1375 9fec: ff 86                  smi     86h                 ; check for variable
 1376 9fee: c2 a0 07               lbz     execvar             ; jump if so
 1377 9ff1: 07                     ldn     r7                  ; get type
 1378 9ff2: ff 87                  smi     87h                 ; check for function
 1379 9ff4: ca 9f e0               lbnz    ascerr              ; jump if not
 1380 9ff7: e2                     sex     r2                  ; be sure X is pointing to stack
 1381 9ff8: 88                     glo     r8                  ; save position
 1382 9ff9: 73                     stxd                        ; and store on stack
 1383 9ffa: 98                     ghi     r8
 1384 9ffb: 73                     stxd
 1385 9ffc: d4                     sep     scall               ; call exec to execute stored program
 1386 9ffd: 9f 76                  dw      exec
 1387 9fff: 60                     irx                         ; recover pointer
 1388 a000: 72                     ldxa
 1389 a001: bb                     phi     rb
 1390 a002: f0                     ldx
 1391 a003: ab                     plo     rb
 1392 a004: c0 9f 76               lbr     exec                ; and continue execution
 1393 a007: d4          execvar:   sep     scall               ; push var address to stack
 1394 a008: 9c 61                  dw      push
 1395 a00a: 98                     ghi     r8                  ; transfer address back to rb
 1396 a00b: bb                     phi     rb
 1397 a00c: 88                     glo     r8
 1398 a00d: ab                     plo     rb
 1399 a00e: c0 9f 76               lbr     exec                ; execute next code
 1400 a011:                        
 1401 a011: d5          execdn:    sep     sret                ; return to caller
 1402 a012:             
 1403 a012: f8 01       error:     ldi     1                   ; indicate error
 1404 a014: c0 9f ad               lbr     execret             ; return to caller
 1405 a017: f8 00       good:      ldi     0                   ; indicate success
 1406 a019: c0 9f ad               lbr     execret             ; return to caller
 1407 a01c:             
 1408 a01c:             ;          org     600h
 1409 a01c: d4          cdup:      sep     scall               ; pop value from forth stack
 1410 a01d: 9c 32                  dw      pop
 1411 a01f: c3 a0 12               lbdf    error               ; jump if stack was empty
 1412 a022: d4                     sep     scall               ; push back twice
 1413 a023: 9c 61                  dw      push
 1414 a025:             goodpush:	
 1415 a025: d4                     sep     scall
 1416 a026: 9c 61                  dw      push
 1417 a028: c0 a0 17               lbr     good                ; return
 1418 a02b:             
 1419 a02b: d4          cdrop:     sep     scall               ; pop value from stack
 1420 a02c: 9c 32                  dw      pop
 1421 a02e: c3 a0 12               lbdf    error               ; jump if stack was empty
 1422 a031: c0 a0 17               lbr     good                ; return
 1423 a034:                        
 1424 a034: d4          cplus:     sep     scall               ; get value from stack
 1425 a035: 9c 32                  dw      pop
 1426 a037: c3 a0 12               lbdf    error               ; jump if stack was empty
 1427 a03a: 9b                     ghi     rb                  ; move number 
 1428 a03b: b7                     phi     r7
 1429 a03c: 8b                     glo     rb
 1430 a03d: a7                     plo     r7
 1431 a03e: d4                     sep     scall               ; get next number
 1432 a03f: 9c 32                  dw      pop
 1433 a041: c3 a0 12               lbdf    error               ; jump if stack was empty
 1434 a044: e2                     sex     r2                  ; be sure X points to stack
 1435 a045: 87                     glo     r7                  ; perform addition
 1436 a046: 52                     str     r2
 1437 a047: 8b                     glo     rb
 1438 a048: f4                     add
 1439 a049: ab                     plo     rb
 1440 a04a: 97                     ghi     r7
 1441 a04b: 52                     str     r2
 1442 a04c: 9b                     ghi     rb
 1443 a04d: 74                     adc
 1444 a04e: bb                     phi     rb
 1445 a04f: c0 a0 25    	   lbr     goodpush
 1446 a052:             
 1447 a052:             
 1448 a052:             
 1449 a052: d4          cminus:    sep     scall               ; get value from stack
 1450 a053: 9c 32                  dw      pop
 1451 a055: c3 a0 12               lbdf    error               ; jump if stack was empty
 1452 a058: 9b                     ghi     rb                  ; move number 
 1453 a059: b7                     phi     r7
 1454 a05a: 8b                     glo     rb
 1455 a05b: a7                     plo     r7
 1456 a05c: d4                     sep     scall               ; get next number
 1457 a05d: 9c 32                  dw      pop
 1458 a05f: c3 a0 12               lbdf    error               ; jump if stack was empty
 1459 a062: e2                     sex     r2                  ; be sure X points to stack
 1460 a063: 87                     glo     r7                  ; perform addition
 1461 a064: 52                     str     r2
 1462 a065: 8b                     glo     rb
 1463 a066: f7                     sm
 1464 a067: ab                     plo     rb
 1465 a068: 97                     ghi     r7
 1466 a069: 52                     str     r2
 1467 a06a: 9b                     ghi     rb
 1468 a06b: 77                     smb
 1469 a06c: bb                     phi     rb
 1470 a06d: c0 a0 25    	   lbr goodpush
 1471 a070:             
 1472 a070:             
 1473 a070: d4          cdot:      sep     scall               ; get value from stack
 1474 a071: 9c 32                  dw      pop
 1475 a073: c3 a0 12               lbdf    error               ; jump if stack was empty
 1476 a076: f8 01                  ldi     1
 1477 a078: ae                     plo     re                  ; signal signed int
 1478 a079: d4                     sep     scall
 1479 a07a: ab be                  dw      typenum             ; [GDJ]
 1480 a07c:                        ; sep     scall               ; call integer out routine
 1481 a07c:                        ; dw      intout
 1482 a07c:                        ; ldi     ' '                 ; need a space
 1483 a07c:                        ; sep     scall               ; need to call character out
 1484 a07c:                        ; dw      disp
 1485 a07c: c0 a0 17               lbr     good                ; return
 1486 a07f:             
 1487 a07f: d4          cudot:     sep     scall               ; get value from stack
 1488 a080: 9c 32                  dw      pop
 1489 a082: c3 a0 12               lbdf    error               ; jump if stack was empty
 1490 a085: f8 00                  ldi     0
 1491 a087: ae                     plo     re                  ; signal unsigned int
 1492 a088: d4                     sep     scall               ; call integer out routine
 1493 a089: ab be                  dw      typenum             ; [GDJ]
 1494 a08b:                        ; sep     scall
 1495 a08b:                        ; dw      uintout
 1496 a08b:                        ; ldi     ' '                 ; need a space
 1497 a08b:                        ; sep     scall               ; need to call character out
 1498 a08b:                        ; dw      disp
 1499 a08b: c0 a0 17               lbr     good                ; return
 1500 a08e:             
 1501 a08e: d4          cand:      sep     scall               ; get value from stack
 1502 a08f: 9c 32                  dw      pop
 1503 a091: c3 a0 12               lbdf    error               ; jump if stack was empty
 1504 a094: 9b                     ghi     rb                  ; move number 
 1505 a095: b7                     phi     r7
 1506 a096: 8b                     glo     rb
 1507 a097: a7                     plo     r7
 1508 a098: d4                     sep     scall               ; get next number
 1509 a099: 9c 32                  dw      pop
 1510 a09b: c3 a0 12               lbdf    error               ; jump if stack was empty
 1511 a09e: e2                     sex     r2                  ; be sure X points to stack
 1512 a09f: 87                     glo     r7                  ; perform and
 1513 a0a0: 52                     str     r2
 1514 a0a1: 8b                     glo     rb
 1515 a0a2: f2                     and
 1516 a0a3: ab                     plo     rb
 1517 a0a4: 97                     ghi     r7
 1518 a0a5: 52                     str     r2
 1519 a0a6: 9b                     ghi     rb
 1520 a0a7: f2                     and
 1521 a0a8: bb                     phi     rb
 1522 a0a9: c0 a0 25    	   lbr goodpush
 1523 a0ac:             
 1524 a0ac:             
 1525 a0ac: d4          cor:       sep     scall               ; get value from stack
 1526 a0ad: 9c 32                  dw      pop
 1527 a0af: c3 a0 12               lbdf    error               ; jump if stack was empty
 1528 a0b2: 9b                     ghi     rb                  ; move number 
 1529 a0b3: b7                     phi     r7
 1530 a0b4: 8b                     glo     rb
 1531 a0b5: a7                     plo     r7
 1532 a0b6: d4                     sep     scall               ; get next number
 1533 a0b7: 9c 32                  dw      pop
 1534 a0b9: c3 a0 12               lbdf    error               ; jump if stack was empty
 1535 a0bc: e2                     sex     r2                  ; be sure X points to stack
 1536 a0bd: 87                     glo     r7                  ; perform and
 1537 a0be: 52                     str     r2
 1538 a0bf: 8b                     glo     rb
 1539 a0c0: f1                     or
 1540 a0c1: ab                     plo     rb
 1541 a0c2: 97                     ghi     r7
 1542 a0c3: 52                     str     r2
 1543 a0c4: 9b                     ghi     rb
 1544 a0c5: f1                     or
 1545 a0c6: bb                     phi     rb
 1546 a0c7: c0 a0 25    	   lbr     goodpush
 1547 a0ca:             
 1548 a0ca: d4          cxor:      sep     scall               ; get value from stack
 1549 a0cb: 9c 32                  dw      pop
 1550 a0cd: c3 a0 12               lbdf    error               ; jump if stack was empty
 1551 a0d0: 9b                     ghi     rb                  ; move number 
 1552 a0d1: b7                     phi     r7
 1553 a0d2: 8b                     glo     rb
 1554 a0d3: a7                     plo     r7
 1555 a0d4: d4                     sep     scall               ; get next number
 1556 a0d5: 9c 32                  dw      pop
 1557 a0d7: c3 a0 12               lbdf    error               ; jump if stack was empty
 1558 a0da: e2                     sex     r2                  ; be sure X points to stack
 1559 a0db: 87                     glo     r7                  ; perform and
 1560 a0dc: 52                     str     r2
 1561 a0dd: 8b                     glo     rb
 1562 a0de: f3                     xor
 1563 a0df: ab                     plo     rb
 1564 a0e0: 97                     ghi     r7
 1565 a0e1: 52                     str     r2
 1566 a0e2: 9b                     ghi     rb
 1567 a0e3: f3                     xor
 1568 a0e4: bb                     phi     rb
 1569 a0e5: c0 a0 25    	   lbr    goodpush
 1570 a0e8:             
 1571 a0e8:             
 1572 a0e8: d4          ccr:	   sep scall
 1573 a0e9: 9c 17       	   dw crlfout
 1574 a0eb: c0 a0 17               lbr     good                ; return
 1575 a0ee:             
 1576 a0ee: d4          cswap:     sep     scall               ; get value from stack
 1577 a0ef: 9c 32                  dw      pop
 1578 a0f1: c3 a0 12               lbdf    error               ; jump if stack was empty
 1579 a0f4: 9b                     ghi     rb                  ; move number 
 1580 a0f5: b7                     phi     r7
 1581 a0f6: 8b                     glo     rb
 1582 a0f7: a7                     plo     r7
 1583 a0f8: d4                     sep     scall               ; get next number
 1584 a0f9: 9c 32                  dw      pop
 1585 a0fb: c3 a0 12               lbdf    error               ; jump if stack was empty
 1586 a0fe: 9b                     ghi     rb                  ; move number 
 1587 a0ff: b8                     phi     r8
 1588 a100: 8b                     glo     rb
 1589 a101: a8                     plo     r8
 1590 a102: 97                     ghi     r7                  ; move number 
 1591 a103: bb                     phi     rb
 1592 a104: 87                     glo     r7
 1593 a105: ab                     plo     rb
 1594 a106: d4                     sep     scall               ; put answer back on stack
 1595 a107: 9c 61                  dw      push
 1596 a109: 98                     ghi     r8                  ; move number 
 1597 a10a: bb                     phi     rb
 1598 a10b: 88                     glo     r8
 1599 a10c: ab                     plo     rb
 1600 a10d: d4                     sep     scall               ; put answer back on stack
 1601 a10e: 9c 61                  dw      push
 1602 a110: c0 a0 17               lbr     good                ; return
 1603 a113:             
 1604 a113: d4          ci:        sep     scall               ; get value from return stack
 1605 a114: 9c 77                  dw      rpop
 1606 a116: d4                     sep     scall               ; put back on return stack
 1607 a117: 9c 8f                  dw      rpush 
 1608 a119: c0 a0 25    	   lbr  goodpush
 1609 a11c:             
 1610 a11c: e2          cmem:      sex     r2                  ; be sure x is pointing to stack
 1611 a11d: f8 06                  ldi     low freemem         ; point to free memory pointer
 1612 a11f: a9                     plo     r9                  ; place into data frame
 1613 a120: 49                     lda     r9                  ; get high byte of free memory pointer
 1614 a121: 73                     stxd                        ; store on stack
 1615 a122: 49                     lda     r9                  ; get low byte
 1616 a123: 52                     str     r2                  ; store on stack
 1617 a124: f8 08                  ldi     low fstack          ; get pointer to stack
 1618 a126: a9                     plo     r9                  ; set into data frame
 1619 a127: 19                     inc     r9                  ; point to lo byte
 1620 a128: 09                     ldn     r9                  ; get it
 1621 a129: f7                     sm                          ; perform subtract
 1622 a12a: ab                     plo     rb                  ; put into result
 1623 a12b: 29                     dec     r9                  ; high byte of stack pointer
 1624 a12c: 60                     irx                         ; point to high byte os free mem
 1625 a12d: 09                     ldn     r9                  ; get high byte of stack
 1626 a12e: 77                     smb                         ; continue subtraction
 1627 a12f: bb                     phi     rb                  ; store answer
 1628 a130: c0 a0 25    	   lbr  goodpush
 1629 a133:             
 1630 a133:              
 1631 a133:             
 1632 a133: d4          cdo:       sep     scall               ; get value from stack
 1633 a134: 9c 32                  dw      pop
 1634 a136: c3 a0 12               lbdf    error               ; jump if stack was empty
 1635 a139: 9b                     ghi     rb                  ; move number 
 1636 a13a: b7                     phi     r7
 1637 a13b: 8b                     glo     rb
 1638 a13c: a7                     plo     r7
 1639 a13d: d4                     sep     scall               ; get next number
 1640 a13e: 9c 32                  dw      pop
 1641 a140: c3 a0 12               lbdf    error               ; jump if stack was empty
 1642 a143: 9b                     ghi     rb                  ; move number 
 1643 a144: b8                     phi     r8
 1644 a145: 8b                     glo     rb
 1645 a146: a8                     plo     r8
 1646 a147: 92                     ghi     r2                  ; get copy of machine stack
 1647 a148: ba                     phi     ra
 1648 a149: 82                     glo     r2
 1649 a14a: aa                     plo     ra
 1650 a14b: 1a                     inc     ra                  ; pointing at R[6] value high
 1651 a14c: 4a                     lda     ra                  ; get high of R[6]
 1652 a14d: bb                     phi     rb                  ; put into r6
 1653 a14e: 4a                     lda     ra
 1654 a14f: ab                     plo     rb
 1655 a150: d4                     sep     scall               ; store inst point on return stack
 1656 a151: 9c 8f                  dw      rpush
 1657 a153: 98                     ghi     r8                  ; transfer termination to rb
 1658 a154: bb                     phi     rb
 1659 a155: 88                     glo     r8
 1660 a156: ab                     plo     rb
 1661 a157: d4                     sep     scall               ; store termination on return stack
 1662 a158: 9c 8f                  dw      rpush
 1663 a15a: 97                     ghi     r7                  ; transfer count to rb
 1664 a15b: bb                     phi     rb
 1665 a15c: 87                     glo     r7
 1666 a15d: ab                     plo     rb
 1667 a15e: d4                     sep     scall
 1668 a15f: 9c 8f       	   dw rpush
 1669 a161: c0 a0 17    	   lbr good
 1670 a164:             
 1671 a164:             
 1672 a164: d4          cloop:     sep     scall               ; get top or return stack
 1673 a165: 9c 77                  dw      rpop
 1674 a167: 1b                     inc     rb                  ; add 1 to it
 1675 a168: 9b          loopcnt:   ghi     rb                  ; move it
 1676 a169: b7                     phi     r7
 1677 a16a: 8b                     glo     rb
 1678 a16b: a7                     plo     r7
 1679 a16c: d4                     sep     scall               ; get termination
 1680 a16d: 9c 77                  dw      rpop
 1681 a16f: e2                     sex     r2                  ; make sure x is pointing to stack
 1682 a170: 8b                     glo     rb                  ; get lo of termination
 1683 a171: 52                     str     r2                  ; place into memory 
 1684 a172: 87                     glo     r7                  ; get count
 1685 a173: f7                     sm                          ; perform subtract
 1686 a174: 9b                     ghi     rb                  ; get hi of termination
 1687 a175: 52                     str     r2                  ; place into memory
 1688 a176: 97                     ghi     r7                  ; get high of count
 1689 a177: 77                     smb                         ; continue subtract
 1690 a178: c3 a1 a0               lbdf    cloopdn             ; jump if loop complete
 1691 a17b: 9b                     ghi     rb                  ; move termination
 1692 a17c: b8                     phi     r8
 1693 a17d: 8b                     glo     rb
 1694 a17e: a8                     plo     r8
 1695 a17f: d4                     sep     scall               ; get loop address
 1696 a180: 9c 77                  dw      rpop
 1697 a182: d4                     sep     scall               ; keep on stack as well
 1698 a183: 9c 8f                  dw      rpush
 1699 a185: 92                     ghi     r2                  ; get copy of machine stack
 1700 a186: ba                     phi     ra
 1701 a187: 82                     glo     r2
 1702 a188: aa                     plo     ra
 1703 a189: 1a                     inc     ra                  ; pointing at ra value high
 1704 a18a: 9b                     ghi     rb
 1705 a18b: 5a                     str     ra                  ; and write it
 1706 a18c: 1a                     inc     ra                 
 1707 a18d: 8b                     glo     rb                  ; get rb lo value
 1708 a18e: 5a                     str     ra                  ; and write it
 1709 a18f: 98                     ghi     r8                  ; transfer termination
 1710 a190: bb                     phi     rb
 1711 a191: 88                     glo     r8
 1712 a192: ab                     plo     rb
 1713 a193: d4                     sep     scall               ; push onto return stack
 1714 a194: 9c 8f                  dw      rpush
 1715 a196: 97                     ghi     r7                  ; transfer count
 1716 a197: bb                     phi     rb
 1717 a198: 87                     glo     r7
 1718 a199: ab                     plo     rb
 1719 a19a: d4                     sep     scall               ; push onto return stack
 1720 a19b: 9c 8f                  dw      rpush
 1721 a19d: c0 a0 17               lbr     good                ; and return
 1722 a1a0: d4          cloopdn:   sep     scall               ; pop off start of loop address
 1723 a1a1: 9c 77                  dw      rpop
 1724 a1a3: c0 a0 17               lbr     good                ; and return
 1725 a1a6: d4          cploop:    sep     scall               ; get top or return stack
 1726 a1a7: 9c 77                  dw      rpop
 1727 a1a9: e2                     sex     r2                  ; make sure X points to stack
 1728 a1aa: 9b                     ghi     rb                  ; put count into memory
 1729 a1ab: 73                     stxd
 1730 a1ac: 8b                     glo     rb
 1731 a1ad: 73                     stxd
 1732 a1ae: d4                     sep     scall               ; get word from data stack
 1733 a1af: 9c 32                  dw      pop
 1734 a1b1: c3 a0 12               lbdf    error
 1735 a1b4: 60                     irx
 1736 a1b5: 8b                     glo     rb                  ; add to count
 1737 a1b6: f4                     add
 1738 a1b7: ab                     plo     rb
 1739 a1b8: 9b                     ghi     rb
 1740 a1b9: 60                     irx
 1741 a1ba: 74                     adc
 1742 a1bb: bb                     phi     rb
 1743 a1bc: c0 a1 68               lbr     loopcnt             ; then standard loop code
 1744 a1bf:             
 1745 a1bf: 92          cbegin:    ghi     r2                  ; get copy of machine stack
 1746 a1c0: ba                     phi     ra
 1747 a1c1: 82                     glo     r2
 1748 a1c2: aa                     plo     ra
 1749 a1c3: 1a                     inc     ra                  ; pointing at ra value high
 1750 a1c4: 4a                     lda     ra                  ; get high of ra
 1751 a1c5: bb                     phi     rb                  ; put into rb
 1752 a1c6: 4a                     lda     ra
 1753 a1c7: ab                     plo     rb
 1754 a1c8: d4                     sep     scall               ; store inst point on return stack
 1755 a1c9: 9c 8f                  dw      rpush
 1756 a1cb: c0 a0 17               lbr     good                ; and return
 1757 a1ce:             
 1758 a1ce:             ; [GDJ] corrected logic - BEGIN/UNTIL loop should repeat if flag preceding UNTIL is FALSE
 1759 a1ce: d4          cuntil:    sep     scall               ; get top of stack
 1760 a1cf: 9c 32                  dw      pop
 1761 a1d1: c3 a0 12               lbdf    error               ; jump if stack was empty
 1762 a1d4: 8b                     glo     rb                  ; [GDJ] check flag LSB - if true were done
 1763 a1d5: ca a1 dc               lbnz    untilno             ; [GDJ]
 1764 a1d8: 9b                     ghi     rb                  ; [GDJ] check flag MSB
 1765 a1d9: c2 a1 e2               lbz     untilyes
 1766 a1dc: d4          untilno:   sep     scall               ; pop off begin address
 1767 a1dd: 9c 77                  dw      rpop
 1768 a1df: c0 a0 17               lbr     good                ; we are done, just return
 1769 a1e2: d4          untilyes:  sep     scall               ; get return address - continue looping
 1770 a1e3: 9c 77                  dw      rpop
 1771 a1e5: d4                     sep     scall               ; also keep on stack
 1772 a1e6: 9c 8f                  dw      rpush
 1773 a1e8: 92                     ghi     r2                  ; get copy of machine stack
 1774 a1e9: ba                     phi     ra
 1775 a1ea: 82                     glo     r2
 1776 a1eb: aa                     plo     ra
 1777 a1ec: 1a                     inc     ra                  ; pointing at ra value high
 1778 a1ed: 9b                     ghi     rb
 1779 a1ee: 5a                     str     ra                  ; and write it
 1780 a1ef: 1a                     inc     ra                 
 1781 a1f0: 8b                     glo     rb                  ; get rb lo value
 1782 a1f1: 5a                     str     ra                  ; and write it
 1783 a1f2: c0 a0 17               lbr     good                ; now return
 1784 a1f5:             
 1785 a1f5: d4          crgt:      sep     scall               ; get value from return stack
 1786 a1f6: 9c 77                  dw      rpop
 1787 a1f8: c0 a0 25    	   lbr goodpush
 1788 a1fb:             
 1789 a1fb:             
 1790 a1fb: d4          cgtr:      sep     scall               ; get value from stack
 1791 a1fc: 9c 32                  dw      pop
 1792 a1fe: c3 a0 12               lbdf    error               ; jump if stack was empty
 1793 a201: d4                     sep     scall               ; push to return stack
 1794 a202: 9c 8f                  dw      rpush
 1795 a204: c0 a0 17               lbr     good                ; return to caller
 1796 a207:             
 1797 a207: d4          cunequal:  sep     scall               ; get value from stack
 1798 a208: 9c 32                  dw      pop
 1799 a20a: c3 a0 12               lbdf    error               ; jump if stack was empty
 1800 a20d: 9b                     ghi     rb                  ; move number 
 1801 a20e: b7                     phi     r7
 1802 a20f: 8b                     glo     rb
 1803 a210: a7                     plo     r7
 1804 a211: d4                     sep     scall               ; get next number
 1805 a212: 9c 32                  dw      pop
 1806 a214: c3 a0 12               lbdf    error               ; jump if stack was empty
 1807 a217: e2                     sex     r2                  ; be sure X points to stack
 1808 a218: 87                     glo     r7                  ; perform and
 1809 a219: 52                     str     r2
 1810 a21a: 8b                     glo     rb
 1811 a21b: f3                     xor
 1812 a21c: ca a2 2b               lbnz    unequal             ; jump if not equal
 1813 a21f: 97                     ghi     r7
 1814 a220: 52                     str     r2
 1815 a221: 9b                     ghi     rb
 1816 a222: f3                     xor
 1817 a223: ca a2 2b               lbnz    unequal             ; jump if not equal
 1818 a226: bb                     phi     rb                  ; set return result
 1819 a227: ab                     plo     rb
 1820 a228: c0 a0 25    	   lbr goodpush
 1821 a22b:             
 1822 a22b: f8 00       unequal:   ldi     0                   ; set return result
 1823 a22d: bb                     phi     rb
 1824 a22e: ab                     plo     rb
 1825 a22f: 1b                     inc     rb                  ; it is now 1
 1826 a230: c0 a0 25               lbr     goodpush
 1827 a233:             
 1828 a233:             
 1829 a233:             ; [GDJ]
 1830 a233:             ; determine if NOS < TOS
 1831 a233: d4          cless:     sep     scall               ; get value from stack
 1832 a234: 9c 32                  dw      pop
 1833 a236: c3 a0 12               lbdf    error               ; jump if stack was empty
 1834 a239: 9b                     ghi     rb                  ; move number 
 1835 a23a: b8                     phi     r8
 1836 a23b: 8b                     glo     rb
 1837 a23c: a8                     plo     r8
 1838 a23d: d4                     sep     scall               ; get next number
 1839 a23e: 9c 32                  dw      pop
 1840 a240: c3 a0 12               lbdf    error               ; jump if stack was empty
 1841 a243: e2                     sex     r2                  ; be sure X points to stack
 1842 a244:             
 1843 a244: 9b                     ghi     rb                  ; move number 
 1844 a245: b7                     phi     r7
 1845 a246: 8b                     glo     rb
 1846 a247: a7                     plo     r7
 1847 a248:             
 1848 a248:                        ; bias numbers for comparison
 1849 a248: 97                     ghi     r7
 1850 a249: fb 80                  xri     080h                ; bias upwards
 1851 a24b: b7                     phi     r7
 1852 a24c:             
 1853 a24c: 98                     ghi     r8
 1854 a24d: fb 80                  xri     080h                ; bias upwards
 1855 a24f: b8                     phi     r8
 1856 a250:             
 1857 a250: 87                     glo     7                   ; subtract them
 1858 a251: 52                     str     r2
 1859 a252: 88                     glo     r8
 1860 a253: f5                     sd
 1861 a254: a7                     plo     r7
 1862 a255: 97                     ghi     r7
 1863 a256: 52                     str     r2
 1864 a257: 98                     ghi     r8
 1865 a258: 75                     sdb
 1866 a259: b7                     phi     r7
 1867 a25a:             
 1868 a25a: cb a2 66               lbnf    less1               ; DF signaled with borrow
 1869 a25d: f8 00 ab f8 
            00 bb                  mov     rb, 0
 1870 a263: c0 a0 25               lbr     goodpush
 1871 a266: f8 01 ab f8 
            00 bb       less1:     mov     rb, 1
 1872 a26c: c0 a0 25    	   lbr goodpush 
 1873 a26f:             
 1874 a26f:             
 1875 a26f:             
 1876 a26f:             
 1877 a26f:             ; [GDJ]
 1878 a26f: d4          culess:    sep     scall               ; get value from stack
 1879 a270: 9c 32                  dw      pop
 1880 a272: c3 a0 12               lbdf    error               ; jump if stack was empty
 1881 a275: 9b                     ghi     rb                  ; move number 
 1882 a276: b7                     phi     r7
 1883 a277: 8b                     glo     rb
 1884 a278: a7                     plo     r7
 1885 a279: d4                     sep     scall               ; get next number
 1886 a27a: 9c 32                  dw      pop
 1887 a27c: c3 a0 12               lbdf    error               ; jump if stack was empty
 1888 a27f: e2                     sex     r2                  ; be sure X points to stack
 1889 a280:             
 1890 a280: 9b                     ghi     rb                  ; move number 
 1891 a281: b8                     phi     r8
 1892 a282: 8b                     glo     rb
 1893 a283: a8                     plo     r8
 1894 a284:             
 1895 a284:                        ; perform subtraction r8-r7  (NOS-TOS) to check for borrow
 1896 a284: 88                     glo     r8
 1897 a285: 52                     str     r2
 1898 a286: 87                     glo     r7
 1899 a287: f5                     sd
 1900 a288: a8                     plo     r8
 1901 a289: 98                     ghi     r8
 1902 a28a: 52                     str     r2
 1903 a28b: 97                     ghi     r7
 1904 a28c: 75                     sdb                         ; subtract with borrow
 1905 a28d: cb a2 99               lbnf    uless1              ; DF signaled with borrow
 1906 a290: f8 00 ab f8 
            00 bb                  mov     rb, 0
 1907 a296: c0 a0 25               lbr     goodpush
 1908 a299: f8 01 ab f8 
            00 bb       uless1:    mov     rb, 1
 1909 a29f: c0 a0 25    	   lbr     goodpush
 1910 a2a2:             
 1911 a2a2:             
 1912 a2a2: f8 ac       cwords:    ldi     high cmdtable       ; point to command table
 1913 a2a4: b7                     phi     r7                  ; put into a pointer register
 1914 a2a5: f8 f6                  ldi     low cmdtable
 1915 a2a7: a7                     plo     r7
 1916 a2a8: f8 00 ad f8 
            00 bd                  mov     rd, 0
 1917 a2ae: 47          cwordslp:  lda     r7                  ; get byte
 1918 a2af: c2 a2 dd               lbz     cwordsdn            ; jump if done
 1919 a2b2: ab                     plo     rb                  ; save it
 1920 a2b3: fa 80                  ani     128                 ; check for final of token
 1921 a2b5: ca a2 bf               lbnz    cwordsf             ; jump if so
 1922 a2b8: 8b                     glo     rb                  ; get byte
 1923 a2b9: d4                     sep     scall               ; display it
 1924 a2ba: 9c 2a                  dw      disp 
 1925 a2bc: c0 a2 ae               lbr     cwordslp            ; and loop back
 1926 a2bf: 8b          cwordsf:   glo     rb                  ; get byte
 1927 a2c0: fa 7f                  ani     07fh                ; strip high bit
 1928 a2c2: d4                     sep     scall               ; display it
 1929 a2c3: 9c 2a                  dw      disp
 1930 a2c5: f8 20                  ldi     ' '                 ; display a space
 1931 a2c7: d4                     sep     scall               ; display it
 1932 a2c8: 9c 2a                  dw      disp
 1933 a2ca: 1d                     inc     rd
 1934 a2cb: 8d                     glo     rd
 1935 a2cc: ff 0c                  smi     12
 1936 a2ce: ca a2 ae               lbnz    cwordslp
 1937 a2d1: f8 00 ad f8 
            00 bd                  mov     rd, 0
 1938 a2d7: d4          	   sep scall
 1939 a2d8: 9c 17       	   dw crlfout
 1940 a2da: c0 a2 ae               lbr     cwordslp            ; and loop back
 1941 a2dd: d4          cwordsdn:  sep scall
 1942 a2de: 9c 17       	   dw  crlfout
 1943 a2e0: f8 03                  ldi     high storage        ; get beginning of program memory
 1944 a2e2: b7                     phi     r7
 1945 a2e3: f8 0d                  ldi     low storage
 1946 a2e5: a7                     plo     r7
 1947 a2e6: f8 00 ad f8 
            00 bd                  mov     rd, 0
 1948 a2ec: 47          cwordslp2: lda     r7                  ; get pointer to next entry
 1949 a2ed: b8                     phi     r8                  ; put into r8
 1950 a2ee: 47                     lda     r7                  ; now pointing at type indicator
 1951 a2ef: a8                     plo     r8                  ; save low of link
 1952 a2f0: ca a2 fd               lbnz    cwordsnot           ; jump if not link terminator
 1953 a2f3: 98                     ghi     r8                  ; check high byte too
 1954 a2f4: ca a2 fd               lbnz    cwordsnot
 1955 a2f7: d4          cwordsdn1: sep  scall
 1956 a2f8: 9c 17       	   dw   crlfout 
 1957 a2fa: c0 a0 17               lbr     good                ; return to caller
 1958 a2fd: 17          cwordsnot: inc     r7                  ; now pointing at ascii indicator
 1959 a2fe: 17                     inc     r7                  ; first character of name
 1960 a2ff: 47          wordsnotl: lda     r7                  ; get byte from string
 1961 a300: c2 a3 09               lbz     wordsnxt            ; jump if end of string
 1962 a303: d4                     sep     scall               ; display it
 1963 a304: 9c 2a                  dw      disp
 1964 a306: c0 a2 ff               lbr     wordsnotl           ; keep going
 1965 a309: f8 20       wordsnxt:  ldi     ' '                 ; want a space
 1966 a30b: d4                     sep     scall               ; display it
 1967 a30c: 9c 2a                  dw      disp
 1968 a30e: 98                     ghi     r8                  ; transfer next word address to r7
 1969 a30f: b7                     phi     r7
 1970 a310: 88                     glo     r8
 1971 a311: a7                     plo     r7
 1972 a312: 1d                     inc     rd
 1973 a313: 8d                     glo     rd
 1974 a314: ff 08                  smi     8
 1975 a316: ca a2 ec               lbnz    cwordslp2
 1976 a319: f8 00 ad f8 
            00 bd                  mov     rd, 0
 1977 a31f: d4           	   sep     scall
 1978 a320: 9c 17       	   dw crlfout
 1979 a322: c0 a2 ec               lbr     cwordslp2           ; and check next word
 1980 a325:             
 1981 a325:             
 1982 a325: d4          cemit:     sep     scall               ; get top of stack
 1983 a326: 9c 32                  dw      pop
 1984 a328: c3 a0 12               lbdf    error               ; jump if error
 1985 a32b: 8b                     glo     rb                  ; get low of return value
 1986 a32c: d4                     sep     scall               ; and display ti
 1987 a32d: 9c 2a                  dw      disp
 1988 a32f: c0 a0 17               lbr     good                ; return to caller
 1989 a332:             
 1990 a332:             ; [GDJ]
 1991 a332: d4          cemitp:    sep     scall               ; get top of stack
 1992 a333: 9c 32                  dw      pop
 1993 a335: c3 a0 12               lbdf    error               ; jump if error
 1994 a338: 8b                     glo     rb                  ; get low of return value
 1995 a339:             
 1996 a339: ff 20                  smi     32                  ; check for below space
 1997 a33b: cb a3 48               lbnf    notprint            ; jump if not printable
 1998 a33e: 8b                     glo     rb
 1999 a33f: ff 7f                  smi     127                 ; check for above tilde ~
 2000 a341: c3 a3 48               lbdf    notprint            ; jump if not printable
 2001 a344:             
 2002 a344: 8b                     glo     rb
 2003 a345: c0 a3 4a               lbr     emitpout            ; ok printable
 2004 a348:             
 2005 a348: f8 2e       notprint:  ldi     '.'
 2006 a34a:             
 2007 a34a: d4          emitpout:  sep     scall               ; and display ti
 2008 a34b: 9c 2a                  dw      disp
 2009 a34d: c0 a0 17               lbr     good                ; return to caller
 2010 a350:             
 2011 a350:             
 2012 a350: d4          cwhile:    sep     scall               ; get top of stack
 2013 a351: 9c 32                  dw      pop
 2014 a353: c3 a0 12               lbdf    error               ; jump if error
 2015 a356: 8b                     glo     rb                  ; need to check for zero
 2016 a357: ca a3 8c               lbnz    whileno             ; jump if not zero
 2017 a35a: 9b                     ghi     rb                  ; check high byte
 2018 a35b: ca a3 8c               lbnz    whileno
 2019 a35e: 92                     ghi     r2                  ; copy machine stack to RA
 2020 a35f: ba                     phi     ra
 2021 a360: 82                     glo     r2
 2022 a361: aa                     plo     ra
 2023 a362: 1a                     inc     ra                  ; point to R[6]
 2024 a363: 4a                     lda     ra                  ; get command stream
 2025 a364: bb                     phi     rb                  ; put into r6
 2026 a365: 0a                     ldn     ra
 2027 a366: ab                     plo     rb
 2028 a367: f8 00                  ldi     0                   ; set while count to zero
 2029 a369: a7                     plo     r7
 2030 a36a: 0b          findrep:   ldn     rb                  ; get byte from stream
 2031 a36b: ff 81                  smi     81h                 ; was a while found
 2032 a36d: ca a3 75               lbnz    notwhile            ; jump if not
 2033 a370: 17                     inc     r7                  ; increment while count
 2034 a371: 1b          notrep:    inc     rb                  ; point to next byte
 2035 a372: c0 a3 6a               lbr     findrep             ; and keep looking
 2036 a375: 0b          notwhile:  ldn     rb                  ; retrieve byte
 2037 a376: ff 82                  smi     82h                 ; is it a repeat
 2038 a378: ca a3 71               lbnz    notrep              ; jump if not
 2039 a37b: 87                     glo     r7                  ; get while count
 2040 a37c: c2 a3 83               lbz     fndrep              ; jump if not zero
 2041 a37f: 27                     dec     r7                  ; decrement count
 2042 a380: c0 a3 71               lbr     notrep              ; and keep looking
 2043 a383: 1b          fndrep:    inc     rb                  ; move past the while
 2044 a384: 8b                     glo     rb                  ; now put back into R[6]
 2045 a385: 5a                     str     ra
 2046 a386: 2a                     dec     ra
 2047 a387: 9b                     ghi     rb
 2048 a388: 5a                     str     ra
 2049 a389: c0 a0 17               lbr     good                ; then return to caller
 2050 a38c: 92          whileno:   ghi     r2                  ; copy machine stack to RA
 2051 a38d: ba                     phi     ra
 2052 a38e: 82                     glo     r2
 2053 a38f: aa                     plo     ra
 2054 a390: 1a                     inc     ra                  ; now pointing to high byte of R[6]
 2055 a391: 4a                     lda     ra                  ; get it
 2056 a392: bb                     phi     rb                  ; and put into r6
 2057 a393: 0a                     ldn     ra                  ; get low byte
 2058 a394: ab                     plo     rb
 2059 a395: 2b                     dec     rb                  ; point back to while command
 2060 a396: d4                     sep     scall               ; put onto return stack
 2061 a397: 9c 8f                  dw      rpush
 2062 a399: c0 a0 17               lbr     good                ; then return
 2063 a39c:             
 2064 a39c: d4          crepeat:   sep     scall               ; get address on return stack
 2065 a39d: 9c 77                  dw      rpop
 2066 a39f: 92                     ghi     r2                  ; transfer machine stack to RA
 2067 a3a0: ba                     phi     ra
 2068 a3a1: 82                     glo     r2
 2069 a3a2: aa                     plo     ra
 2070 a3a3: 1a                     inc     ra                  ; now pointing at high byte of R[6]
 2071 a3a4: 9b                     ghi     rb                  ; get while address
 2072 a3a5: 5a                     str     ra                  ; and place into R[6]
 2073 a3a6: 1a                     inc     ra
 2074 a3a7: 8b                     glo     rb
 2075 a3a8: 5a                     str     ra
 2076 a3a9: c0 a0 17               lbr     good                ; then return
 2077 a3ac:                        
 2078 a3ac: d4          cif:       sep     scall               ; get top of stack 
 2079 a3ad: 9c 32                  dw      pop
 2080 a3af: c3 a0 12               lbdf    error               ; jump if error
 2081 a3b2: 8b                     glo     rb                  ; check for zero
 2082 a3b3: ca a3 f2               lbnz    ifno                ; jump if not zero
 2083 a3b6: 9b                     ghi     rb                  ; check hi byte too
 2084 a3b7: ca a3 f2               lbnz    ifno                ; jump if not zero
 2085 a3ba: 92                     ghi     r2                  ; transfer machine stack to RA
 2086 a3bb: ba                     phi     ra
 2087 a3bc: 82                     glo     r2
 2088 a3bd: aa                     plo     ra
 2089 a3be: 1a                     inc     ra                  ; now pointing at R[6]
 2090 a3bf: 4a                     lda     ra                  ; get R[6]
 2091 a3c0: bb                     phi     rb
 2092 a3c1: 0a                     ldn     ra
 2093 a3c2: ab                     plo     rb
 2094 a3c3: f8 00                  ldi     0                   ; set IF count
 2095 a3c5: a7                     plo     r7                  ; put into counter
 2096 a3c6: 0b          iflp1:     ldn     rb                  ; get next byte
 2097 a3c7: ff 83                  smi     83h                 ; check for IF
 2098 a3c9: ca a3 d1               lbnz    ifnotif             ; jump if not
 2099 a3cc: 17                     inc     r7                  ; increment if count
 2100 a3cd: 1b          ifcnt:     inc     rb                  ; point to next byte
 2101 a3ce: c0 a3 c6               lbr     iflp1               ; keep looking
 2102 a3d1: 0b          ifnotif:   ldn     rb                  ; retrieve byte
 2103 a3d2: ff 84                  smi     84h                 ; check for ELSE
 2104 a3d4: ca a3 e4               lbnz    ifnotelse           ; jump if not
 2105 a3d7: 87                     glo     r7                  ; get IF count
 2106 a3d8: ca a3 cd               lbnz    ifcnt               ; jump if it is not zero
 2107 a3db: 1b                     inc     rb                  ; move past the else
 2108 a3dc: 8b          ifsave:    glo     rb                  ; store back into instruction pointer
 2109 a3dd: 5a                     str     ra
 2110 a3de: 2a                     dec     ra
 2111 a3df: 9b                     ghi     rb
 2112 a3e0: 5a                     str     ra
 2113 a3e1: c0 a0 17               lbr     good                ; and return
 2114 a3e4: 0b          ifnotelse: ldn     rb                  ; retrieve byte
 2115 a3e5: ff 85                  smi     85h                 ; check for THEN
 2116 a3e7: ca a3 cd               lbnz    ifcnt               ; jump if not
 2117 a3ea: 87                     glo     r7                  ; get if count
 2118 a3eb: 27                     dec     r7                  ; decrement if count
 2119 a3ec: ca a3 cd               lbnz    ifcnt               ; jump if not zero
 2120 a3ef: c0 a3 dc               lbr     ifsave              ; otherwise found
 2121 a3f2: c0 a0 17    ifno:      lbr     good                ; no action needed, just return
 2122 a3f5:             
 2123 a3f5: 92          celse:     ghi     r2                  ; transfer machine stack to ra
 2124 a3f6: ba                     phi     ra
 2125 a3f7: 82                     glo     r2
 2126 a3f8: aa                     plo     ra
 2127 a3f9: 1a                     inc     ra                  ; now pointing at R[6]
 2128 a3fa: 4a                     lda     ra                  ; get current R[6]
 2129 a3fb: bb                     phi     rb                  ; and place into r6
 2130 a3fc: 0a                     ldn     ra
 2131 a3fd: ab                     plo     rb
 2132 a3fe: f8 00                  ldi     0                   ; count of IFs
 2133 a400: a7                     plo     r7                  ; put into R7
 2134 a401: 0b          elselp1:   ldn     rb                  ; get next byte from stream
 2135 a402: ff 83                  smi     83h                 ; check for IF
 2136 a404: ca a4 0c               lbnz    elsenif             ; jump if not if
 2137 a407: 17                     inc     r7                  ; increment IF count
 2138 a408: 1b          elsecnt:   inc     rb                  ; point to next byte
 2139 a409: c0 a4 01               lbr     elselp1             ; keep looking
 2140 a40c: 0b          elsenif:   ldn     rb                  ; retrieve byte
 2141 a40d: ff 85                  smi     85h                 ; is it THEN
 2142 a40f: ca a4 08               lbnz    elsecnt             ; jump if not
 2143 a412: 87                     glo     r7                  ; get IF count
 2144 a413: 27                     dec     r7                  ; minus 1 IF
 2145 a414: ca a4 08               lbnz    elsecnt             ; jump if not 0
 2146 a417: 8b                     glo     rb                  ; put into instruction pointer
 2147 a418: 5a                     str     ra
 2148 a419: 2a                     dec     ra
 2149 a41a: 9b                     ghi     rb
 2150 a41b: 5a                     str     ra
 2151 a41c: c0 a0 17               lbr     good                ; now pointing at a then
 2152 a41f:             
 2153 a41f: c0 a0 17    cthen:     lbr     good                ; then is nothing but a place holder
 2154 a422:             
 2155 a422: d4          cequal:    sep     scall               ; get value from stack
 2156 a423: 9c 32                  dw      pop
 2157 a425: c3 a0 12               lbdf    error               ; jump if stack was empty
 2158 a428: 9b                     ghi     rb                  ; move number 
 2159 a429: b7                     phi     r7
 2160 a42a: 8b                     glo     rb
 2161 a42b: a7                     plo     r7
 2162 a42c: d4                     sep     scall               ; get next number
 2163 a42d: 9c 32                  dw      pop
 2164 a42f: c3 a0 12               lbdf    error               ; jump if stack was empty
 2165 a432: e2                     sex     r2                  ; be sure X points to stack
 2166 a433: 87                     glo     r7                  ; perform and
 2167 a434: 52                     str     r2
 2168 a435: 8b                     glo     rb
 2169 a436: f3                     xor
 2170 a437: ca a4 47               lbnz    unequal2            ; jump if not equal
 2171 a43a: 97                     ghi     r7
 2172 a43b: 52                     str     r2
 2173 a43c: 9b                     ghi     rb
 2174 a43d: f3                     xor
 2175 a43e: ca a4 47               lbnz    unequal2            ; jump if not equal
 2176 a441: bb                     phi     rb                  ; set return result
 2177 a442: ab                     plo     rb
 2178 a443: 1b                     inc     rb
 2179 a444: c0 a0 25               lbr goodpush
 2180 a447: f8 00       unequal2:  ldi     0                   ; set return result
 2181 a449: bb                     phi     rb
 2182 a44a: ab                     plo     rb
 2183 a44b: c0 a0 25               lbr     goodpush
 2184 a44e:             
 2185 a44e:             
 2186 a44e: e2          cdepth:    sex     r2                  ; be sure x is pointing to stack
 2187 a44f: f8 08                  ldi     low fstack          ; point to free memory pointer
 2188 a451: a9                     plo     r9                  ; place into data frame
 2189 a452: 49                     lda     r9                  ; get high byte of free memory pointer
 2190 a453: 73                     stxd                        ; store on stack
 2191 a454: 49                     lda     r9                  ; get low byte
 2192 a455: 52                     str     r2                  ; store on stack
 2193 a456: f8 04                  ldi     low tos             ; get pointer to stack
 2194 a458: a9                     plo     r9                  ; set into data frame
 2195 a459: 19                     inc     r9                  ; point to lo byte
 2196 a45a: 09                     ldn     r9                  ; get it
 2197 a45b: f7                     sm                          ; perform subtract
 2198 a45c: ab                     plo     rb                  ; put into result
 2199 a45d: 29                     dec     r9                  ; high byte of stack pointer
 2200 a45e: 60                     irx                         ; point to high byte os free mem
 2201 a45f: 09                     ldn     r9                  ; get high byte of stack
 2202 a460: 77                     smb                         ; continue subtraction
 2203 a461: f6                     shr                         ; divide by 2
 2204 a462: bb                     phi     rb                  ; store answer
 2205 a463: 8b                     glo     rb                  ; propagate the shift
 2206 a464: 76                     shrc
 2207 a465: ab                     plo     rb
 2208 a466: c0 a0 25    	   lbr goodpush
 2209 a469:             
 2210 a469:              
 2211 a469: d4          crot:      sep     scall               ; get C
 2212 a46a: 9c 32                  dw      pop
 2213 a46c: c3 a0 12               lbdf    error               ; jump if error
 2214 a46f: 9b                     ghi     rb                  ; transfer to R7
 2215 a470: b7                     phi     r7
 2216 a471: 8b                     glo     rb
 2217 a472: a7                     plo     r7
 2218 a473: d4                     sep     scall               ; get B
 2219 a474: 9c 32                  dw      pop
 2220 a476: c3 a0 12               lbdf    error               ; jump if error
 2221 a479: 9b                     ghi     rb                  ; transfer to R7
 2222 a47a: b8                     phi     r8
 2223 a47b: 8b                     glo     rb
 2224 a47c: a8                     plo     r8
 2225 a47d: d4                     sep     scall               ; get A
 2226 a47e: 9c 32                  dw      pop
 2227 a480: c3 a0 12               lbdf    error               ; jump if error
 2228 a483: 9b                     ghi     rb                  ; transfer to R7
 2229 a484: bc                     phi     rc
 2230 a485: 8b                     glo     rb
 2231 a486: ac                     plo     rc
 2232 a487: 98                     ghi     r8                  ; get B
 2233 a488: bb                     phi     rb
 2234 a489: 88                     glo     r8
 2235 a48a: ab                     plo     rb
 2236 a48b: d4                     sep     scall               ; put onto stack
 2237 a48c: 9c 61                  dw      push
 2238 a48e: 97                     ghi     r7                  ; get C
 2239 a48f: bb                     phi     rb
 2240 a490: 87                     glo     r7
 2241 a491: ab                     plo     rb
 2242 a492: d4                     sep     scall               ; put onto stack
 2243 a493: 9c 61                  dw      push
 2244 a495: 9c                     ghi     rc                  ; get A
 2245 a496: bb                     phi     rb
 2246 a497: 8c                     glo     rc
 2247 a498: ab                     plo     rb
 2248 a499: c0 a0 25    	   lbr goodpush
 2249 a49c:             
 2250 a49c:              
 2251 a49c: d4          cmrot:     sep     scall               ; get C
 2252 a49d: 9c 32                  dw      pop
 2253 a49f: c3 a0 12               lbdf    error               ; jump if error
 2254 a4a2: 9b                     ghi     rb                  ; transfer to R7
 2255 a4a3: b7                     phi     r7
 2256 a4a4: 8b                     glo     rb
 2257 a4a5: a7                     plo     r7
 2258 a4a6: d4                     sep     scall               ; get B
 2259 a4a7: 9c 32                  dw      pop
 2260 a4a9: c3 a0 12               lbdf    error               ; jump if error
 2261 a4ac: 9b                     ghi     rb                  ; transfer to R7
 2262 a4ad: b8                     phi     r8
 2263 a4ae: 8b                     glo     rb
 2264 a4af: a8                     plo     r8
 2265 a4b0: d4                     sep     scall               ; get A
 2266 a4b1: 9c 32                  dw      pop
 2267 a4b3: c3 a0 12               lbdf    error               ; jump if error
 2268 a4b6: 9b                     ghi     rb                  ; transfer to R7
 2269 a4b7: bc                     phi     rc
 2270 a4b8: 8b                     glo     rb
 2271 a4b9: ac                     plo     rc
 2272 a4ba: 97                     ghi     r7                  ; get C
 2273 a4bb: bb                     phi     rb
 2274 a4bc: 87                     glo     r7
 2275 a4bd: ab                     plo     rb
 2276 a4be: d4                     sep     scall               ; put onto stack
 2277 a4bf: 9c 61                  dw      push
 2278 a4c1: 9c                     ghi     rc                  ; get A
 2279 a4c2: bb                     phi     rb
 2280 a4c3: 8c                     glo     rc
 2281 a4c4: ab                     plo     rb
 2282 a4c5: d4                     sep     scall               ; put onto stack
 2283 a4c6: 9c 61                  dw      push
 2284 a4c8: 98                     ghi     r8                  ; get B
 2285 a4c9: bb                     phi     rb
 2286 a4ca: 88                     glo     r8
 2287 a4cb: ab                     plo     rb
 2288 a4cc: c0 a0 25    	   lbr goodpush
 2289 a4cf:             
 2290 a4cf:              
 2291 a4cf: d4          cover:     sep     scall               ; get B
 2292 a4d0: 9c 32                  dw      pop
 2293 a4d2: c3 a0 12               lbdf    error               ; jump if error
 2294 a4d5: 9b                     ghi     rb                  ; transfer to R7
 2295 a4d6: b7                     phi     r7
 2296 a4d7: 8b                     glo     rb
 2297 a4d8: a7                     plo     r7
 2298 a4d9: d4                     sep     scall               ; get A
 2299 a4da: 9c 32                  dw      pop
 2300 a4dc: c3 a0 12               lbdf    error               ; jump if error
 2301 a4df: 9b                     ghi     rb                  ; transfer to R*
 2302 a4e0: b8                     phi     r8
 2303 a4e1: 8b                     glo     rb
 2304 a4e2: a8                     plo     r8
 2305 a4e3: d4                     sep     scall               ; put onto stack
 2306 a4e4: 9c 61                  dw      push
 2307 a4e6: 97                     ghi     r7                  ; get B
 2308 a4e7: bb                     phi     rb
 2309 a4e8: 87                     glo     r7
 2310 a4e9: ab                     plo     rb
 2311 a4ea: d4                     sep     scall               ; put onto stack
 2312 a4eb: 9c 61                  dw      push
 2313 a4ed: 98                     ghi     r8                  ; get A
 2314 a4ee: bb                     phi     rb
 2315 a4ef: 88                     glo     r8
 2316 a4f0: ab                     plo     rb
 2317 a4f1: c0 a0 25    	  lbr goodpush
 2318 a4f4:             
 2319 a4f4:                        
 2320 a4f4: d4          cat:       sep     scall               ; get address from stack
 2321 a4f5: 9c 32                  dw      pop
 2322 a4f7: c3 a0 12               lbdf    error               ; jump on error
 2323 a4fa: 9b                     ghi     rb                  ; transfer address
 2324 a4fb: b7                     phi     r7
 2325 a4fc: 8b                     glo     rb
 2326 a4fd: a7                     plo     r7
 2327 a4fe: 47                     lda     r7                  ; get word at address
 2328 a4ff: bb                     phi     rb
 2329 a500: 07                     ldn     r7
 2330 a501: ab                     plo     rb
 2331 a502: c0 a0 25    	   lbr goodpush
 2332 a505:             
 2333 a505:                        
 2334 a505: d4          cexcl:     sep     scall               ; get address from stack
 2335 a506: 9c 32                  dw      pop
 2336 a508: c3 a0 12               lbdf    error               ; jump on error
 2337 a50b: 9b                     ghi     rb                  ; transfer address
 2338 a50c: b7                     phi     r7
 2339 a50d: 8b                     glo     rb
 2340 a50e: a7                     plo     r7
 2341 a50f: d4                     sep     scall               ; date data word from stack
 2342 a510: 9c 32                  dw      pop
 2343 a512: c3 a0 12               lbdf    error               ; jump on error
 2344 a515: 9b                     ghi     rb                  ; write word to memory
 2345 a516: 57                     str     r7
 2346 a517: 17                     inc     r7
 2347 a518: 8b                     glo     rb
 2348 a519: 57                     str     r7
 2349 a51a: c0 a0 17               lbr     good                ; and return
 2350 a51d:                        
 2351 a51d: d4          ccat:      sep     scall               ; get address from stack
 2352 a51e: 9c 32                  dw      pop
 2353 a520: c3 a0 12               lbdf    error               ; jump on error
 2354 a523: 9b                     ghi     rb                  ; transfer address
 2355 a524: b7                     phi     r7
 2356 a525: 8b                     glo     rb
 2357 a526: a7                     plo     r7
 2358 a527: 47                     lda     r7                  ; get word at address
 2359 a528: ab                     plo     rb
 2360 a529: f8 00                  ldi     0                   ; high byte is zero
 2361 a52b: bb                     phi     rb
 2362 a52c: c0 a0 25    	   lbr goodpush
 2363 a52f:             
 2364 a52f:                        
 2365 a52f: d4          ccexcl:    sep     scall               ; get address from stack
 2366 a530: 9c 32                  dw      pop
 2367 a532: c3 a0 12               lbdf    error               ; jump on error
 2368 a535: 9b                     ghi     rb                  ; transfer address
 2369 a536: b7                     phi     r7
 2370 a537: 8b                     glo     rb
 2371 a538: a7                     plo     r7
 2372 a539: d4                     sep     scall               ; date data word from stack
 2373 a53a: 9c 32                  dw      pop
 2374 a53c: c3 a0 12               lbdf    error               ; jump on error
 2375 a53f: 8b                     glo     rb                  ; write byte to memory
 2376 a540: 57                     str     r7
 2377 a541: c0 a0 17               lbr     good                ; and return
 2378 a544:             
 2379 a544: 92          cvariable: ghi     r2                  ; transfer machine stack
 2380 a545: ba                     phi     ra
 2381 a546: 82                     glo     r2
 2382 a547: aa                     plo     ra
 2383 a548: 1a                     inc     ra                  ; point to R[6]
 2384 a549: 4a                     lda     ra                  ; and retrieve it
 2385 a54a: bb                     phi     rb
 2386 a54b: 0a                     ldn     ra
 2387 a54c: ab                     plo     rb
 2388 a54d: 0b                     ldn     rb                  ; get next byte
 2389 a54e: ff fe                  smi     T_ASCII             ; it must be an ascii mark
 2390 a550: ca a0 12               lbnz    error               ; jump if not
 2391 a553: 1b                     inc     rb                  ; move into string
 2392 a554: 4b          varlp1:    lda     rb                  ; get byte
 2393 a555: ca a5 54               lbnz    varlp1              ; jump if terminator not found
 2394 a558: 1b                     inc     rb                  ; allow space for var value
 2395 a559: 1b                     inc     rb                  ; new value of freemem
 2396 a55a: f8 06                  ldi     low freemem         ; get current free memory pointer
 2397 a55c: a9                     plo     r9                  ; put into data segment
 2398 a55d: 49                     lda     r9                  ; get current pointer
 2399 a55e: b7                     phi     r7                  ; place here
 2400 a55f: 09                     ldn     r9                  ; get low byte
 2401 a560: a7                     plo     r7
 2402 a561: 9b                     ghi     rb                  ; get memory pointer
 2403 a562: 57                     str     r7                  ; and store into link list
 2404 a563: 17                     inc     r7
 2405 a564: 8b                     glo     rb
 2406 a565: 57                     str     r7
 2407 a566: 8b                     glo     rb                  ; store new freemem value
 2408 a567: 59                     str     r9
 2409 a568: 29                     dec     r9
 2410 a569: 9b                     ghi     rb
 2411 a56a: 59                     str     r9
 2412 a56b: f8 00                  ldi     0                   ; need zero at end of list
 2413 a56d: 5b                     str     rb                  ; store it
 2414 a56e: 1b                     inc     rb
 2415 a56f: 5b                     str     rb
 2416 a570: 8b                     glo     rb                  ; write back to instruction pointer
 2417 a571: 5a                     str     ra
 2418 a572: 2a                     dec     ra
 2419 a573: 9b                     ghi     rb
 2420 a574: 5a                     str     ra
 2421 a575: c0 a0 17               lbr     good                ; return
 2422 a578:             
 2423 a578: 92          ccolon:    ghi     r2                  ; transfer machine stack
 2424 a579: ba                     phi     ra
 2425 a57a: 82                     glo     r2
 2426 a57b: aa                     plo     ra
 2427 a57c: 1a                     inc     ra                  ; point to R[6]
 2428 a57d: 4a                     lda     ra                  ; and retrieve it
 2429 a57e: bb                     phi     rb
 2430 a57f: 0a                     ldn     ra
 2431 a580: ab                     plo     rb
 2432 a581: 0b                     ldn     rb                  ; get next byte
 2433 a582: ff fe                  smi     T_ASCII             ; it must be an ascii mark
 2434 a584: ca a0 12               lbnz    error               ; jump if not
 2435 a587: 1b                     inc     rb                  ; move into string
 2436 a588: 4b          colonlp1:  lda     rb                  ; get byte
 2437 a589: ff 88                  smi     88h                 ; look for the ;
 2438 a58b: ca a5 88               lbnz    colonlp1            ; jump if terminator not found
 2439 a58e: f8 00                  ldi     0                   ; want a command terminator
 2440 a590: 5b                     str     rb                  ; write it
 2441 a591: 1b                     inc     rb                  ; new value for freemem
 2442 a592: f8 06                  ldi     low freemem         ; get current free memory pointer
 2443 a594: a9                     plo     r9                  ; put into data segment
 2444 a595: 49                     lda     r9                  ; get current pointer
 2445 a596: b7                     phi     r7                  ; place here
 2446 a597: 09                     ldn     r9                  ; get low byte
 2447 a598: a7                     plo     r7
 2448 a599: 9b                     ghi     rb                  ; get memory pointer
 2449 a59a: 57                     str     r7                  ; and store into link list
 2450 a59b: 17                     inc     r7
 2451 a59c: 8b                     glo     rb
 2452 a59d: 57                     str     r7
 2453 a59e: 8b                     glo     rb                  ; store new freemem value
 2454 a59f: 59                     str     r9
 2455 a5a0: 29                     dec     r9
 2456 a5a1: 9b                     ghi     rb
 2457 a5a2: 59                     str     r9
 2458 a5a3: f8 00                  ldi     0                   ; need zero at end of list
 2459 a5a5: 5b                     str     rb                  ; store it
 2460 a5a6: 1b                     inc     rb
 2461 a5a7: 5b                     str     rb
 2462 a5a8: 8b                     glo     rb                  ; write back to instruction pointer
 2463 a5a9: 5a                     str     ra
 2464 a5aa: 2a                     dec     ra
 2465 a5ab: 9b                     ghi     rb
 2466 a5ac: 5a                     str     ra
 2467 a5ad: c0 a0 17               lbr     good                ; return
 2468 a5b0:             
 2469 a5b0: c0 a0 17    csemi:     lbr     good
 2470 a5b3:             
 2471 a5b3:             
 2472 a5b3: 92          csee:      ghi     r2                  ; transfer machine stack
 2473 a5b4: ba                     phi     ra
 2474 a5b5: 82                     glo     r2
 2475 a5b6: aa                     plo     ra
 2476 a5b7: 1a                     inc     ra                  ; point to R[6]
 2477 a5b8: 4a                     lda     ra                  ; and retrieve it
 2478 a5b9: b8                     phi     r8
 2479 a5ba: 0a                     ldn     ra
 2480 a5bb: a8                     plo     r8
 2481 a5bc: 08                     ldn     r8                  ; get next byte
 2482 a5bd: ff fe                  smi     T_ASCII             ; it must be an ascii mark
 2483 a5bf: ca a0 12               lbnz    error               ; jump if not
 2484 a5c2: 18                     inc     r8                  ; move into string
 2485 a5c3: d4                     sep     scall               ; find the name
 2486 a5c4: 9c a5                  dw      findname
 2487 a5c6: c3 a0 12               lbdf    error               ; jump if not found
 2488 a5c9: 88                     glo     r8                  ; put new address into inst pointer
 2489 a5ca: 5a                     str     ra 
 2490 a5cb: 2a                     dec     ra
 2491 a5cc: 98                     ghi     r8
 2492 a5cd: 5a                     str     ra
 2493 a5ce: d4          	   sep     scall
 2494 a5cf: a5 de       	   dw      csee_sub
 2495 a5d1: c0 a0 17    	   lbr     good                ; otherwise good	
 2496 a5d4:             	
 2497 a5d4:             	;;  make see callable so we can use it from inside Forth words
 2498 a5d4:             	;;  r7= address of descriptor  (main pointer to word; points to next address)
 2499 a5d4:             	;;  rb = first byte in data
 2500 a5d4:             	;;  user callable csee_sub0 only requires r7. If r7 and rb are set call csee_sub
 2501 a5d4:             csee_sub0:
 2502 a5d4: 97          	ghi r7
 2503 a5d5: bb          	phi rb
 2504 a5d6: 87          	glo r7
 2505 a5d7: ab          	plo rb
 2506 a5d8: 1b          	inc rb
 2507 a5d9: 1b          	inc rb
 2508 a5da: 0b          csub0:	ldn rb    		; set up rb to point correctly
 2509 a5db: 1b          	inc rb
 2510 a5dc: 3a da       	bnz csub0
 2511 a5de:             csee_sub:
 2512 a5de: 47          	lda r7          ; move past next address  (store next in in RF for later)
 2513 a5df: bf          	phi rf
 2514 a5e0: 47          	lda r7
 2515 a5e1: af          	plo rf
 2516 a5e2: 07                     ldn     r7                  ; get type byte
 2517 a5e3: ff 86                  smi     86h                 ; check for variable
 2518 a5e5: ca a6 b3               lbnz    cseefunc            ; jump if not
 2519 a5e8: d4          	   sep scall
 2520 a5e9: ff 66       	   dw f_inmsg
 2521 a5eb: 56 41 52 49 
            41 42 4c 45 
            20 00       	   db 'VARIABLE ',0
 2522 a5f5: 17          	   inc r7		       ; skip variable mark
 2523 a5f6: 87 73 97 73 	   push r7
 2524 a5fa:             seevname:
 2525 a5fa: 17          	inc	   r7		       ; point to name
 2526 a5fb: 07          	ldn	   r7
 2527 a5fc: c2 a6 05    	lbz seeveq
 2528 a5ff: d4          	sep scall
 2529 a600: 9c 2a       	dw disp
 2530 a602: c0 a5 fa    	lbr seevname
 2531 a605:             seeveq:
 2532 a605: d4          	sep scall
 2533 a606: 9c 17       	dw crlfout
 2534 a608:             	;;  need to see if we need an allot here 
 2535 a608:             	;; if [next]-2 == rb then we do not need it
 2536 a608: 2f          	dec rf
 2537 a609: 2f          	dec rf 			; next-2
 2538 a60a: 8f          	glo rf
 2539 a60b: 52          	str r2
 2540 a60c: 8b          	glo rb   ; (next-2)-dataaddress
 2541 a60d: f5          	sd
 2542 a60e: af          	plo rf
 2543 a60f: 9f          	ghi rf
 2544 a610: 52          	str r2
 2545 a611: 9b          	ghi rb
 2546 a612: 75          	sdb
 2547 a613: bf          	phi rf   		; now RF is the offset
 2548 a614: 52          	str r2
 2549 a615: 8f          	glo rf
 2550 a616: f1          	or
 2551 a617: 32 92       	bz seevnoa            	; was equal, jump
 2552 a619:             seevallot:	
 2553 a619:             	;; ok we need to do the allot here
 2554 a619: 8b 73 9b 73 	push rb
 2555 a61d: 9f          	ghi rf
 2556 a61e: f6          	shr
 2557 a61f: bb          	phi rb
 2558 a620: 8f          	glo rf
 2559 a621: 76          	shrc 
 2560 a622: ab          	plo rb
 2561 a623: d4          	sep scall
 2562 a624: ab 9d       	dw typenumind    	; type count
 2563 a626:             
 2564 a626: d4          	sep scall
 2565 a627: ff 66       	dw f_inmsg
 2566 a629: 41 4c 4c 4f 
            54 0a 0d 00 	db 'ALLOT',10,13,0
 2567 a631:             	;;   dump all words (rf has byte count which needs +2 for the original word)
 2568 a631: 1f          	inc rf
 2569 a632: 1f          	inc rf
 2570 a633: 60 72 bb f0 
            ab          	pop rb 			; start address
 2571 a638: f8 00       	ldi 0
 2572 a63a: bc          	phi rc
 2573 a63b: ac          	plo rc
 2574 a63c:             seesto:	
 2575 a63c: 8b 73 9b 73 	push rb  		; save for addr disp	
 2576 a640: 4b          	lda rb
 2577 a641: b7          	phi r7
 2578 a642: 4b          	lda rb
 2579 a643: ab          	plo rb
 2580 a644: 97          	ghi r7
 2581 a645: bb          	phi rb
 2582 a646: d4          	sep scall
 2583 a647: ab 9d       	dw typenumind   	; print data
 2584 a649:             	
 2585 a649: 60 72 bb f0 
            ab          	pop rb
 2586 a64e: 60 72 b7 f0 
            a7          	pop r7
 2587 a653: 87 73 97 73 	push r7
 2588 a657: 8b 73 9b 73 	push rb
 2589 a65b:             seevnamea:
 2590 a65b: 17          	inc	   r7		       ; point to name
 2591 a65c: 07          	ldn	   r7
 2592 a65d: 32 64       	bz seevdata
 2593 a65f: d4          	sep scall
 2594 a660: 9c 2a       	dw disp
 2595 a662: 30 5b       	br seevnamea
 2596 a664:             seevdata:
 2597 a664: f8 20       	ldi ' '
 2598 a666: d4          	sep scall
 2599 a667: 9c 2a       	dw disp
 2600 a669: 8c          	glo rc
 2601 a66a: ab          	plo rb
 2602 a66b: 9c          	ghi rc
 2603 a66c: bb          	phi rb
 2604 a66d: 1c          	inc rc
 2605 a66e: 1c          	inc rc    		; increase count
 2606 a66f: d4          	sep scall
 2607 a670: ab 9d       	dw typenumind
 2608 a672: 60 72 bb f0 
            ab          	pop rb  		; print n  
 2609 a677:             	
 2610 a677:             
 2611 a677: d4          	sep scall		;print !
 2612 a678: ff 66       	dw f_inmsg
 2613 a67a: 2b 20 21 0a 
            0d 00       	db '+ !',10,13,0
 2614 a680: 1b          	inc rb			; point to next word
 2615 a681: 1b          	inc rb
 2616 a682: 2f          	dec rf			; two less bytes
 2617 a683: 2f          	dec rf
 2618 a684:             	;;  stop when rf is zero (assumes rf was even)
 2619 a684: 8f          	glo rf
 2620 a685: ca a6 3c    	lbnz seesto
 2621 a688: 9f          	ghi rf
 2622 a689: ca a6 3c    	lbnz seesto
 2623 a68c: 60 72 b7 f0 
            a7          	pop r7
 2624 a691: d5          	sep sret   		; final CRLF already in place
 2625 a692:             	
 2626 a692:             seevnoa:	
 2627 a692: 4b                     lda     rb                  ; get value
 2628 a693: b7                     phi     r7
 2629 a694: 4b                     lda     rb
 2630 a695: ab                     plo     rb
 2631 a696: 97                     ghi     r7
 2632 a697: bb                     phi     rb
 2633 a698:                        
 2634 a698:                        ;sep     scall               ; display the value
 2635 a698:                        ;dw      intout
 2636 a698:                        ;   [GDJ]
 2637 a698: d4                     sep     scall               ; display the value
 2638 a699: ab 9d                  dw      typenumind
 2639 a69b: 60 72 b7 f0 
            a7          	pop r7
 2640 a6a0:             seevname1:
 2641 a6a0: 17          	inc r7
 2642 a6a1: 07          	ldn r7
 2643 a6a2: 32 a9       	bz seeveq1
 2644 a6a4: d4          	sep scall
 2645 a6a5: 9c 2a       	dw disp
 2646 a6a7: 30 a0       	br seevname1
 2647 a6a9:             seeveq1:
 2648 a6a9: d4          	sep scall
 2649 a6aa: ff 66       	dw f_inmsg
 2650 a6ac: 20 21 00    	db ' !',0
 2651 a6af: d4          seeexit:   sep scall
 2652 a6b0: 9c 17       	   dw crlfout
 2653 a6b2: d5                     sep     sret
 2654 a6b3: f8 3a       cseefunc:  ldi     ':'                 ; start with a colon
 2655 a6b5: d4                     sep     scall               ; display character
 2656 a6b6: 9c 2a                  dw      disp
 2657 a6b8: 17                     inc     r7                  ; move address to name
 2658 a6b9: f8 20       seefunclp: ldi     ' '                 ; need a space
 2659 a6bb: d4                     sep     scall               ; display character
 2660 a6bc: 9c 2a                  dw      disp
 2661 a6be: 07                     ldn     r7                  ; get next token
 2662 a6bf: c2 a6 af               lbz     seeexit             ; jump if done
 2663 a6c2: ff fe                  smi     T_ASCII             ; check for ascii
 2664 a6c4: ca a6 d7               lbnz    seenota             ; jump if not ascii
 2665 a6c7: 17                     inc     r7                  ; move into string
 2666 a6c8: 07          seestrlp:  ldn     r7                  ; get next byte
 2667 a6c9: c2 a6 d3               lbz     seenext             ; jump if done with token
 2668 a6cc: d4                     sep     scall               ; display character
 2669 a6cd: 9c 2a                  dw      disp
 2670 a6cf: 17                     inc     r7                  ; point to next character
 2671 a6d0: c0 a6 c8               lbr     seestrlp            ; and continue til done
 2672 a6d3: 17          seenext:   inc     r7                  ; point to next token
 2673 a6d4: c0 a6 b9               lbr     seefunclp
 2674 a6d7: 07          seenota:   ldn     r7                  ; reget token
 2675 a6d8: ff ff                  smi     T_NUM               ; is it a number
 2676 a6da: ca a6 f1               lbnz    seenotn             ; jump if not a number
 2677 a6dd: 17                     inc     r7                  ; move past token
 2678 a6de: 47                     lda     r7                  ; get number into rb
 2679 a6df: bb                     phi     rb
 2680 a6e0: 07                     ldn     r7
 2681 a6e1: ab                     plo     rb
 2682 a6e2: 87                     glo     r7                  ; save r7
 2683 a6e3: 73                     stxd
 2684 a6e4: 97                     ghi     r7
 2685 a6e5: 73                     stxd
 2686 a6e6:             
 2687 a6e6:                        ;sep     scall               ; display the number
 2688 a6e6:                        ;dw      intout
 2689 a6e6:                        ; [GDJ]
 2690 a6e6: d4                     sep     scall
 2691 a6e7: ab 9d                  dw      typenumind             ; display the number
 2692 a6e9: 60                     irx                         ; retrieve r7
 2693 a6ea: 72                     ldxa
 2694 a6eb: b7                     phi     r7
 2695 a6ec: f0                     ldx
 2696 a6ed: a7                     plo     r7
 2697 a6ee: c0 a6 d3               lbr     seenext             ; on to next token
 2698 a6f1: f8 ac       seenotn:   ldi     high cmdtable       ; point to command table
 2699 a6f3: bb                     phi     rb
 2700 a6f4: f8 f6                  ldi     low cmdtable
 2701 a6f6: ab                     plo     rb
 2702 a6f7: 07                     ldn     r7                  ; get token
 2703 a6f8: fa 7f                  ani     07fh                ; strip high bit
 2704 a6fa: a8                     plo     r8                  ; token counter
 2705 a6fb: 28          seenotnlp: dec     r8                  ; decrement count
 2706 a6fc: 88                     glo     r8                  ; get count
 2707 a6fd: c2 a7 09               lbz     seetoken            ; found the token
 2708 a700: 4b          seelp3:    lda     rb                  ; get byte from token
 2709 a701: fa 80                  ani     128                 ; was it last one?
 2710 a703: ca a6 fb               lbnz    seenotnlp           ; jump if it was
 2711 a706: c0 a7 00               lbr     seelp3              ; keep looking
 2712 a709: 0b          seetoken:  ldn     rb                  ; get byte from token
 2713 a70a: fa 80                  ani     128                 ; is it last
 2714 a70c: ca a7 17               lbnz    seetklast           ; jump if so
 2715 a70f: 0b                     ldn     rb                  ; retrieve byte
 2716 a710: d4                     sep     scall               ; display it
 2717 a711: 9c 2a                  dw      disp
 2718 a713: 1b                     inc     rb                  ; point to next character
 2719 a714: c0 a7 09               lbr     seetoken            ; and loop til done
 2720 a717: 0b          seetklast: ldn     rb                  ; retrieve byte
 2721 a718: fa 7f                  ani     07fh                ; strip high bit
 2722 a71a: d4                     sep     scall               ; display it
 2723 a71b: 9c 2a                  dw      disp
 2724 a71d: c0 a6 d3               lbr     seenext             ; jump for next token
 2725 a720:             
 2726 a720: 92          cdotqt:    ghi     r2                  ; transfer machine stack
 2727 a721: ba                     phi     ra
 2728 a722: 82                     glo     r2
 2729 a723: aa                     plo     ra
 2730 a724: 1a                     inc     ra                  ; point to R[6]
 2731 a725: 4a                     lda     ra                  ; and retrieve it
 2732 a726: b8                     phi     r8
 2733 a727: 0a                     ldn     ra
 2734 a728: a8                     plo     r8
 2735 a729: 08                     ldn     r8                  ; get next byte
 2736 a72a: ff fe                  smi     T_ASCII             ; it must be an ascii mark
 2737 a72c: ca a0 12               lbnz    error               ; jump if not
 2738 a72f: 18                     inc     r8                  ; move past ascii mark
 2739 a730: 48          cdotqtlp:  lda     r8                  ; get next byte
 2740 a731: c2 a7 41               lbz     cdotqtdn            ; jump if terinator
 2741 a734: ff 22                  smi     34                  ; check for quote
 2742 a736: c2 a7 30               lbz     cdotqtlp            ; do not display quotes
 2743 a739: 28                     dec     r8
 2744 a73a: 48                     lda     r8
 2745 a73b: d4                     sep     scall               ; display byte
 2746 a73c: 9c 2a                  dw      disp
 2747 a73e: c0 a7 30               lbr     cdotqtlp            ; loop back
 2748 a741: 88          cdotqtdn:  glo     r8                  ; put pointer back
 2749 a742: 5a                     str     ra
 2750 a743: 2a                     dec     ra
 2751 a744: 98                     ghi     r8
 2752 a745: 5a                     str     ra
 2753 a746: c0 a0 17               lbr     good                ; and return
 2754 a749:             
 2755 a749: d4          ckey:      sep     scall               ; go and get a key
 2756 a74a: 9c 2e                  dw      getkey
 2757 a74c: ab                     plo     rb                  ; put into rb
 2758 a74d: f8 00                  ldi     0                   ; zero the high byte
 2759 a74f: bb                     phi     rb
 2760 a750: c0 a0 25    	   lbr     goodpush
 2761 a753:             
 2762 a753:             	;; [GDJ]				
 2763 a753: f8 00 a7 f8 
            00 b7       ckeyq:     mov     r7, 0
 2764 a759: d4                     sep     scall               ; check for key pressed
 2765 a75a: ac 63                  dw      inkey
 2766 a75c: 87                     glo     r7
 2767 a75d: ab                     plo     rb                  ; put into rb
 2768 a75e: f8 00                  ldi     0                   ; zero the high byte
 2769 a760: bb                     phi     rb
 2770 a761: c0 a0 25    	   lbr	   goodpush
 2771 a764:             
 2772 a764: f8 03       callot:    ldi     high storage        ; get address of storage
 2773 a766: b7                     phi     r7
 2774 a767: f8 0d                  ldi     low storage
 2775 a769: a7                     plo     r7
 2776 a76a: 47          callotlp1: lda     r7                  ; get next link
 2777 a76b: b8                     phi     r8
 2778 a76c: 07                     ldn     r7
 2779 a76d: a8                     plo     r8
 2780 a76e: 48                     lda     r8                  ; get value at that link
 2781 a76f: bb                     phi     rb
 2782 a770: 08                     ldn     r8
 2783 a771: 28                     dec     r8                  ; keep r8 pointing at link
 2784 a772: ca a7 7c               lbnz    callotno            ; jump if next link is not zero
 2785 a775: 9b                     ghi     rb                  ; check high byte
 2786 a776: ca a7 7c               lbnz    callotno            ; jump if not zero
 2787 a779: c0 a7 83               lbr     callotyes
 2788 a77c: 98          callotno:  ghi     r8                  ; transfer link to r7
 2789 a77d: b7                     phi     r7
 2790 a77e: 88                     glo     r8
 2791 a77f: a7                     plo     r7
 2792 a780: c0 a7 6a               lbr     callotlp1           ; and keep looking
 2793 a783: 17          callotyes: inc     r7                  ; point to type byte
 2794 a784: 07                     ldn     r7                  ; get it
 2795 a785: ff 86                  smi     FVARIABLE           ; it must be a variable
 2796 a787: ca a0 12               lbnz    error               ; jump if not
 2797 a78a: d4                     sep     scall               ; get word from stack
 2798 a78b: 9c 32                  dw      pop
 2799 a78d: c3 a0 12               lbdf    error               ; jump if error
 2800 a790: 8b                     glo     rb                  ; multiply by 2
 2801 a791: fe                     shl
 2802 a792: ab                     plo     rb
 2803 a793: 9b                     ghi     rb
 2804 a794: 7e                     shlc
 2805 a795: bb                     phi     rb
 2806 a796: e2                     sex     r2                  ; be sure X points to stack
 2807 a797: 8b                     glo     rb                  ; add rb to r8
 2808 a798: 52                     str     r2
 2809 a799: 88                     glo     r8
 2810 a79a: f4                     add
 2811 a79b: a8                     plo     r8
 2812 a79c: 9b                     ghi     rb
 2813 a79d: 52                     str     r2
 2814 a79e: 98                     ghi     r8
 2815 a79f: 74                     adc
 2816 a7a0: b8                     phi     r8
 2817 a7a1: 27                     dec     r7                  ; point back to link
 2818 a7a2: 88                     glo     r8                  ; and write new pointer
 2819 a7a3: 57                     str     r7
 2820 a7a4: 27                     dec     r7
 2821 a7a5: 98                     ghi     r8
 2822 a7a6: 57                     str     r7
 2823 a7a7: f8 06                  ldi     low freemem         ; need to adjust free memory pointer
 2824 a7a9: a9                     plo     r9                  ; put into data frame
 2825 a7aa: 98                     ghi     r8                  ; and save new memory position
 2826 a7ab: 59                     str     r9
 2827 a7ac: 19                     inc     r9
 2828 a7ad: 88                     glo     r8
 2829 a7ae: 59                     str     r9
 2830 a7af: f8 00                  ldi     0                   ; zero new position
 2831 a7b1: 58                     str     r8
 2832 a7b2: 18                     inc     r8
 2833 a7b3: 58                     str     r8
 2834 a7b4: c0 a0 17               lbr     good
 2835 a7b7:             
 2836 a7b7: d4          cmul:      sep     scall               ; get first value from stack
 2837 a7b8: 9c 32                  dw      pop
 2838 a7ba: c3 a0 12               lbdf    error               ; jump on error
 2839 a7bd: 9b                     ghi     rb                  ; transfer to r7
 2840 a7be: b7                     phi     r7
 2841 a7bf: 8b                     glo     rb
 2842 a7c0: a7                     plo     r7
 2843 a7c1: d4                     sep     scall               ; get second number
 2844 a7c2: 9c 32                  dw      pop
 2845 a7c4: c3 a0 12               lbdf    error               ; jump on error
 2846 a7c7: d4                     sep     scall               ; call multiply routine
 2847 a7c8: 9c e8                  dw      mul16
 2848 a7ca: c0 a0 25    	   lbr goodpush
 2849 a7cd:             
 2850 a7cd:             
 2851 a7cd: d4          cdiv:      sep     scall               ; get first value from stack
 2852 a7ce: 9c 32                  dw      pop
 2853 a7d0: c3 a0 12               lbdf    error               ; jump on error
 2854 a7d3: 9b                     ghi     rb                  ; transfer to r7
 2855 a7d4: b7                     phi     r7
 2856 a7d5: 8b                     glo     rb
 2857 a7d6: a7                     plo     r7
 2858 a7d7: d4                     sep     scall               ; get second number
 2859 a7d8: 9c 32                  dw      pop
 2860 a7da: c3 a0 12               lbdf    error               ; jump on error
 2861 a7dd: e2                     sex     r2
 2862 a7de: 99                     ghi     r9
 2863 a7df: 73                     stxd
 2864 a7e0: d4                     sep     scall               ; call multiply routine
 2865 a7e1: 9d 47                  dw      div16
 2866 a7e3: 60                     irx
 2867 a7e4: f0                     ldx
 2868 a7e5: b9                     phi     r9
 2869 a7e6: 9c                     ghi     rc                  ; transfer answer
 2870 a7e7: bb                     phi     rb
 2871 a7e8: 8c                     glo     rc
 2872 a7e9: ab                     plo     rb
 2873 a7ea: c0 a0 25    	   lbr goodpush
 2874 a7ed:             
 2875 a7ed: 92          cforget:   ghi     r2                  ; transfer machine stack
 2876 a7ee: ba                     phi     ra
 2877 a7ef: 82                     glo     r2
 2878 a7f0: aa                     plo     ra
 2879 a7f1: 1a                     inc     ra                  ; point to ra
 2880 a7f2: 4a                     lda     ra                  ; and retrieve it
 2881 a7f3: b8                     phi     r8
 2882 a7f4: 0a                     ldn     ra
 2883 a7f5: a8                     plo     r8
 2884 a7f6: 08                     ldn     r8                  ; get next byte
 2885 a7f7: ff fe                  smi     T_ASCII             ; it must be an ascii mark
 2886 a7f9: ca a0 12               lbnz    error               ; jump if not
 2887 a7fc: 18                     inc     r8                  ; move into string
 2888 a7fd: d4                     sep     scall               ; find the name
 2889 a7fe: 9c a5                  dw      findname
 2890 a800: c3 a0 12               lbdf    error               ; jump if not found
 2891 a803: 88                     glo     r8
 2892 a804: 5a                     str     ra
 2893 a805: 2a                     dec     ra
 2894 a806: 98                     ghi     r8
 2895 a807: 5a                     str     ra
 2896 a808: 47                     lda     r7                  ; get next entry
 2897 a809: bb                     phi     rb
 2898 a80a: 07                     ldn     r7
 2899 a80b: ab                     plo     rb
 2900 a80c: 27                     dec     r7
 2901 a80d: e2                     sex     r2                  ; be sure X is pointing to stack
 2902 a80e: 87                     glo     r7                  ; find difference in pointers
 2903 a80f: 52                     str     r2
 2904 a810: 8b                     glo     rb
 2905 a811: f7                     sm
 2906 a812: ac                     plo     rc
 2907 a813: 97                     ghi     r7
 2908 a814: 52                     str     r2
 2909 a815: 9b                     ghi     rb
 2910 a816: 77                     smb
 2911 a817: bc                     phi     rc                  ; RC now has offset, RB is next descr.
 2912 a818: 4b          forgetlp1: lda     rb                  ; get pointer
 2913 a819: ba                     phi     ra                  ; put into ra
 2914 a81a: 52                     str     r2
 2915 a81b: 0b                     ldn     rb
 2916 a81c: aa                     plo     ra
 2917 a81d: f1                     or                          ; see if it was zero
 2918 a81e: c2 a8 33               lbz     forgetd1            ; jump if it was
 2919 a821: 8c                     glo     rc                  ; subtract RC from RA
 2920 a822: 52                     str     r2
 2921 a823: 8a                     glo     ra
 2922 a824: f7                     sm
 2923 a825: 5b                     str     rb                  ; store back into pointer
 2924 a826: 2b                     dec     rb
 2925 a827: 9c                     ghi     rc
 2926 a828: 52                     str     r2
 2927 a829: 9a                     ghi     ra
 2928 a82a: 77                     smb
 2929 a82b: 5b                     str     rb
 2930 a82c: 9a                     ghi     ra                  ; transfer value
 2931 a82d: bb                     phi     rb
 2932 a82e: 8a                     glo     ra
 2933 a82f: ab                     plo     rb
 2934 a830: c0 a8 18               lbr     forgetlp1           ; loop until done
 2935 a833:             
 2936 a833: 47          forgetd1:  lda     r7                  ; get next entry
 2937 a834: bb                     phi     rb
 2938 a835: 07                     ldn     r7
 2939 a836: ab                     plo     rb
 2940 a837: 27                     dec     r7
 2941 a838:             
 2942 a838: f8 06                  ldi     low freemem         ; get end of memory pointer
 2943 a83a: a9                     plo     r9                  ; and place into data frame
 2944 a83b: 49                     lda     r9                  ; get free memory position
 2945 a83c: b8                     phi     r8
 2946 a83d: 09                     ldn     r9
 2947 a83e: a8                     plo     r8
 2948 a83f: 18                     inc     r8                  ; account for zero bytes at end
 2949 a840: 18                     inc     r8
 2950 a841: 8b                     glo     rb                  ; subtract RB from R8
 2951 a842: 52                     str     r2
 2952 a843: 88                     glo     r8
 2953 a844: f7                     sm
 2954 a845: a8                     plo     r8
 2955 a846: 9b                     ghi     rb
 2956 a847: 52                     str     r2
 2957 a848: 98                     ghi     r8
 2958 a849: 77                     smb
 2959 a84a: b8                     phi     r8                  ; r8 now has number of bytes to move
 2960 a84b: 4b          forgetlp:  lda     rb                  ; get byte from higher memory
 2961 a84c: 57                     str     r7                  ; write to lower memory
 2962 a84d: 17                     inc     r7                  ; point to next position
 2963 a84e: 28                     dec     r8                  ; decrement the count
 2964 a84f: 88                     glo     r8                  ; check for zero
 2965 a850: ca a8 4b               lbnz    forgetlp
 2966 a853: 98                     ghi     r8
 2967 a854: ca a8 4b               lbnz    forgetlp
 2968 a857: 27                     dec     r7                  ; move back to freemem position
 2969 a858: 27                     dec     r7 
 2970 a859: 87                     glo     r7                  ; store back into freemem pointer
 2971 a85a: 59                     str     r9
 2972 a85b: 29                     dec     r9
 2973 a85c: 97                     ghi     r7
 2974 a85d: 59                     str     r9
 2975 a85e: c0 a0 17               lbr     good                ; and return
 2976 a861:             
 2977 a861: d4          cerror:    sep     scall               ; get number fro stack
 2978 a862: 9c 32                  dw      pop
 2979 a864: c3 a0 12               lbdf    error               ; jump on error
 2980 a867: 8b                     glo     rb                  ; get returned value
 2981 a868: c0 9f ad               lbr     execret             ; return to caller
 2982 a86b:             
 2983 a86b:             ; [GDJ]
 2984 a86b:             ; following org prevents short branch out of page for bn1..bn4
 2985 a86b:             ; if any preceding code is added - may need change depending on
 2986 a86b:             ; amount of any further additions above
 2987 a86b:             ;           org 2e00h 
 2988 a86b:             
 2989 a86b: f8 00       cef:       ldi     0                   ; start with zero
 2990 a86d: 3c 71                  bn1     cef1                ; jump if ef1 not on
 2991 a86f: f9 01                  ori     1                   ; signal ef1 is on
 2992 a871: 3d 75       cef1:      bn2     cef2                ; jump if ef2 ot on
 2993 a873: f9 02                  ori     2                   ; signal ef2 is on
 2994 a875: 3e 79       cef2:      bn3     cef3                ; jump if ef3 not on
 2995 a877: f9 04                  ori     4                   ; signal ef3 is on
 2996 a879: 3f 7d       cef3:      bn4     cef4                ; jump if ef4 not on
 2997 a87b: f9 08                  ori     8
 2998 a87d: ab          cef4:      plo     rb                  ; prepare to put on stack
 2999 a87e: f8 00                  ldi     0
 3000 a880: bb                     phi     rb
 3001 a881: c0 a0 25    	   lbr goodpush
 3002 a884:             	
 3003 a884:             
 3004 a884:             
 3005 a884: d4          cout:      sep     scall               ; get value from stack
 3006 a885: 9c 32                  dw      pop
 3007 a887: c3 a0 12               lbdf    error               ; jump on error
 3008 a88a: 8b                     glo     rb
 3009 a88b: a8                     plo     r8                  ; hold onto it
 3010 a88c: d4                     sep     scall               ; get port value
 3011 a88d: 9c 32                  dw      pop
 3012 a88f: c3 a0 12               lbdf    error               ; jump on error
 3013 a892: 88                     glo     r8                  ; get vlue
 3014 a893: 73                     stxd                        ; store into memory for out
 3015 a894: 60                     irx                         ; point to value
 3016 a895: 8b                     glo     rb                  ; get port
 3017 a896: ff 01                  smi     1                   ; try port 1
 3018 a898: ca a8 a0               lbnz    cout2               ; jump if not
 3019 a89b: 61                     out     1                   ; prform out
 3020 a89c: 22                     dec     r2                  ; move pointer back
 3021 a89d: c0 a0 17               lbr     good                ; and return to caller
 3022 a8a0: ff 01       cout2:     smi     1                   ; try port 1
 3023 a8a2: ca a8 aa               lbnz    cout3               ; jump if not
 3024 a8a5: 62                     out     2                   ; prform out
 3025 a8a6: 22                     dec     r2                  ; move pointer back
 3026 a8a7: c0 a0 17               lbr     good                ; and return to caller
 3027 a8aa: ff 01       cout3:     smi     1                   ; try port 1
 3028 a8ac: ca a8 b4               lbnz    cout4               ; jump if not
 3029 a8af: 63                     out     3                   ; prform out
 3030 a8b0: 22                     dec     r2                  ; move pointer back
 3031 a8b1: c0 a0 17               lbr     good                ; and return to caller
 3032 a8b4: ff 01       cout4:     smi     1                   ; try port 1
 3033 a8b6: ca a8 be               lbnz    cout5               ; jump if not
 3034 a8b9: 64                     out     4                   ; prform out
 3035 a8ba: 22                     dec     r2                  ; move pointer back
 3036 a8bb: c0 a0 17               lbr     good                ; and return to caller
 3037 a8be: ff 01       cout5:     smi     1                   ; try port 1
 3038 a8c0: ca a8 c8               lbnz    cout6               ; jump if not
 3039 a8c3: 65                     out     5                   ; prform out
 3040 a8c4: 22                     dec     r2                  ; move pointer back
 3041 a8c5: c0 a0 17               lbr     good                ; and return to caller
 3042 a8c8: ff 01       cout6:     smi     1                   ; try port 1
 3043 a8ca: ca a8 d2               lbnz    cout7               ; jump if not
 3044 a8cd: 66                     out     6                   ; prform out
 3045 a8ce: 22                     dec     r2                  ; move pointer back
 3046 a8cf: c0 a0 17               lbr     good                ; and return to caller
 3047 a8d2: ff 01       cout7:     smi     1                   ; try port 1
 3048 a8d4: ca a8 d9               lbnz    cout8               ; jump if not
 3049 a8d7: 67                     out     7                   ; prform out
 3050 a8d8: 22                     dec     r2                  ; move pointer back
 3051 a8d9: c0 a0 17    cout8:     lbr     good                ; and return to caller
 3052 a8dc:             
 3053 a8dc: d4          cinp:      sep     scall               ; get port
 3054 a8dd: 9c 32                  dw      pop
 3055 a8df: c3 a0 12               lbdf    error               ; jump on error
 3056 a8e2: 8b                     glo     rb                  ; get port
 3057 a8e3: ff 01                  smi     1                   ; check port 1
 3058 a8e5: ca a8 ec               lbnz    cinp2               ; jump if not
 3059 a8e8: 69                     inp     1                   ; read port
 3060 a8e9: c0 a9 1f               lbr     cinpd               ; complete
 3061 a8ec: ff 01       cinp2:     smi     1                   ; check port 1
 3062 a8ee: ca a8 f5               lbnz    cinp3               ; jump if not
 3063 a8f1: 6a                     inp     2                   ; read port
 3064 a8f2: c0 a9 1f               lbr     cinpd               ; complete
 3065 a8f5: ff 01       cinp3:     smi     1                   ; check port 1
 3066 a8f7: ca a8 fe               lbnz    cinp4               ; jump if not
 3067 a8fa: 6b                     inp     3                   ; read port
 3068 a8fb: c0 a9 1f               lbr     cinpd               ; complete
 3069 a8fe: ff 01       cinp4:     smi     1                   ; check port 1
 3070 a900: ca a9 07               lbnz    cinp5               ; jump if not
 3071 a903: 6c                     inp     4                   ; read port
 3072 a904: c0 a9 1f               lbr     cinpd               ; complete
 3073 a907: ff 01       cinp5:     smi     1                   ; check port 1
 3074 a909: ca a9 10               lbnz    cinp6               ; jump if not
 3075 a90c: 6d                     inp     5                   ; read port
 3076 a90d: c0 a9 1f               lbr     cinpd               ; complete
 3077 a910: ff 01       cinp6:     smi     1                   ; check port 1
 3078 a912: ca a9 19               lbnz    cinp7               ; jump if not
 3079 a915: 6e                     inp     6                   ; read port
 3080 a916: c0 a9 1f               lbr     cinpd               ; complete
 3081 a919: ff 01       cinp7:     smi     1                   ; check port 1
 3082 a91b: ca a0 12               lbnz    error               ; jump if not
 3083 a91e: 6f                     inp     7                   ; read port
 3084 a91f: ab          cinpd:     plo     rb                  ; prepare to put on stack
 3085 a920: f8 00                  ldi     0
 3086 a922: bb                     phi     rb
 3087 a923: c0 a0 25    	   lbr goodpush
 3088 a926:             
 3089 a926:             
 3090 a926:             
 3091 a926:             ; cstk:      mov     rb,fstack           ; get stack address
 3092 a926:                        ; sep     scall               ; push onto stack
 3093 a926:                        ; dw      push
 3094 a926:                        ; lbr     good
 3095 a926:             
 3096 a926:             ; [GDJ]
 3097 a926: f8 08 ab f8 
            03 bb       cspat:     mov     rb,fstack           ; get stack address pointer
 3098 a92c: 8b                     glo     rb
 3099 a92d: a8                     plo     r8
 3100 a92e: 9b                     ghi     rb
 3101 a92f: b8                     phi     r8
 3102 a930:             
 3103 a930:                        ; get stack address 
 3104 a930: 48                     lda     r8
 3105 a931: bb                     phi     rb
 3106 a932: 08                     ldn     r8
 3107 a933: ab                     plo     rb
 3108 a934:             
 3109 a934:                        ; add 1 byte offset
 3110 a934: f8 01 a7 f8 
            00 b7                  mov     r7, 1
 3111 a93a: e2                     sex     r2                  ; be sure X points to stack
 3112 a93b: 87                     glo     r7                  ; perform addition
 3113 a93c: 52                     str     r2
 3114 a93d: 8b                     glo     rb
 3115 a93e: f4                     add
 3116 a93f: ab                     plo     rb
 3117 a940: 97                     ghi     r7
 3118 a941: 52                     str     r2
 3119 a942: 9b                     ghi     rb
 3120 a943: 74                     adc
 3121 a944: bb                     phi     rb
 3122 a945:             
 3123 a945: c0 a0 25    	   lbr goodpush
 3124 a948:             
 3125 a948:             
 3126 a948:             ; -----------------------------------------------------------------
 3127 a948:             ; additions April 2022  GDJ
 3128 a948:             ; -----------------------------------------------------------------
 3129 a948: d4          ccmove:    sep     scall               ; get top of stack
 3130 a949: 9c 32                  dw      pop
 3131 a94b: c3 a0 12               lbdf    error               ; jump if error
 3132 a94e: 8b ac 9b bc            mov     rc,rb               ; rc is count of bytes
 3133 a952: d4                     sep     scall               ; get top of stack
 3134 a953: 9c 32                  dw      pop
 3135 a955: c3 a0 12               lbdf    error               ; jump if error
 3136 a958: 8b a8 9b b8            mov     r8,rb               ; r8 is destination address
 3137 a95c: d4                     sep     scall               ; get top of stack
 3138 a95d: 9c 32                  dw      pop
 3139 a95f: c3 a0 12               lbdf    error               ; jump if error
 3140 a962: 8b a7 9b b7            mov     r7,rb               ; r7 is source address
 3141 a966:             
 3142 a966:                        ; transfer data
 3143 a966:                        ; begin check for zero byte count else tragedy could result
 3144 a966: 8c          cmovelp:   glo     rc
 3145 a967: ca a9 71               lbnz    cmovestr
 3146 a96a: 9c                     ghi     rc
 3147 a96b: ca a9 71               lbnz    cmovestr
 3148 a96e: c0 a9 78               lbr     cmovertn
 3149 a971: 47          cmovestr:  lda     r7
 3150 a972: 58                     str     r8
 3151 a973: 18                     inc     r8
 3152 a974: 2c                     dec     rc
 3153 a975: c0 a9 66               lbr     cmovelp
 3154 a978: c0 a0 17    cmovertn:  lbr     good                ; return to caller
 3155 a97b:             
 3156 a97b:             
 3157 a97b: d4          csetq:     sep     scall               ; get top of stack
 3158 a97c: 9c 32                  dw      pop
 3159 a97e: c3 a0 12               lbdf    error               ; jump if error
 3160 a981: 8b                     glo     rb                  ; get low of return value
 3161 a982: c2 a9 89               lbz     setqno              ; jump if zero
 3162 a985: 7b                     seq
 3163 a986: c0 a0 17               lbr     good
 3164 a989: 7a          setqno:    req
 3165 a98a: c0 a0 17               lbr     good                ; return to caller
 3166 a98d:             
 3167 a98d:             
 3168 a98d: f8 17 ad f8 
            03 bd       cdecimal:  mov     rd, basen
 3169 a993: f8 0a                  ldi     10
 3170 a995: 5d                     str     rd
 3171 a996: c0 a0 17               lbr     good
 3172 a999:             
 3173 a999: f8 17 ad f8 
            03 bd       chex:      mov     rd, basen
 3174 a99f: f8 10                  ldi     16
 3175 a9a1: 5d                     str     rd
 3176 a9a2: c0 a0 17               lbr     good
 3177 a9a5:             
 3178 a9a5: d4          crat:      sep     scall               ; get value from return stack
 3179 a9a6: 9c 77                  dw      rpop
 3180 a9a8: d4                     sep     scall               ; put back on return stack
 3181 a9a9: 9c 8f                  dw      rpush 
 3182 a9ab: c0 a0 25    	   lbr goodpush
 3183 a9ae:             
 3184 a9ae:             
 3185 a9ae: d4          crand:     sep     scall
 3186 a9af: ac ae                  dw      randbyte
 3187 a9b1: 98                     ghi     r8
 3188 a9b2: ab                     plo     rb
 3189 a9b3: f8 00                  ldi     0
 3190 a9b5: bb                     phi     rb
 3191 a9b6: c0 a0 25    	   lbr goodpush
 3192 a9b9:             
 3193 a9b9:             
 3194 a9b9:             ; VT100 ansi control
 3195 a9b9:             ; printf("%c[%d;%dH",ESC,y,x);
 3196 a9b9: d4          cgotoxy:   sep     scall               ; get top of stack
 3197 a9ba: 9c 32                  dw      pop
 3198 a9bc: c3 a0 12               lbdf    error               ; jump if error
 3199 a9bf: 8b ad 9b bd            mov     rd,rb               ; rd is Y coord (row)
 3200 a9c3: d4                     sep     scall               ; get top of stack
 3201 a9c4: 9c 32                  dw      pop
 3202 a9c6: c3 a0 12               lbdf    error               ; jump if error
 3203 a9c9: 8b a8 9b b8            mov     r8,rb               ; r8 is X coord (col)
 3204 a9cd:             
 3205 a9cd:                        ; send CSI sequence
 3206 a9cd: d4                     sep    scall
 3207 a9ce: ff 66                  dw     f_inmsg
 3208 a9d0: 1b 5b 00               db     27, '[', 0
 3209 a9d3:             
 3210 a9d3:                        ; Y
 3211 a9d3: f8 00 af f8 
            02 bf                  mov     rf, buffer
 3212 a9d9: d4                     sep     scall
 3213 a9da: ff 60                  dw      f_uintout
 3214 a9dc: f8 00                  ldi     0                   ; write terminator
 3215 a9de: 5f                     str     rf
 3216 a9df: f8 00 af f8 
            02 bf                  mov     rf, buffer
 3217 a9e5: d4                     sep     scall
 3218 a9e6: ff 09                  dw      f_msg
 3219 a9e8:             
 3220 a9e8:                        ; type separator
 3221 a9e8: f8 3b                  ldi     ';'
 3222 a9ea: d4                     sep     scall               ; call type routine
 3223 a9eb: ff 4e                  dw      f_tty
 3224 a9ed:             
 3225 a9ed:                        ; X
 3226 a9ed: f8 00 af f8 
            02 bf                  mov     rf, buffer
 3227 a9f3: 88 ad 98 bd            mov     rd,r8
 3228 a9f7: d4                     sep     scall
 3229 a9f8: ff 60                  dw      f_uintout
 3230 a9fa: f8 00                  ldi     0                   ; write terminator
 3231 a9fc: 5f                     str     rf
 3232 a9fd: f8 00 af f8 
            02 bf                  mov     rf, buffer
 3233 aa03: d4                     sep     scall
 3234 aa04: ff 09                  dw      f_msg
 3235 aa06:                        
 3236 aa06:                        ; type ending char
 3237 aa06: f8 48                  ldi     'H'
 3238 aa08: d4                     sep     scall               ; call type routine
 3239 aa09: ff 4e                  dw      f_tty
 3240 aa0b:             
 3241 aa0b: c0 a0 17               lbr     good
 3242 aa0e:             
 3243 aa0e:             
 3244 aa0e:             ; -----------------------------------------------------------------------------
 3245 aa0e:             ; 'C' style operators for bit shifting, note no range check on number of shifts
 3246 aa0e:             ; -----------------------------------------------------------------------------
 3247 aa0e: d4          clshift:   sep     scall               ; get value from stack
 3248 aa0f: 9c 32                  dw      pop
 3249 aa11: c3 a0 12               lbdf    error               ; jump if stack was empty
 3250 aa14: 8b                     glo     rb                  ; move number 
 3251 aa15: a7                     plo     r7                  ; number of shifts
 3252 aa16:             
 3253 aa16: d4                     sep     scall               ; get next number
 3254 aa17: 9c 32                  dw      pop
 3255 aa19: c3 a0 12               lbdf    error               ; jump if stack was empty
 3256 aa1c: 8b a8 9b b8            mov     r8,rb               ; value to shift left
 3257 aa20:             
 3258 aa20: 87                     glo     r7                  ; zero shift is identity 
 3259 aa21: ca aa 27               lbnz    lshiftlp
 3260 aa24: c0 aa 32               lbr     lshiftret           ; return with no shift
 3261 aa27:             
 3262 aa27: 88          lshiftlp:  glo     r8
 3263 aa28: fe                     shl                         ; shift lo byte
 3264 aa29: a8                     plo     r8
 3265 aa2a: 98                     ghi     r8
 3266 aa2b: 7e                     shlc                        ; shift hi byte with carry
 3267 aa2c: b8                     phi     r8
 3268 aa2d: 27                     dec     r7
 3269 aa2e: 87                     glo     r7
 3270 aa2f: ca aa 27               lbnz    lshiftlp
 3271 aa32:             
 3272 aa32: 88 ab 98 bb lshiftret: mov     rb,r8
 3273 aa36: c0 a0 25    	   lbr goodpush
 3274 aa39:             
 3275 aa39:             
 3276 aa39: d4          crshift:   sep     scall               ; get value from stack
 3277 aa3a: 9c 32                  dw      pop
 3278 aa3c: c3 a0 12               lbdf    error               ; jump if stack was empty
 3279 aa3f: 8b                     glo     rb                  ; move number 
 3280 aa40: a7                     plo     r7                  ; number of shifts
 3281 aa41:             
 3282 aa41: d4                     sep     scall               ; get next number
 3283 aa42: 9c 32                  dw      pop
 3284 aa44: c3 a0 12               lbdf    error               ; jump if stack was empty
 3285 aa47: 8b a8 9b b8            mov     r8,rb
 3286 aa4b:             
 3287 aa4b: 87                     glo     r7                  ; zero shift is identity 
 3288 aa4c: ca aa 52               lbnz    rshiftlp
 3289 aa4f: c0 aa 5d               lbr     rshiftret           ; return with no shift
 3290 aa52:             
 3291 aa52: 98          rshiftlp:  ghi     r8
 3292 aa53: f6                     shr                         ; shift hi byte
 3293 aa54: b8                     phi     r8
 3294 aa55: 88                     glo     r8
 3295 aa56: 76                     shrc                        ; shift lo byte with carry
 3296 aa57: a8                     plo     r8
 3297 aa58: 27                     dec     r7
 3298 aa59: 87                     glo     r7
 3299 aa5a: ca aa 52               lbnz    rshiftlp
 3300 aa5d:                
 3301 aa5d: 88 ab 98 bb rshiftret: mov     rb,r8
 3302 aa61: c0 a0 25    	   lbr goodpush
 3303 aa64:             
 3304 aa64:             
 3305 aa64:             ; delay for approx 1 millisecond on 4MHz 1802
 3306 aa64: d4          cdelay:    sep     scall               ; get value from stack
 3307 aa65: 9c 32                  dw      pop
 3308 aa67: c3 a0 12               lbdf    error               ; jump if stack was empty
 3309 aa6a: 8b                     glo     rb                  ; move number 
 3310 aa6b: a7                     plo     r7
 3311 aa6c: 9b                     ghi     rb
 3312 aa6d: b7                     phi     r7
 3313 aa6e:             
 3314 aa6e: f8 3c       delaylp1:  ldi     60
 3315 aa70: c4          delaylp2:  nop
 3316 aa71: ff 01                  smi     1
 3317 aa73: ca aa 70               lbnz    delaylp2
 3318 aa76:             
 3319 aa76: 27                     dec     r7
 3320 aa77: 87                     glo     r7
 3321 aa78: ca aa 6e               lbnz    delaylp1
 3322 aa7b: 97                     ghi     r7
 3323 aa7c: ca aa 6e               lbnz    delaylp1
 3324 aa7f: c0 a0 17               lbr     good
 3325 aa82:             
 3326 aa82:             	
 3327 aa82: d4          cexec:	   sep scall
 3328 aa83: 9c 32       	   dw pop
 3329 aa85: c3 a0 12      	   lbdf error
 3330 aa88: f8 0a a8 f8 
            03 b8                  mov     r8, jump            ; point to jump address
 3331 aa8e: f8 c0                  ldi     0c0h                ; lbr
 3332 aa90: 58                     str     r8                  ; store it
 3333 aa91: 18                     inc     r8
 3334 aa92: 9b          	   ghi     rb
 3335 aa93: 58                     str     r8
 3336 aa94: 18                     inc     r8
 3337 aa95: 8b          	   glo     rb
 3338 aa96: 58                     str     r8
 3339 aa97: d4          	   sep     scall
 3340 aa98: aa 9d       	   dw      cexec0
 3341 aa9a:             	;; if we return RB is pushed on stack
 3342 aa9a: c0 a0 25    	   lbr goodpush
 3343 aa9d: c0 03 0a    cexec0:	   lbr jump   		; transfer to user code. If it returns, it goes back to my scaller
 3344 aaa0:             
 3345 aaa0:             
 3346 aaa0:             ; -----------------------------------------------------------------------------
 3347 aaa0:             ; Load contents of dictionary - any session defined words/values will be zapped
 3348 aaa0:             ; -----------------------------------------------------------------------------
 3349 aaa0:             
 3350 aaa0: 8f 73 9f 73 cbload:    push    rf
 3351 aaa4: 8d 73 9d 73            push    rd
 3352 aaa8: 8c 73 9c 73            push    rc
 3353 aaac:                        
 3354 aaac: f8 8a af f8 
            ae bf                  mov     rf, extblock        ; source address
            #else
 3358 aab2: f8 00 ad f8 
            03 bd                  mov     rd, 0300h           ; destination address
            #endif
 3360 aab8: f8 00 ac f8 
            05 bc                  mov     rc, endextblock-extblock  ; block size
 3361 aabe:             
 3362 aabe: 4f          bloadlp:   lda     rf
 3363 aabf: 5d                     str     rd
 3364 aac0: 1d                     inc     rd
 3365 aac1: 2c                     dec     rc
 3366 aac2: 8c                     glo     rc
 3367 aac3: ca aa be               lbnz    bloadlp
 3368 aac6: 9c                     ghi     rc
 3369 aac7: ca aa be               lbnz    bloadlp
 3370 aaca:             
 3371 aaca: 60 72 bc f0 
            ac                     pop     rc
 3372 aacf: 60 72 bd f0 
            ad                     pop     rd
 3373 aad4: 60 72 bf f0 
            af                     pop     rf
 3374 aad9: c0 9b e7               lbr     mainlp              ; back to main loop
 3375 aadc:             
 3376 aadc:             
 3377 aadc:             ; -----------------------------------------------------------------
 3378 aadc:             
 3379 aadc:             
            #ifdef ANYROM
 3381 aadc: 8f 73 9f 73 csave:     push    rf                  ; save consumed registers
 3382 aae0: 8c 73 9c 73            push    rc
 3383 aae4: d4                     sep     scall               ; open XMODEM channel for writing
 3384 aae5: ed 00                  dw      xopenw
 3385 aae7: f8 06 af f8 
            03 bf                  mov     rf,freemem          ; need pointer to freemem
 3386 aaed: 4f                     lda     rf                  ; get high address of free memory
            #else
 3390 aaee: ff 03                  smi     3                   ; subtract base address
            #endif
 3392 aaf0: bc                     phi     rc                  ; store into count
 3393 aaf1: 0f                     ldn     rf                  ; get low byte of free memory
 3394 aaf2: ac                     plo     rc                  ; store into count
 3395 aaf3: 1c                     inc     rc                  ; account for terminator
 3396 aaf4: 1c                     inc     rc
 3397 aaf5: f8 00 af f8 
            02 bf                  mov     rf,buffer           ; temporary storage
 3398 aafb: 9c                     ghi     rc                  ; get high byte of count
 3399 aafc: 5f                     str     rf                  ; store it
 3400 aafd: 1f                     inc     rf                  ; point to low byte
 3401 aafe: 8c                     glo     rc                  ; get it
 3402 aaff: 5f                     str     rf                  ; store into buffer
 3403 ab00: 2f                     dec     rf                  ; move back to buffer
 3404 ab01: f8 02 ac f8 
            00 bc                  mov     rc,2                ; 2 bytes of length
 3405 ab07: d4                     sep     scall               ; write to XMODEM channel
 3406 ab08: ed 09                  dw      xwrite
 3407 ab0a: f8 00 af f8 
            02 bf                  mov     rf,buffer           ; point to where count is
 3408 ab10: 4f                     lda     rf                  ; retrieve high byte
 3409 ab11: bc                     phi     rc                  ; set into count for write
 3410 ab12: 0f                     ldn     rf                  ; get low byte
 3411 ab13: ac                     plo     rc                  ; rc now has count of bytes to save
 3412 ab14: f8 00 af f8 
            03 bf                  mov     rf,himem            ; point to forth data
 3413 ab1a: d4                     sep     scall               ; write it all out
 3414 ab1b: ed 09                  dw      xwrite
 3415 ab1d: d4                     sep     scall               ; close XMODEM channel
 3416 ab1e: ed 0c                  dw      xclosew
 3417 ab20: 60 72 bc f0 
            ac                     pop     rc                  ; recover consumed registers
 3418 ab25: 60 72 bf f0 
            af                     pop     rf
 3419 ab2a: c0 a0 17               lbr     good                ; all done
            #endif
 3421 ab2d:             
            #endif
 3484 ab2d:             
            #ifdef ANYROM
 3486 ab2d: 8f 73 9f 73 cload:     push    rf                  ; save consumed registers
 3487 ab31: 8c 73 9c 73            push    rc
 3488 ab35: 8e 73 9e 73            push    re                  ; [GDJ]
 3489 ab39: d4                     sep     scall               ; open XMODEM channel for reading
 3490 ab3a: ed 03                  dw      xopenr
 3491 ab3c: f8 00 af f8 
            02 bf                  mov     rf,buffer           ; point to buffer
 3492 ab42: f8 02 ac f8 
            00 bc                  mov     rc,2                ; need to read 2 bytes
 3493 ab48: d4                     sep     scall               ; read them
 3494 ab49: ed 06                  dw      xread
 3495 ab4b: f8 00 af f8 
            02 bf                  mov     rf,buffer           ; point to buffer
 3496 ab51: 4f                     lda     rf                  ; retrieve count
 3497 ab52: bc                     phi     rc                  ; into rc
 3498 ab53: 0f                     ldn     rf
 3499 ab54: ac                     plo     rc                  ; rc now has count of bytes to read
 3500 ab55: f8 00 af f8 
            03 bf                  mov     rf,himem            ; point to forth data
 3501 ab5b: d4                     sep     scall               ; now read program data
 3502 ab5c: ed 06                  dw      xread
 3503 ab5e:                        
 3504 ab5e:                        ; temp removal [GDJ]
 3505 ab5e:                        ;sep     scall               ; close XMODEM channel
 3506 ab5e:                        ;dw      xcloser
 3507 ab5e: 60 72 be f0 
            ae                     pop     re                  ; [GDJ]
 3508 ab63: 60 72 bc f0 
            ac                     pop     rc                  ; recover consumed registers
 3509 ab68: 60 72 bf f0 
            af                     pop     rf
 3510 ab6d:                        ; irx                         ; [GDJ] remove exec portions from stack
 3511 ab6d:                        ; irx
 3512 ab6d:                        ; irx
 3513 ab6d:                        ; irx
 3514 ab6d:             
 3515 ab6d: c0 9b e7               lbr     mainlp              ; back to main loop
            #endif
 3517 ab70:             
            #endif
 3582 ab70:             
 3583 ab70: c0 80 03    cbye:      lbr     exitaddr
 3584 ab73:             
            #endif
 3605 ab73:             
 3606 ab73:             
 3607 ab73:             ; **********************************************************
 3608 ab73:             ; ***** Convert string to uppercase, honor quoted text *****
 3609 ab73:             ; **********************************************************
 3610 ab73: 0f          touc:      ldn     rf                  ; check for quote
 3611 ab74: ff 22                  smi     022h
 3612 ab76: c2 ab 90               lbz     touc_qt             ; jump if quote
 3613 ab79: 0f                     ldn     rf                  ; get byte from string
 3614 ab7a: c2 ab 8f               lbz     touc_dn             ; jump if done
 3615 ab7d: ff 61                  smi     'a'                 ; check if below lc
 3616 ab7f: cb ab 8b               lbnf    touc_nxt            ; jump if so
 3617 ab82: ff 1b                  smi     27                  ; check upper rage
 3618 ab84: c3 ab 8b               lbdf    touc_nxt            ; jump if above lc
 3619 ab87: 0f                     ldn     rf                  ; otherwise convert character to lc
 3620 ab88: ff 20                  smi     32
 3621 ab8a: 5f                     str     rf
 3622 ab8b: 1f          touc_nxt:  inc     rf                  ; point to next character
 3623 ab8c: c0 ab 73               lbr     touc                ; loop to check rest of string
 3624 ab8f: d5          touc_dn:   sep     sret                ; return to caller
 3625 ab90: 1f          touc_qt:   inc     rf                  ; move past quote
 3626 ab91: 4f          touc_qlp:  lda     rf                  ; get next character
 3627 ab92: c2 ab 8f               lbz     touc_dn             ; exit if terminator found
 3628 ab95: ff 22                  smi     022h                ; check for quote charater
 3629 ab97: c2 ab 73               lbz     touc                ; back to main loop if quote
 3630 ab9a: c0 ab 91               lbr     touc_qlp            ; otherwise keep looking
 3631 ab9d:             
 3632 ab9d:             
 3633 ab9d:             ; [GDJ] type out number according to selected BASE and signed/unsigned flag
 3634 ab9d:             typenumind:   ; get BASE  ; enter here to have 0x or 0# put on front
 3635 ab9d: 8f 73 9f 73         push    rf                  ; save rf for tokenizer
 3636 aba1: f8 30       	ldi '0'
 3637 aba3: d4          	sep scall
 3638 aba4: 9c 2a       	dw disp
 3639 aba6: f8 17 ad f8 
            03 bd               mov     rd, basen
 3640 abac: 0d                  ldn     rd
 3641 abad: ff 0a               smi     10
 3642 abaf: 32 b4       	bz typenuminddec
 3643 abb1: f8 78       	ldi 'x'
 3644 abb3: c8          	lskp
 3645 abb4:             typenuminddec:
 3646 abb4: f8 23       	ldi '#'
 3647 abb6: d4          	sep scall
 3648 abb7: 9c 2a       	dw disp
 3649 abb9: f8 00       	ldi 0
 3650 abbb: ae          	plo re  		; always unsigned here
 3651 abbc: 30 c2       	br typenumx
 3652 abbe:             
 3653 abbe:             typenum:   ; get BASE  ; enter here for normal output
 3654 abbe: 8f 73 9f 73            push    rf                  ; save rf for tokenizer
 3655 abc2:             typenumx:	
 3656 abc2: f8 17 ad f8 
            03 bd                  mov     rd, basen
 3657 abc8: 0d                     ldn     rd
 3658 abc9: ff 0a                  smi     10
 3659 abcb: ca ab e8               lbnz    typehex
 3660 abce: 8b ad 9b bd            mov     rd,rb
 3661 abd2: f8 00 af f8 
            02 bf                  mov     rf, buffer
 3662 abd8: 8e                     glo     re
 3663 abd9: c2 ab e2               lbz     typenumU
 3664 abdc: d4                     sep     scall
 3665 abdd: ff 63                  dw      f_intout
 3666 abdf: c0 ab ff               lbr     typeout
 3667 abe2: d4          typenumU:  sep     scall
 3668 abe3: ff 60                  dw      f_uintout
 3669 abe5: c0 ab ff               lbr     typeout
 3670 abe8:             
 3671 abe8:             typehex:
 3672 abe8: 8b ad 9b bd 	   mov     rd,rb
 3673 abec: f8 00 af f8 
            02 bf                  mov     rf, buffer
 3674 abf2: 9d                     ghi     rd
 3675 abf3: c2 ab fc               lbz     hexbyte
 3676 abf6: d4                     sep     scall
 3677 abf7: ff 4b                  dw      f_hexout4
 3678 abf9: c0 ab ff               lbr     typeout
 3679 abfc: d4          hexbyte:   sep     scall
 3680 abfd: ff 48                  dw      f_hexout2
 3681 abff:             
 3682 abff: f8 20       typeout:   ldi     ' '                 ; add space
 3683 ac01: 5f                     str     rf
 3684 ac02: 1f                     inc     rf
 3685 ac03: f8 00                  ldi     0                   ; and terminator
 3686 ac05: 5f                     str     rf
 3687 ac06: f8 00 af f8 
            02 bf                  mov     rf, buffer
 3688 ac0c: d4                     sep     scall
 3689 ac0d: ff 09                  dw      f_msg
 3690 ac0f: 60 72 bf f0 
            af                     pop     rf
 3691 ac14: d5                     sep     sret                ; return to caller
 3692 ac15:             
 3693 ac15:             
 3694 ac15:             
 3695 ac15:             ; *************************************
 3696 ac15:             ; *** Check if character is numeric ***
 3697 ac15:             ; *** D - char to check             ***
 3698 ac15:             ; *** Returns DF=1 if numeric       ***
 3699 ac15:             ; ***         DF=0 if not           ***
 3700 ac15:             ; *************************************
 3701 ac15: ae          isnum:     plo     re                  ; save a copy
 3702 ac16: ff 30                  smi     '0'                 ; check for below zero
 3703 ac18: cb ac 23               lbnf    fails               ; jump if below
 3704 ac1b: ff 0a                  smi     10                  ; see if above
 3705 ac1d: c3 ac 23               lbdf    fails               ; fails if so
 3706 ac20: ff 00       passes:    smi     0                   ; signal success
 3707 ac22: c8                     lskp
 3708 ac23: fc 00       fails:     adi     0                   ; signal failure
 3709 ac25: 8e                     glo     re                  ; recover character
 3710 ac26: d5                     sep     sret                ; and return
 3711 ac27:             
 3712 ac27: ff 00       err:       smi     0                   ; signal an error
 3713 ac29: d5                     sep     sret                ; and return
 3714 ac2a:                        
 3715 ac2a:                        
 3716 ac2a:             ; **********************************
 3717 ac2a:             ; *** check D if hex             ***
 3718 ac2a:             ; *** Returns DF=1 - hex         ***
 3719 ac2a:             ; ***         DF=0 - non-hex     ***
 3720 ac2a:             ; **********************************
 3721 ac2a: d4          ishex:     sep     scall               ; see if it is numeric
 3722 ac2b: ac 15                  dw      isnum
 3723 ac2d: ae                     plo     re                  ; keep a copy
 3724 ac2e: c3 ac 20               lbdf    passes              ; jump if it is numeric
 3725 ac31: ff 41                  smi     'A'                 ; check for below uppercase a
 3726 ac33: cb ac 23               lbnf    fails               ; value is not hex
 3727 ac36: ff 06                  smi     6                   ; check for less then 'G'
 3728 ac38: cb ac 20               lbnf    passes              ; jump if so
 3729 ac3b: 8e                     glo     re                  ; recover value
 3730 ac3c: ff 61                  smi     'a'                 ; check for lowercase a
 3731 ac3e: cb ac 23               lbnf    fails               ; jump if not
 3732 ac41: ff 06                  smi     6                   ; check for less than 'g'
 3733 ac43: cb ac 20               lbnf    passes              ; jump if so
 3734 ac46: c0 ac 23               lbr     fails
 3735 ac49:             
 3736 ac49:             
 3737 ac49:             
 3738 ac49:                        ; clear tos, himem & rstack blocks 
 3739 ac49: f8 00 a7 f8 
            03 b7       clrstacks: mov     r7, 300h            ; clear 768 bytes
 3740 ac4f: f8 00 ac f8 
            7c bc                  mov     rc, 7c00h
 3741 ac55:                        
 3742 ac55: f8 00       clrmemlp:  ldi     0h
 3743 ac57: 5c                     str     rc
 3744 ac58: 1c                     inc     rc
 3745 ac59: 27                     dec     r7
 3746 ac5a: 87                     glo     r7
 3747 ac5b: ca ac 55               lbnz    clrmemlp
 3748 ac5e: 97                     ghi     r7
 3749 ac5f: ca ac 55               lbnz    clrmemlp
 3750 ac62: d5                     rtn
 3751 ac63:             
 3752 ac63:             
 3753 ac63:             ;--------------------------------------------------------------
 3754 ac63:             ;    Read byte from UART if char available  
 3755 ac63:             ;    return in r7.0 - else return null
 3756 ac63:             ;
 3757 ac63:             ;    from original bios code of Bob Armstrong
 3758 ac63:             ;    modified for non-blocking console input
 3759 ac63:             ;--------------------------------------------------------------
 3760 ac63: f8 15       inkey:  ldi     015h            ; need UART line status register
 3761 ac65: 52                  str     r2              ; prepare for out
 3762 ac66: 66                  out     UART_SELECT     ; write to register select port
 3763 ac67: 22                  dec     r2              ; correct for inc on out
 3764 ac68: 6f                  inp     UART_DATA       ; read line status register
 3765 ac69: fa 01               ani     1               ; mask for data ready bit
 3766 ac6b: c2 ac 76            lbz     nokey           ; return if no bytes to read
 3767 ac6e: f8 10               ldi     010h            ; select data register
 3768 ac70: 52                  str     r2              ; prepare for out
 3769 ac71: 66                  out     UART_SELECT     ; write to register select port
 3770 ac72: 22                  dec     r2              ; back to free spot
 3771 ac73: 6f                  inp     UART_DATA       ; read UART data register
 3772 ac74: a7                  plo     r7
 3773 ac75: d5                  rtn
 3774 ac76:                     
 3775 ac76: f8 00       nokey:  ldi     0h
 3776 ac78: a7                  plo     r7
 3777 ac79: d5                  rtn
 3778 ac7a:             
 3779 ac7a:             
 3780 ac7a: f8 0d a7 f8 
            03 b7       clist:	mov r7,storage
 3781 ac80:             clist0:
 3782 ac80: 87 73 97 73 	push r7
 3783 ac84: 07          	ldn r7
 3784 ac85: 3a 93       	bnz clist1
 3785 ac87: 17          	inc r7
 3786 ac88: 07          	ldn r7
 3787 ac89: 3a 93       	bnz clist1
 3788 ac8b: 60 72 b7 f0 
            a7          	pop r7
 3789 ac90: c0 a0 17    	lbr good
 3790 ac93:             clist1:	
 3791 ac93: 60 72 b7 f0 
            a7          	pop r7
 3792 ac98: 87 73 97 73 	push r7
 3793 ac9c: d4          	sep scall
 3794 ac9d: a5 d4       	dw csee_sub0
 3795 ac9f: 60 72 b7 f0 
            a7          	pop r7
 3796 aca4: 07          	ldn r7
 3797 aca5: bb          	phi rb
 3798 aca6: 17          	inc r7
 3799 aca7: 07          	ldn r7
 3800 aca8: a7          	plo r7
 3801 aca9: 9b          	ghi rb
 3802 acaa: b7          	phi r7
 3803 acab: c0 ac 80    	lbr clist0
 3804 acae:             	
 3805 acae:             
 3806 acae:             
 3807 acae:             ;------------------------------------------------------------------
 3808 acae:             ; Generate a psuedo-random byte
 3809 acae:             ;
 3810 acae:             ; IN:       N/A
 3811 acae:             ; OUT:      D=psuedo-random number
 3812 acae:             ; TRASHED:  RA
 3813 acae:             ;
 3814 acae:             ; This PRNG was extracted from AdventureLand
 3815 acae:             ; Copyright (C) 2019 by Richard Goedeken, All Rights Reserved.
 3816 acae:             ;
 3817 acae:             ; modified GDJ 2021 --> return in r8.1, changed r7 to ra
 3818 acae:             ;
 3819 acae:             ; Update1: 23 Jan 2022 no period has been determined, thus 
 3820 acae:             ; far a 320kB file has been checked - 12 minutes on the PicoElf2
 3821 acae:             ; gave 20479 lines of 16 samples --> 327664 bytes
 3822 acae:             ;
 3823 acae:             ; Update2: 25 Feb 2022 translated this code into 'C' and 
 3824 acae:             ; discovered a period of P = 2020966655
 3825 acae:             ; after which the sequence repeats!
 3826 acae:             ; other init params often gave the same period, however the
 3827 acae:             ; initial arrays:
 3828 acae:             ;        {1,3,5,7} gave a period of 543537919
 3829 acae:             ;   {12,137,98,32} gave a period of 1080837375
 3830 acae:             ;------------------------------------------------------------------
 3831 acae: f8 f0 ad f8 
            02 bd       randbyte:   mov rd,rseed
 3832 acb4: ed                      sex rd
 3833 acb5:             
 3834 acb5: 0d                      ldn rd      ; D = VarX
 3835 acb6: fc 01                   adi 1
 3836 acb8: 5d                      str rd
 3837 acb9: 1d                      inc rd
 3838 acba: 4d                      lda rd      ; D = VarA
 3839 acbb: 1d                      inc rd
 3840 acbc: f3                      xor         ; D = VarA XOR VarC
 3841 acbd: 2d                      dec rd
 3842 acbe: 2d                      dec rd
 3843 acbf: 2d                      dec rd
 3844 acc0: f3                      xor         ; D = VarA XOR VarC XOR VarX
 3845 acc1: 1d                      inc rd
 3846 acc2: 5d                      str rd      ; VarA = D
 3847 acc3: 1d                      inc rd
 3848 acc4: f4                      add
 3849 acc5: 73                      stxd
 3850 acc6: f6                      shr
 3851 acc7: f3                      xor
 3852 acc8: 1d                      inc rd
 3853 acc9: 1d                      inc rd
 3854 acca: f4                      add
 3855 accb: 5d                      str rd
 3856 accc: b8                      phi r8      ; added GDJ
 3857 accd:             
 3858 accd: e2                      sex r2      ;    ...
 3859 acce: d5                      rtn
 3860 accf:             
 3861 accf:             
 3862 accf:             
 3863 accf:             
 3864 accf: 52 63 2f 46 
            6f 72 74 68 
            20 30 2e 33 hello:     db      'Rc/Forth 0.3'
 3865 acdb: 0a 0d 00    crlf:      db       10,13,0
 3866 acde: 6f 6b 20 00 prompt:    db      'ok ',0
 3867 ace2: 73 74 61 63 
            6b 20 65 6d 
            70 74 79 0a 
            0d 00       msempty:   db      'stack empty',10,13,0
 3868 acf0: 65 72 72 0a 
            0d 00       msgerr:    db      'err',10,13,0
 3869 acf6: 57 48 49 4c 
            c5          cmdtable:  db      'WHIL',('E'+80h)
 3870 acfb: 52 45 50 45 
            41 d4                  db      'REPEA',('T'+80h)
 3871 ad01: 49 c6                  db      'I',('F'+80h)
 3872 ad03: 45 4c 53 c5            db      'ELS',('E'+80h)
 3873 ad07: 54 48 45 ce            db      'THE',('N'+80h)
 3874 ad0b: 56 41 52 49 
            41 42 4c c5            db      'VARIABL',('E'+80h)
 3875 ad13: ba                     db      (':'+80h)
 3876 ad14: bb                     db      (';'+80h)
 3877 ad15: 44 55 d0               db      'DU',('P'+80h)
 3878 ad18: 44 52 4f d0            db      'DRO',('P'+80h)
 3879 ad1c: 53 57 41 d0            db      'SWA',('P'+80h)
 3880 ad20: ab                     db      ('+'+80h)
 3881 ad21: ad                     db      ('-'+80h)
 3882 ad22: aa                     db      ('*'+80h)
 3883 ad23: af                     db      ('/'+80h)
 3884 ad24: ae                     db      ('.'+80h)
 3885 ad25: 55 ae                  db      'U',('.'+80h)
 3886 ad27: c9                     db      ('I'+80h)
 3887 ad28: 41 4e c4               db      'AN',('D'+80h)
 3888 ad2b: 4f d2                  db      'O',('R'+80h)
 3889 ad2d: 58 4f d2               db      'XO',('R'+80h)
 3890 ad30: 43 d2                  db      'C',('R'+80h)
 3891 ad32: 4d 45 cd               db      'ME',('M'+80h)
 3892 ad35: 44 cf                  db      'D',('O'+80h)
 3893 ad37: 4c 4f 4f d0            db      'LOO',('P'+80h)
 3894 ad3b: 2b 4c 4f 4f 
            d0                     db      '+LOO',('P'+80h)
 3895 ad40: bd                     db      ('='+80h)
 3896 ad41: 3c be                  db      '<',('>'+80h)
 3897 ad43: bc                     db      ('<'+80h)           ; [GDJ]
 3898 ad44: 55 bc                  db      'U',('<'+80h)       ; [GDJ]
 3899 ad46: 42 45 47 49 
            ce                     db      'BEGI',('N'+80h)
 3900 ad4b: 55 4e 54 49 
            cc                     db      'UNTI',('L'+80h)
 3901 ad50: 52 be                  db      'R',('>'+80h)
 3902 ad52: 3e d2                  db      '>',('R'+80h)
 3903 ad54: 52 c0                  db      'R',('@'+80h)       ; [GDJ]
 3904 ad56: 57 4f 52 44 
            d3                     db      'WORD',('S'+80h)
 3905 ad5b: 45 4d 49 d4            db      'EMI',('T'+80h)
 3906 ad5f: 45 4d 49 54 
            d0                     db      'EMIT',('P'+80h)    ; [GDJ]
 3907 ad64: 44 45 50 54 
            c8                     db      'DEPT',('H'+80h)
 3908 ad69: 52 4f d4               db      'RO',('T'+80h)
 3909 ad6c: 2d 52 4f d4            db      '-RO',('T'+80h)
 3910 ad70: 4f 56 45 d2            db      'OVE',('R'+80h)
 3911 ad74: c0                     db      ('@'+80h)
 3912 ad75: a1                     db      ('!'+80h)
 3913 ad76: 43 c0                  db      'C',('@'+80h)
 3914 ad78: 43 a1                  db      'C',('!'+80h)
 3915 ad7a: 43 4d 4f 56 
            c5                     db      'CMOV',('E'+80h)    ; [GDJ]
 3916 ad7f: 2e a2                  db      '.',(34+80h)
 3917 ad81: 4b 45 d9               db      'KE',('Y'+80h)
 3918 ad84: 4b 45 59 bf            db      'KEY',('?'+80h)     ; [GDJ]
 3919 ad88: 41 4c 4c 4f 
            d4                     db      'ALLO',('T'+80h)
 3920 ad8d: 45 52 52 4f 
            d2                     db      'ERRO',('R'+80h)
 3921 ad92: 53 45 c5               db      'SE',('E'+80h)
 3922 ad95: 46 4f 52 47 
            45 d4                  db      'FORGE',('T'+80h)
 3923 ad9b: 4f 55 d4               db      'OU',('T'+80h)
 3924 ad9e: 49 4e d0               db      'IN',('P'+80h)
 3925 ada1: 45 c6                  db      'E',('F'+80h)
 3926 ada3: 53 45 54 d1            db      'SET',('Q'+80h)     ; [GDJ]
 3927 ada7: 53 41 56 c5            db      'SAV',('E'+80h)
 3928 adab: 4c 4f 41 c4            db      'LOA',('D'+80h)
 3929 adaf: 42 59 c5               db      'BY',('E'+80h)
 3930 adb2: 53 50 c0               db      'SP',('@'+80h)      ; [GDJ]
 3931 adb5: 44 45 43 49 
            4d 41 cc               db      'DECIMA',('L'+80h)  ; [GDJ]
 3932 adbc: 48 45 d8               db      'HE',('X'+80h)      ; [GDJ]
 3933 adbf: 3c bc                  db      '<',('<'+80h)       ; [GDJ]
 3934 adc1: 3e be                  db      '>',('>'+80h)       ; [GDJ]
 3935 adc3: 44 45 4c 41 
            d9                     db      'DELA',('Y'+80h)    ; [GDJ]
 3936 adc8: 42 4c 4f 41 
            c4                     db      'BLOA',('D'+80h)    ; [GDJ]
 3937 adcd: 47 4f 54 4f 
            58 d9                  db      'GOTOX',('Y'+80h)   ; [GDJ]
 3938 add3: 52 41 4e c4            db      'RAN',('D'+80h)     ; [GDJ]
 3939 add7: 45 58 45 c3 	   db	   'EXE',('C'+80h) 
 3940 addb: 4c 49 53 d4 	   db      'LIS',('T'+80h)
 3941 addf: 00                     db      0                   ; no more tokens
 3942 ade0:             
 3943 ade0: a3 50       cmdvecs:   dw      cwhile              ; 81h
 3944 ade2: a3 9c                  dw      crepeat             ; 82h
 3945 ade4: a3 ac                  dw      cif                 ; 83h
 3946 ade6: a3 f5                  dw      celse               ; 84h
 3947 ade8: a4 1f                  dw      cthen               ; 85h
 3948 adea: a5 44                  dw      cvariable           ; 86h
 3949 adec: a5 78                  dw      ccolon              ; 87h
 3950 adee: a5 b0                  dw      csemi               ; 88h
 3951 adf0: a0 1c                  dw      cdup                ; 89h
 3952 adf2: a0 2b                  dw      cdrop               ; 8ah
 3953 adf4: a0 ee                  dw      cswap               ; 8bh
 3954 adf6: a0 34                  dw      cplus               ; 8ch
 3955 adf8: a0 52                  dw      cminus              ; 8dh
 3956 adfa: a7 b7                  dw      cmul                ; 8eh
 3957 adfc: a7 cd                  dw      cdiv                ; 8fh
 3958 adfe: a0 70                  dw      cdot                ; 90h
 3959 ae00: a0 7f                  dw      cudot               ; 91h
 3960 ae02: a1 13                  dw      ci                  ; 92h
 3961 ae04: a0 8e                  dw      cand                ; 93h
 3962 ae06: a0 ac                  dw      cor                 ; 94h
 3963 ae08: a0 ca                  dw      cxor                ; 95h
 3964 ae0a: a0 e8                  dw      ccr                 ; 96h
 3965 ae0c: a1 1c                  dw      cmem                ; 97h
 3966 ae0e: a1 33                  dw      cdo                 ; 98h
 3967 ae10: a1 64                  dw      cloop               ; 99h
 3968 ae12: a1 a6                  dw      cploop              ; 9ah
 3969 ae14: a4 22                  dw      cequal              ; 9bh
 3970 ae16: a2 07                  dw      cunequal            ; 9ch
 3971 ae18: a2 33                  dw      cless               ; 9dh [GDJ]
 3972 ae1a: a2 6f                  dw      culess              ; 9eh [GDJ]
 3973 ae1c: a1 bf                  dw      cbegin              ; 9fh
 3974 ae1e: a1 ce                  dw      cuntil              ; a0h
 3975 ae20: a1 f5                  dw      crgt                ; a1h
 3976 ae22: a1 fb                  dw      cgtr                ; a2h
 3977 ae24: a9 a5                  dw      crat                ; a3h [GDJ]
 3978 ae26: a2 a2                  dw      cwords              ; a4h
 3979 ae28: a3 25                  dw      cemit               ; a5h
 3980 ae2a: a3 32                  dw      cemitp              ; a6h [GDJ]
 3981 ae2c: a4 4e                  dw      cdepth              ; a7h
 3982 ae2e: a4 69                  dw      crot                ; a8h
 3983 ae30: a4 9c                  dw      cmrot               ; a9h
 3984 ae32: a4 cf                  dw      cover               ; aah
 3985 ae34: a4 f4                  dw      cat                 ; abh
 3986 ae36: a5 05                  dw      cexcl               ; ach
 3987 ae38: a5 1d                  dw      ccat                ; adh
 3988 ae3a: a5 2f                  dw      ccexcl              ; aeh
 3989 ae3c: a9 48                  dw      ccmove              ; afh [GDJ]
 3990 ae3e: a7 20                  dw      cdotqt              ; b0h
 3991 ae40: a7 49                  dw      ckey                ; b1h
 3992 ae42: a7 53                  dw      ckeyq               ; b2h [GDJ]
 3993 ae44: a7 64                  dw      callot              ; b3h
 3994 ae46: a8 61                  dw      cerror              ; b4h
 3995 ae48: a5 b3                  dw      csee                ; b5h
 3996 ae4a: a7 ed                  dw      cforget             ; b6h
 3997 ae4c: a8 84                  dw      cout                ; b7h
 3998 ae4e: a8 dc                  dw      cinp                ; b8h
 3999 ae50: a8 6b                  dw      cef                 ; b9h
 4000 ae52: a9 7b                  dw      csetq               ; bah [GDJ]
 4001 ae54: aa dc                  dw      csave               ; bbh
 4002 ae56: ab 2d                  dw      cload               ; bch
 4003 ae58: ab 70                  dw      cbye                ; bdh
 4004 ae5a: a9 26                  dw      cspat               ; beh [GDJ]
 4005 ae5c: a9 8d                  dw      cdecimal            ; bfh [GDJ]
 4006 ae5e: a9 99                  dw      chex                ; c0h [GDJ]
 4007 ae60: aa 0e                  dw      clshift             ; c1h [GDJ]
 4008 ae62: aa 39                  dw      crshift             ; c2h [GDJ]
 4009 ae64: aa 64                  dw      cdelay              ; c3h [GDJ]
 4010 ae66: aa a0                  dw      cbload              ; c4h [GDJ]
 4011 ae68: a9 b9                  dw      cgotoxy             ; c5h [GDJ]
 4012 ae6a: a9 ae                  dw      crand               ; c6h [GDJ]
 4013 ae6c: aa 82       	   dw      cexec               ; c7h [gnr]
 4014 ae6e: ac 7a       	   dw	   clist	       ; c8h [gnr]
 4015 ae70:             
 4016 ae70:             
 4017 ae70:             ; this precompiled BASE variable is loaded at startup freemem
 4018 ae70:             ; important to zero next word else 'words' may interpret
 4019 ae70:             ; startup random data as valid (rarely) which will type garbage 
            #else
 4026 ae70: 03 18       basev:  db 003h, 018h,					   ; this must be basen+1 word
 4027 ae72: 7c ff c0 29 
            40 03 18 86         db 07ch, 0ffh, 0c0h, 029h, 040h, 003h, 018h, 086h, ; next word address + VARIABLE
 4028 ae7a: fe 42 41 53 
            45 00 00 0a         db 0feh, 042h, 041h, 053h, 045h, 000h, 000h, 00ah, ; T_NUM 'BASE' VALUE
 4029 ae82: 00 00 00 00 
            00 00 00 00         db 000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h  ; zero next word
            #endif
 4031 ae8a:             	
 4032 ae8a:             
            #ifdef STGROM
 4034 ae8a:             extblock:
 4035 ae8a: 7e ff 7d ff 
            7c ff 07 c8             db  07eh, 0ffh, 07dh, 0ffh, 07ch, 0ffh, 007h, 0c8h, 
 4036 ae92: 7c ff c0 2f 
            1b 03 18 86             db  07ch, 0ffh, 0c0h, 02fh, 01bh, 003h, 018h, 086h, 
 4037 ae9a: fe 42 41 53 
            45 00 00 0a             db  0feh, 042h, 041h, 053h, 045h, 000h, 000h, 00ah, 
 4038 aea2: 03 24 87 fe 
            4e 49 50 00             db  003h, 024h, 087h, 0feh, 04eh, 049h, 050h, 000h, 
 4039 aeaa: 8b 8a 88 00 
            03 31 87 fe             db  08bh, 08ah, 088h, 000h, 003h, 031h, 087h, 0feh, 
 4040 aeb2: 54 55 43 4b 
            00 8b aa 88             db  054h, 055h, 043h, 04bh, 000h, 08bh, 0aah, 088h, 
 4041 aeba: 00 03 47 87 
            fe 50 49 43             db  000h, 003h, 047h, 087h, 0feh, 050h, 049h, 043h, 
 4042 aec2: 4b 00 ff 00 
            02 8e ff 00             db  04bh, 000h, 0ffh, 000h, 002h, 08eh, 0ffh, 000h, 
 4043 aeca: 02 8c be 8c 
            ab 88 00 03             db  002h, 08ch, 0beh, 08ch, 0abh, 088h, 000h, 003h, 
 4044 aed2: 54 87 fe 32 
            44 55 50 00             db  054h, 087h, 0feh, 032h, 044h, 055h, 050h, 000h, 
 4045 aeda: aa aa 88 00 
            03 62 87 fe             db  0aah, 0aah, 088h, 000h, 003h, 062h, 087h, 0feh, 
 4046 aee2: 32 44 52 4f 
            50 00 8a 8a             db  032h, 044h, 052h, 04fh, 050h, 000h, 08ah, 08ah, 
 4047 aeea: 88 00 03 80 
            87 fe 32 4f             db  088h, 000h, 003h, 080h, 087h, 0feh, 032h, 04fh, 
 4048 aef2: 56 45 52 00 
            ff 00 03 fe             db  056h, 045h, 052h, 000h, 0ffh, 000h, 003h, 0feh, 
 4049 aefa: 50 49 43 4b 
            00 ff 00 03             db  050h, 049h, 043h, 04bh, 000h, 0ffh, 000h, 003h, 
 4050 af02: fe 50 49 43 
            4b 00 88 00             db  0feh, 050h, 049h, 043h, 04bh, 000h, 088h, 000h, 
 4051 af0a: 03 90 87 fe 
            32 53 57 41             db  003h, 090h, 087h, 0feh, 032h, 053h, 057h, 041h, 
 4052 af12: 50 00 a2 a9 
            a1 a9 88 00             db  050h, 000h, 0a2h, 0a9h, 0a1h, 0a9h, 088h, 000h, 
 4053 af1a: 03 9e 87 fe 
            54 52 55 45             db  003h, 09eh, 087h, 0feh, 054h, 052h, 055h, 045h, 
 4054 af22: 00 ff 00 01 
            88 00 03 ad             db  000h, 0ffh, 000h, 001h, 088h, 000h, 003h, 0adh, 
 4055 af2a: 87 fe 46 41 
            4c 53 45 00             db  087h, 0feh, 046h, 041h, 04ch, 053h, 045h, 000h, 
 4056 af32: ff 00 00 88 
            00 03 b6 87             db  0ffh, 000h, 000h, 088h, 000h, 003h, 0b6h, 087h, 
 4057 af3a: fe 4a 00 a3 
            88 00 03 c3             db  0feh, 04ah, 000h, 0a3h, 088h, 000h, 003h, 0c3h, 
 4058 af42: 87 fe 31 2b 
            00 ff 00 01             db  087h, 0feh, 031h, 02bh, 000h, 0ffh, 000h, 001h, 
 4059 af4a: 8c 88 00 03 
            d0 87 fe 31             db  08ch, 088h, 000h, 003h, 0d0h, 087h, 0feh, 031h, 
 4060 af52: 2d 00 ff 00 
            01 8d 88 00             db  02dh, 000h, 0ffh, 000h, 001h, 08dh, 088h, 000h, 
 4061 af5a: 03 dd 87 fe 
            32 2b 00 ff             db  003h, 0ddh, 087h, 0feh, 032h, 02bh, 000h, 0ffh, 
 4062 af62: 00 02 8c 88 
            00 03 ea 87             db  000h, 002h, 08ch, 088h, 000h, 003h, 0eah, 087h, 
 4063 af6a: fe 32 2d 00 
            ff 00 02 8d             db  0feh, 032h, 02dh, 000h, 0ffh, 000h, 002h, 08dh, 
 4064 af72: 88 00 03 f7 
            87 fe 30 3d             db  088h, 000h, 003h, 0f7h, 087h, 0feh, 030h, 03dh, 
 4065 af7a: 00 ff 00 00 
            9b 88 00 04             db  000h, 0ffh, 000h, 000h, 09bh, 088h, 000h, 004h, 
 4066 af82: 05 87 fe 4e 
            4f 54 00 fe             db  005h, 087h, 0feh, 04eh, 04fh, 054h, 000h, 0feh, 
 4067 af8a: 30 3d 00 88 
            00 04 10 87             db  030h, 03dh, 000h, 088h, 000h, 004h, 010h, 087h, 
 4068 af92: fe 55 3e 00 
            8b 9e 88 00             db  0feh, 055h, 03eh, 000h, 08bh, 09eh, 088h, 000h, 
 4069 af9a: 04 28 87 fe 
            55 3e 3d 00             db  004h, 028h, 087h, 0feh, 055h, 03eh, 03dh, 000h, 
 4070 afa2: fe 32 44 55 
            50 00 fe 55             db  0feh, 032h, 044h, 055h, 050h, 000h, 0feh, 055h, 
 4071 afaa: 3e 00 a2 9b 
            a1 94 88 00             db  03eh, 000h, 0a2h, 09bh, 0a1h, 094h, 088h, 000h, 
 4072 afb2: 04 3c 87 fe 
            55 3c 3d 00             db  004h, 03ch, 087h, 0feh, 055h, 03ch, 03dh, 000h, 
 4073 afba: fe 55 3e 3d 
            00 fe 4e 4f             db  0feh, 055h, 03eh, 03dh, 000h, 0feh, 04eh, 04fh, 
 4074 afc2: 54 00 88 00 
            04 46 87 fe             db  054h, 000h, 088h, 000h, 004h, 046h, 087h, 0feh, 
 4075 afca: 3e 00 8b 9d 
            88 00 04 57             db  03eh, 000h, 08bh, 09dh, 088h, 000h, 004h, 057h, 
 4076 afd2: 87 fe 3c 3d 
            00 fe 3e 00             db  087h, 0feh, 03ch, 03dh, 000h, 0feh, 03eh, 000h, 
 4077 afda: fe 4e 4f 54 
            00 88 00 04             db  0feh, 04eh, 04fh, 054h, 000h, 088h, 000h, 004h, 
 4078 afe2: 66 87 fe 3e 
            3d 00 9d fe             db  066h, 087h, 0feh, 03eh, 03dh, 000h, 09dh, 0feh, 
 4079 afea: 4e 4f 54 00 
            88 00 04 75             db  04eh, 04fh, 054h, 000h, 088h, 000h, 004h, 075h, 
 4080 aff2: 87 fe 30 3e 
            00 ff 00 00             db  087h, 0feh, 030h, 03eh, 000h, 0ffh, 000h, 000h, 
 4081 affa: fe 3e 00 88 
            00 04 82 87             db  0feh, 03eh, 000h, 088h, 000h, 004h, 082h, 087h, 
 4082 b002: fe 30 3c 00 
            ff 00 00 9d             db  0feh, 030h, 03ch, 000h, 0ffh, 000h, 000h, 09dh, 
 4083 b00a: 88 00 04 90 
            87 fe 46 52             db  088h, 000h, 004h, 090h, 087h, 0feh, 046h, 052h, 
 4084 b012: 45 45 00 97 
            91 96 88 00             db  045h, 045h, 000h, 097h, 091h, 096h, 088h, 000h, 
 4085 b01a: 04 9f 87 fe 
            2b 21 00 8b             db  004h, 09fh, 087h, 0feh, 02bh, 021h, 000h, 08bh, 
 4086 b022: aa ab 8c 8b 
            ac 88 00 04             db  0aah, 0abh, 08ch, 08bh, 0ach, 088h, 000h, 004h, 
 4087 b02a: af 87 fe 2d 
            21 00 8b aa             db  0afh, 087h, 0feh, 02dh, 021h, 000h, 08bh, 0aah, 
 4088 b032: ab 8b 8d 8b 
            ac 88 00 04             db  0abh, 08bh, 08dh, 08bh, 0ach, 088h, 000h, 004h, 
 4089 b03a: be 87 fe 2a 
            21 00 8b aa             db  0beh, 087h, 0feh, 02ah, 021h, 000h, 08bh, 0aah, 
 4090 b042: ab 8e 8b ac 
            88 00 04 ce             db  0abh, 08eh, 08bh, 0ach, 088h, 000h, 004h, 0ceh, 
 4091 b04a: 87 fe 2f 21 
            00 8b aa ab             db  087h, 0feh, 02fh, 021h, 000h, 08bh, 0aah, 0abh, 
 4092 b052: 8b 8f 8b ac 
            88 00 04 de             db  08bh, 08fh, 08bh, 0ach, 088h, 000h, 004h, 0deh, 
 4093 b05a: 87 fe 43 2b 
            21 00 89 a2             db  087h, 0feh, 043h, 02bh, 021h, 000h, 089h, 0a2h, 
 4094 b062: ad 8c a1 ae 
            88 00 04 ef             db  0adh, 08ch, 0a1h, 0aeh, 088h, 000h, 004h, 0efh, 
 4095 b06a: 87 fe 43 2d 
            21 00 89 a2             db  087h, 0feh, 043h, 02dh, 021h, 000h, 089h, 0a2h, 
 4096 b072: ad 8b 8d a1 
            ae 88 00 05             db  0adh, 08bh, 08dh, 0a1h, 0aeh, 088h, 000h, 005h, 
 4097 b07a: 00 87 fe 40 
            2b 00 89 ab             db  000h, 087h, 0feh, 040h, 02bh, 000h, 089h, 0abh, 
 4098 b082: 8b ff 00 02 
            8c 8b 88 00             db  08bh, 0ffh, 000h, 002h, 08ch, 08bh, 088h, 000h, 
 4099 b08a: 05 0a 87 fe 
            3f 00 ab 91             db  005h, 00ah, 087h, 0feh, 03fh, 000h, 0abh, 091h, 
 4100 b092: 88 00 05 19 
            87 fe 4e 45             db  088h, 000h, 005h, 019h, 087h, 0feh, 04eh, 045h, 
 4101 b09a: 47 00 ff 00 
            00 8b 8d 88             db  047h, 000h, 0ffh, 000h, 000h, 08bh, 08dh, 088h, 
 4102 b0a2: 00 05 30 87 
            fe 4d 49 4e             db  000h, 005h, 030h, 087h, 0feh, 04dh, 049h, 04eh, 
 4103 b0aa: 00 fe 32 44 
            55 50 00 fe             db  000h, 0feh, 032h, 044h, 055h, 050h, 000h, 0feh, 
 4104 b0b2: 3e 00 83 8b 
            85 8a 88 00             db  03eh, 000h, 083h, 08bh, 085h, 08ah, 088h, 000h, 
 4105 b0ba: 05 45 87 fe 
            4d 41 58 00             db  005h, 045h, 087h, 0feh, 04dh, 041h, 058h, 000h, 
 4106 b0c2: fe 32 44 55 
            50 00 9d 83             db  0feh, 032h, 044h, 055h, 050h, 000h, 09dh, 083h, 
 4107 b0ca: 8b 85 8a 88 
            00 05 5e 87             db  08bh, 085h, 08ah, 088h, 000h, 005h, 05eh, 087h, 
 4108 b0d2: fe 55 4d 49 
            4e 00 fe 32             db  0feh, 055h, 04dh, 049h, 04eh, 000h, 0feh, 032h, 
 4109 b0da: 44 55 50 00 
            fe 55 3e 00             db  044h, 055h, 050h, 000h, 0feh, 055h, 03eh, 000h, 
 4110 b0e2: 83 8b 85 8a 
            88 00 05 74             db  083h, 08bh, 085h, 08ah, 088h, 000h, 005h, 074h, 
 4111 b0ea: 87 fe 55 4d 
            41 58 00 fe             db  087h, 0feh, 055h, 04dh, 041h, 058h, 000h, 0feh, 
 4112 b0f2: 32 44 55 50 
            00 9e 83 8b             db  032h, 044h, 055h, 050h, 000h, 09eh, 083h, 08bh, 
 4113 b0fa: 85 8a 88 00 
            05 83 87 fe             db  085h, 08ah, 088h, 000h, 005h, 083h, 087h, 0feh, 
 4114 b102: 3f 44 55 50 
            00 89 83 89             db  03fh, 044h, 055h, 050h, 000h, 089h, 083h, 089h, 
 4115 b10a: 85 88 00 05 
            99 87 fe 41             db  085h, 088h, 000h, 005h, 099h, 087h, 0feh, 041h, 
 4116 b112: 42 53 00 89 
            fe 30 3c 00             db  042h, 053h, 000h, 089h, 0feh, 030h, 03ch, 000h, 
 4117 b11a: 83 ff 00 00 
            8b 8d 85 88             db  083h, 0ffh, 000h, 000h, 08bh, 08dh, 085h, 088h, 
 4118 b122: 00 05 a5 87 
            fe 42 4c 00             db  000h, 005h, 0a5h, 087h, 0feh, 042h, 04ch, 000h, 
 4119 b12a: ff 00 20 88 
            00 05 b5 87             db  0ffh, 000h, 020h, 088h, 000h, 005h, 0b5h, 087h, 
 4120 b132: fe 53 50 41 
            43 45 00 ff             db  0feh, 053h, 050h, 041h, 043h, 045h, 000h, 0ffh, 
 4121 b13a: 00 20 a5 88 
            00 05 cb 87             db  000h, 020h, 0a5h, 088h, 000h, 005h, 0cbh, 087h, 
 4122 b142: fe 53 50 41 
            43 45 53 00             db  0feh, 053h, 050h, 041h, 043h, 045h, 053h, 000h, 
 4123 b14a: ff 00 00 98 
            ff 00 20 a5             db  0ffh, 000h, 000h, 098h, 0ffh, 000h, 020h, 0a5h, 
 4124 b152: 99 88 00 05 
            f1 87 fe 43             db  099h, 088h, 000h, 005h, 0f1h, 087h, 0feh, 043h, 
 4125 b15a: 4c 53 00 ff 
            00 1b a5 ff             db  04ch, 053h, 000h, 0ffh, 000h, 01bh, 0a5h, 0ffh, 
 4126 b162: 00 5b a5 ff 
            00 32 a5 ff             db  000h, 05bh, 0a5h, 0ffh, 000h, 032h, 0a5h, 0ffh, 
 4127 b16a: 00 4a a5 ff 
            00 1b a5 ff             db  000h, 04ah, 0a5h, 0ffh, 000h, 01bh, 0a5h, 0ffh, 
 4128 b172: 00 5b a5 ff 
            00 48 a5 88             db  000h, 05bh, 0a5h, 0ffh, 000h, 048h, 0a5h, 088h, 
 4129 b17a: 00 06 0d 87 
            fe 4c 53 48             db  000h, 006h, 00dh, 087h, 0feh, 04ch, 053h, 048h, 
 4130 b182: 49 46 54 00 
            89 81 8b ff             db  049h, 046h, 054h, 000h, 089h, 081h, 08bh, 0ffh, 
 4131 b18a: 00 02 8e 8b 
            ff 00 01 8d             db  000h, 002h, 08eh, 08bh, 0ffh, 000h, 001h, 08dh, 
 4132 b192: 89 82 8a 88 
            00 06 29 87             db  089h, 082h, 08ah, 088h, 000h, 006h, 029h, 087h, 
 4133 b19a: fe 52 53 48 
            49 46 54 00             db  0feh, 052h, 053h, 048h, 049h, 046h, 054h, 000h, 
 4134 b1a2: 89 81 8b ff 
            00 02 8f 8b             db  089h, 081h, 08bh, 0ffh, 000h, 002h, 08fh, 08bh, 
 4135 b1aa: ff 00 01 8d 
            89 82 8a 88             db  0ffh, 000h, 001h, 08dh, 089h, 082h, 08ah, 088h, 
 4136 b1b2: 00 06 3a 87 
            fe 49 4e 56             db  000h, 006h, 03ah, 087h, 0feh, 049h, 04eh, 056h, 
 4137 b1ba: 45 52 54 00 
            ff ff ff 95             db  045h, 052h, 054h, 000h, 0ffh, 0ffh, 0ffh, 095h, 
 4138 b1c2: 88 00 06 54 
            87 fe 53 47             db  088h, 000h, 006h, 054h, 087h, 0feh, 053h, 047h, 
 4139 b1ca: 4e 00 89 83 
            ff 80 00 93             db  04eh, 000h, 089h, 083h, 0ffh, 080h, 000h, 093h, 
 4140 b1d2: 83 ff ff ff 
            84 ff 00 01             db  083h, 0ffh, 0ffh, 0ffh, 084h, 0ffh, 000h, 001h, 
 4141 b1da: 85 85 88 00 
            06 66 87 fe             db  085h, 085h, 088h, 000h, 006h, 066h, 087h, 0feh, 
 4142 b1e2: 4d 4f 44 00 
            89 a8 89 a8             db  04dh, 04fh, 044h, 000h, 089h, 0a8h, 089h, 0a8h, 
 4143 b1ea: 8f a8 8e 8d 
            88 00 06 7a             db  08fh, 0a8h, 08eh, 08dh, 088h, 000h, 006h, 07ah, 
 4144 b1f2: 87 fe 2f 4d 
            4f 44 00 aa             db  087h, 0feh, 02fh, 04dh, 04fh, 044h, 000h, 0aah, 
 4145 b1fa: aa fe 4d 4f 
            44 00 a9 8f             db  0aah, 0feh, 04dh, 04fh, 044h, 000h, 0a9h, 08fh, 
 4146 b202: 88 00 06 8c 
            87 fe 47 45             db  088h, 000h, 006h, 08ch, 087h, 0feh, 047h, 045h, 
 4147 b20a: 54 42 49 54 
            00 c2 ff 00             db  054h, 042h, 049h, 054h, 000h, 0c2h, 0ffh, 000h, 
 4148 b212: 01 93 88 00 
            06 9f 87 fe             db  001h, 093h, 088h, 000h, 006h, 09fh, 087h, 0feh, 
 4149 b21a: 53 45 54 42 
            49 54 00 ff             db  053h, 045h, 054h, 042h, 049h, 054h, 000h, 0ffh, 
 4150 b222: 00 01 8b c1 
            94 88 00 06             db  000h, 001h, 08bh, 0c1h, 094h, 088h, 000h, 006h, 
 4151 b22a: b6 87 fe 43 
            4c 52 42 49             db  0b6h, 087h, 0feh, 043h, 04ch, 052h, 042h, 049h, 
 4152 b232: 54 00 ff 00 
            01 8b c1 ff             db  054h, 000h, 0ffh, 000h, 001h, 08bh, 0c1h, 0ffh, 
 4153 b23a: ff ff 95 93 
            88 00 06 c9             db  0ffh, 0ffh, 095h, 093h, 088h, 000h, 006h, 0c9h, 
 4154 b242: 87 fe 54 47 
            4c 42 49 54             db  087h, 0feh, 054h, 047h, 04ch, 042h, 049h, 054h, 
 4155 b24a: 00 ff 00 01 
            8b c1 95 88             db  000h, 0ffh, 000h, 001h, 08bh, 0c1h, 095h, 088h, 
 4156 b252: 00 06 e7 87 
            fe 42 59 54             db  000h, 006h, 0e7h, 087h, 0feh, 042h, 059h, 054h, 
 4157 b25a: 45 53 57 41 
            50 00 89 ff             db  045h, 053h, 057h, 041h, 050h, 000h, 089h, 0ffh, 
 4158 b262: 00 08 c2 8b 
            ff 00 ff 93             db  000h, 008h, 0c2h, 08bh, 0ffh, 000h, 0ffh, 093h, 
 4159 b26a: ff 00 08 c1 
            94 88 00 07             db  0ffh, 000h, 008h, 0c1h, 094h, 088h, 000h, 007h, 
 4160 b272: 01 87 fe 46 
            49 4c 4c 00             db  001h, 087h, 0feh, 046h, 049h, 04ch, 04ch, 000h, 
 4161 b27a: 8b a2 aa ae 
            89 fe 31 2b             db  08bh, 0a2h, 0aah, 0aeh, 089h, 0feh, 031h, 02bh, 
 4162 b282: 00 a1 fe 31 
            2d 00 af 88             db  000h, 0a1h, 0feh, 031h, 02dh, 000h, 0afh, 088h, 
 4163 b28a: 00 07 16 87 
            fe 45 52 41             db  000h, 007h, 016h, 087h, 0feh, 045h, 052h, 041h, 
 4164 b292: 53 45 00 ff 
            00 00 fe 46             db  053h, 045h, 000h, 0ffh, 000h, 000h, 0feh, 046h, 
 4165 b29a: 49 4c 4c 00 
            88 00 07 27             db  049h, 04ch, 04ch, 000h, 088h, 000h, 007h, 027h, 
 4166 b2a2: 87 fe 43 4c 
            45 41 52 00             db  087h, 0feh, 043h, 04ch, 045h, 041h, 052h, 000h, 
 4167 b2aa: a7 81 8a a7 
            82 88 00 07             db  0a7h, 081h, 08ah, 0a7h, 082h, 088h, 000h, 007h, 
 4168 b2b2: 60 87 fe 2e 
            53 00 b0 fe             db  060h, 087h, 0feh, 02eh, 053h, 000h, 0b0h, 0feh, 
 4169 b2ba: 3c 20 22 00 
            a7 ff 00 08             db  03ch, 020h, 022h, 000h, 0a7h, 0ffh, 000h, 008h, 
 4170 b2c2: a5 90 ff 00 
            08 a5 b0 fe             db  0a5h, 090h, 0ffh, 000h, 008h, 0a5h, 0b0h, 0feh, 
 4171 b2ca: 3e 20 22 00 
            a7 fe 3f 44             db  03eh, 020h, 022h, 000h, 0a7h, 0feh, 03fh, 044h, 
 4172 b2d2: 55 50 00 83 
            89 ff 00 00             db  055h, 050h, 000h, 083h, 089h, 0ffh, 000h, 000h, 
 4173 b2da: 98 89 92 8d 
            fe 50 49 43             db  098h, 089h, 092h, 08dh, 0feh, 050h, 049h, 043h, 
 4174 b2e2: 4b 00 90 99 
            8a 85 88 00             db  04bh, 000h, 090h, 099h, 08ah, 085h, 088h, 000h, 
 4175 b2ea: 07 7d 87 fe 
            54 59 50 45             db  007h, 07dh, 087h, 0feh, 054h, 059h, 050h, 045h, 
 4176 b2f2: 00 89 83 ff 
            00 00 98 89             db  000h, 089h, 083h, 0ffh, 000h, 000h, 098h, 089h, 
 4177 b2fa: ad a6 ff 00 
            01 8c 99 84             db  0adh, 0a6h, 0ffh, 000h, 001h, 08ch, 099h, 084h, 
 4178 b302: 8a 85 8a 88 
            00 07 c8 87             db  08ah, 085h, 08ah, 088h, 000h, 007h, 0c8h, 087h, 
 4179 b30a: fe 44 55 4d 
            50 00 96 ff             db  0feh, 044h, 055h, 04dh, 050h, 000h, 096h, 0ffh, 
 4180 b312: 00 05 fe 53 
            50 41 43 45             db  000h, 005h, 0feh, 053h, 050h, 041h, 043h, 045h, 
 4181 b31a: 53 00 ff 00 
            10 ff 00 00             db  053h, 000h, 0ffh, 000h, 010h, 0ffh, 000h, 000h, 
 4182 b322: 98 92 90 99 
            ff 00 00 98             db  098h, 092h, 090h, 099h, 0ffh, 000h, 000h, 098h, 
 4183 b32a: 96 89 90 ff 
            00 10 ff 00             db  096h, 089h, 090h, 0ffh, 000h, 010h, 0ffh, 000h, 
 4184 b332: 00 98 89 ad 
            90 fe 31 2b             db  000h, 098h, 089h, 0adh, 090h, 0feh, 031h, 02bh, 
 4185 b33a: 00 99 89 ff 
            00 10 8d ff             db  000h, 099h, 089h, 0ffh, 000h, 010h, 08dh, 0ffh, 
 4186 b342: 00 10 fe 54 
            59 50 45 00             db  000h, 010h, 0feh, 054h, 059h, 050h, 045h, 000h, 
 4187 b34a: ff 00 10 9a 
            8a 96 88 00             db  0ffh, 000h, 010h, 09ah, 08ah, 096h, 088h, 000h, 
 4188 b352: 00 00 00 00 
            00 00 00 00             db  000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h, 
 4189 b35a: 00 00 00 00 
            00 00 00 00             db  000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h, 
 4190 b362: 00 00 00 00 
            00 00 00 00             db  000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h, 
 4191 b36a: 00 00 00 00 
            00 00 00 00             db  000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h, 
 4192 b372: 00 00 00 00 
            00 00 00 00             db  000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h, 
 4193 b37a: 00 00 00 00 
            00 00 00 00             db  000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h, 
 4194 b382: 00 00 00 00 
            00 00 00 00             db  000h, 000h, 000h, 000h, 000h, 000h, 000h, 000h
 4195 b38a:             endextblock:
            #endif
 4197 b38a:             
 4198 b38a:             endrom:    equ     $
 4199 b38a:             
            #endif
 4212 b38a:             
 4213 b38a:                        end     start
 4214 b38a:             
 4215 b38a:             
 4216 b38a:                        
 4217 b38a:             

9fe0h: ASCERR           - <  1367>   1379 
9fe9h: ASCNOERR         - <  1372>   1366 
0317h: BASEN            - <   103>   1081   1258   3168   3173   3639   3656 
ae70h: BASEV            - <  4026>    427 
aabeh: BLOADLP          - <  3362>   3367   3369 
0200h: BUFFER           - <    95>    508    510    521    945    947   3211 
         3216   3226   3232   3397   3407   3491   3495   3661   3673   3687 
ffe0h: CALL             - <   142> 
a764h: CALLOT           - <  2772>   3993 
a76ah: CALLOTLP1        - <  2776>   2792 
a77ch: CALLOTNO         - <  2788>   2784   2786 
a783h: CALLOTYES        - <  2793>   2787 
a08eh: CAND             - <  1501>   3961 
a4f4h: CAT              - <  2320>   3985 
a1bfh: CBEGIN           - <  1745>   3973 
aaa0h: CBLOAD           - <  3350>   4010 
ab70h: CBYE             - <  3583>   4003 
a51dh: CCAT             - <  2351>   3987 
a52fh: CCEXCL           - <  2365>   3988 
a948h: CCMOVE           - <  3129>   3989 
a578h: CCOLON           - <  2423>   3949 
a0e8h: CCR              - <  1572>   3964 
a98dh: CDECIMAL         - <  3168>   4005 
aa64h: CDELAY           - <  3306>   4009 
a44eh: CDEPTH           - <  2186>   3981 
a7cdh: CDIV             - <  2851>   3957 
a133h: CDO              - <  1632>   3966 
a070h: CDOT             - <  1473>   3958 
a720h: CDOTQT           - <  2726>   3990 
a741h: CDOTQTDN         - <  2748>   2740 
a730h: CDOTQTLP         - <  2739>   2742   2747 
a02bh: CDROP            - <  1419>   3952 
a01ch: CDUP             - <  1409>   3951 
a86bh: CEF              - <  2989>   3999 
a871h: CEF1             - <  2992>   2990 
a875h: CEF2             - <  2994>   2992 
a879h: CEF3             - <  2996>   2994 
a87dh: CEF4             - <  2998>   2996 
a3f5h: CELSE            - <  2123>   3946 
a325h: CEMIT            - <  1982>   3979 
a332h: CEMITP           - <  1991>   3980 
a422h: CEQUAL           - <  2155>   3969 
a861h: CERROR           - <  2977>   3994 
a505h: CEXCL            - <  2334>   3986 
aa82h: CEXEC            - <  3327>   4013 
aa9dh: CEXEC0           - <  3343>   3340 
a7edh: CFORGET          - <  2875>   3996 
a9b9h: CGOTOXY          - <  3196>   4011 
a1fbh: CGTR             - <  1790>   3976 
a999h: CHEX             - <  3173>   4006 
a113h: CI               - <  1604>   3960 
a3ach: CIF              - <  2078>   3945 
a8dch: CINP             - <  3053>   3998 
a8ech: CINP2            - <  3061>   3058 
a8f5h: CINP3            - <  3065>   3062 
a8feh: CINP4            - <  3069>   3066 
a907h: CINP5            - <  3073>   3070 
a910h: CINP6            - <  3077>   3074 
a919h: CINP7            - <  3081>   3078 
a91fh: CINPD            - <  3084>   3060   3064   3068   3072   3076   3080 
a749h: CKEY             - <  2755>   3991 
a753h: CKEYQ            - <  2763>   3992 
a233h: CLESS            - <  1831>   3971 
ac7ah: CLIST            - <  3780>   4014 
ac80h: CLIST0           - <  3781>   3803 
ac93h: CLIST1           - <  3790>   3784   3787 
ab2dh: CLOAD            - <  3486>   4002 
a164h: CLOOP            - <  1672>   3967 
a1a0h: CLOOPDN          - <  1722>   1690 
ac55h: CLRMEMLP         - <  3742>   3747   3749 
ac49h: CLRSTACKS        - <  3739>    437 
aa0eh: CLSHIFT          - <  3247>   4007 
9e13h: CMDEND           - <  1019>    990 
9de6h: CMDLOOP          - <   981>   1014 
acf6h: CMDTABLE         - <  3869>    972    974   1912   1914   2698   2700 
ade0h: CMDVECS          - <  3943>   1305   1308 
a11ch: CMEM             - <  1610>   3965 
a052h: CMINUS           - <  1449>   3955 
a966h: CMOVELP          - <  3144>   3153 
a978h: CMOVERTN         - <  3154>   3148 
a971h: CMOVESTR         - <  3149>   3145   3147 
a49ch: CMROT            - <  2251>   3983 
a7b7h: CMUL             - <  2836>   3956 
a588h: COLONLP1         - <  2436>   2438 
a0ach: COR              - <  1525>   3962 
a884h: COUT             - <  3005>   3997 
a8a0h: COUT2            - <  3022>   3018 
a8aah: COUT3            - <  3027>   3023 
a8b4h: COUT4            - <  3032>   3028 
a8beh: COUT5            - <  3037>   3033 
a8c8h: COUT6            - <  3042>   3038 
a8d2h: COUT7            - <  3047>   3043 
a8d9h: COUT8            - <  3051>   3048 
a4cfh: COVER            - <  2291>   3984 
a1a6h: CPLOOP           - <  1725>   3968 
a034h: CPLUS            - <  1424>   3954 
a9aeh: CRAND            - <  3185>   4012 
a9a5h: CRAT             - <  3178>   3977 
a39ch: CREPEAT          - <  2064>   3944 
a1f5h: CRGT             - <  1785>   3975 
acdbh: CRLF             - <  3865>    542    544 
9c17h: CRLFOUT          - <   540>    520   1573   1939   1942   1956   1978 
         2533   2652 
a469h: CROT             - <  2211>   3982 
aa39h: CRSHIFT          - <  3276>   4008 
aadch: CSAVE            - <  3381>   4001 
a5b3h: CSEE             - <  2472>   3995 
a6b3h: CSEEFUNC         - <  2654>   2518 
a5deh: CSEE_SUB         - <  2511>   2494 
a5d4h: CSEE_SUB0        - <  2501>   3794 
a5b0h: CSEMI            - <  2469>   3950 
a97bh: CSETQ            - <  3157>   4000 
a926h: CSPAT            - <  3097>   4004 
a5dah: CSUB0            - <  2508>   2510 
a0eeh: CSWAP            - <  1576>   3953 
a41fh: CTHEN            - <  2153>   3947 
a07fh: CUDOT            - <  1487>   3959 
a26fh: CULESS           - <  1878>   3972 
a207h: CUNEQUAL         - <  1797>   3970 
a1ceh: CUNTIL           - <  1759>   3974 
a544h: CVARIABLE        - <  2379>   3948 
a350h: CWHILE           - <  2012>   3943 
a2a2h: CWORDS           - <  1912>   3978 
a2ddh: CWORDSDN         - <  1941>   1918 
a2f7h: CWORDSDN1        - <  1955> 
a2bfh: CWORDSF          - <  1926>   1921 
a2aeh: CWORDSLP         - <  1917>   1925   1936   1940 
a2ech: CWORDSLP2        - <  1948>   1975   1979 
a2fdh: CWORDSNOT        - <  1958>   1952   1954 
a0cah: CXOR             - <  1548>   3963 
9d5fh: D16LP1           - <   862>    855    857    877 
9e70h: DECNUM           - <  1086>   1078 
aa6eh: DELAYLP1         - <  3314>   3321   3323 
aa70h: DELAYLP2         - <  3315>   3317 
9c2ah: DISP             - <   558>   1924   1929   1932   1963   1967   1987 
         2008   2529   2594   2599   2645   2656   2660   2669   2717   2723 
         2746   3638   3648 
9d47h: DIV16            - <   845>   2865 
9d8bh: DIVGO            - <   893>    879    881 
9db1h: DIVNO            - <   927>    914 
9d8ah: DIVRET           - <   892>    884 
9d74h: DIVST            - <   878>    864    939 
9da5h: DIVYES           - <   915>    909 
a408h: ELSECNT          - <  2138>   2142   2145 
a401h: ELSELP1          - <  2134>   2139 
a40ch: ELSENIF          - <  2140>   2136 
a34ah: EMITPOUT         - <  2007>   2003 
b38ah: ENDEXTBLOCK      - <  4195>   3360 
b38ah: ENDROM           - <  4198> 
ac27h: ERR              - <  3712> 
a012h: ERROR            - <  1403>   1411   1421   1426   1433   1451   1458 
         1475   1489   1503   1510   1527   1534   1550   1557   1578   1585 
         1634   1641   1734   1761   1792   1799   1806   1833   1840   1880 
         1887   1984   1993   2014   2080   2157   2164   2213   2220   2227 
         2253   2260   2267   2293   2300   2322   2336   2343   2353   2367 
         2374   2390   2434   2483   2487   2737   2796   2799   2838   2845 
         2853   2860   2886   2890   2979   3007   3012   3055   3082   3131 
         3135   3139   3159   3198   3202   3249   3255   3278   3284   3308 
         3329 
9f76h: EXEC             - <  1288>    536   1330   1358   1386   1392   1399 
9fd5h: EXECASCII        - <  1359>   1294 
a011h: EXECDN           - <  1401>   1289 
9fc2h: EXECNUM          - <  1343>   1291 
9fadh: EXECRET          - <  1322>   1404   1406   2981 
9fbeh: EXECRMSG         - <  1335>   1371 
a007h: EXECVAR          - <  1393>   1376 
8003h: EXITADDR         - <   106>   3583 
ae8ah: EXTBLOCK         - <  4034>   3354   3360 
ac23h: FAILS            - <  3708>   3703   3705   3726   3731   3734 
00b3h: FALLOT           - <   289>    290 
0093h: FAND             - <   257>    258 
00abh: FAT              - <   281>    282 
009fh: FBEGIN           - <   269>    270 
00adh: FCAT             - <   283>    284 
00aeh: FCEXCL           - <   284>    285 
00afh: FCMOVE           - <   285>    286 
0087h: FCOLON           - <   245>    246 
0096h: FCR              - <   260>    261 
00a7h: FDEPTH           - <   277>    278 
008fh: FDIV             - <   253>    254 
0098h: FDO              - <   262>    263 
0090h: FDOT             - <   254>    255 
00b0h: FDOTQT           - <   286>    287   1036 
008ah: FDROP            - <   248>    249 
0089h: FDUP             - <   247>    248 
0084h: FELSE            - <   242>    243 
00a5h: FEMIT            - <   275>    276 
00a6h: FEMITP           - <   276>    277 
009bh: FEQUAL           - <   265>    266 
00b4h: FERROR           - <   290>    291 
00ach: FEXCL            - <   282>    283 
00b7h: FEXEC            - <   293>    294 
00b6h: FFORGET          - <   292>    293 
00a2h: FGTR             - <   272>    273 
0092h: FI               - <   256>    257 
0083h: FIF              - <   241>    242 
9cc3h: FINDCHK          - <   726>    735 
9cd3h: FINDFOUND        - <   736>    732 
9cbch: FINDGO           - <   719>    713    715 
9cach: FINDLP           - <   708>    751 
9ca5h: FINDNAME         - <   703>   1365   2486   2889 
9cdch: FINDNEXT         - <   742>    730 
a36ah: FINDREP          - <  2030>   2035 
9cbah: FINDRET          - <   717>    741 
00b1h: FKEY             - <   287>    288 
00b2h: FKEYQ            - <   288>    289 
009dh: FLESS            - <   267>    268 
00b8h: FLIST            - <   294> 
0099h: FLOOP            - <   263>    264 
0097h: FMEM             - <   261>    262 
008dh: FMINUS           - <   251>    252 
00a9h: FMROT            - <   279>    280 
008eh: FMUL             - <   252>    253 
a383h: FNDREP           - <  2043>   2040 
0094h: FOR              - <   258>    259 
a833h: FORGETD1         - <  2936>   2918 
a84bh: FORGETLP         - <  2960>   2965   2967 
a818h: FORGETLP1        - <  2912>   2934 
00aah: FOVER            - <   280>    281 
009ah: FPLOOP           - <   264>    265 
008ch: FPLUS            - <   250>    251 
00a3h: FRAT             - <   273>    274 
0306h: FREEMEM          - <    99>    356    428    527    949   1611   2396 
         2442   2823   2942   3385 
0082h: FREPEAT          - <   240>    241 
00a1h: FRGT             - <   271>    272 
00a8h: FROT             - <   278>    279 
00b5h: FSEE             - <   291>    292 
0088h: FSEMI            - <   246>    247 
0308h: FSTACK           - <   100>    403    486    583    609    622    634 
         1617   2187   3097 
008bh: FSWAP            - <   249>    250 
0085h: FTHEN            - <   243>    244 
0091h: FUDOT            - <   255>    256 
009eh: FULESS           - <   268>    269 
009ch: FUNEQUAL         - <   266>    267 
00a0h: FUNTIL           - <   270>    271 
0086h: FVARIABLE        - <   244>    245   2795 
0081h: FWHILE           - <   239>    240 
00a4h: FWORDS           - <   274>    275 
0095h: FXOR             - <   259>    260 
f830h: F_ASTODT         - <   211> 
f833h: F_ASTOTM         - <   212> 
ff5dh: F_ATOI           - <   177> 
ff00h: F_BOOT           - <   146> 
ff42h: F_BOOTIDE        - <   168> 
f800h: F_BREAD          - <   195> 
ff6ch: F_BRKTEST        - <   182> 
f806h: F_BTEST          - <   197> 
f803h: F_BTYPE          - <   196> 
ff33h: F_DIV16          - <   163> 
ff2ah: F_DRIVE          - <   160> 
f827h: F_DTTOAS         - <   209> 
ff6fh: F_FINDTKN        - <   183> 
ff57h: F_FREEMEM        - <   175>    352 
ff81h: F_GETDEV         - <   189> 
f815h: F_GETTOD         - <   202> 
ff45h: F_HEXIN          - <   169> 
ff48h: F_HEXOUT2        - <   170>   3680 
ff4bh: F_HEXOUT4        - <   171>   3677 
f824h: F_IDEID          - <   207> 
ff3ch: F_IDEREAD        - <   166> 
ff36h: F_IDERESET       - <   164> 
f821h: F_IDESIZE        - <   206> 
ff39h: F_IDEWRITE       - <   165> 
ff7bh: F_IDNUM          - <   187> 
ff3fh: F_INITCALL       - <   167>    313    316 
ff66h: F_INMSG          - <   180>   2520   2565   2612   2649   3207 
ff0fh: F_INPUT          - <   151>    516 
ff69h: F_INPUTL         - <   181> 
ff63h: F_INTOUT         - <   179>   3665 
ff78h: F_ISALNUM        - <   186> 
ff72h: F_ISALPHA        - <   184> 
ff75h: F_ISHEX          - <   185> 
ff5ah: F_ISNUM          - <   176> 
ff7eh: F_ISTERM         - <   188> 
ff15h: F_LTRIM          - <   153> 
ff1bh: F_MEMCPY         - <   155> 
ff54h: F_MINIMON        - <   174> 
ff51h: F_MOVER          - <   173> 
ff09h: F_MSG            - <   149>    338    506    550   1339   3218   3234 
         3689 
ff30h: F_MUL16          - <   162> 
f836h: F_NVRCCHK        - <   213> 
f81bh: F_RDNVR          - <   204> 
ff21h: F_RDSEC          - <   157> 
ff06h: F_READ           - <   148>    573 
f82dh: F_RTCTEST        - <   210> 
ff27h: F_SEEK           - <   159> 
ff24h: F_SEEK0          - <   158> 
ff2dh: F_SETBD          - <   161> 
f818h: F_SETTOD         - <   203> 
ff12h: F_STRCMP         - <   152> 
ff18h: F_STRCPY         - <   154> 
f82ah: F_TMTOAS         - <   208> 
ff4eh: F_TTY            - <   172>   3223   3239 
ff03h: F_TYPE           - <   147>    327    562 
ff0ch: F_TYPEX          - <   150> 
ff60h: F_UINTOUT        - <   178>   3213   3229   3668 
f80ch: F_UREAD          - <   199> 
f812h: F_USETBD         - <   201> 
f80fh: F_UTEST          - <   200> 
f809h: F_UTYPE          - <   198> 
fff9h: F_VERSION        - <   191> 
f81eh: F_WRNVR          - <   205> 
ff1eh: F_WRTSEC         - <   156> 
9c2eh: GETKEY           - <   569>   2756 
a017h: GOOD             - <  1405>   1417   1422   1485   1499   1574   1602 
         1669   1721   1724   1756   1768   1783   1795   1957   1988   2009 
         2049   2062   2076   2113   2121   2151   2153   2349   2377   2421 
         2467   2469   2495   2753   2834   2975   3021   3026   3031   3036 
         3041   3046   3051   3154   3163   3165   3171   3176   3241   3324 
         3419   3789 
a025h: GOODPUSH         - <  1414>   1445   1470   1522   1546   1569   1608 
         1628   1787   1820   1826   1870   1872   1907   1909   2179   2183 
         2208   2248   2288   2317   2331   2362   2760   2770   2848   2873 
         3001   3087   3123   3182   3191   3273   3302   3342 
accfh: HELLO            - <  3864>    330    332 
abfch: HEXBYTE          - <  3679>   3675 
9efah: HEXNUM           - <  1194>   1077   1084 
0300h: HIMEM            - <    96>    319    378    460    462   3412   3500 
a3cdh: IFCNT            - <  2100>   2106   2116   2119 
a3c6h: IFLP1            - <  2096>   2101 
a3f2h: IFNO             - <  2121>   2082   2084 
a3e4h: IFNOTELSE        - <  2114>   2104 
a3d1h: IFNOTIF          - <  2102>   2098 
a3dch: IFSAVE           - <  2108>   2120 
ac63h: INKEY            - <  3760>   2765 
ac2ah: ISHEX            - <  3721>   1246 
ac15h: ISNUM            - <  3701>   3722 
9e94h: ISNUMBER         - <  1110> 
030ah: JUMP             - <   101>   1295   1321   3330   3343 
a266h: LESS1            - <  1871>   1868 
a168h: LOOPCNT          - <  1675>   1743 
aa27h: LSHIFTLP         - <  3262>   3259   3270 
aa32h: LSHIFTRET        - <  3272>   3260 
9be7h: MAINLP           - <   498>    458    538   3374   3515 
9d20h: MDNORM           - <   809>    846 
9d37h: MDNORM2          - <   827>    819 
9d45h: MDNORM3          - <   837>    829 
9b43h: MEMDONE          - <   378> 
ace2h: MSEMPTY          - <  3867>   1331   1333 
acf0h: MSGERR           - <  3868>   1367   1369 
9ce8h: MUL16            - <   756>   2847 
9cfch: MULCONT          - <   771>    763    765 
9d17h: MULCONT2         - <   794>    777 
9cefh: MULLOOP          - <   762>    800 
9b12h: NEW              - <   314>    309 
9b8dh: NEXTBASE         - <   429>    434 
ac76h: NOKEY            - <  3775>   3766 
9e00h: NOMTCH1          - <  1006>   1010 
9e0ah: NOMTCH2          - <  1011>   1008 
9f4ah: NONNUMBER        - <  1257>   1099   1102   1169   1205   1211   1214 
9f5ch: NONNUMBER1       - <  1265>   1261   1263 
9dddh: NONWHITE         - <   972>    965 
9f46h: NOTHEXNUM        - <  1251> 
9b03h: NOTNEW           - <   310> 
9e47h: NOTOKEN          - <  1061>   1015 
9e88h: NOTOKEN1         - <  1097>   1092 
9e64h: NOTOKENBASE      - <  1080>   1065 
9e63h: NOTOKENBASEADJ   - <  1079>   1072 
9f5eh: NOTOKENLP        - <  1267>   1274 
9e5bh: NOTOKEN_0        - <  1073>   1069 
9f6bh: NOTOKWHT         - <  1275>   1272 
a348h: NOTPRINT         - <  2005>   1997   2000 
a371h: NOTREP           - <  2034>   2038   2042 
a375h: NOTWHILE         - <  2036>   2032 
9ee0h: NUMBERDN         - <  1170>   1157 
9eedh: NUMBERDN1        - <  1179>   1171   1240 
9ed9h: NUMBERERR        - <  1165>   1160   1163 
9e99h: NUMBERLP         - <  1114>   1164 
9bbdh: OLD              - <   460>    312 
ac20h: PASSES           - <  3706>   3724   3728   3733 
9c32h: POP              - <   582>   1410   1420   1425   1432   1450   1457 
         1474   1488   1502   1509   1526   1533   1549   1556   1577   1584 
         1633   1640   1733   1760   1791   1798   1805   1832   1839   1879 
         1886   1983   1992   2013   2079   2156   2163   2212   2219   2226 
         2252   2259   2266   2292   2299   2321   2335   2342   2352   2366 
         2373   2798   2837   2844   2852   2859   2978   3006   3011   3054 
         3130   3134   3138   3158   3197   3201   3248   3254   3277   3283 
         3307   3328 
9c4dh: POPRET           - <   602>    617 
acdeh: PROMPT           - <  3866>    498    500 
9c61h: PUSH             - <   622>   1353   1394   1413   1416   1595   1601 
         2237   2243   2277   2283   2306   2312 
acaeh: RANDBYTE         - <  3831>   3186 
fff1h: RET              - <   143> 
9c77h: RPOP             - <   648>   1605   1673   1680   1696   1723   1726 
         1767   1770   1786   2065   3179 
9c8fh: RPUSH            - <   673>   1607   1656   1662   1668   1698   1714 
         1720   1755   1772   1794   2061   3181 
02f0h: RSEED            - <   104>    442    450   3831 
aa52h: RSHIFTLP         - <  3291>   3288   3299 
aa5dh: RSHIFTRET        - <  3301>   3289 
0302h: RSTACK           - <    97>    387    470    649    660    673    685 
0004h: SCALL            - <   139>    323    334    351    502    512    519 
          522    524    535    546    558    569    845   1245   1335   1352 
         1364   1385   1393   1409   1412   1415   1419   1424   1431   1449 
         1456   1473   1478   1487   1492   1501   1508   1525   1532   1548 
         1555   1572   1576   1583   1594   1600   1604   1606   1632   1639 
         1655   1661   1667   1672   1679   1695   1697   1713   1719   1722 
         1725   1732   1754   1759   1766   1769   1771   1785   1790   1793 
         1797   1804   1831   1838   1878   1885   1923   1928   1931   1938 
         1941   1955   1962   1966   1977   1982   1986   1991   2007   2012 
         2060   2064   2078   2155   2162   2211   2218   2225   2236   2242 
         2251   2258   2265   2276   2282   2291   2298   2305   2311   2320 
         2334   2341   2351   2365   2372   2485   2493   2519   2528   2532 
         2561   2564   2582   2593   2598   2606   2611   2637   2644   2648 
         2651   2655   2659   2668   2690   2716   2722   2745   2755   2764 
         2797   2836   2843   2846   2851   2858   2864   2888   2977   3005 
         3010   3053   3129   3133   3137   3157   3178   3180   3185   3196 
         3200   3206   3212   3217   3222   3228   3233   3238   3247   3253 
         3276   3282   3306   3327   3339   3383   3405   3413   3415   3489 
         3493   3501   3637   3647   3664   3667   3676   3679   3688   3721 
         3793 
a6afh: SEEEXIT          - <  2651>   2662 
a6b9h: SEEFUNCLP        - <  2658>   2673 
a700h: SEELP3           - <  2708>   2711 
a6d3h: SEENEXT          - <  2672>   2667   2697   2724 
a6d7h: SEENOTA          - <  2674>   2664 
a6f1h: SEENOTN          - <  2698>   2676 
a6fbh: SEENOTNLP        - <  2705>   2710 
a63ch: SEESTO           - <  2574>   2620   2622 
a6c8h: SEESTRLP         - <  2666>   2671 
a717h: SEETKLAST        - <  2720>   2714 
a709h: SEETOKEN         - <  2712>   2707   2719 
a619h: SEEVALLOT        - <  2552> 
a664h: SEEVDATA         - <  2596>   2592 
a605h: SEEVEQ           - <  2531>   2527 
a6a9h: SEEVEQ1          - <  2647>   2643 
a5fah: SEEVNAME         - <  2524>   2530 
a6a0h: SEEVNAME1        - <  2640>   2646 
a65bh: SEEVNAMEA        - <  2589>   2595 
a692h: SEEVNOA          - <  2626>   2551 
a989h: SETQNO           - <  3164>   3161 
0005h: SRET             - <   140>    553    564    575    603    641    668 
          692    718    770    838    861    892   1281   1341   1401   2624 
         2653   3624   3691   3710   3713 
01ffh: STACK            - <   105>    311    314 
9c4fh: STACKOK          - <   604>    595    600 
9b21h: START            - <   319>    315   4213   4213 
030dh: STORAGE          - <   102>    358    361    411    413    703    705 
         1943   1945   2772   2774   3780 
9e3ch: TDOTQTDN         - <  1047>   1044 
9e30h: TDOTQTLP         - <  1040>   1046 
9dc0h: TKNIZER          - <   945>    525 
9f23h: TOHEX            - <  1219>   1215 
9f26h: TOHEXAD          - <  1221>   1218 
9f2ah: TOHEXAL          - <  1224>   1232 
9f1dh: TOHEXD           - <  1216>   1208 
9f02h: TOHEXLP          - <  1203>   1247 
9f72h: TOKENDN          - <  1279>    963 
9dd0h: TOKENLP          - <   962>    967   1037   1054   1188   1278 
9deah: TOKLOOP          - <   988>    998 
9dfch: TOKNOMTCH        - <  1002>    995   1024   1028 
0304h: TOS              - <    98>    395    478    589   2193 
ab73h: TOUC             - <  3610>    523   3623   3629 
ab8fh: TOUC_DN          - <  3624>   3614   3627 
ab8bh: TOUC_NXT         - <  3622>   3616   3618 
ab91h: TOUC_QLP         - <  3626>   3630 
ab90h: TOUC_QT          - <  3625>   3612 
abe8h: TYPEHEX          - <  3671>   3659 
abbeh: TYPENUM          - <  3653>   1479   1493 
ab9dh: TYPENUMIND       - <  3634>   2562   2583   2607   2638   2691 
abb4h: TYPENUMINDDEC    - <  3645>   3642 
abe2h: TYPENUMU         - <  3667>   3663 
abc2h: TYPENUMX         - <  3655>   3651 
abffh: TYPEOUT          - <  3682>   3666   3669   3678 
00feh: T_ASCII          - <   297>   1039   1266   1293   2389   2433   2482 
         2663   2736   2885 
00ffh: T_NUM            - <   296>   1179   1290   2675 
a299h: ULESS1           - <  1908>   1905 
a22bh: UNEQUAL          - <  1822>   1812   1817 
a447h: UNEQUAL2         - <  2180>   2170   2175 
a1dch: UNTILNO          - <  1766>   1763 
a1e2h: UNTILYES         - <  1769>   1765 
a554h: VARLP1           - <  2392>   2393 
a38ch: WHILENO          - <  2050>   2016   2018 
a2ffh: WORDSNOTL        - <  1960>   1964 
a309h: WORDSNXT         - <  1965>   1961 
ed0fh: XCLOSER          - <    94> 
ed0ch: XCLOSEW          - <    93>   3416 
ed03h: XOPENR           - <    90>   3490 
ed00h: XOPENW           - <    89>   3384 
ed06h: XREAD            - <    91>   3494   3502 
ed09h: XWRITE           - <    92>   3406   3414 

4217 Lines assembled
0 Errors
430 Labels
Object Code:6282 bytes

