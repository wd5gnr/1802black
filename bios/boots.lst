0001   0000             	.TITLE	 "BTS1802 -- Monitor for the COSMAC Elf 2000"
0002   0000             ;	 Bob Armstrong [14-Jun-82]
0003   0000             
0004   0000             ;       Copyright (C) 2004-2020 By Spare Time Gizmos, Milpitas CA.
0005   0000             ;	Copyright (C) 1982 By Robert Armstrong, Indianapolis, IN.
0006   0000             
0007   0000             ;   This program is free software; you can redistribute it and/or modify
0008   0000             ; it under the terms of the GNU General Public License as published by
0009   0000             ; the Free Software Foundation; either version 2 of the License, or
0010   0000             ; (at your option) any later version.
0011   0000             ;
0012   0000             ;   This program is distributed in the hope that it will be useful, but
0013   0000             ; WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
0014   0000             ; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
0015   0000             ; for more details.
0016   0000             ;
0017   0000             ;   You should have received a copy of the GNU General Public License along
0018   0000             ; with this program; if not, write to the Free Software Foundation, Inc.,
0019   0000             ; 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
0020   0000             
0021   0000             ;     BBBBBBBB	      OOOOOO	    OOOOOO	TTTTTTTTTT	SSSSSS
0022   0000             ;     BBBBBBBBB	     OOOOOOOO	   OOOOOOOO	TTTTTTTTTT     SSSSSSSS
0023   0000             ;     BB      BB    OO	    OO	  OO	  OO	    TT	      SS      SS
0024   0000             ;     BB      BB    OO	    OO	  OO	  OO	    TT	      SS      SS
0025   0000             ;     BB      BB    OO	    OO	  OO	  OO	    TT	      SS
0026   0000             ;     BB      BB    OO	    OO	  OO	  OO	    TT	      SS
0027   0000             ;     BBBBBBBB	    OO	    OO	  OO	  OO	    TT	       SSSSSSS
0028   0000             ;     BBBBBBBB	    OO	    OO	  OO	  OO	    TT		SSSSSSS
0029   0000             ;     BB      BB    OO	    OO	  OO	  OO	    TT		      SS
0030   0000             ;     BB      BB    OO	    OO	  OO	  OO	    TT		      SS
0031   0000             ;     BB      BB    OO	    OO	  OO	  OO	    TT	      SS      SS
0032   0000             ;     BB      BB    OO	    OO	  OO	  OO	    TT	      SS      SS
0033   0000             ;     BBBBBBBBB	     OOOOOOOO	   OOOOOOOO	    TT	       SSSSSSSS
0034   0000             ;     BBBBBBBB	      OOOOOO	    OOOOOO	    TT		SSSSSS
0035   0000             ;
0036   0000             ;
0037   0000             ;   This is a multi-propose piece of software which lives in the EPROM of the
0038   0000             ; Spare Time Gizmos COSMAC Elf 2000.  First of all, it's a diagnostic tool -
0039   0000             ; it contains a power on self test (POST) that performs a basic test of the
0040   0000             ; Elf 2000 components (e.g. an EPROM checksum test, a simple terminal test, 
0041   0000             ; etc), and commands for more in-depth tests of individual Elf subsections 
0042   0000             ; (e.g. a CDP1861 Pixie test, an extensive RAM diagnostic, etc).
0043   0000             ;
0044   0000             ;   It contains a simple monitor with a "bit banged" serial terminal interface
0045   0000             ; that allows you to examine and change memory bytes, fill RAM with a constant,
0046   0000             ; checksum or move blocks of RAM from one address to another, and start running
0047   0000             ; a user program.  The monitor also contains a rudimentary breakpoint function
0048   0000             ; which allows you to place breakpoints in a user program, stop and examine
0049   0000             ; memory or registers, and then continue.  Finally, the monitor allows Intel
0050   0000             ; HEX file records to be downloaded directly from a PC - just send the HEX file
0051   0000             ; lines over the serial port and the monitor will decode them and deposit the
0052   0000             ; data in 1802 memory.
0053   0000             ;
0054   0000             ;   The EPROM image also contains several small but useful 1802 programming 
0055   0000             ; languages from Mike Riley, including Forth, BASIC, and an editor/assembler.
0056   0000             ; These languages can be easily bootstrapped with a single command, and
0057   0000             ; programs stored in the nonvolatile RAM of the Elf 2000 will not be lost when
0058   0000             ; power is turned off.
0059   0000             
0060   0000             ;0000000001111111111222222222233333333334444444444555555555566666666667777777777
0061   0000             ;1234567890123456789012345678901234567890123456789012345678901234567890123456789
0062   0000             
0063   0000             	.MSFIRST \ .PAGE \ .CODES
0063   0000             
TASM 1802 Assembler.              boots.asm                        page 1
BTS1802 -- Monitor for the COSMAC Elf 2000

0063   0000             
0064   0000             
0070   0000             	.LIST
0071   0000             	
TASM 1802 Assembler.              boots.asm                        page 12
BTS1802 -- Monitor for the COSMAC Elf 2000

0072   0000             	.EJECT
0073   0000             ;++
0074   0000             ; REVISION HISTORY
0075   0000             ;
0076   0000             ; 001	-- Convert from SMILE to TASM assembly language.
0077   0000             ;
0078   0000             ; 002	-- Change memory layout to low RAM/high ROM.  Add entry vectors page.
0079   0000             ;
0080   0000             ; 003	-- Add a super simple POST with a memory test...
0081   0000             ;
0082   0000             ; 004	-- Add DIVIDE and TDEC16 to type 16 bit unsigned decimal values...
0083   0000             ;
0084   0000             ; 005	-- Add Intel Hex file downloads.
0085   0000             ;
0086   0000             ; 006   -- Make SCRT preserve both D and DF...  Change INCHRW/OUTCHR to pass
0087   0000             ;	   ASCII characters in D (to conform to TB calling conventions).  Add
0088   0000             ;	   BRKCHK...
0089   0000             ;
0090   0000             ; 007	-- Add rudimentary breakpoint support.
0091   0000             ;
0092   0000             ; 008	-- Fix BREAK routine to conform to TB standards.  Add INCHWE function
0093   0000             ;	   (input character with wait and echo) for Tiny Basic...
0094   0000             ;
0095   0000             ; 009	-- Change the breakpoint procedure to make the MARK instruction the
0096   0000             ;	   responsibility of the caller (a breakpoint now requrires two
0097   0000             ;	   bytes - $79, $D1).  This allows us to save both X and P, and
0098   0000             ;	   makes it possible to continue.
0099   0000             ;
0100   0000             ; 010	-- Make the E(xamine) command print both hex and ASCII...
0101   0000             ;
0102   0000             ; 011	-- Add basic support for the CDP1861 (in 64x32 resolution mode) and
0103   0000             ; 	   add a copy of the famous "Starship Enterprise" picture for testing.
0104   0000             ;
0105   0000             ; 012	-- Integrate with Mike Riley's ElfOS BIOS....
0106   0000             ;
0107   0000             ; 013	-- Add BASIC, LISP and Forth commands...
0108   0000             ;
0109   0000             ; 014	-- Add RUN, CALL and CONTINUE commands...
0110   0000             ;
0111   0000             ; 015	-- Add exhaustive RAMTEST function.  Rewrite startup code to size
0112   0000             ;	   SRAM only rather than testing all of memory.  Now we do a trivial
0113   0000             ;	   memory test on the monitor's data page (RAMPAGE) only...
0114   0000             ;
0115   0000             ; 016	-- Disable interrupts on boot, and then re-enable (and disable)
0116   0000             ;	   interrupts as needed for the video test...
0117   0000             ;
0118   0000             ; 017	-- Make sure that R0 is always cleared by the CONTinue command (it
0119   0000             ;	   breaks Tiny BASIC if it isn't!!)...
0120   0000             ;
0121   0000             ; 020	-- Add "For help type HELP." message and (it seems only fair!) add
0122   0000             ;	   the "HELP" command...
0123   0000             ;
0124   0000             ; 021	-- Mark's latest BIOS no longer requires a DEC P1 after F_HEXIN...
0125   0000             ;
0126   0000             ; 022	-- If the switches are 0x81 on bootup, then bypass any console
0127   0000             ;	   interaction and go directly to the video test...
0128   0000             ;
0129   0000             ; 023	-- Integrate new BIOS from Mike which fixes the hex number input
0130   0000             ;	   problem!
TASM 1802 Assembler.              boots.asm                        page 13
BTS1802 -- Monitor for the COSMAC Elf 2000

0131   0000             ;
0132   0000             ; 024	-- Add IN[PUT] and OUT[PUT] commands to test I/O ports...
0133   0000             ;
0134   0000             ; 025	-- Add SEQ, REQ and EF commands...
0135   0000             ;
0136   0000             ; 026	-- Add initialization and POST code for the ELFDISK board UART.
0137   0000             ;
0138   0000             ; 027	-- Add intialization and POST code for the ELFDISK board NVR/RTC..
0139   0000             ;
0140   0000             ; 028	-- If the NVR is installed, print the current date/time on boot.
0141   0000             ;
0142   0000             ; 029	-- During initialization, probe for any attached IDE drives and, if
0143   0000             ;	   any are found, initialize them...
0144   0000             ;
0145   0000             ; 030	-- Force RAM initialization (and autobaud!) if the switches are set
0146   0000             ;	   to 0x42 ("0100 0010") during startup.
0147   0000             ;
0148   0000             ; 031	-- Fix up a few error messages that were being corrupted by the
0149   0000             ; 	   INLMES() macro bug....
0150   0000             ;
0151   0000             ; 032	-- Add the DA[TIME] command to set and show the RTC...
0152   0000             ;
0153   0000             ; 033	-- Use f_input instead of f_inputl so that the user can't overflow
0154   0000             ;	   the command buffer...
0155   0000             ;
0156   0000             ; 034	-- Change some of the BIOS error returns to be more consistent about
0157   0000             ;	   using DF.
0158   0000             ;
0159   0000             ; 035	-- Hack up NVR code to reset the UART (yes, that's right!)
0160   0000             ;
0161   0000             ; 036	-- Rewrite UART self test so that it actually works...
0162   0000             ;
0163   0000             ; 037	-- Remove main board UART polarity test (POST 18) and substitute
0164   0000             ;	   NVR initialization (when switches are set to 0x43) instead!
0165   0000             ;
0166   0000             ; 038	-- Invent the SET, SHOW and TEST commands and group various less used
0167   0000             ;	   commands (e.g. TEST RAM, SHOW RTC, SET Q, etc) together under them.
0168   0000             ;
0169   0000             ; 040   -- Purge the code for a lot od dead commands (e.g. P1, P2, DSKRD, NVRRD,
0170   0000             ;	   and stuff like that)...
0171   0000             ;
0172   0000             ; 040	-- Add the SET RESTART [ffff | BOOT | NONE] command.
0173   0000             ;
0174   0000             ; 041	-- Update the HELP text...
0175   0000             ;
0176   0000             ; 042	-- Allow the MEMDMP routine (used to generate the output from the E
0177   0000             ;	   command) to terminate early if the user presses BREAK on the console.
0178   0000             ;
0179   0000             ; 043	-- Remove the LISP command, and add the ASM command...
0180   0000             ;
0181   0000             ; 044	-- Adding the call to TTYINI accidentally broke the TRAP routine.
0182   0000             ;	   Move the TTYINI call to a more prudent location!
0183   0000             ;
0184   0000             ; 045	-- Add more SHOW commands - TERMINAL, VERSION, MEMORY, and RESTART.
0185   0000             ;
0186   0000             ; 046	-- On a cold start, only clear the monitor's data page to zero,
0187   0000             ;	   instead of clearing all of memory...
0188   0000             ;
0189   0000             ; 047	-- Add a switch combination to force SRAM, NVR or both to be initalized
TASM 1802 Assembler.              boots.asm                        page 14
BTS1802 -- Monitor for the COSMAC Elf 2000

0190   0000             ; 	   on startup.  Startup switch combinations....
0191   0000             ;
0192   0000             ;		1 0 0 0   0 0 0 1 - Special CHM startup mode
0193   0000             ;		0 1 0 0   0 0 1 0 - force SRAM to be initialized
0194   0000             ;		0 1 0 0   0 0 1 1 - force SRAM and NVR both to be initialized
0195   0000             ;
0196   0000             ; 048	-- Eliminate garbage characters after "Booting Primary IDE..." message.
0197   0000             ;
0198   0000             ; 049	-- Add Mike's SEDIT (Sector EDIT) program to the ROM...
0199   0000             ;
0200   0000             ; 050	-- Add monitor warm start vector at $8003.  Move Tiny BASIC vectors
0201   0000             ;	   down by three...
0202   0000             ;
0203   0000             ; 051	-- Allow the BOOT command to be abbreviated to just "B"...
0204   0000             ;
0205   0000             ; 052	-- Add the "SHOW REGISTERS" command...
0206   0000             ;
0207   0000             ; 053	-- Give a better error message for the "SET Q" command when the Q
0208   0000             ;	   output is being used for the console serial port...
0209   0000             ;
0210   0000             ; 054	-- Fix a spelling error in the help text ("INTEL" not "INTEX"). Rewrite
0211   0000             ;	   the help to include all the new monitior commands and to still (I
0212   0000             ;	   hope!) look reasonably pretty...
0213   0000             ;
0214   0000             ; 055	-- Disallow (give an error message for) SET, SHOW and TEST commands
0215   0000             ;	   without any argument...
0216   0000             ;
0217   0000             ; 056	-- Allow a BREAK on the console to interrupt the video and/or RAM test.
0218   0000             ;
0219   0000             ; 057	-- Fix a spelling error (it's that ***#$$# INLMES bug!) in VIDEO...
0220   0000             ;
0221   0000             ; 058	-- Remove some unused Tiny BASIC vectors...
0222   0000             ;
0223   0000             ; 059	-- Ignore any command lines that are terminated by ^C...
0224   0000             ;
0225   0000             ; 060	-- Fix SETQ, which was broken by edit 053 (don't ever confuse RET with
0226   0000             ;	   RETURN!!)
0227   0000             ;
0228   0000             ; 061	-- Change BATTERY OK message to CONTENTS OK to avoid confusion.
0229   0000             ;
0230   0000             ; 062	-- Change the TEST VIDEO command to TEST PIXIE (to avoid confusion
0231   0000             ;	   with the 80 column video card).  Change some internal labels from
0232   0000             ;	   VIDEOxx to PIXIExx for the same reason...
0233   0000             ;
0234   0000             ; 063	-- Change the POST for SCRT initialization to 40, and then call the
0235   0000             ;	   8275 video POST/initialization from the SYSINI code.  Note that
0236   0000             ;	   this has to happen AFTER SCRT is initialized!
0237   0000             ;
0238   0000             ; 064   -- Relocate DSKBUF so that it's below the screen buffer!
0239   0000             ;
0240   0000             ; 065	-- Add the POST for the GPIO card PS/2 keyboard interface.
0241   0000             ;
0242   0000             ; 066	-- When the video card is active, disallow RUN and CONTINUE commands.
0243   0000             ;
0244   0000             ; 067	-- Don't load RLDI(1,TRAP) at MAIN1 if video is in use.
0245   0000             ;
0246   0000             ; 068	-- If the NVR says to restart at an address and the video is active,
0247   0000             ;	   then just ignore it and go to MAIN0.  Also disallow the SET RESTART
0248   0000             ;	   xxxx form when video is active.  These are both impossible because
TASM 1802 Assembler.              boots.asm                        page 15
BTS1802 -- Monitor for the COSMAC Elf 2000

0249   0000             ;	   the ASTART1 code uses R0 to restart the user's program.
0250   0000             ;
0251   0000             ; 069	-- Change the TEST VIDEO command to TEST PIXIE to avoid confusion.
0252   0000             ;	   Disallow this command if the real Elf 80 column video card is
0253   0000             ;	   in use...
0254   0000             ;
0255   0000             ; 070	-- The help text for SET DATIME is wrong - the format should be
0256   0000             ;	   mm/dd/yyyy, not dd/mm/yyyy...
0257   0000             ;
0258   0000             ; 071	-- Update the copyright notices for 2006...
0259   0000             ;
0260   0000             ; 072	-- If the video card and PS2 keyboard is in use, make the SHOW TERMINAL
0261   0000             ;	   command report the VT52 emulator and PS2 APU firmware versions.
0262   0000             ;
0263   0000             ; 073	-- Make the TEST RAM command respect the frame buffer when the video
0264   0000             ;	   card is in use.  Display the number of bytes to be tested before
0265   0000             ;	   starting.  Display the pass count on the LEDs too.
0266   0000             ;
0267   0000             ; 074	-- If there's no PS/2 keyboard or VT1802 video installed, then don't
0268   0000             ;	   use as the console even if the NVR says to!  Likewise, if there's
0269   0000             ;	   no UART installed then don't use it as the console even if the
0270   0000             ;	   NVR says to!
0271   0000             ;
0272   0000             ; 075	-- Add the SHOW CPU command to report the CPU type and speed.
0273   0000             ;
0274   0000             ; 076	-- Add POST functions for the PPI and SPEAKER options...
0275   0000             ;
0276   0000             ; 077	-- Add post code $10 for auto IDE boot, and add text error message for
0277   0000             ;	   autoboot failure...
0278   0000             ;
0279   0000             ; 078	-- Turns out that TASM limits any macro argument to a maximum of 16
0280   0000             ;	   characters, which is something of a problem for INLMES()...  Go
0281   0000             ;	   thru the BOOTS source and fix a few INLMES calls that are broken.
0282   0000             ;
0283   0000             ; 079	-- Use the master memory configuration file, config.inc, which is
0284   0000             ;	   generated by the Makefile.  Also, now we use the same bios
0285   0000             ;	   definitions that Mike does, from bios.inc..
0286   0000             ;
0287   0000             ; 080	-- Move help text into a separate file, HELP.TXT.  This gets "compiled"
0288   0000             ;	   by the ROMTEXT program and then merged into the EPROM image...
0289   0000             ;
0290   0000             ; 081	-- Implement the "SET NVR DEFAULT" command...
0291   0000             ;
0292   0000             ; 082	-- When the VT1802 is in use, have the "SHOW TERMINAL" command print
0293   0000             ;	   the VT1802 firmware identification string directly from the VT1802
0294   0000             ;	   code.  A pointer to this string is stored in entry vector 3 of the
0295   0000             ;	   VT1802 firmware.
0296   0000             ;
0297   0000             ; 083	-- Add "more" style pagination to the HELP command when the VT1802
0298   0000             ;	   is used.  For all other terminals, we just do the same as before.
0299   0000             ;
0300   0000             ; 084	-- Add the "TEST VT1802" command to display a test pattern on the
0301   0000             ;	   VT1802 screen.
0302   0000             ;
0303   0000             ; 085	-- Add the CLS command to clear the VT1802 screen.
0304   0000             ;
0305   0000             ; 086	-- Make the POST for the speaker generate a short tone.
0306   0000             ;
0307   0000             ; 087	-- Shorten SCANP1 slightly (it contains some stupid code).
TASM 1802 Assembler.              boots.asm                        page 16
BTS1802 -- Monitor for the COSMAC Elf 2000

0308   0000             ;
0309   0000             ; 088	-- ISCRTC/NOCRTC breaks the RUN command (and probably others) because
0310   0000             ; 	   it trashes P1.  ISCRTC really should use T1 instead.  Thanks go to
0311   0000             ;	   Dave Ruske for figuring this one out.
0312   0000             ;
0313   0000             ;	   Also change "Joeseph Weisberger..." to "Weisbecker" ...
0314   0000             ;
0315   0000             ; 089	-- Sprinkle some "#ifdef VIDEO" around here and there so that BOOTS can
0316   0000             ; 	   actually assemble without the VT1802 video support.
0317   0000             ;
0318   0000             ; 090	-- Start porting to the Pico/Elf by adding some "#ifdef ELF2K"s ...
0319   0000             ;
0320   0000             ; 091	-- Put the CDP1861/PIXIE code under "#ifdef PIXIE" ...
0321   0000             ;
0322   0000             ; 092	-- Add "VIsual" command to invoke Mike's Visual/02 ...
0323   0000             ;
0324   0000             ; 093   -- Update Mike's copyright notice .
0325   0000             ;
0326   0000             ; 094	-- Make SHOW RTC give an error if the RTC isn't installed ...
0327   0000             ;
0328   0000             ; 095	-- SHOW RTC and SHOW CPU need to use NVR_SELECT/NVR_DATA ports ...
0329   0000             ;
0330   0000             ; 096	-- Add the PicoElf style NVR/RTC/UART reset code ...
0331   0000             ;
0332   0000             ; 097	-- Change "SHOW RTC" to "SHOW NVR" ...
0333   0000             ;	   Also make SHOW NVR show the size and checksum as well ...
0334   0000             ;
0335   0000             ; 098	-- In PROBE: make sure the model number string is null terminated.
0336   0000             ;	   Apparently some manufacturers don't bother!
0337   0000             ;
0338   0000             ; 099	-- Fix a BIOS bug in the software serial that always set the MSB of
0339   0000             ;	   echoed characters ...
0340   0000             ;
0341   0000             ; 100	-- Change most of the short branch (BR/BZ/BDF/...) to the long form.
0342   0000             ;	   This eliminates a lot of "off page" errors caused by the various
0343   0000             ;	   assembly options.  There are still a few short branches left.
0344   0000             ;
0345   0000             ; 101	-- Rearrange the code at SYSINI so the DIS is first, then the POST.
0346   0000             ;
0347   0000             ; 102	-- When booting IDE, distinguish hardware errors from non-bootable
0348   0000             ;	   volumes.  Also remove the "AUTOBOOT FAIL" message from the
0349   0000             ;	   startup code - there are already error messages for booting.
0350   0000             ;
0351   0000             ; 103   -- Extensive rewrites for the restart logic - Use constants ABTNONE,
0352   0000             ;	   ABTDISK and ABTADDR for BOOTF.  None of these are zero and none are
0353   0000             ;	   0xFF to avoid any uexpected results when clearing NVR!
0354   0000             ;
0355   0000             ; 104	-- Clean up the TTYINI code a little bit to ensure that BAUD1/0 values
0356   0000             ;	   of $FF/$FF (what you get after initializing NVR!) will autobaud.
0357   0000             ;
0358   0000             ; 105	-- Store the monitor version (MONVER) in NVR.  Check it on startup at
0359   0000             ;	   SYSIN3 and force NVR to be initialized if it doesn't match ours.
0360   0000             ;
0361   0000             ; 106	-- For SET RESTART xxxx, set both X and P to zero before jumping.
0362   0000             ;	   Also print "RESTART @xxxx" during boot to make it clear ...
0363   0000             ;
0364   0000             ; 107	-- The BIOS serial output sense (i.e. SEQ/REQ) is reversed on the Elf2K.
0365   0000             ;
0366   0000             ; 108   -- Change SET/SHOW DATIME to SET/SHOW DATE.
TASM 1802 Assembler.              boots.asm                        page 17
BTS1802 -- Monitor for the COSMAC Elf 2000

0367   0000             ;          Change SHOW CPU to report CDP1804/5/6
0368   0000             ;
0369   0000             ; 109	-- [edit deleted - not  good idea!]
0370   0000             ; 110	-- [edit deleted - not  good idea!]
0371   0000             ;
0372   0000             ; 111	-- Fix the conditionals at PIXTEST: so that the PIXIE code still works
0373   0000             ; 	   if VIDEO is not defined.  (Thanks, Gaston Williams!).=
0374   0000             ;
0375   0000             ; 112	-- Reorder some of the code around FOLD: and TCRLF et al to fix some
0376   0000             ;	   off page errors caused by edit 111.
0377   0000             ;
0378   0000             ; 113   -- Reorder the code at SYSINI: so that we don't depend on X=0!
0379   0000             ;
0380   0000             ; 114	-- Update some of Mike's XMODEM and EDTASM code.
0381   0000             ;
0382   0000             ; 115	-- Fix yet another XMODEM bug (thanks, David Madole!).
0383   0000             ;--
0384   0000             MONVER	.EQU	115
0385   0000             
0386   0000             ; SUGGESTIONS FOR ENHANCEMENTS
0387   0000             ; Add hardware flow control for loading HEX files over UART?
0388   0000             ; Make the cold start entry point at $8000 work even if X!=P!=0
0389   0000             ; add a hardware bit vector and a SHOW CONFIG command 
0390   0000             ;   DEVICES: UART, RTC, IDE, VIDEO, PS2, PPI, PIXIE, SPEAKER
0391   0000             ;	bit-banged-serial
0392   0000             ; PS/2 keyboard attached test (0xAA, TPS25:) doesn't work!!
0393   0000             ;   Requires APU firmware update to support bidirectional communication.
0394   0000             ; Maybe we ought to add xon/xoff support?
0395   0000             ;  (Talk to mike about adding it to the BIOS)
0396   0000             ; Add a "TEST NVR" command
0397   0000             ; figure out why Kevin Timmerman's 1861 test program doesn't work
0398   0000             ;   it's because our RUN command doesn't enable interrupts.
0399   0000             ;   _Should_ our RUN command enable interrupts?????
0400   0000             ; Add a BEEP command to beep
0401   0000             ; Add TEST SPEAKER to play a simple song?
0402   0000             ; Add TEST PS2 to echo any PS/2 keyboard input?
0403   0000             ; All VT1802 to be used even w/o GPIO card
0404   0000             ;	- Allow interrupts (fix CALL command) and DMA
0405   0000             ;	- Allow TEST VT1802
0406   0000             ;	- disallow VT1802 with bit banged serial port
0407   0000             ; Add multiple commands per line with ";" separator
0408   0000             ; Add a REPEAT (RP) command
0409   0000             
TASM 1802 Assembler.              boots.asm                        page 18
BTS1802 -- Monitor for the COSMAC Elf 2000

0410   0000             	.EJECT
0411   0000             ;	.SBTTL	RAM Page Storage Map
0412   0000             
0413   0000             ;   The monitor requires one page of SRAM for internal data, command line
0414   0000             ; buffers, and housekeeping.  Normally this would be page zero of memory
0415   0000             ; (SRAM addresses $0000..$00FF), but it could also be the last page ($7F00..
0416   0000             ; $7FFF) or, for that matter, any page.  In absolute principle it doesn't
0417   0000             ; really matter if one of the EPROM languages (Forth,  BASIC, etc)
0418   0000             ; scribbles over the monitor's data, but if it does you won't be able to
0419   0000             ; use the monitor's breakpoint feature, nor will you be able to get back
0420   0000             ; to the monitor without resetting the system.
0421   0000             
0422   0000             ;   Note that variables marked with a [NVR] tag are also saved to the RTC/NVR
0423   0000             ; (aka CMOS) memory if one exists.  Of course, the main board also supports
0424   0000             ; a battery backup and, if that is installed, all SRAM is preserved.
0425   0000             
0426   0000             ;   By convention, whenever the monitor is active the DP register always
0427   0000             ; contains RAMPAGE in its upper eight bits.  This allows the DP register
0428   0000             ; to be used for direct addressing of any data on this page simply by
0429   0000             ; reloading the lower byte rather than the entire register...
0430   7F00             	.ORG	RAMPAGE
0431   7F00             
0432   7F00             ;   In addition to its internal data page, the monitor occasionally needs 512
0433   7F00             ; bytes of RAM to use as a disk buffer.  This two page buffer is located just
0434   7F00             ; below RAMPAGE...
0435   7F00~            #ifdef VIDEO
0436   7F00~            DSKBUF	.EQU	SCREEN-512
0437   7F00             #else
0438   7F00             DSKBUF	.EQU	RAMPAGE-512
0439   7F00             #endif
0440   7F00             
0441   7F00             ;   Since the CDP1802 stack grows downward, ideally we'd like to pack all
0442   7F00             ; the static variables into the high part of the data page, and then start
0443   7F00             ; the stack just below the first variable.  Unfortunately there's no easy
0444   7F00             ; way to do that, so we just make an educated guess...
0445   7F78             	.ORG	$+120
0446   7F78             STACK	.EQU	$-1
0447   7F78             
0448   7F78             ;   If the bytes in this "key" matches with the EPROM signature then the
0449   7F78             ; SRAM contents are valid. 
0450   7F78             KEY:	.BLOCK	5	; 3 "key" bytes plus the EPROM checksum...
0451   7F7D             
0452   7F7D             ;   The byte at NVRVER contains the "version" of the non-volatile RAM data, if
0453   7F7D             ; present.  This is compared with MONVER to see if the NVR data is current.
0454   7F7D             NVRVER:	.BLOCK	1	; [NVR] associated monitor version number
0455   7F7E             
0456   7F7E             ;   On a break point, as much of the user state as we can recover is saved
0457   7F7E             ; here.  Note that the order of these bytes is critical - you can't change
0458   7F7E             ; 'em without also changing the code at TRAP:...
0459   7F7E             SAVEXP:	.BLOCK	1	; saved state of the user's X register
0460   7F7F             SAVED:	.BLOCK	1	;   "    "    "   "    "    D    "
0461   7F80             SAVEDF:	.BLOCK	1	;   "    "    "   "    "    DF   "
0462   7F81             REGS:	.BLOCK	16*2	; All user registers after a breakpoint
0463   7FA1             
0464   7FA1             ;   These two locations are used for (gasp!) self modifying code.  The first
0465   7FA1             ; byte gets either an INP or OUT instruction, and the second a "SEP PC".  The
0466   7FA1             ; entire fragment runs with T1 as the program counter and is used so that
0467   7FA1             ; we can compute an I/O instruction to a variable port address...
0468   7FA1             IOT:	.BLOCK	3
TASM 1802 Assembler.              boots.asm                        page 19
BTS1802 -- Monitor for the COSMAC Elf 2000

0469   7FA4             
0470   7FA4             ;   These two bytes keep track of the console terminal baud rate and port in
0471   7FA4             ; use.  BAUD1 is a copy of BAUD.1 (RE.1) and contains the baud rate constant
0472   7FA4             ; for the bit banged serial port.  If this value is non-zero then the software
0473   7FA4             ; port is in use.  BAUD0 contains a copy of the hardware UART parameters (as
0474   7FA4             ; passed to F_USETBD) if the hardware UART is used for the serial port.
0475   7FA4             BAUD1:	.BLOCK	1	; [NVR] backup of the baud rate constant from BAUD.1
0476   7FA5             BAUD0:	.BLOCK	1	; [NVR]   "    "   "  UART settings from RF.0
0477   7FA6             
0478   7FA6             ;   Other miscellaneous data.  As much as I hate to say it, you should
0479   7FA6             ; be careful before changing the order of any of these locations.  The
0480   7FA6             ; 1802 makes direct memory addressing so painful that that code is often
0481   7FA6             ; tempted to take shortcuts and make assumptions about the order of these
0482   7FA6             ; items!
0483   7FA6             TIMBUF:	.BLOCK	6	; buffer for the DA[TIME] command
0484   7FAC             BATTOK:	.BLOCK	1	; 1 if RAM battery backup is OK
0485   7FAD             VRTC:	.BLOCK	1	; CDP1861 vertical retrace counter
0486   7FAE             PASSK:	.BLOCK	2	; pass count for MEMTEST and other diagnostics
0487   7FB0             ERRORK:	.BLOCK	2	; error  "    "     "     "    "        "
0488   7FB2             UARTOK:	.BLOCK	1	; non-zero if a high speed UART is present
0489   7FB3             
0490   7FB3             ;   The following two bytes contain the version numbers of the PS/2 keyboard
0491   7FB3             ; APU firmware (that's the firmware in our 89C2051 chip on the Elf 2000 GPIO
0492   7FB3             ; board, NOT the firmware of the keyboard itself!) and the version of the
0493   7FB3             ; VT52 emulator firmware for the Elf 2000 video card.  If either one of these
0494   7FB3             ; values is zero, the corresponding option is not present.  DON'T CHANGE THE
0495   7FB3             ; ORDER OF THESE TWO BYTES - the code assumes they're together!
0496   7FB3             #ifdef ELF2K
0497   7FB3             PS2VER:	.BLOCK	1	; PS2 keyboard version number
0498   7FB4             VIDVER:	.BLOCK	1	; VT52 emulator video card version
0499   7FB5             #endif
0500   7FB5             
0501   7FB5             ;   These three bytes are used for the power fail auto restart/auto bootstrap
0502   7FB5             ; data.  If the boot flag (BOOTF) is zero, then nothing special happens and the
0503   7FB5             ; monitor enters the normal command loop after SYSINI finishes.  If BOOTF is
0504   7FB5             ; 1, then the monitor jumps to RESTA (which should contain the address of the
0505   7FB5             ; restart routine!).  If BOOTF is 0xFF then the monitor attempts to boot from
0506   7FB5             ; the primary IDE drive...
0507   7FB5             BOOTF:	.BLOCK	1	; [NVR] 0=HALT, 1=RESTART, FF=BOOTSTRAP
0508   7FB6             RESTA:	.BLOCK	2	; [NVR] restart address when BOOTF==1
0509   7FB8             
0510   7FB8             ; Command line buffer...
0511   7FB8             CMDMAX	.EQU	64	; maximum command line length
0512   7FB8             CMDBUF:	.BLOCK	CMDMAX+1; buffer for a line of text read from the terminal
0513   7FF9             
0514   7FF9             ; If we've overflowed the data page, then cause an assembly error...
0515   7FF9~            #if ( ($ & $FF00) != (STACK & $FF00))
0516   7FF9~            	.ECHO	"**** ERROR **** Data page overflow!"
0517   7FF9             #endif
0518   7FF9             
TASM 1802 Assembler.              boots.asm                        page 20
BTS1802 -- Monitor for the COSMAC Elf 2000

0519   7FF9             	.EJECT
0520   7FF9             ;	.SBTTL	Monitor Startup Vectors
0521   7FF9             
0522   7FF9             ;   In the COSMAC Elf 2000, a hardware reset sets the BOOTSTRAP flag (a one
0523   7FF9             ; bit flip flop in the hardware) and this flag, as long as it is set, forces
0524   7FF9             ; EPROM to be selected for all memory accesses regardless of A15.  That's
0525   7FF9             ; how the hardware tricks the processor into starting at location $8000 rather
0526   7FF9             ; than $0000 after a reset.  The BOOTSTRAP flag will stay set until either one
0527   7FF9             ; of two things happens.  Either a) the hardware detects a real memory ref-
0528   7FF9             ; erence with the A15 bit set, or b) when the hardware detects an output to
0529   7FF9             ; any port with N3=1 (i.e. ports 4..7).  The first condition is met by the
0530   7FF9             ; "LBR SYSINI" below, and the second condition is met when SYSINI immedately
0531   7FF9             ; sets the POST code to $99.  It's important to remember that the system
0532   7FF9             ; SRAM is untouchable until this happens!!!
0533   8000             	.ORG	BOOTS
0534   8000 C0 80 9A    	LBR	SYSINI		; 8000 hardware reset (cold start) vector
0535   8003 C0 84 C2    	LBR	MAIN		; 8003 warm start vector
0536   8006             
0537   8006             ;   This dummy vector is used only by Tiny BASIC to fix a bug (er, umm,
0538   8006             ; "incompatibility") between TB and Mike's BIOS...
0539   8006             ;;BTYPE:SEX	R2		; ensure that the stack is selected
0540   8006             ;;	LBR	F_TTY		; and type a character from D
0541   8006             
0542   8006             ;   The romcksum program computes a sixteen bit checksum for the entire EPROM
0543   8006             ; image and stores it in the last two bytes of memory.  The EPROM is computed
0544   8006             ; such that the sum of ALL bytes in the EPROM (including the last two!) is
0545   8006             ; equal to the sixteen bit value represented by the last two bytes.  This
0546   8006             ; rather arcane system is used because it gives the same value for the EPROM
0547   8006             ; checksum that the Data I/O and other EPROM programmers report.
0548   8006             ;
0549   8006             ;   Since the checksum is included in itself, we have to go to some lengths
0550   8006             ; to prevent the checksum value from affecting its own calculation.  The way
0551   8006             ; that's done is to actually use the last FOUR bytes of the ROM - the last
0552   8006             ; two contain the checksum and the two before that contain the complement of
0553   8006             ; each byte in the checksum.  The sum of a byte and its complement is always
0554   8006             ; 0x0100, and since there are two such bytes, adding a checksum to the ROM in
0555   8006             ; this way always adds 0x0200 to the original checksum REGARDLESS of what
0556   8006             ; the actual checksum value may be.  The ROMCKSUM program that's used to
0557   8006             ; calculate and store the checksum in the .HEX file takes this into account,
0558   8006             ; so we can simply ignore the whole issue here.
0559   8006             CHKSUM	.EQU	$FFFE		; high byte first, then low byte
0560   8006             
0561   8006             ;  And last but not least, the copyright notice or notices always appear in
0562   8006             ; plain ASCII near the beginning of the EPROM.  We don't want them to be hard
0563   8006             ; to find, after all :-)
0564   8006             SYSTEM:
0565   8006             #ifdef ELF2K
0566   8006 0D 0A 43 4F 	.TEXT	"\r\nCOSMAC ELF 2000 \000"
0566   800A 53 4D 41 43 
0566   800E 20 45 4C 46 
0566   8012 20 32 30 30 
0566   8016 30 20 00 
0567   8019             #endif
0568   8019~            #ifdef PICOELF
0569   8019~            	.TEXT	"\r\r\nPICO ELF \000"
0570   8019             #endif
0571   8019 43 6F 70 79 RIGHTS:	.TEXT	"Copyright (C) 2004-2020 by Spare Time Gizmos.  All rights reserved.\r\n"
0571   801D 72 69 67 68 
0571   8021 74 20 28 43 
TASM 1802 Assembler.              boots.asm                        page 21
BTS1802 -- Monitor for the COSMAC Elf 2000

0571   8025 29 20 32 30 
0571   8029 30 34 2D 32 
0571   802D 30 32 30 20 
0571   8031 62 79 20 53 
0571   8035 70 61 72 65 
0571   8039 20 54 69 6D 
0571   803D 65 20 47 69 
0571   8041 7A 6D 6F 73 
0571   8045 2E 20 20 41 
0571   8049 6C 6C 20 72 
0571   804D 69 67 68 74 
0571   8051 73 20 72 65 
0571   8055 73 65 72 76 
0571   8059 65 64 2E 0D 
0571   805D 0A 
0572   805E             #ifdef BIOS
0573   805E 45 6C 66 4F 	.TEXT	"ElfOS BIOS Copyright (C) 2004-2020 by Mike Riley.\r\n"
0573   8062 53 20 42 49 
0573   8066 4F 53 20 43 
0573   806A 6F 70 79 72 
0573   806E 69 67 68 74 
0573   8072 20 28 43 29 
0573   8076 20 32 30 30 
0573   807A 34 2D 32 30 
0573   807E 32 30 20 62 
0573   8082 79 20 4D 69 
0573   8086 6B 65 20 52 
0573   808A 69 6C 65 79 
0573   808E 2E 0D 0A 
0574   8091             #endif
0575   8091 0D 0A 00    	.TEXT	"\r\n\000"
0576   8094             
0577   8094             ;   This table gives the "factory default" settings for the non-volatile RAM.
0578   8094             ; It's used to re-initialize the NVR any time the switches are set to 0x43
0579   8094             ; on startup...
0580   8094             NVRDEFAULT:
0581   8094 FF 80 00    	.DB	ABTNONE, $80, 0	; default boot/restart flag
0582   8097 00 00       	.DB	0, 0		; default software and hardware UART settings
0583   8099 73          	.DB	MONVER		; associated monitor version number
0584   809A             
TASM 1802 Assembler.              boots.asm                        page 22
BTS1802 -- Monitor for the COSMAC Elf 2000

0585   809A             	.EJECT
0586   809A             ;	.SBTTL	POST Code Summary
0587   809A             
0588   809A             ;	99 -- basic CPU checks
0589   809A             ;	98 -- calculating EPROM checksum
0590   809A             ;	97 -- EPROM checksum failure
0591   809A             ;	89 -- sizing SRAM
0592   809A             ;	88 -- SRAM size wrong (no monitor data page)
0593   809A             ;	87 -- testing SRAM key
0594   809A             ;	86 -- monitor data page failure
0595   809A             ;	85 -- clearing memory
0596   809A             ;	84 -- initializing monitor data page
0597   809A             ;	79 -- NVR/RTC/UART Reset (PicoElf only!)
0598   809A             ;	76 -- NVR/RTC Initialization
0599   809A             ;	75 -- RTC clock not ticking
0600   809A             ;	74 -- RTC battery fail
0601   809A             ;	69 -- UART Reset (Elf2K only!)
0602   809A             ;	68 -- UART initialization
0603   809A             ;	67 -- UART loopback failure (waiting for THRE set and DR clear)
0604   809A             ;	66 -- UART loopback failure (THRE won't clear)
0605   809A             ;	65 -- UART loopback failure (waiting for DR set)
0606   809A             ;	64 -- UART loopback failure (wrong data)
0607   809A             ;	63 -- UART loopback failure (waiting for THRE set and DR clear)
0608   809A             ;	59 -- PPI detect
0609   809A             ;	58 -- PPI data test
0610   809A             ;	57 -- PPI address test
0611   809A             ;	54 -- testing for GPIO PS/2 keyboard APU
0612   809A             ;	53 -- waiting for PS/2 APU version byte
0613   809A             ;	52 -- no PS/2 keyboard attached
0614   809A             ;	40 -- initialize SCRT
0615   809A             ;	39 -- CRTC status register test
0616   809A             ;	38 -- CRTC command/error test
0617   809A             ;	37 -- initialize video frame buffer
0618   809A             ;	36 -- enable video interrupts
0619   809A             ;	35 -- no video DMA
0620   809A             ;	34 -- no video end of frame interrupt
0621   809A             ;	19 -- initializing BIOS (SCRT)
0622   809A             ;	18 -- console terminal failure or polarity wrong
0623   809A             ;	17 -- special CHM bootstrap mode
0624   809A             ;	16 -- waiting for autobaud
0625   809A             ;	15 -- printing system sign on message
0626   809A             ;	14 -- intializing master IDE drive
0627   809A             ;	13 -- intializing slave IDE drive
0628   809A             ;	12 -- printing date/time
0629   809A             ;	11 -- autorestart
0630   809A             ;	10 -- autoboot
0631   809A             ;       0x -- used by ElfOS
0632   809A             ;	00 -- startup done
0633   809A             ;
0634   809A             ; Note that POST tests $5x and $3x are used on the Elf2K only!
0635   809A             
TASM 1802 Assembler.              boots.asm                        page 23
BTS1802 -- Monitor for the COSMAC Elf 2000

0636   809A             	.EJECT
0637   809A             ;	.SBTTL	System Initialization (EPROM Test)
0638   809A             
0639   809A             ;    This routine is entered thru the cold start vector after the processor is
0640   809A             ; reset.  It will test EPROM checksum and then, if that's successful, it will
0641   809A             ; test and initialize SRAM.  I apologize for the rather "linear" nature of this
0642   809A             ; code, but remember - at this point we don't even have a stack we can trust!
0643   809A             ; That makes it hard to call subroutines :-)
0644   809A             ;
0645   809A             ; REMEMBER!  At this point , X=P=0!
0646   809A E0          SYSINI:	POST($99)		; POST code 99 - the CPU is alive!
0646   809B 64          
0646   809C 99          
0647   809D 71          	DIS			; disable interrupts ...
0648   809E 00          	.DB	$00		; ... and set X=P=0
0649   809F             
0650   809F             ;   There are supposed to be some rudimentary CPU tests here, but I never
0651   809F             ; got around to writing any!  We'll just fall into the EPROM checksum test...
0652   809F             
0653   809F             ;   The first thing we do is to calculate the checksum of the program EPROM.
0654   809F             ; The checksum is calculated so that the 16 bit unsigned sum of all the bytes
0655   809F             ; in the ROM, INCLUDING the last two bytes, is equal to the last two bytes.
0656   809F             ;
0657   809F             ;   Note that this code assumes a 32K byte EPROM starting at address $8000.
0658   809F E0          ROMCHK:	POST($98)		; POST code 98 - EPROM test
0658   80A0 64          
0658   80A1 98          
0659   80A2 F8 80       	RLDI(P1,BOOTS)		; initialize P1 to the start of EPROM 
0659   80A4 BF          
0659   80A5 F8 00       
0659   80A7 AF          
0660   80A8 F8 00       	RCLEAR(P2)		; and accumulate the checksum in P2
0660   80AA BD          
0660   80AB AD          
0661   80AC EF          	SEX	P1		; use P1 to address memory now
0662   80AD             
0663   80AD             ; Read a byte and accumulate a 16 bit checksum in P2...
0664   80AD 8D          ROMCK1: GLO	P2		; get the low byte of the current total
0665   80AE F4          	ADD			; add another byte from M(R(X))
0666   80AF AD          	PLO	P2		; update the low byte
0667   80B0 9D          	GHI	P2		; and propagate any carry bit
0668   80B1 7C 00       	ADCI	$00		; ...
0669   80B3 BD          	PHI	P2		; ...
0670   80B4 60          	IRX			; on to the next byte
0671   80B5 9F          	GHI	P1		; have we rolled over from $FFFF to $0000?
0672   80B6 CA 80 AD    	LBNZ	ROMCK1		; nope - keep checking
0673   80B9             
0674   80B9             ;   If the checksum doesn't match the last two bytes in EPROM, then this POST
0675   80B9             ; test fails with code $97 displayed...
0676   80B9 E0          	SEX	PC0		; back to X=P=0
0677   80BA E0          	POST($97)		; POST code 97 - EPROM checksum failure
0677   80BB 64          
0677   80BC 97          
0678   80BD F8 FF       	RLDI(P1,CHKSUM)		; the checksum lives here in EPROM
0678   80BF BF          
0678   80C0 F8 FE       
0678   80C2 AF          
0679   80C3 EF          	SEX	P1		; ....
0680   80C4 9D          	GHI	P2		; get the high byte first
TASM 1802 Assembler.              boots.asm                        page 24
BTS1802 -- Monitor for the COSMAC Elf 2000

0681   80C5 F7          	SM			; does it equal the byte at $FFFE ?
0682   80C6 3A C6       	BNZ	$		; fail if it doesn't
0683   80C8 60          	IRX			; test the low byte next
0684   80C9 8D          	GLO	P2		; ...
0685   80CA F7          	SM			; ...
0686   80CB 3A CB       	BNZ	$		; ...
0687   80CD E0          	SEX	PC0		; the EPROM checksum is OK!
0688   80CE             
0689   80CE             ; Fall thru into the RAM test code...
TASM 1802 Assembler.              boots.asm                        page 25
BTS1802 -- Monitor for the COSMAC Elf 2000

0690   80CE             	.EJECT
0691   80CE             
0692   80CE             ;	.SBTTL	System Initialization (RAM Size Test)
0693   80CE             
0694   80CE             ;   The first stage in RAM testing is simply a matter of sizing RAM.  This
0695   80CE             ; test starts from location zero and works upward until it finds the first
0696   80CE             ; non-read/write location (either nonexistent memory or EPROM - it doesn't
0697   80CE             ; matter which!).
0698   80CE             ;
0699   80CE             ;   One important point - this is a NON-DESTRUCTIVE test!  This is a big
0700   80CE             ; deal because the ELF2K has (potentially at least) non-volatile memory
0701   80CE             ; and there might be a thousand line BASIC program or something in there!
0702   80CE E0          SIZMEM:	POST($89)		; POST code 89 - sizing memory
0702   80CF 64          
0702   80D0 89          
0703   80D1 F8 00       	RCLEAR(P1)		; start scanning from location zero
0703   80D3 BF          
0703   80D4 AF          
0704   80D5 EF          	SEX	P1		; and use P1 to address memory
0705   80D6 F0          SIZME1:	LDX			; get a byte
0706   80D7 AD          	PLO	P2		; save temporarily
0707   80D8 FB FF       	XRI	$FF		; make the byte different
0708   80DA 5F          	STR	P1		; and write it to memory
0709   80DB 8D          	GLO	P2		; get the original value
0710   80DC F4          	ADD			; that plus its complement
0711   80DD FC 01       	ADI	1		; should always total $FF
0712   80DF CA 80 E8    	LBNZ	SIZME2		; branch if no memory here
0713   80E2 8D          	GLO	P2		; once again get the original value
0714   80E3 5F          	STR	P1		; and restore memory
0715   80E4 1F          	INC	P1		; on to the next byte
0716   80E5 C0 80 D6    	LBR	SIZME1		; and keep looping
0717   80E8             
0718   80E8             ; Here when we find a location that can't be written..
0719   80E8 2F          SIZME2:	DEC	P1		; back to the last writable location
0720   80E9 E0          	SEX	PC0		; back to the regular X
0721   80EA E0          	POST($88)		; and clear post code 89
0721   80EB 64          
0721   80EC 88          
0722   80ED             
0723   80ED             ;   The monitor always uses the last page of SRAM for its data (RAMPAGE) and
0724   80ED             ; the sad, sad truth is that the monitor can't actually adjust to different
0725   80ED             ; memory sizes.  If the amount of memory we found isn't exactly what we expect
0726   80ED             ; (i.e. RAMPAGE+FF), then we just halt with post code 88 displayed...
0727   80ED 9F          	GHI	P1		; get the high order byte of memory size
0728   80EE FB 7F       	XRI	HIGH(RAMPAGE)	; is it the monitor's page??
0729   80F0 3A F0       	BNZ	$		; nope - halt with post code 88
0730   80F2 8F          	GLO	P1		; and the low byte must be $FF
0731   80F3 FB FF       	XRI	$FF		; ...
0732   80F5 3A F5       	BNZ	$		; ...
0733   80F7             
0734   80F7             ; Fall thru into the RAM initialization test...
TASM 1802 Assembler.              boots.asm                        page 26
BTS1802 -- Monitor for the COSMAC Elf 2000

0735   80F7             	.EJECT
0736   80F7             ;	.SBTTL	System Initialization (RAM Key Test)
0737   80F7             
0738   80F7             ;   If the RAM size is correct, then the next step is to see whether the
0739   80F7             ; current RAM contents are valid.  We do that by comparing the key in the
0740   80F7             ; SRAM (location KEY:) against the signature built into EPROM.  If they
0741   80F7             ; match, then we assume the RAM is initialized and we proceed with the current
0742   80F7             ; RAM contents.
0743   80F7 E0          RAMTS1:	SEX	PC0		; just in case
0744   80F8 E0          	POST($87)		; POST code 87 - RAM initialization test
0744   80F9 64          
0744   80FA 87          
0745   80FB F8 7F       	RLDI(SP,STACK-1)	; try to point SP at some RAM somewhere
0745   80FD B2          
0745   80FE F8 76       
0745   8100 A2          
0746   8101             #ifdef ELF2K
0747   8101 E2          	SEX	SP		; ...
0748   8102 6C          	INP	SWITCHES	; and read the switches
0749   8103 FA FE       	ANI	$FE		; ignore the LSB for this test
0750   8105 FB 42       	XRI	$42		; are they set to 0x42 or 0x43 ??
0751   8107 C2 81 41    	LBZ	DPTEST		; yes - force ram initialization
0752   810A             #endif
0753   810A F8 7F       	RLDI(P1,KEY)		; P1 points to the SRAM key
0753   810C BF          
0753   810D F8 78       
0753   810F AF          
0754   8110 F8 FF       	RLDI(P2,CHKSUM)		; and P2 points to the EPROM checksum
0754   8112 BD          
0754   8113 F8 FE       
0754   8115 AD          
0755   8116 EF          	SEX	P1		; let X point to EPROM
0756   8117             
0757   8117             ; Compare the SRAM key with the EPROM signature...
0758   8117 72          	LDXA			; get the first byte of the key
0759   8118 FB 72       	XRI	'r'		; test it
0760   811A CA 81 41    	LBNZ	DPTEST		; branch if the key doesn't match
0761   811D 72          	LDXA			; next byte
0762   811E FB 6C       	XRI	'l'		; ...
0763   8120 CA 81 41    	LBNZ	DPTEST		; ...
0764   8123 72          	LDXA			; and the third
0765   8124 FB 61       	XRI	'a'		; ...
0766   8126 CA 81 41    	LBNZ	DPTEST		; ...
0767   8129 0D          	LDN	P2		; finally, test the last two bytes ...
0768   812A F3          	XOR			;  ... against the EPROM checksum
0769   812B CA 81 41    	LBNZ	DPTEST		; ...
0770   812E 60          	IRX\ INC P2		; advance both pointers
0770   812F 1D          
0771   8130 0D          	LDN	P2		; and test one more byte
0772   8131 F3          	XOR			; ...
0773   8132 CA 81 41    	LBNZ	DPTEST		; ...
0774   8135             
0775   8135             ; Here if the current RAM contents are valid...
0776   8135 F8 7F       	RLDI(DP,BATTOK)		; set the "battery OK" flag
0776   8137 B7          
0776   8138 F8 AC       
0776   813A A7          
0777   813B F8 FF       	LDI	$FF		; ...
0778   813D 57          	STR	DP		; ...
TASM 1802 Assembler.              boots.asm                        page 27
BTS1802 -- Monitor for the COSMAC Elf 2000

0779   813E C0 81 91    	LBR	DPDONE		; and then proceed with the initialization
0780   8141             
TASM 1802 Assembler.              boots.asm                        page 28
BTS1802 -- Monitor for the COSMAC Elf 2000

0781   8141             	.EJECT
0782   8141             ;	.SBTTL	System Initialization (RAM Initialization)
0783   8141             
0784   8141             ;   The SRAM is (apparently) uninitialized, so we proceed with a very simple
0785   8141             ; memory test on the monitor's data page only (not all of SRAM!), then we
0786   8141             ; initialize all of SRAM to zeros, and finally we initialize the monitor's
0787   8141             ; data page and key...
0788   8141             ;
0789   8141             ;   This loop does a very, very simple test on the monitor's data page
0790   8141             ; just to ensure that it has 256 bytes of R/W memory.  It doesn't check
0791   8141             ; the memory addressing beyond that, and it's not much to speak of.  Once
0792   8141             ; the monitor is running, the RAMTEST command can be used for a much more
0793   8141             ; exhaustive memory test...
0794   8141 E0          DPTEST:	SEX	PC0		; back to the regular X register
0795   8142 E0          	POST($86)		; monitor data page test
0795   8143 64          
0795   8144 86          
0796   8145 F8 7F       	RLDI(DP,RAMPAGE+$FF)	; point to the monitor's data page
0796   8147 B7          
0796   8148 F8 FF       
0796   814A A7          
0797   814B E7          	SEX	DP		; use DP to address memory
0798   814C 87          DPTES1:	GLO	DP		; get the low byte of the address
0799   814D 73          	STXD			; store it and decrement DP
0800   814E 3A 4C       	BNZ	DPTES1		; branch if there are still more to do
0801   8150 F8 7F       	RLDI(DP,RAMPAGE)	; yes - start over again
0801   8152 B7          
0801   8153 F8 00       
0801   8155 A7          
0802   8156 87          DPTES2:	GLO	DP		; this time compare memory
0803   8157 F7          	SM			; ...
0804   8158 3A 58       	BNZ	$		; POST code 86 - monitor data page failure
0805   815A 17          	INC	DP		; on to the next (previous) address
0806   815B 87          	GLO	DP		; done 'em all
0807   815C CA 81 56    	LBNZ	DPTES2		; no - keep testing
0808   815F             
0809   815F             ;   The monitor's RAM page tests OK.  Now initialize all memory, from $0000
0810   815F             ; to RAMPAGE+$FF, to zero...
0811   815F E0          	SEX	PC0		; back to the usual X register
0812   8160 E0          	POST($85)		; POST code 85 - clearing memory
0812   8161 64          
0812   8162 85          
0813   8163 F8 7F       	RLDI(P1,RAMPAGE+$FF)	; start at the top of memory again
0813   8165 BF          
0813   8166 F8 FF       
0813   8168 AF          
0814   8169 EF          	SEX	P1		; ...
0815   816A F8 00       CLRRAM:	LDI	$00		; set memory to zero
0816   816C 73          	STXD			; do the next byte
0817   816D             ; [RLA] Actually, we just initialize the data page to zeros...
0818   816D             ;	GHI	P1		; did we roll over from $0000 to $FFFF?
0819   816D 8F          	GLO	P1		; did we roll over from $7F00 to $7EFF?
0820   816E FB FF       	XRI	$FF		; ...
0821   8170 3A 6A       	BNZ	CLRRAM		; nope - keep clearing...
0822   8172             
0823   8172             ;   And lastly we're ready to store the signature in the monitor's RAM page.
0824   8172             ; That's actually the only non-zero data that's presently required in the
0825   8172             ; data page, but if the if the monitor had any other data that needed initial-
0826   8172             ; izing, this would be the time to do it!
TASM 1802 Assembler.              boots.asm                        page 29
BTS1802 -- Monitor for the COSMAC Elf 2000

0827   8172 E0          	SEX	PC0		; ...
0828   8173 E0          	POST($84)		; POST code 84 - initializing monitor data page
0828   8174 64          
0828   8175 84          
0829   8176 F8 7F       	RLDI(DP,KEY+4)		; P1 points to the SRAM key
0829   8178 B7          
0829   8179 F8 7C       
0829   817B A7          
0830   817C F8 FF       	RLDI(P2,CHKSUM+1)	; and P2 points to the EPROM checksum
0830   817E BD          
0830   817F F8 FF       
0830   8181 AD          
0831   8182 E7          	SEX	DP		; use DP to address memory
0832   8183             
0833   8183             ; Store the rest of the SRAM "key"...
0834   8183 0D          	LDN	P2		; store the two checksum bytes first
0835   8184 73          	STXD			; ...
0836   8185 2D          	DEC	P2		; (and in "backwards" order!
0837   8186 0D          	LDN	P2		; ...
0838   8187 73          	STXD			; ...
0839   8188 F8 61       	LDI	'a'		; now store the rest of the key
0840   818A 73          	STXD			; (again, "backwards"!)
0841   818B F8 6C       	LDI	'l'		; ...
0842   818D 73          	STXD			; ...
0843   818E F8 72       	LDI	'r'		; ...
0844   8190 73          	STXD			; ...
0845   8191             
0846   8191             ; Fall into RTCINI...
0847   8191             DPDONE:
TASM 1802 Assembler.              boots.asm                        page 30
BTS1802 -- Monitor for the COSMAC Elf 2000

0848   8191             	.EJECT
0849   8191             ;	.SBTTL	Option Board Initialization (RTC)
0850   8191             
0851   8191             ;   Initialize and test the real time clock on the disk/UART/RTC/NVR option
0852   8191             ; board.  In particular, if the clock is present, make sure the lithium
0853   8191             ; battery isn't dead and make sure that the clock is running...
0854   8191             RTCINI:
0855   8191             
0856   8191             ;   The Elf2K Disk/UART/RTC board requires a horrific kludge to reset the UART
0857   8191             ; (you can read the whole story at NVRL2:, below) but the PicoElf UART/RTC board
0858   8191             ; is much cleaner.  Both the HART and DS12887 chip will be reset when a byte is
0859   8191             ; written to the select register with bit 7 cleared and bit 6 set.  The reset
0860   8191             ; condition is removed by writing a byte with bit 6 cleared (and bit 7 doesn't
0861   8191             ; matter).
0862   8191             ;
0863   8191             ;   FWIW, resetting the DS12887 clears all pending interrupt requests and all
0864   8191             ; interrupt enables.  It doesn't affect the current time nor the RAM contents.
0865   8191~            #ifdef PICOELF
0866   8191~            	SEX	PC0		; all OUTs are inline
0867   8191~            	POST($79)		; ...
0867   8191~            	POST($79)		; ...
0867   8191~            	POST($79)		; ...
0868   8191~            	OUT	NVR_SELECT	; write the UART/NVR select register
0869   8191~            	.DB	$40		; ... bit 7 cleared and bit 6 set
0870   8191~            	NOP\ NOP\ NOP		; stall for a few microseconds
0870   8191~            	NOP\ NOP\ NOP		; stall for a few microseconds
0870   8191~            	NOP\ NOP\ NOP		; stall for a few microseconds
0871   8191~            	OUT	NVR_SELECT	; and then remove the reset condition
0872   8191~            	.DB	$00		; ...
0873   8191             #endif
0874   8191             
0875   8191             ; Now proceed with testing the RTC/NVR chip ...
0876   8191 F8 7F       	RLDI(SP,STACK-1)	; for some of this we need a valid RAM pointer
0876   8193 B2          
0876   8194 F8 76       
0876   8196 A2          
0877   8197 E0          	SEX	PC0		; X=P
0878   8198 E0          	POST($76)		; NVR initialization
0878   8199 64          
0878   819A 76          
0879   819B 62          	RNVR(NVRFREE)		; read the first free RAM location
0879   819C 8E          
0879   819D E2          
0879   819E 6B          
0880   819F A9          	PLO	T1		; save that data for a minute
0881   81A0 E0          	SEX	PC0		; ...
0882   81A1 62          	WNVR(NVRFREE,$5A)	; write a test byte
0882   81A2 8E          
0882   81A3 63          
0882   81A4 5A          
0883   81A5 E0          	SEX	PC0		; ...
0884   81A6 62          	RNVR(NVRFREE)		; and read it back
0884   81A7 8E          
0884   81A8 E2          
0884   81A9 6B          
0885   81AA FB 5A       	XRI	$5A		; is it what we expect?
0886   81AC CA 82 09    	LBNZ	NONVR		; jump if no NVR present
0887   81AF E0          	SEX	PC0		; ...
0888   81B0 62          	WNVR(NVRFREE,$A5)	; write another test byte
TASM 1802 Assembler.              boots.asm                        page 31
BTS1802 -- Monitor for the COSMAC Elf 2000

0888   81B1 8E          
0888   81B2 63          
0888   81B3 A5          
0889   81B4 E0          	SEX	PC0		; ...
0890   81B5 62          	RNVR(NVRFREE)		; read it back
0890   81B6 8E          
0890   81B7 E2          
0890   81B8 6B          
0891   81B9 FB A5       	XRI	$A5		; did this work too?
0892   81BB CA 82 09    	LBNZ	NONVR		; jump if no NVR present
0893   81BE E0          	SEX	PC0		; restore the original value
0894   81BF 62          	OUT	NVR_SELECT	; ...
0895   81C0 8E          	.DB	NVRFREE		; ...
0896   81C1 E2          	SEX	SP		; ...
0897   81C2 89          	GLO	T1		; ...
0898   81C3 52          	STR	SP		; ...
0899   81C4 63          	OUT	NVR_DATA		; ...
0900   81C5             
0901   81C5             ;   If we really have a NVR/RTC chip, then perform two tests on it.  First,
0902   81C5             ; be sure that the VRT (battery OK) bit is set and second, be sure that
0903   81C5             ; the clock is ticking...
0904   81C5 E0          	SEX	PC0		; X=P
0905   81C6 62          	WNVR(NVRA,DV1)		; be sure the oscillator is enabled
0905   81C7 8A          
0905   81C8 63          
0905   81C9 20          
0906   81CA E0          NVRL1:	SEX	PC0		; X=P again
0907   81CB E0          	POST($75)		; POST code 75 RTC not ticking
0907   81CC 64          
0907   81CD 75          
0908   81CE 62          	RNVR(NVRA)		; read status register A
0908   81CF 8A          
0908   81D0 E2          
0908   81D1 6B          
0909   81D2 FA 80       	ANI	UIP		; test the update in progress bit
0910   81D4 32 CA       	BZ	NVRL1		; wait for it to set
0911   81D6 E0          	SEX	PC0		; X=P
0912   81D7 E0          	POST($74)		; NVR battery dead
0912   81D8 64          
0912   81D9 74          
0913   81DA 62          	RNVR(NVRD)		; read control register D
0913   81DB 8D          
0913   81DC E2          
0913   81DD 6B          
0914   81DE FB 80       	XRI	VRT		; the VRT bit should be set, all others zero
0915   81E0 3A E0       	BNZ	$		; loop on failure
0916   81E2             
0917   81E2             #ifdef ELF2K
0918   81E2             ;   And now it's time for a monumental (and I mean really monumental) hack.
0919   81E2             ; In the original prototype disk/uart/rtc cards, there was no way to reset
0920   81E2             ; the UART.  This was a serious oversight, and there were no gates left over,
0921   81E2             ; no bits left over anywhere, and the _only_ halfway general purpose output
0922   81E2             ; available to us is the SQW (square wave) output of the DS1287.  Yep, you
0923   81E2             ; guessed it - the prototype boards were ECO'ed to connect the UART reset
0924   81E2             ; input the the DS1287 SQW output.  The 8250 data sheet specified a minimum
0925   81E2             ; pulse width of 1ms for the RESET input, and so our job here is to generate
0926   81E2             ; a 1us or more pulse on the DS1287 SQW output.
0927   81E2 E0          	SEX	PC0		; X=P
0928   81E3 E0          	POST($69)		; reset UART
TASM 1802 Assembler.              boots.asm                        page 32
BTS1802 -- Monitor for the COSMAC Elf 2000

0928   81E4 64          
0928   81E5 69          
0929   81E6 62          	WNVR(NVRA,DV1+$03)	; turn on periodic interrupt divider chain
0929   81E7 8A          
0929   81E8 63          
0929   81E9 23          
0930   81EA 62          	WNVR(NVRB,SQWE+DM+HR24+DSE); turn on the square wave output
0930   81EB 8B          
0930   81EC 63          
0930   81ED 0F          
0931   81EE E0          NVRL2:	SEX	PC0		; wait for the PF flag to set, and clear again
0932   81EF 62          	RNVR(NVRC)		; read register C
0932   81F0 8C          
0932   81F1 E2          
0932   81F2 6B          
0933   81F3 FA 40       	ANI	PF		; check the PF bit
0934   81F5 32 EE       	BZ	NVRL2		; wait for it to set
0935   81F7 E0          NVRL3:	SEX	PC0		; ...
0936   81F8 62          	RNVR(NVRC)		; read register C
0936   81F9 8C          
0936   81FA E2          
0936   81FB 6B          
0937   81FC FA 40       	ANI	PF		; check the PF bit
0938   81FE 3A F7       	BNZ	NVRL3		; wait for it to clear
0939   8200 E0          	SEX	PC0		; turn off the square wave output
0940   8201 62          	WNVR(NVRB,DM+HR24+DSE)	; ...
0940   8202 8B          
0940   8203 63          
0940   8204 07          
0941   8205 62          	WNVR(NVRA,DV1)		; and turn off the divider chain
0941   8206 8A          
0941   8207 63          
0941   8208 20          
0942   8209             #endif
0943   8209             
0944   8209             ; Here if no NVR/RTC chip is installed...
0945   8209             NONVR:
0946   8209             ; Fall into UINI...
0947   8209~            #ifdef PICOELF
0948   8209~                   LBR	UINI		; adjust the alignment for all the
0949   8209~                   PAGE			;  ... code that's removed on the PicoElf
0950   8209             #endif
0951   8209             	
TASM 1802 Assembler.              boots.asm                        page 33
BTS1802 -- Monitor for the COSMAC Elf 2000

0952   8209             	.EJECT
0953   8209             ;	.SBTTL	Option Board Initialization (UART)
0954   8209             
0955   8209             ;   This routine will initialize the UART on the Elf2K disk option board.
0956   8209             ; There are several complications here - first, the UART and/or the entire
0957   8209             ; disk board may be absent, second, any one of the 8250/16450/16550 UARTs
0958   8209             ; or their cousins may be used.  Third, revision 1A of the ELFDISK boards
0959   8209             ; had a bug such that a hardware reset did NOT reset the UART chip, so at
0960   8209             ; at this point the UART may be in any kind of state at all!
0961   8209 F8 7F       UINI:	RLDI(DP,UARTOK)		; set the UART flag to zero
0961   820B B7          
0961   820C F8 B2       
0961   820E A7          
0962   820F F8 00       	LDI	0		;  ...
0963   8211 57          	STR	DP		; until we know better!
0964   8212 F8 7F       	RLDI(SP,STACK-1)	; for some of this we need a valid RAM pointer
0964   8214 B2          
0964   8215 F8 76       
0964   8217 A2          
0965   8218 E0          	SEX	PC0		; back to X=P
0966   8219 E0          	POST($68)		; POST code for UART initialization
0966   821A 64          
0966   821B 68          
0967   821C 62          	WUART(MCR,$10)		; enable loopback, all modem bits OFF
0967   821D 14          
0967   821E 63          
0967   821F 10          
0968   8220 62          	RUART(MSR)		; read the modem status register
0968   8221 16          
0968   8222 E2          
0968   8223 6B          
0969   8224 FA F0       	ANI	$F0		; check the current modem status
0970   8226 CA 82 9F    	LBNZ	NOUART		; all bits should be zero now
0971   8229 E0          	SEX	PC0		; back to X=P
0972   822A 62          	WUART(MCR,$1F)		; enable loopback, turn all modem bits ON
0972   822B 14          
0972   822C 63          
0972   822D 1F          
0973   822E 62          	RUART(MSR)		; and read the modem status register again
0973   822F 16          
0973   8230 E2          
0973   8231 6B          
0974   8232 FA F0       	ANI	$F0		; check the current modem status
0975   8234 FB F0       	XRI	$F0		; all bits should be one this time
0976   8236 CA 82 9F    	LBNZ	NOUART		; no UART if they aren't
0977   8239             
0978   8239             ; Initialize the UART with some default parameters...
0979   8239 E0          	SEX	PC0		; X=P
0980   823A 62          	WUART(FCR,$06)		; reset 16550 FIFO and turn it off
0980   823B 12          
0980   823C 63          
0980   823D 06          
0981   823E 62          	WUART(IER,$00)		; turn off all interrupt sources
0981   823F 11          
0981   8240 63          
0981   8241 00          
0982   8242 62          	WUART(LCR,DLAB)		; turn on divisor latch access bit
0982   8243 13          
0982   8244 63          
TASM 1802 Assembler.              boots.asm                        page 34
BTS1802 -- Monitor for the COSMAC Elf 2000

0982   8245 80          
0983   8246 62          	WUART(DLL,$10)		; set divisor to $0010 for 9600 bps
0983   8247 10          
0983   8248 63          
0983   8249 10          
0984   824A 62          	WUART(DLH,$00)		; ...
0984   824B 11          
0984   824C 63          
0984   824D 00          
0985   824E 62          	WUART(LCR,$03)		; select 8N1 character format
0985   824F 13          
0985   8250 63          
0985   8251 03          
0986   8252 62          	RUART(LSR)		; read the LSR to clear the error bits
0986   8253 15          
0986   8254 E2          
0986   8255 6B          
0987   8256 E0          	SEX	PC0		; ...
0988   8257 62          	RUART(RBR)		; next read the data register to clear DR
0988   8258 10          
0988   8259 E2          
0988   825A 6B          
0989   825B             
0990   825B             ;   Ok, now let's test the UART for real.  Turn on loopback mode and walk
0991   825B             ; thru transmitting and receiving a byte just to make sure everything works
0992   825B             ; as we expect!
0993   825B             
0994   825B             ;   Wait for THRE to set and then transmit a test byte.  Remember that we're
0995   825B             ; still in loopback mode, so we'll jsut receive it right back again...
0996   825B E0          UINI2:	SEX	PC0		; ...
0997   825C E0          	POST($67)		; UART loopback test (THRE won't set)
0997   825D 64          
0997   825E 67          
0998   825F 62          	RUART(LSR)		; finally, read the LSR again
0998   8260 15          
0998   8261 E2          
0998   8262 6B          
0999   8263 FA 21       	ANI	THRE+DR		; wait for THRE set and DR clear
1000   8265 FB 20       	XRI	THRE		; ...
1001   8267 3A 5B       	BNZ	UINI2		; wait for it if necessary
1002   8269 E0          	SEX	PC0		; ...
1003   826A 62          	WUART(THR,$5A)		; transmit a test byte
1003   826B 10          
1003   826C 63          
1003   826D 5A          
1004   826E             
1005   826E             ; And DR should set when the character is received...
1006   826E E0          UINI4:	SEX	PC0		; ...
1007   826F E0          	POST($65)		; UART loopback test (waiting for DR set)
1007   8270 64          
1007   8271 65          
1008   8272 62          	RUART(LSR)		; read the LSR
1008   8273 15          
1008   8274 E2          
1008   8275 6B          
1009   8276 FA 01       	ANI	DR		; and look for DR set
1010   8278 32 6E       	BZ	UINI4		; wait for it
1011   827A             
1012   827A             ; Read the receiver buffer and make sure we got the right byte...
TASM 1802 Assembler.              boots.asm                        page 35
BTS1802 -- Monitor for the COSMAC Elf 2000

1013   827A E0          	SEX	PC0		; ...
1014   827B E0          	POST($64)		; UART loopback test (wrong data received)
1014   827C 64          
1014   827D 64          
1015   827E 62          	RUART(RBR)		; finally, read the receiver data buffer
1015   827F 10          
1015   8280 E2          
1015   8281 6B          
1016   8282 FB 5A       	XRI	$5A		; we'd better read what we wrote!
1017   8284 3A 84       	BNZ	$		; fail if not
1018   8286             
1019   8286             ;   Finally check the LSR again - THRE should be set, DR and all the error bits
1020   8286             ; should be cleared...
1021   8286 E0          UINI5:	SEX	PC0		; ...
1022   8287 E0          	POST($63)		; UART loopback test (waiting for THRE and DR)
1022   8288 64          
1022   8289 63          
1023   828A 62          	RUART(LSR)		; back to the LSR register
1023   828B 15          
1023   828C E2          
1023   828D 6B          
1024   828E FA 2F       	ANI	THRE+DR+OE+FE+PE; THRE should be set and DR and error bits clear
1025   8290 FB 20       	XRI	THRE		; ...
1026   8292 3A 92       	BNZ	$ ;UNI5		; ...
1027   8294             
1028   8294             ; Return the UART to normal mode and we're done!
1029   8294 E0          	SEX	PC0		; ...
1030   8295 E0          	POST($60)		; UART tests done
1030   8296 64          
1030   8297 60          
1031   8298 62          	WUART(MCR,$03)		; turn off loop back; set RTS and DTR
1031   8299 14          
1031   829A 63          
1031   829B 03          
1032   829C F8 FF       	LDI	$FF		; set the UART present flag to TRUE
1033   829E 57          	STR	DP		; (DP still points to UARTOK!)
1034   829F             
1035   829F             ; Here if there's no UART installed...
1036   829F             NOUART:
1037   829F             
1038   829F             ; Fall into the GPIO PPI/Speaker test ...
TASM 1802 Assembler.              boots.asm                        page 36
BTS1802 -- Monitor for the COSMAC Elf 2000

1039   829F             	.EJECT
1040   829F             ;	.SBTTL	PPI and Speaker Initialization
1041   829F             
1042   829F             #ifdef ELF2K
1043   829F             ;   The speaker test is pretty simple - it has to be, because there's no way
1044   829F             ; we can tell whether the speaker hardware is even installed, let alone
1045   829F             ; functioning.  We could take a guess and say that if the PPI and PS/2 key-
1046   829F             ; board are installed the speaker probably is, but that's no guarantee because
1047   829F             ; the GPIO subsystems are all independent and optional.
1048   829F             ;
1049   829F             ;   The only thing we can do is to turn the speaker on with its built in tone
1050   829F             ; generator for about 1/4 second, and then turn it off.  If it's working, the
1051   829F             ; user will hear a "beep" at startup.  Even this is pretty suboptimal, however,
1052   829F             ; because the delay is calculated for a 3MHz clock.  At 1.77Mhz it'll be about
1053   829F             ; 1.69x longer and at 5Mhz it'll be 1.66x shorter!
1054   829F E0          	POST($59)		; start of speaker test
1054   82A0 64          
1054   82A1 59          
1055   82A2 67          	OUT	GPIO		; turn the speaker on
1056   82A3 28          	.DB	SPTONE		;  ... with a fixed tone
1057   82A4 F8 51       	RLDI(P1,$51FF)		; 20991 iterations of this loop
1057   82A6 BF          
1057   82A7 F8 FF       
1057   82A9 AF          
1058   82AA 2F          SPTST1:	DEC	P1		; [2] count down
1059   82AB 9F          	GHI	P1		; [2] and wait for zero
1060   82AC 3A AA       	BNZ	SPTST1		; [2] ...
1061   82AE 67          	OUT	GPIO		; then turn the speaker off
1062   82AF 20          	.DB	SPOFF		; ...
1063   82B0             
1064   82B0             ;   We'd like to do some simple tests on the 8255 PPI to be sure its address
1065   82B0             ; and data lines are working OK.  You might be tempted to use the control for
1066   82B0             ; this, but according to the "official" Intel 8255 data sheet this register
1067   82B0             ; is write only.  Actually, all the 82C55s I've seen allow you to read back the
1068   82B0             ; control register, but I guess we can't depend on this.
1069   82B0             ;
1070   82B0             ;   The big problem with doing read/write test on the other registers is that
1071   82B0             ; we have to configure all the PPI bits as outputs first; otherwise when we
1072   82B0             ; read the port register we'll read the actual state of the pins and not what
1073   82B0             ; we last wrote there.  The problem with this is that it may cause contention
1074   82B0             ; if any of the 8255 port pins happen to be wired up to external drivers.
1075   82B0             ;
1076   82B0             ;  That's why there are series current limiting resistors on the GPIO card!
1077   82B0             
1078   82B0             ; Write the control register and condition all three ports as outputs.
1079   82B0 E0          	POST($58)		; PPI control register test
1079   82B1 64          
1079   82B2 58          
1080   82B3 67          	WPPI(PPICTL,$9B)	; first make all ports inputs
1080   82B4 07          
1080   82B5 66          
1080   82B6 9B          
1081   82B7 67          	RPPI(PPICTL)		; try to read the control word back
1081   82B8 07          
1081   82B9 E2          
1081   82BA 6E          
1082   82BB FB 9B       	XRI	$9B		; did we read it successfully?
1083   82BD CA 83 19    	LBNZ	NOPPI		; nope - no PPI installed
1084   82C0 E0          	SEX	PC0		; now make all the ports outputs
TASM 1802 Assembler.              boots.asm                        page 37
BTS1802 -- Monitor for the COSMAC Elf 2000

1085   82C1 67          	WPPI(PPICTL,$80)	; ...
1085   82C2 07          
1085   82C3 66          
1085   82C4 80          
1086   82C5 67          	RPPI(PPICTL)		; ...
1086   82C6 07          
1086   82C7 E2          
1086   82C8 6E          
1087   82C9 FB 80       	XRI	$80		; ...
1088   82CB CA 83 19    	LBNZ	NOPPI		; nope - no PPI installed
1089   82CE             
1090   82CE             ; Super simple PPI data bus test to check for shorts or opens...
1091   82CE E0          	POST($57)		; PPI data bus test
1091   82CF 64          
1091   82D0 57          
1092   82D1 67          	WPPI(PPIPA,$AA)		; write pattern #1
1092   82D2 04          
1092   82D3 66          
1092   82D4 AA          
1093   82D5 67          	RPPI(PPIPA)		; and read it back
1093   82D6 04          
1093   82D7 E2          
1093   82D8 6E          
1094   82D9 FB AA       	XRI	$AA		; did we read it OK?
1095   82DB 3A DB       	BNZ	$		; nope - loop forever
1096   82DD E0          	SEX	PC0		; ...
1097   82DE 67          	WPPI(PPIPA,$55)		; one more simple test
1097   82DF 04          
1097   82E0 66          
1097   82E1 55          
1098   82E2 67          	RPPI(PPIPA)		; ...
1098   82E3 04          
1098   82E4 E2          
1098   82E5 6E          
1099   82E6 FB 55       	XRI	$55		; ...
1100   82E8 3A E8       	BNZ	$		; and that's enough for now
1101   82EA             
1102   82EA             ; Now a simple PPI address bus test...
1103   82EA E0          	POST($56)		; PPI address bus test
1103   82EB 64          
1103   82EC 56          
1104   82ED 67          	WPPI(PPIPA,$AA)		; write one value to register A
1104   82EE 04          
1104   82EF 66          
1104   82F0 AA          
1105   82F1 67          	WPPI(PPIPB,$BB)		; and another to register B
1105   82F2 05          
1105   82F3 66          
1105   82F4 BB          
1106   82F5 67          	WPPI(PPIPC,$CC)		; and a third to register C
1106   82F6 06          
1106   82F7 66          
1106   82F8 CC          
1107   82F9 67          	RPPI(PPIPA)		; read 'em back and see if they're OK
1107   82FA 04          
1107   82FB E2          
1107   82FC 6E          
1108   82FD FB AA       	XRI	$AA		; ???
1109   82FF C4          	NOP			; needed for page alignment!
TASM 1802 Assembler.              boots.asm                        page 38
BTS1802 -- Monitor for the COSMAC Elf 2000

1110   8300 3A 00       	BNZ	$		; just loop forever if one fails
1111   8302 E0          	SEX	PC0		; ...
1112   8303 67          	RPPI(PPIPB)		; ...
1112   8304 05          
1112   8305 E2          
1112   8306 6E          
1113   8307 FB BB       	XRI	$BB		; ...
1114   8309 3A 09       	BNZ	$		; ...
1115   830B E0          	SEX	PC0		; one more time!
1116   830C 67          	RPPI(PPIPC)		; ...
1116   830D 06          
1116   830E E2          
1116   830F 6E          
1117   8310 FB CC       	XRI	$CC		; ...
1118   8312 3A 12       	BNZ	$		; ...
1119   8314             
1120   8314             ; Leave the PPI in input mode and we're done...
1121   8314 E0          	SEX	PC0		; ...
1122   8315 67          	WPPI(PPICTL,$9B)	; ...
1122   8316 07          
1122   8317 66          
1122   8318 9B          
1123   8319             #endif
1124   8319             
1125   8319             NOPPI:
1126   8319             ; Fall into the PS/2 keyboard test...
1127   8319             
TASM 1802 Assembler.              boots.asm                        page 39
BTS1802 -- Monitor for the COSMAC Elf 2000

1128   8319             	.EJECT
1129   8319             ;	.SBTTL	PS/2 Keyboard Initialization
1130   8319             
1131   8319             #ifdef ELF2K
1132   8319             ;   After a power up or a reset the keyboard APU, if it is alive and well,
1133   8319             ; sends three bytes - 0xCB, 0x42 ("KB") and then the APU firmware version.
1134   8319             ; After that it sends either 0xAA if the keyboard is connected and OK, or
1135   8319             ; nothing if there's no keyboard or the keyboard failed its own internal
1136   8319             ; self test.
1137   8319             ;
1138   8319             ;   Remember, though, that the PS/2 keyboard interface may not even be
1139   8319             ; present on this Elf 2000 system, so we can't wait forever for the "KB"
1140   8319             ; to show up - there has to be a simple time out.
1141   8319 E0          TSTPS2:	POST($54)		; PS/2 keyboard test
1141   831A 64          
1141   831B 54          
1142   831C F8 7F       	RLDI(P1,PS2VER)		; start by initializing the PS2 keyboard
1142   831E BF          
1142   831F F8 B3       
1142   8321 AF          
1143   8322 F8 00       	LDI	0		;  ... APU firmware version to zero
1144   8324 5F          	STR	P1		;  ... which means "no keyboard attached"!
1145   8325             
1146   8325             ;   Note that the keyboard APU is pretty fast by 1802 standards, and so for
1147   8325             ; a time out we simply count up in the D register.  When it overflows, the
1148   8325             ; time out has expired!
1149   8325 35 2E       TPS21:	BPS2(TPS22)		; branch if the keyboard flag is set
1150   8327 FC 01       	ADI	1		; nope - increment D
1151   8329 3B 25       	BNF	TPS21		; and keep going 'till it overflows
1152   832B C0 83 4B    	LBR	NOKBD		; no keyboard present
1153   832E             
1154   832E             ; Read the first byte from the keyboard ...
1155   832E E2          TPS22:	SEX	SP		; be sure X points to real memory
1156   832F 6F          	INP	PS2KBD		; and read the keyboard data
1157   8330 FB CB       	XRI	'K'+$80		; check the first magic byte
1158   8332 CA 83 4B    	LBNZ	NOKBD		; no keyboard if that's not it
1159   8335             
1160   8335             ; Wait for the second byte...
1161   8335 35 3E       TPS23:	BPS2(TPS24)		; ...
1162   8337 FC 01       	ADI	1		; ...
1163   8339 3B 35       	BNF	TPS23		; ...
1164   833B C0 83 4B    	LBR	NOKBD		; no keyboard present
1165   833E             
1166   833E             ; Read the second byte from the keyboard ...
1167   833E 6F          TPS24:	INP	PS2KBD		; ...
1168   833F FB 42       	XRI	'B'		; and check this one too
1169   8341 CA 83 4B    	LBNZ	NOKBD		; no keyboard ..
1170   8344             
1171   8344             ;   Having received those two bytes succesfully, we now assume that there's
1172   8344             ; an Elf 2000 GPIO card with the PS/2 keyboard APU present.  Now we wait,
1173   8344             ; forever if necessary, for the firmware version number...
1174   8344 E0          	POST($53)		; waiting for keyboard version
1174   8345 64          
1174   8346 53          
1175   8347 3D 47       	BNPS2($)		; wait for the flag to set
1176   8349 EF          	SEX	P1		; read the version directly into
1177   834A 6F          	INP	PS2KBD		;  ... location PS2VER in RAM
1178   834B             
1179   834B             ;   That's it for the canned part of the APU firmware startup.  If there is
TASM 1802 Assembler.              boots.asm                        page 40
BTS1802 -- Monitor for the COSMAC Elf 2000

1180   834B             ; really a keyboard connected to the GPIO card, then it will send 0xAA to the
1181   834B             ; APU when the keyboard completes its own internal self test.  The APU passes
1182   834B             ; that along to us, which we wait for here.  Notice that if the GPIO and APU
1183   834B             ; is present but no keyboard is plugged in, we'll actually loop forever with
1184   834B             ; POST code 57 displayed ...
1185   834B             ;
1186   834B             ;   NOTE - we'd like to do this, but we can't.  An 1802 RESET doesn't reset
1187   834B             ; the PS/2 keyboard, so if the system is reset after a power up the keyboard
1188   834B             ; won't send the 0xAA byte.  The APU _is_ reset by a 1802 RESET, however, and
1189   834B             ; the way to fix this would be to make the APU firmware transmit a reset
1190   834B             ; command to the keyboard whenever the APU is restarted, but the current APU
1191   834B             ; firmware is receive only and doesn't have the ability to transmit anything.
1192   834B             ;TPS25:	POST($52)		; no PS/2 keyboard
1193   834B             ;	BNPS2($)		; wait for some data
1194   834B             ;	SEX	SP		; ...
1195   834B             ;	INP	PS2KBD		; now read what it is
1196   834B             ;	XRI	$AA		; if it isn't keyboard OK
1197   834B             ;	BNZ	TPS25		; then keep waiting!
1198   834B             #endif
1199   834B             
1200   834B             NOKBD:
1201   834B             ; Fall into SYSI2B...
1202   834B             
TASM 1802 Assembler.              boots.asm                        page 41
BTS1802 -- Monitor for the COSMAC Elf 2000

1203   834B             	.EJECT
1204   834B             ;	.SBTTL	Software Initialization
1205   834B             
1206   834B             ;   When we get here, both the EPROM and SRAM have been tested and the SRAM
1207   834B             ; cleared OR, if the battery backup is working, then the SRAM contents have
1208   834B             ; been tested and found to be valid.  Now we set up all the software, including
1209   834B             ; the SCRT (standard call/return technique) linkage, the software stack, and
1210   834B             ; initialize the terminal...
1211   834B             
1212   834B             ;   Time to initialize SCRT before going any further.  It may not sound like
1213   834B             ; much, but remember that from here on P=3!!
1214   834B E0          SYSI2B:	SEX	PC0		; do POST() one last time
1215   834C E0          	POST($40)		; ...
1215   834D 64          
1215   834E 40          
1216   834F F8 7F       	RLDI(SP,STACK)		; initialize the stack pointer
1216   8351 B2          
1216   8352 F8 77       
1216   8354 A2          
1217   8355 F8 83       	RLDI(A,SYSIN3)		; continue processing from SYSIN3:
1217   8357 B6          
1217   8358 F8 5E       
1217   835A A6          
1218   835B C0 FF 3F    	LBR	F_INITCALL	; and intialize the SCRT routines
1219   835E             
1220   835E             ;   Change the POST to 19 to indicate that all hardware tests have passed.
1221   835E             ; Post codes in the range $10..$19 are used for various software initialization
1222   835E             ; stages...
1223   835E             
1224   835E             ;   If the non-volatile RAM chip is installed, then check then see if the NVR
1225   835E             ; contents are valid and if they match the version number of this monitor.
1226   835E             ; If the contents are invalid or if they're leftover from a different monitor
1227   835E             ; version then load the NVR with the default settings now.
1228   835E             ;
1229   835E             ;   As a special hack for the ELF2K only, if the switch register is set to 0x43
1230   835E             ; then re-initialize the NVR (assuming it's present) regardless ...
1231   835E E3          SYSIN3:	OUTI(LEDS,$18)		; set the LEDs 18 to indicate BIOS OK
1231   835F 64          
1231   8360 18          
1231   8361 E2          
1232   8362 D4          	CALL(F_RTCTEST)		; is the RTC/NVR installed?
1232   8363 F8 2D       
1233   8365 CB 83 A8    	LBNF	SYSI3B		; nope - there's nothing to do
1234   8368             
1235   8368             ; See if the switches are set to $43 ...
1236   8368             #ifdef ELF2K
1237   8368 E2          	SEX	SP		; address temporary RAM
1238   8369 6C          	INP	SWITCHES	; read the switch register
1239   836A FB 43       	XRI	$43		; are they set to 43?
1240   836C C2 83 93    	LBZ	SYSI3A		; yes - force NVR to be initialized
1241   836F             #endif
1242   836F             
1243   836F             ; Read the version number stored in the NVR and compare to MONVER ...
1244   836F F8 00       	RLDI(P1,NVRVERS)	; offset of the NVR version number
1244   8371 BF          
1244   8372 F8 05       
1244   8374 AF          
1245   8375 F8 7F       	RLDI(P2,NVRVER)		; store what we read here
1245   8377 BD          
TASM 1802 Assembler.              boots.asm                        page 42
BTS1802 -- Monitor for the COSMAC Elf 2000

1245   8378 F8 7D       
1245   837A AD          
1246   837B F8 00       	RLDI(P3,1)		; and read just one byte
1246   837D BC          
1246   837E F8 01       
1246   8380 AC          
1247   8381 D4          	CALL(F_RDNVR)		; try to read NVR
1247   8382 F8 1B       
1248   8384 C3 83 93    	LBDF	SYSI3A		; NVR contents are not valid - initialize
1249   8387 F8 7F       	RLDI(DP,NVRVER)		; point to the NVRVER in RAM
1249   8389 B7          
1249   838A F8 7D       
1249   838C A7          
1250   838D 07          	LDN	DP		; and see what we got
1251   838E FB 73       	XRI	MONVER		; does it match our version?
1252   8390 C2 83 A8    	LBZ	SYSI3B		; yes - NVR contents are valid!
1253   8393             
1254   8393             ; Initialize NVR with all the default settings ...
1255   8393 F8 00       SYSI3A:	RLDI(P1,NVRBASE)	; offset of monitor data in NVR
1255   8395 BF          
1255   8396 F8 00       
1255   8398 AF          
1256   8399 F8 80       	RLDI(P2,NVRDEFAULT)	; pointer to default NVR data in ROM
1256   839B BD          
1256   839C F8 94       
1256   839E AD          
1257   839F F8 00       	RLDI(P3,NVRSIZE)	; count of bytes to write
1257   83A1 BC          
1257   83A2 F8 06       
1257   83A4 AC          
1258   83A5 D4          	CALL(F_WRNVR)		; attempt to save it
1258   83A6 F8 1E       
1259   83A8             
1260   83A8             ;   If the data switches are set to 0x81 then just go directly to the video
1261   83A8             ; test without messing with the terminal or autobaud...
1262   83A8             SYSI3B:
1263   83A8~            #ifdef PIXIE
1264   83A8~            	OUTI(LEDS,$17)		; special CHM startup mode
1264   83A8~            	OUTI(LEDS,$17)		; special CHM startup mode
1264   83A8~            	OUTI(LEDS,$17)		; special CHM startup mode
1264   83A8~            	OUTI(LEDS,$17)		; special CHM startup mode
1265   83A8~            	SEX	SP		; address the stack
1266   83A8~            	INP	SWITCHES	; SWITCHES -> D, R(X)
1267   83A8~            	XRI	$81		; are they set to 0x81??
1268   83A8~            	LBZ	PIXCHM		; yes - just do the video test now
1269   83A8             #endif
1270   83A8             
1271   83A8             ;   See if the 8275 video card is installed and, if it is, then start it
1272   83A8             ; up.  Remember that this card uses DMA and interrupts, so from here on R0
1273   83A8             ; and R1 are off limits!!
1274   83A8~            #ifdef VIDEO
1275   83A8~            	CALL(VIDEO)		; call INIT75
1275   83A8~            	CALL(VIDEO)		; call INIT75
1276   83A8~            	PUSHD			; temporarily save the status
1277   83A8~            	RLDI(P1,VIDVER)		;  ... so we can save it in VIDVER
1277   83A8~            	RLDI(P1,VIDVER)		;  ... so we can save it in VIDVER
1277   83A8~            	RLDI(P1,VIDVER)		;  ... so we can save it in VIDVER
1277   83A8~            	RLDI(P1,VIDVER)		;  ... so we can save it in VIDVER
1278   83A8~            	POPD			; ...
TASM 1802 Assembler.              boots.asm                        page 43
BTS1802 -- Monitor for the COSMAC Elf 2000

1278   83A8~            	POPD			; ...
1279   83A8~            	STR	P1		; ...
1280   83A8             #endif
1281   83A8             
1282   83A8             ;   Now initialize (or re-initialize) the console serial port.  The console can
1283   83A8             ; be either the bit banged serial port on the main board, or the UART port on
1284   83A8             ; the disk card, and either one supports several different baud rates.  If this
1285   83A8             ; is a warm start and serial port data is saved in SRAM or NVR, the TTYINI
1286   83A8             ; routine will attempt to restore the previous console state. Otherwise it will
1287   83A8             ; call the BIOS autobaud function to determine the correct console port and
1288   83A8             ; speed...
1289   83A8 D4          	CALL(TTYINI)
1289   83A9 90 5D       
1290   83AB             
1291   83AB             ;   Now print a sign on message with a whole bunch of information about the
1292   83AB             ; system configuration (well, a little bit at least!)...
1293   83AB E3          SYSI30:	OUTI(LEDS,$15)		; POST code 15 - software initialization done
1293   83AC 64          
1293   83AD 15          
1293   83AE E2          
1294   83AF F8 80       	OUTSTR(SYSTEM)		; "COSMAC ELF 2000" ...
1294   83B1 BF          
1294   83B2 F8 06       
1294   83B4 AF          
1294   83B5 D4          
1294   83B6 FF 09       
1295   83B8             
1296   83B8             ; Print the EPROM version and checksum...
1297   83B8 D4          	INLMES(" EPROM V")	; ...
1297   83B9 FF 66       
1297   83BB 20 45 50 52 
1297   83BF 4F 4D 20 56 
1297   83C3 00          
1298   83C4 F8 00       	RLDI(P1,MONVER)		; print the EPROM version number
1298   83C6 BF          
1298   83C7 F8 73       
1298   83C9 AF          
1299   83CA D4          	CALL(TDEC16)		; always in decimal
1299   83CB 91 82       
1300   83CD D4          	INLMES(" CHECKSUM ")	; and the EPROM checksum
1300   83CE FF 66       
1300   83D0 20 43 48 45 
1300   83D4 43 4B 53 55 
1300   83D8 4D 20 
1300   83DA 00          
1301   83DB F8 FF       	RLDI(P2,CHKSUM)		; stored here by the romcksum program
1301   83DD BD          
1301   83DE F8 FE       
1301   83E0 AD          
1302   83E1 ED          	SEX	P2		; use P2 to address memory
1303   83E2 72          	POPR(P1)		; and fetch the checksum into P1
1303   83E3 BF          
1303   83E4 72          
1303   83E5 AF          
1304   83E6 D4          	CALL(THEX4)		; type that in HEX
1304   83E7 91 7A       
1305   83E9             
1306   83E9             ;   Now give the RAM status...  We could actually call the BIOS F_FREEMEM
1307   83E9             ; function here to determine the SRAM size, but this code (especially the
TASM 1802 Assembler.              boots.asm                        page 44
BTS1802 -- Monitor for the COSMAC Elf 2000

1308   83E9             ; RAM test) is pretty much hardwired for a 32K SRAM.  Also, F_FREEMEM takes
1309   83E9             ; several seconds to execute, which is annoying here.
1310   83E9             RAMSIZE	.EQU	(RAMPAGE+$100) / 1024
1311   83E9 D4          	INLMES("  SRAM ")	; print the SRAM size
1311   83EA FF 66       
1311   83EC 20 20 53 52 
1311   83F0 41 4D 20 
1311   83F3 00          
1312   83F4 F8 00       	RLDI(P1,RAMSIZE)	; in decimal kilobytes
1312   83F6 BF          
1312   83F7 F8 20       
1312   83F9 AF          
1313   83FA D4          	CALL(TDEC16)		; ...
1313   83FB 91 82       
1314   83FD D4          	INLMES("K ")		; ...
1314   83FE FF 66       
1314   8400 4B 20       
1314   8402 00          
1315   8403 F8 7F       	RLDI(DP,BATTOK)		; get the battery backup flag
1315   8405 B7          
1315   8406 F8 AC       
1315   8408 A7          
1316   8409 07          	LDN	DP		; from the monitor's RAM page
1317   840A CA 84 1F    	LBNZ	SYSIN4		; branch if battery backup was OK
1318   840D D4          	INLMES("INITIALIZED")	; SRAM was initialized from scratch
1318   840E FF 66       
1318   8410 49 4E 49 54 
1318   8414 49 41 4C 49 
1318   8418 5A 45 44 
1318   841B 00          
1319   841C C0 84 2E    	LBR	SYSI4A		; ...
1320   841F D4          SYSIN4:	INLMES("CONTENTS OK")	; current SRAM contents were used
1320   8420 FF 66       
1320   8422 43 4F 4E 54 
1320   8426 45 4E 54 53 
1320   842A 20 4F 4B 
1320   842D 00          
1321   842E             
1322   842E             ; That's the end of line 1. Next, print all the copyright notice(s)...
1323   842E D4          SYSI4A:	CALL(TCRLF)		; ...
1323   842F 90 D5       
1324   8431 F8 80       	OUTSTR(RIGHTS)		; type the copyright notices
1324   8433 BF          
1324   8434 F8 19       
1324   8436 AF          
1324   8437 D4          
1324   8438 FF 09       
1325   843A             
1326   843A             ; Fall into the IDE drive discovery...
TASM 1802 Assembler.              boots.asm                        page 45
BTS1802 -- Monitor for the COSMAC Elf 2000

1327   843A             	.EJECT
1328   843A             ;	.SBTTL	Probe for IDE drives
1329   843A             
1330   843A             ;  Probe for a master and/or slave ide drive and identify what we find...
1331   843A E3          SYSI5A:	OUTI(LEDS,$14)		; POST code for IDE master
1331   843B 64          
1331   843C 14          
1331   843D E2          
1332   843E F8 00       	LDI	0		; first test the IDE master drive
1333   8440 D4          	CALL(PROBE)		; ...
1333   8441 89 43       
1334   8443             ;   Currently the IDE slave isn't supported by the BIOS, so there's no reason
1335   8443             ; to probe for it.  It just makes the boot take longer!
1336   8443             ;	OUTI(LEDS,$13)		; POST code for IDE slave
1337   8443             ;	LDI	1		; then test the IDE slae
1338   8443             ;	CALL(PROBE)		; ...
1339   8443             
1340   8443             ; If this system as a RTC and NVR, then print the date and time...
1341   8443 E3          	OUTI(LEDS,$12)		; printing date and time
1341   8444 64          
1341   8445 12          
1341   8446 E2          
1342   8447 D4          	CALL(F_RTCTEST)		; is the real time clock installed?
1342   8448 F8 2D       
1343   844A 3B 52       	BNF	SYSI5B		; skip if not
1344   844C D4          	CALL(SHOWNOW)		; type the current date/time
1344   844D 8A 3A       
1345   844F D4          	CALL(TCRLF)		; and finish the line
1345   8450 90 D5       
1346   8452             
1347   8452             ; Fall into the auto [re]start routine...
1348   8452             SYSI5B:
1349   8452             
TASM 1802 Assembler.              boots.asm                        page 46
BTS1802 -- Monitor for the COSMAC Elf 2000

1350   8452             	.EJECT
1351   8452             ;	.SBTTL	System Auto [Re]Start
1352   8452             
1353   8452             ;   The boot flag (BOOTF) can be set to a non-zero value to cause the system
1354   8452             ; to automatically restart or boot on a power up. Remember that, so long as the
1355   8452             ; main board has the battery backup installed, all of SRAM will be preserved
1356   8452             ; while power is off.  If the BOOTF flag is ABTADDR then RESTA is assumed to
1357   8452             ; contain a 16 bit restart address and we jump there before starting the
1358   8452             ; monitor's command scanner.
1359   8452             ;
1360   8452             ;   If the BOOTF flag contains ABTDISK, then we'll attempt to boot the primary
1361   8452             ; IDE drive.  If this is succesful then we can go directly to ElfOS without
1362   8452             ; needing to type the monitor "BOOT" command.  If the bootstrap is unsuccessful
1363   8452             ; (i.e. there's no IDE drive or the media is not bootable) then we simply
1364   8452             ; enter the monitor's command loop anyway.
1365   8452             ;
1366   8452             ;   If the system contains NVR (non-volatile RAM) then it's possible to store
1367   8452             ; the boot flag in NVR as well.
1368   8452 E3          ASTART:	OUTI(LEDS, $11)		; POST code 11 for restart
1368   8453 64          
1368   8454 11          
1368   8455 E2          
1369   8456 F8 7F       	RLDI(DP,BOOTF)		; point DP to the boot flag
1369   8458 B7          
1369   8459 F8 B5       
1369   845B A7          
1370   845C 07          	LDN	DP		; and then load the boot flag
1371   845D CA 84 7C    	LBNZ	ASTAR1		; if it's not zero, then decode it
1372   8460             
1373   8460             ; See if there's an NVR attached, and attempt to read the boot flag from it.
1374   8460 F8 00       	RLDI(P1,NVRBOOT)	; offset of the boot flag in NVR
1374   8462 BF          
1374   8463 F8 00       
1374   8465 AF          
1375   8466 F8 7F       	RLDI(P2,BOOTF)		; where to store the data in SRAM
1375   8468 BD          
1375   8469 F8 B5       
1375   846B AD          
1376   846C F8 00       	RLDI(P3,3)		; number of bytes to read
1376   846E BC          
1376   846F F8 03       
1376   8471 AC          
1377   8472 D4          	CALL(F_RDNVR)		; ...
1377   8473 F8 1B       
1378   8475             ;   Note that if this fails (either because there's no NVR installed or because
1379   8475             ; the NVR contents are invalid) then BOOTF will be unchanged and remain zero.
1380   8475 F8 7F       	RLDI(DP,BOOTF)		; F_RDNVR trashes DP, so reload it
1380   8477 B7          
1380   8478 F8 B5       
1380   847A A7          
1381   847B 47          	LDA	DP		; get the new boot flag
1382   847C             
1383   847C             ; Decode the restart option selected ...
1384   847C C2 84 B6    ASTAR1:	LBZ	MAIN0		; if it's zero, then start the command scanner
1385   847F FB A5       	XRI	ABTDISK		; autoboot from IDE?
1386   8481 C2 84 9A    	LBZ	ASTAR2		; yes - go do that
1387   8484 47          	LDA	DP		; get the boot flag again
1388   8485 FB 5A       	XRI	ABTADDR		; "SET RESTART xxxx" ?
1389   8487 CA 84 B6    	LBNZ	MAIN0		; nope - default to SET RESTART NONE
TASM 1802 Assembler.              boots.asm                        page 47
BTS1802 -- Monitor for the COSMAC Elf 2000

1390   848A             
1391   848A             ; Here to restart at a specific address ...
1392   848A~            #ifdef VIDEO
1393   848A~            	CALL(ISCRTC)		; is the video card installed?
1393   848A~            	CALL(ISCRTC)		; is the video card installed?
1394   848A~            	LBDF	MAIN0		; yes - can't do this (it uses R0!)
1395   848A             #endif
1396   848A D4          	CALL(RESADR)		; print "RESTART @...."
1396   848B 8B C0       
1397   848D F8 7F       	RLDI(DP,RESTA)		; point to the restart address
1397   848F B7          
1397   8490 F8 B6       
1397   8492 A7          
1398   8493 E7          	SEX	DP		; ...
1399   8494 72          	POPR(PC0)		; load PC0
1399   8495 B0          
1399   8496 72          
1399   8497 A0          
1400   8498 E0          	SEX	PC0		; set X=0 too
1401   8499 D0          	SEP	PC0		; and hope for the best!
1402   849A             
1403   849A             
1404   849A             ; Attempt to bootstrap the primary IDE drive...
1405   849A E0          ASTAR2:	POST($10)		; autoboot
1405   849B 64          
1405   849C 10          
1406   849D D4          	CALL(BOOTIDE)		; this returns only if the bootstrap fails!
1406   849E 88 E6       
1407   84A0             ;	OUTSTR(ABTMSG)		; BOOTIDE already prints an error message!
1408   84A0 C0 84 B6    	LBR	MAIN0		; so if it does fail, just run the monitor
1409   84A3             
1410   84A3             ; These messages are used during a cold start...
1411   84A3             ;ABTMSG:	.TEXT	"?AUTOBOOT FAIL\r\n\000"
1412   84A3             #ifdef HELP
1413   84A3 46 6F 72 20 FORHLP:	.TEXT	"For help type HELP\000"
1413   84A7 68 65 6C 70 
1413   84AB 20 74 79 70 
1413   84AF 65 20 48 45 
1413   84B3 4C 50 00 
1414   84B6             #endif
1415   84B6             
TASM 1802 Assembler.              boots.asm                        page 48
BTS1802 -- Monitor for the COSMAC Elf 2000

1416   84B6             	.EJECT
1417   84B6             ;	.SBTTL	BOOTS Command Scanner
1418   84B6             
1419   84B6             ;   This is the 'main program' for BOOTS. It reads a command line, decodes
1420   84B6             ; the name of the command, and dispatches to the correct command processor
1421   84B6             ; routine...
1422   84B6             
1423   84B6             ; Print the "For help type HELP" message...
1424   84B6             MAIN0:
1425   84B6             #ifdef HELP
1426   84B6 F8 84       	OUTSTR(FORHLP)	; print the help message and we're done
1426   84B8 BF          
1426   84B9 F8 A3       
1426   84BB AF          
1426   84BC D4          
1426   84BD FF 09       
1427   84BF             #endif
1428   84BF D4          MAIN2:	CALL(TCRLF)	; finish the line
1428   84C0 90 D5       
1429   84C2             
1430   84C2             ;  Initialize (or rather, re-initialize) enough context so that the monitor
1431   84C2             ; can still run even if some registers have been screwed up...
1432   84C2 E3          MAIN:	OUTI(LEDS,$00)	; change the POST code to 00
1432   84C3 64          
1432   84C4 00          
1432   84C5 E2          
1433   84C6 F8 7F       MAIN1:	RLDI(SP,STACK)	; reset the stack pointer to the TOS
1433   84C8 B2          
1433   84C9 F8 77       
1433   84CB A2          
1434   84CC E2          	SEX	SP	; and reset X
1435   84CD F8 7F       	RLDI(DP,BAUD1)	; set DP and, as as side effect, ...
1435   84CF B7          
1435   84D0 F8 A4       
1435   84D2 A7          
1436   84D3 07          	LDN	DP	;  ... reset the baud rate constant
1437   84D4 BE          	PHI	BAUD	;  ...
1438   84D5             
1439   84D5             ;   Normally we set R1 to point at the TRAP routine so that break points can
1440   84D5             ; be used inside monitor commands too (after all, there are sometimes bugs
1441   84D5             ; in the monitor too!) but if the video is active then we can't do that...
1442   84D5~            #ifdef VIDEO
1443   84D5~            	CALL(ISCRTC)	; is the video card active:
1443   84D5~            	CALL(ISCRTC)	; is the video card active:
1444   84D5~            	BDF	MAIN10	; yep - skip this
1445   84D5             #endif
1446   84D5 F8 8D       	RLDI(1,TRAP)	; allow breakpoints to be used inside monitor commands
1446   84D7 B1          
1446   84D8 F8 EB       
1446   84DA A1          
1447   84DB             MAIN10:
1448   84DB             
1449   84DB             ; Print the monitor prompt and scan a command line...
1450   84DB D4          	INLMES(">>>")	; print the monitor prompt
1450   84DC FF 66       
1450   84DE 3E 3E 3E    
1450   84E1 00          
1451   84E2 F8 7F       	RLDI(P1,CMDBUF)	; address of the command line buffer
1451   84E4 BF          
TASM 1802 Assembler.              boots.asm                        page 49
BTS1802 -- Monitor for the COSMAC Elf 2000

1451   84E5 F8 B8       
1451   84E7 AF          
1452   84E8 F8 00       	RLDI(P3,CMDMAX)	; and the length of the same
1452   84EA BC          
1452   84EB F8 40       
1452   84ED AC          
1453   84EE D4          	CALL(F_INPUTL)	; read a command line
1453   84EF FF 69       
1454   84F1 C3 84 BF    	LBDF	MAIN2	; branch if the line was terminated by ^C
1455   84F4 D4          	CALL(TCRLF)	; F_INPUT doesn't echo a <LF> at the end
1455   84F5 90 D5       
1456   84F7             
1457   84F7             ;   Parse the command name, look it up, and execute it.  By convention while
1458   84F7             ; we're parsing the command line (which occupies a good bit of code, as you
1459   84F7             ; might imagine), P1 is always used as a command line pointer...
1460   84F7 F8 7F       	RLDI(P1,CMDBUF)	; P1 always points to the command line
1460   84F9 BF          
1460   84FA F8 B8       
1460   84FC AF          
1461   84FD D4          	CALL(F_LTRIM)	; skip any leading spaces
1461   84FE FF 15       
1462   8500 D4          	CALL(ISEOL)	; is the line blank???
1462   8501 85 61       
1463   8503 C3 84 C2    	LBDF	MAIN	; yes - just go read another
1464   8506 F8 92       	RLDI(P2,CMDTBL)	; table of top level commands
1464   8508 BD          
1464   8509 F8 1D       
1464   850B AD          
1465   850C D4          	CALL(COMND)	; parse and execute the command
1465   850D 85 12       
1466   850F C0 84 C2    	LBR	MAIN	; and the do it all over again
1467   8512             
TASM 1802 Assembler.              boots.asm                        page 50
BTS1802 -- Monitor for the COSMAC Elf 2000

1468   8512             	.EJECT
1469   8512             ;	.SBTTL	Lookup and Dispatch Command Verbs
1470   8512             
1471   8512             ;   This routine is called with P1 pointing to the first letter of a command
1472   8512             ; (usually the first thing in the command buffer) and P2 pointing to a table
1473   8512             ; of commands.  It searches the command table for a command that matches the
1474   8512             ; command line and, if it finds one, dispatches to the correct action routine.
1475   8512             ;
1476   8512             ;   Commands can be any number of characters (not necessarily even letters)
1477   8512             ; and may be abbreviated to a minimum length specified in the command table.
1478   8512             ; For example, "BA", "BAS", "BASI" and "BASIC" are all valid for the "BASIC"
1479   8512             ; command, however "BASEBALL" is not.  
1480   8512 9F          COMND:	RCOPY(P3,P1)	; save the command line pointer so we can back up
1480   8513 BC          
1480   8514 8F          
1480   8515 AC          
1481   8516 9C          COMND1:	RCOPY(P1,P3)	; reset the command line pointer
1481   8517 BF          
1481   8518 8C          
1481   8519 AF          
1482   851A 4D          	LDA	P2	; get the minimum match count for the next command
1483   851B C2 85 6C    	LBZ	ERRALL	; end of command table if it's zero
1484   851E AB          	PLO	P4	; save the minimum match count
1485   851F             
1486   851F             ;   Compare characters on the command line with those in the command table
1487   851F             ; and, as long as they match, advance both pointers....
1488   851F 0D          COMND2:	LDN	P2	; take a peek at the next command table byte
1489   8520 C2 85 36    	LBZ	COMN3A	; branch if it's the end of this command
1490   8523 0F          	LDN	P1	; and get the next character
1491   8524 D4          	CALL(FOLD)	; make it upper case
1491   8525 91 17       
1492   8527 ED          	SEX	P2	; now address the command table
1493   8528 F7          	SM		; does the command line match the table?
1494   8529 3A 31       	BNZ	COMND3	; nope - skip over this command
1495   852B 1D          	INC	P2	; yes - increment P2
1496   852C 1F          	INC	P1	; and P1 ...
1497   852D 2B          	DEC	P4	; and keep count of the number of matches
1498   852E C0 85 1F    	LBR	COMND2	; keep comparing characters
1499   8531             
1500   8531             ;   Here when we find something that doesn't match.  If enough characters
1501   8531             ; DID match, then this is the command; otherwise move on to the next table
1502   8531             ; entry...
1503   8531 ED          COMND3:	SEX	P2	; be sure P2 is at the end of this command
1504   8532 72          	LDXA		; ???
1505   8533 3A 32       	BNZ	$-1	; keep going until we're there
1506   8535 38          	SKP		; skip over the IRX
1507   8536 60          COMN3A:	IRX		; skip over the null byte to the dispatch address
1508   8537 8B          	GLO	P4	; how many characters matched?
1509   8538 32 42       	BZ	COMND4	; branch if an exact match
1510   853A FE          	SHL		; test the sign bit of P4.0
1511   853B 33 42       	BDF	COMND4	; more than an exact match
1512   853D             
1513   853D             ; This command doesn't match.  Skip it and move on to the next...
1514   853D 1D          	INC P2\ INC P2	; skip two bytes for the dispatch address
1514   853E 1D          
1515   853F C0 85 16    	LBR	COMND1	; and then start over again
1516   8542             
1517   8542             ; This command matches!
1518   8542 F8 85       COMND4:	RLDI(T1,COMND5)	; switch the PC temporarily
TASM 1802 Assembler.              boots.asm                        page 51
BTS1802 -- Monitor for the COSMAC Elf 2000

1518   8544 B9          
1518   8545 F8 49       
1518   8547 A9          
1519   8548 D9          	SEP	T1	; ...
1520   8549 ED          COMND5:	SEX	P2	; ...
1521   854A 72          	POPR(PC)	; load the dispatch address into the PC
1521   854B B3          
1521   854C 72          
1521   854D A3          
1522   854E E2          	SEX	SP	; return to the usual X value
1523   854F D3          	SEP	PC	; branch to the action routine
1524   8550             
TASM 1802 Assembler.              boots.asm                        page 52
BTS1802 -- Monitor for the COSMAC Elf 2000

1525   8550             	.EJECT
1526   8550             ;	.SBTTL	Command Parsing Functions
1527   8550             
1528   8550             ;   Examine the character pointed to by P1 and if it's a space, tab, or end
1529   8550             ; of line (NULL) then return with DF=1...
1530   8550 0F          ISSPAC:	LDN	P1	; get the byte from the command line
1531   8551 32 5E       	BZ	ISSPA1	; return TRUE for EOL
1532   8553 FF 09       	SMI	CHTAB	; is it a tab?
1533   8555 32 5E       	BZ	ISSPA1	; yes - return true for that too
1534   8557 FF 17       	SMI   ' '-CHTAB	; no - what about a space?
1535   8559 32 5E       	BZ	ISSPA1	; that works as well
1536   855B FC 00       	CDF		; it's not a space, return DF=0
1537   855D D5          	RETURN		; ...
1538   855E FF 00       ISSPA1:	SDF		; it IS a space!
1539   8560 D5          	RETURN
1540   8561             
1541   8561             ; If the character pointed to by P1 is EOL, then return with DF=1...
1542   8561 0F          ISEOL:	LDN	P1	; get the byte from the command line
1543   8562 C2 85 5E    	LBZ	ISSPA1	; return DF=1 if it's EOL
1544   8565 FC 00       	CDF		; otherwise return DF=0
1545   8567 D5          	RETURN		; ...
1546   8568             
1547   8568             ;   This routine will echo a question mark, then all the characters from
1548   8568             ; the start of the command buffer up to the location addressed by P1, and
1549   8568             ; then another question mark and a CRLF.  After that it does a LBR to MAIN
1550   8568             ; to restart the command scanner.  It's used to report syntax errors; for
1551   8568             ; example, if the user types "BASEBALL" instead of "BASIC", he will see
1552   8568             ; "?BASE?"...
1553   8568 F8 00       CMDERR:	LDI	$00	; terminate the string in the command buffer
1554   856A 1F          	INC	P1	; ...
1555   856B 5F          	STR	P1	; at the location currently addressed by P1
1556   856C             ;   Enter here (again with an LBR) to do the same thing, except at this
1557   856C             ; point we'll echo the entire command line regardless of P1...
1558   856C D4          ERRALL:	CALL(TQUEST)	; print a question mark
1558   856D 90 E9       
1559   856F F8 7F       	OUTSTR(CMDBUF)	; and whatever's in the command buffer
1559   8571 BF          
1559   8572 F8 B8       
1559   8574 AF          
1559   8575 D4          
1559   8576 FF 09       
1560   8578 D4          	CALL(TQUEST)	; and another question mark
1560   8579 90 E9       
1561   857B D4          	CALL(TCRLF)	; end the line
1561   857C 90 D5       
1562   857E C0 84 C2    	LBR	MAIN	; and go read a new command
1563   8581 D4          	CALL(F_TTY)	; ...
1563   8582 FF 4E       
1564   8584             
TASM 1802 Assembler.              boots.asm                        page 53
BTS1802 -- Monitor for the COSMAC Elf 2000

1565   8584             	.EJECT
1566   8584             ;	.SBTTL	Scan Command Parameter Lists
1567   8584             
1568   8584             ;   These routines will scan the parameter lists for commands which either
1569   8584             ; one, two or three parameters, all of which are hex numbers.
1570   8584             
1571   8584             ; Scan two parameters and return them in registers P4 and P3...
1572   8584 D4          SCANP2:	CALL(SCANP1)	; scan the first parameter
1572   8585 85 91       
1573   8587 9D          	RCOPY(P3,P2)	; and save it
1573   8588 BC          
1573   8589 8D          
1573   858A AC          
1574   858B D4          	CALL(ISEOL)	; there had better be more there
1574   858C 85 61       
1575   858E C3 85 68    	LBDF	CMDERR	; error if not
1576   8591             			; and fall into SCANP1 to get the other parameter
1577   8591             
1578   8591             ; Scan a single parameter and return its value in register P4...
1579   8591 D4          SCANP1:	CALL(F_LTRIM)	; ignore any leading spaces
1579   8592 FF 15       
1580   8594 0F          	LDN	P1	; get the next character
1581   8595 D4          	CALL(ISHEX)	; is it a hex digit?
1581   8596 91 28       
1582   8598 CB 85 68    	LBNF	CMDERR	; no - print error message and restart
1583   859B C0 FF 45    	LBR	F_HEXIN	; scan a number and return in P2
1584   859E             
TASM 1802 Assembler.              boots.asm                        page 54
BTS1802 -- Monitor for the COSMAC Elf 2000

1585   859E             	.EJECT
1586   859E             ;	.SBTTL	SHOW, SET and TEST Commands
1587   859E             
1588   859E             ;   These three little routines parse the SHOW, SET and TEST commands, each of
1589   859E             ; which takes a secondary argument - e.g. "SHOW RTC", "SET BOOT", or "TEST RAM"!
1590   859E D4          SHOW:	CALL(F_LTRIM)	; skip any spaces
1590   859F FF 15       
1591   85A1 D4          	CALL(ISEOL)	; there has to be an argument there
1591   85A2 85 61       
1592   85A4 C3 85 68    	LBDF	CMDERR	; error if not
1593   85A7 F8 85       	RLDI(P2,SHOCMD)	; point to the table of SHOW commands
1593   85A9 BD          
1593   85AA F8 B0       
1593   85AC AD          
1594   85AD C0 85 12    	LBR	COMND	; parse it (and call CMDERR if we can't!)
1595   85B0             
1596   85B0 04 54 45 52 SHOCMD:	CMD(4, "TERMINAL", SHOTERM)	; show terminal settings
1596   85B4 4D 49 4E 41 
1596   85B8 4C 00 
1596   85BA 8B 6D       
1597   85BC 03 4E 56 52 	CMD(3, "NVR",      SHOWRTC)	; dump RTC/NVR chip
1597   85C0 00 
1597   85C1 8A D5       
1598   85C3 03 49 44 45 	CMD(3, "IDE",	   SHOWIDE)	; identify IDE drives
1598   85C7 00 
1598   85C8 89 33       
1599   85CA 03 4D 45 4D 	CMD(3, "MEMORY",   SHOMEM)	; show memory size
1599   85CE 4F 52 59 00 
1599   85D2 8B 48       
1600   85D4 03 56 45 52 	CMD(3, "VERSION",  SHOVER)	; show monitor and BIOS version number
1600   85D8 53 49 4F 4E 
1600   85DC 00 
1600   85DD 8B F5       
1601   85DF 03 52 45 53 	CMD(3, "RESTART",  SHORES)	; show restart option
1601   85E3 54 41 52 54 
1601   85E7 00 
1601   85E8 8B 9D       
1602   85EA 03 52 45 47 	CMD(3, "REGISTERS",SHOREG)	; show registers (after a breakpoint)
1602   85EE 49 53 54 45 
1602   85F2 52 53 00 
1602   85F5 8E 60       
1603   85F7 02 44 50 00 	CMD(2, "DP",       DPDUMP)	; show monitor data page
1603   85FB 8B 33       
1604   85FD 02 44 41 54 	CMD(2, "DATE",     SHOWTIME)	; show the real time clock
1604   8601 45 00 
1604   8603 8A 2E       
1605   8605 02 45 46 00 	CMD(2, "EF",	   SHOWEF)	; print status of EF inputs
1605   8609 88 20       
1606   860B 03 43 50 55 	CMD(3, "CPU",      SHOCPU)	; print CPU type and speed
1606   860F 00 
1606   8610 8B E3       
1607   8612 00          	.DB	0
1608   8613             
1609   8613             
1610   8613             ; Set command...
1611   8613 D4          SET:	CALL(F_LTRIM)	; ...
1611   8614 FF 15       
1612   8616 D4          	CALL(ISEOL)	; ...
1612   8617 85 61       
TASM 1802 Assembler.              boots.asm                        page 55
BTS1802 -- Monitor for the COSMAC Elf 2000

1613   8619 C3 85 68    	LBDF	CMDERR	; ...
1614   861C F8 86       	RLDI(P2,SETCMD)	; ...
1614   861E BD          
1614   861F F8 25       
1614   8621 AD          
1615   8622 C0 85 12    	LBR	COMND	; ...
1616   8625             
1617   8625 01 51 00    SETCMD:	CMD(1, "Q",	  SETQ)		; set Q (for testing)
1617   8628 89 FB       
1618   862A 02 44 41 54 	CMD(2, "DATE",    SETTIME)	; set the real time clock
1618   862E 45 00 
1618   8630 8A 7E       
1619   8632 03 52 45 53 	CMD(3, "RESTART", SETRESTA)	; set the boot options
1619   8636 54 41 52 54 
1619   863A 00 
1619   863B 88 73       
1620   863D 03 4E 56 52 	CMD(3, "NVR",     SETNVR)	; set the NVR contents
1620   8641 00 
1620   8642 8C 6B       
1621   8644 00          	.DB	0
1622   8645             
1623   8645             
1624   8645             ; Test command...
1625   8645 D4          TEST:	CALL(F_LTRIM)	; ...
1625   8646 FF 15       
1626   8648 D4          	CALL(ISEOL)	; ...
1626   8649 85 61       
1627   864B C3 85 68    	LBDF	CMDERR	; ...
1628   864E F8 86       	RLDI(P2,TSTCMD)	; ...
1628   8650 BD          
1628   8651 F8 57       
1628   8653 AD          
1629   8654 C0 85 12    	LBR	COMND
1630   8657             
1631   8657 03 52 41 4D TSTCMD:	CMD(3, "RAM",   RAMTEST)	; exhaustive RAM test
1631   865B 00 
1631   865C 8F 1C       
1632   865E~            #ifdef PIXIE
1633   865E~            	CMD(3, "PIXIE", PIXTEST)	; test CDP1861 video
1633   865E~            	CMD(3, "PIXIE", PIXTEST)	; test CDP1861 video
1634   865E             #endif
1635   865E~            #ifdef VIDEO
1636   865E~            	CMD(2, "VT1802",VTTEST)		; test VT1802 video terminal
1636   865E~            	CMD(2, "VT1802",VTTEST)		; test VT1802 video terminal
1637   865E             #endif
1638   865E 00          	.DB	0
1639   865F             
TASM 1802 Assembler.              boots.asm                        page 56
BTS1802 -- Monitor for the COSMAC Elf 2000

1640   865F             	.EJECT
1641   865F             ;	.SBTTL	INPUT Command
1642   865F             
1643   865F             ;   The IN[PUT] command reads the specified I/O port, 1..7, and prints
1644   865F             ; the byte received in hexadecimal...
1645   865F D4          INPUT:	CALL(SCANP1)		; read the port number
1645   8660 85 91       
1646   8662 D4          	CALL(ISEOL)		; and that had better be all
1646   8663 85 61       
1647   8665 CB 85 68    	LBNF	CMDERR		; error if there's more
1648   8668 F8 7F       	RLDI(P4,IOT)		; point T1 at the IOT buffer
1648   866A BB          
1648   866B F8 A1       
1648   866D AB          
1649   866E 8D          	GLO	P2		; get the port address
1650   866F FA 07       	ANI	$07		; trim it to just 3 bits
1651   8671 C2 85 68    	LBZ	CMDERR		; error if port 0 selected
1652   8674 F9 68       	ORI	$68		; turn it into an input instruction
1653   8676 5B          	STR	P4		; and store it in IOT
1654   8677 1B          	INC	P4		; point to IOT+1
1655   8678 F8 D3       	LDI	$D0+PC		; load a "SEP PC" instruction
1656   867A 5B          	STR	P4		; and store that in IOT+1
1657   867B 2B          	DEC	P4		; back to IOT:
1658   867C             
1659   867C             ; Execute the IOT and type the result...
1660   867C D4          	INLMES("Port ")
1660   867D FF 66       
1660   867F 50 6F 72 74 
1660   8683 20 
1660   8684 00          
1661   8685 0B          	LDN	P4		; get the INP instruction again
1662   8686 FA 07       	ANI	$07		; convert the port number to ASCII
1663   8688 F9 30       	ORI	'0'		; ...
1664   868A D4          	CALL(F_TTY)		; ...
1664   868B FF 4E       
1665   868D D4          	INLMES(" = ")
1665   868E FF 66       
1665   8690 20 3D 20    
1665   8693 00          
1666   8694 DB          	SEP	P4		; execute the input and hold your breath!
1667   8695 D4          	CALL(THEX2)		; type that in hex
1667   8696 91 6D       
1668   8698 D4          	CALL(TCRLF)		; finish the line
1668   8699 90 D5       
1669   869B C0 84 C2    	LBR	MAIN		; and we're done here!
1670   869E             
TASM 1802 Assembler.              boots.asm                        page 57
BTS1802 -- Monitor for the COSMAC Elf 2000

1671   869E             	.EJECT
1672   869E             ;	.SBTTL	OUTPUT Command
1673   869E             
1674   869E             ;   The OUT[PUT] command (i.e. ">>>OUT <port> <byte>") writes the specified
1675   869E             ; byte to the specified I/O port.
1676   869E D4          OUTPUT:	CALL(SCANP2)		; read the port number and the byte
1676   869F 85 84       
1677   86A1 D4          	CALL(ISEOL)		; there should be no more
1677   86A2 85 61       
1678   86A4 CB 85 68    	LBNF	CMDERR		; error if there is
1679   86A7 F8 7F       	RLDI(P4,IOT)		; point P4 at the IOT buffer
1679   86A9 BB          
1679   86AA F8 A1       
1679   86AC AB          
1680   86AD 8C          	GLO	P3		; get the port address
1681   86AE FA 07       	ANI	$07		; trim it to just 3 bits
1682   86B0 C2 85 68    	LBZ	CMDERR		; error if port 0 selected
1683   86B3 F9 60       	ORI	$60		; turn it into an input instruction
1684   86B5 5B          	STR	P4		; and store it in IOT
1685   86B6 1B          	INC	P4		; point to IOT+1
1686   86B7 8D          	GLO	P2		; get the data byte
1687   86B8 5B          	STR	P4		; and store that
1688   86B9 1B          	INC	P4		; point to IOT+2
1689   86BA F8 D3       	LDI	$D0+PC		; load a "SEP PC" instruction
1690   86BC 5B          	STR	P4		; and store that in IOT+2
1691   86BD 2B          	DEC	P4		; back to IOT:
1692   86BE 2B          	DEC	P4		; ...
1693   86BF EB          	SEX	P4		; set X=P for IOT
1694   86C0 DB          	SEP	P4		; now call the output routine
1695   86C1             
1696   86C1             ;   A branch to MAIN: will change the data LEDs back to $00.  There's no
1697   86C1             ; real harm in this, but just for fun (and so that we can test the data
1698   86C1             ; LEDs with the OUTPUT command) this command bypasses that.
1699   86C1 C0 84 C6    	LBR	MAIN1		; and we're done
1700   86C4             
TASM 1802 Assembler.              boots.asm                        page 58
BTS1802 -- Monitor for the COSMAC Elf 2000

1701   86C4             	.EJECT
1702   86C4             ;	.SBTTL	Examine Memory Command
1703   86C4             
1704   86C4             ;  This routine processes the EXAMINE command. This command will allow the user
1705   86C4             ; to examine one or more bytes of memory. The E command accepts two formats of
1706   86C4             ; operands:
1707   86C4             ;
1708   86C4             ;	>>>E xxxx yyyy
1709   86C4             ;	- or -
1710   86C4             ;	>>>E xxxx
1711   86C4             ;
1712   86C4             ;   The first format will print the contents of all locations from x to y (with
1713   86C4             ; 16 bytes per line). The second format will print the contents of only
1714   86C4             ; location x (all addresses are in hex, of course)...
1715   86C4             
1716   86C4 D4          EXAM:	CALL(SCANP1)	; to scan the first parameter and put it in P2
1716   86C5 85 91       
1717   86C7 9D          	RCOPY(P3,P2)	; save that in a safe place
1717   86C8 BC          
1717   86C9 8D          
1717   86CA AC          
1718   86CB D4          	CALL(ISEOL)	; is there more?
1718   86CC 85 61       
1719   86CE C3 86 EA    	LBDF	EXAM1	; no - examine with one operand
1720   86D1 D4          	CALL(SCANP1)	; otherwise scan a second parameter
1720   86D2 85 91       
1721   86D4 9D          	RCOPY(P4,P2)	; and save it in P4 for a while
1721   86D5 BB          
1721   86D6 8D          
1721   86D7 AB          
1722   86D8 D4          	CALL(ISEOL)	; now there had better be no more
1722   86D9 85 61       
1723   86DB CB 85 68    	LBNF	CMDERR	; error if there's extra junk at the end
1724   86DE D4          	CALL(P3LEP4)	; are the parameters in the right order??
1724   86DF 91 4A       
1725   86E1 CB 85 68    	LBNF	CMDERR	; error if not
1726   86E4 D4          	CALL(MEMDMP)	; go print in the memory dump format
1726   86E5 87 01       
1727   86E7 C0 84 C2    	LBR	MAIN	; and then on to the next command
1728   86EA             
1729   86EA             ; Here for the one address for of the command...
1730   86EA 9C          EXAM1:	RCOPY(P1,P3)	; copy the address
1730   86EB BF          
1730   86EC 8C          
1730   86ED AF          
1731   86EE D4          	CALL(THEX4)	; and type it out
1731   86EF 91 7A       
1732   86F1 D4          	INLMES("> ")	; ...
1732   86F2 FF 66       
1732   86F4 3E 20       
1732   86F6 00          
1733   86F7 0C          	LDN	P3	; now fetch the contents of that byte
1734   86F8 D4          	CALL(THEX2)	; and type that too
1734   86F9 91 6D       
1735   86FB D4          	CALL(TCRLF)	; type a CRLF and we're done
1735   86FC 90 D5       
1736   86FE C0 84 C2    	LBR	MAIN	; ...
1737   8701             
TASM 1802 Assembler.              boots.asm                        page 59
BTS1802 -- Monitor for the COSMAC Elf 2000

1738   8701             	.EJECT
1739   8701             ;	.SBTTL	Generic Memory Dump
1740   8701             
1741   8701             ;   This routine will dump, in both hexadecimal and ASCII, the block of 
1742   8701             ; memory between P3 and P4.  It's used by the EXAMINE command, but it
1743   8701             ; can also be called from other random places, which is especially handy
1744   8701             ; for chasing down bugs...
1745   8701 8C          MEMDMP:	GLO	P3	; round P3 off to $xxx0
1746   8702 FA F0       	ANI	$F0	; ...
1747   8704 AC          	PLO	P3	; ...
1748   8705 8B          	GLO	P4	; and round P4 off to $xxxF
1749   8706 F9 0F       	ORI	$0F	; ...
1750   8708 AB          	PLO	P4	; ...
1751   8709 D4          	CALL(F_INMSG)
1751   870A FF 66       
1752   870C 20 20 20 20 	.TEXT	"        0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\r\n\000"
1752   8710 20 20 20 20 
1752   8714 30 20 20 31 
1752   8718 20 20 32 20 
1752   871C 20 33 20 20 
1752   8720 34 20 20 35 
1752   8724 20 20 36 20 
1752   8728 20 37 20 20 
1752   872C 38 20 20 39 
1752   8730 20 20 41 20 
1752   8734 20 42 20 20 
1752   8738 43 20 20 44 
1752   873C 20 20 45 20 
1752   8740 20 46 0D 0A 
1752   8744 00 
1753   8745             
1754   8745             ; Print the address of this line (the first of a row of 16 bytes)...
1755   8745 9C          MEMDM2:	RCOPY(P1,P3)	; copy the address of this byte
1755   8746 BF          
1755   8747 8C          
1755   8748 AF          
1756   8749 D4          	CALL(THEX4)	; and then type it in hex
1756   874A 91 7A       
1757   874C D4          	INLMES("> ")	; type a > character after the address
1757   874D FF 66       
1757   874F 3E 20       
1757   8751 00          
1758   8752 38          	SKP		; skip the INC P3 the first time around
1759   8753             
1760   8753             ; Now print a row of 16 bytes in hexadecimal...
1761   8753 1C          MEMDM3:	INC	P3	; on to the next byte...
1762   8754 D4          	CALL(TSPACE)	; leave some room between bytes
1762   8755 90 DF       
1763   8757 0C          	LDN	P3	; get the next byte from memory
1764   8758 D4          	CALL(THEX2)	; and type the data in two hex digits
1764   8759 91 6D       
1765   875B             
1766   875B             ; Here to advance to the next data byte...
1767   875B 8C          MEMDM4:	GLO	P3	; get the current address
1768   875C FA 0F       	ANI	$0F	; have we done sixteen bytes??
1769   875E FB 0F       	XRI	$0F	; ???
1770   8760 CA 87 53    	LBNZ	MEMDM3	; no - on to the next address
1771   8763             
1772   8763             ; Print all sixteen bytes again, put this time in ASCII...
TASM 1802 Assembler.              boots.asm                        page 60
BTS1802 -- Monitor for the COSMAC Elf 2000

1773   8763 D4          MEMDM5:	CALL(TSPACE)	; leave a few blanks
1773   8764 90 DF       
1774   8766 D4          	CALL(TSPACE)	; ...
1774   8767 90 DF       
1775   8769 8C          	GLO	P3	; restore the address back to the
1776   876A FA F0       	ANI	$F0	;  ... beginning of the line
1777   876C AC          	PLO	P3	; ...
1778   876D 38          	SKP		; skip the INC P3 the first time around
1779   876E             
1780   876E             ; If the next byte is a printing ASCII character, $20..$7E, then print it.
1781   876E 1C          MEMDM6:	INC	P3	; on to the next byte
1782   876F 0C          	LDN	P3	; get the byte
1783   8770 FA 60       	ANI	$60	; is it a control character??
1784   8772 C2 87 85    	LBZ	MEMDM7	; yep - print a dot
1785   8775 0C          	LDN	P3	; no - get the byte again
1786   8776 FA 7F       	ANI	$7F	; ignore the 8th bit
1787   8778 FB 7F       	XRI	$7F	; and is it a delete (rubout) ??
1788   877A C2 87 85    	LBZ	MEMDM7	; yep - print a dot
1789   877D FB 7F       	XRI	$7F	; no - restore the original byte
1790   877F D4          	CALL(F_TTY)	; and type it
1790   8780 FF 4E       
1791   8782 C0 87 8A    	LBR	MEMDM8	; on to the next byte
1792   8785             
1793   8785             ; Here if the character isn't printing - print a "." instead...
1794   8785 F8 2E       MEMDM7:	OUTCHR('.')	; do just that
1794   8787 D4          
1794   8788 FF 4E       
1795   878A 8C          MEMDM8:	GLO	P3	; get the current address
1796   878B FA 0F       	ANI	$0F	; have we done sixteen bytes?
1797   878D FB 0F       	XRI	$0F	; ???
1798   878F CA 87 6E    	LBNZ	MEMDM6	; nope - keep printing
1799   8792             
1800   8792             ; We're done with this line of sixteen bytes....
1801   8792 D4          	CALL(TCRLF)	; finish the line
1801   8793 90 D5       
1802   8795 D4          	CALL(F_BRKTEST)	; does the user want to stop early?
1802   8796 FF 6C       
1803   8798 C3 87 A2    	LBDF	MEMDM9	; branch if yes
1804   879B 1C          	INC	P3	; on to the next byte
1805   879C D4          	CALL(P3LEP4)	; have we done all of them?
1805   879D 91 4A       
1806   879F C3 87 45    	LBDF	MEMDM2	; nope, keep going
1807   87A2 D5          MEMDM9:	RETURN		; yep - all done
1808   87A3             
TASM 1802 Assembler.              boots.asm                        page 61
BTS1802 -- Monitor for the COSMAC Elf 2000

1809   87A3             	.EJECT
1810   87A3             ;	.SBTTL	Deposit Memory Command
1811   87A3             
1812   87A3             ;   The DEPOSIT command is used	to store bytes in memory.  It accepts an
1813   87A3             ; address and a list of data as operands:
1814   87A3             ;
1815   87A3             ;	>>>D xxxx dd dd dd dd dd dd dd dd ....
1816   87A3             ;
1817   87A3             ; This command will deposit the data specified by d into memory addresses
1818   87A3             ; beginning at xxxx.  Any number of data bytes may be specified; they are
1819   87A3             ; deposited into sequential addresses...
1820   87A3             
1821   87A3 D4          DEPOSIT:CALL(SCANP1) 	; scan the address first
1821   87A4 85 91       
1822   87A6 9D          	RCOPY(P3,P2)	; then save the address where it is safe
1822   87A7 BC          
1822   87A8 8D          
1822   87A9 AC          
1823   87AA D4          	CALL(ISSPAC)	; we'd better have found a space
1823   87AB 85 50       
1824   87AD CB 85 68    	LBNF	CMDERR	; error if not
1825   87B0             
1826   87B0             ; This loop will read and store bytes...
1827   87B0 D4          DEP1:	CALL(SCANP1)	; read another parameter
1827   87B1 85 91       
1828   87B3 D4          	CALL(ISSPAC)	; and we'd better have found a space or EOL
1828   87B4 85 50       
1829   87B6 CB 85 68    	LBNF	CMDERR	; error if not
1830   87B9 8D          	GLO	P2	; get the low byte of the data scanned
1831   87BA 5C          	STR	P3	; and store it in memory at (P3)
1832   87BB EC          	SEX	P3	; then see if it was stored correctly
1833   87BC F7          	SM		; ...
1834   87BD CA 87 C8    	LBNZ	DEP3	; memory error
1835   87C0 1C          	INC	P3	; on to the next address
1836   87C1 D4          	CALL(ISEOL)	; end of line?
1836   87C2 85 61       
1837   87C4 CB 87 B0    	LBNF	DEP1	; nope - keep scanning
1838   87C7             
1839   87C7             ; Here when we have finished the command....
1840   87C7 D5          DEP2:	RETURN
1841   87C8             
1842   87C8             ;   Here if the memory doesn't change - that could be because the command
1843   87C8             ; file attempted to change EPROM or non-existent memory...
1844   87C8 F8 87       DEP3:	OUTSTR(MERMSG)
1844   87CA BF          
1844   87CB F8 D2       
1844   87CD AF          
1844   87CE D4          
1844   87CF FF 09       
1845   87D1 D5          	RETURN
1846   87D2 3F 4D 45 4D MERMSG:	.DB	"?MEMORY ERROR\r\n", 0
1846   87D6 4F 52 59 20 
1846   87DA 45 52 52 4F 
1846   87DE 52 0D 0A 00 
1847   87E2             
TASM 1802 Assembler.              boots.asm                        page 62
BTS1802 -- Monitor for the COSMAC Elf 2000

1848   87E2             	.EJECT
1849   87E2             ;	.SBTTL	RUN and CALL Commands
1850   87E2             
1851   87E2             ;   The RUN command will begin execution of a user's program with X=P=0 and
1852   87E2             ; all other registers undefined.  The starting address may be specified as
1853   87E2             ; an argument to RUN (e.g. "RUN 100" starts at $0100) or it may be omitted
1854   87E2             ; in which case execution starts at location zero.  Since this command runs
1855   87E2             ; a program with X=P=0, it mimics the behavior of the bare hardware when no
1856   87E2             ; monitor is present.  In this case the user's program must return control to
1857   87E2             ; the monitor with a "LBR $8000" instruction.
1858   87E2             ;
1859   87E2             ;   Note that the RUN command can't be used when the Elf 2000 video card
1860   87E2             ; is used because the video card requires that interrupts and DMA be active
1861   87E2             ; all the time (that's how we get the video, after all) so it's impossible
1862   87E2             ; to start a program with X=P=0.  Your only option in that case is to use
1863   87E2             ; the CALL command...
1864   87E2             RUNUSR:
1865   87E2~            #ifdef VIDEO
1866   87E2~            	CALL(NOCRTC)	; not allowed when the video card is in use
1866   87E2~            	CALL(NOCRTC)	; not allowed when the video card is in use
1867   87E2~            	LBDF	RUN0	; ...
1868   87E2             #endif
1869   87E2 D4          	CALL(ISEOL)	; is there any argument to the RUN command?
1869   87E3 85 61       
1870   87E5 C3 87 F9    	LBDF	RUN1	; no - start from address $0000
1871   87E8 D4          	CALL(SCANP1)	; yes - go read the starting address
1871   87E9 85 91       
1872   87EB D4          	CALL(ISEOL)	; and then that had better be the end
1872   87EC 85 61       
1873   87EE CB 85 68    	LBNF	CMDERR	; ...
1874   87F1 9D          	RCOPY(0,P2)	; put the start address in R0
1874   87F2 B0          
1874   87F3 8D          
1874   87F4 A0          
1875   87F5 C0 87 FD    	LBR	RUN2	; and start running from there
1876   87F8 D5          RUN0:	RETURN		; here if error
1877   87F9             
1878   87F9             ; Here to start running from location zero...
1879   87F9 F8 00       RUN1:	RCLEAR(0)	; set at location $0000
1879   87FB B0          
1879   87FC A0          
1880   87FD F8 8D       RUN2:	RLDI(1,TRAP)	; register 1 still points to the TRAP function
1880   87FF B1          
1880   8800 F8 EB       
1880   8802 A1          
1881   8803 E0          	SEX	0	; and start with X=P=0
1882   8804 D0          	SEP	0	; away we go!
1883   8805 C0 84 C2    	LBR	MAIN	; should never get here!!
1884   8808             
1885   8808             ;   The CALL command invokes a user's program as if it were a subroutine of
1886   8808             ; this monitor.  The address specified in the CALL command, which is required
1887   8808             ; in this case, is called via SCRT just as if it were a subroutine.  All the
1888   8808             ; standard monitor registers, including A, CALLPC, RETPC, SP, DP, BAUD, etc.
1889   8808             ; will have the same values they have here.  X will point to the SP (R2)
1890   8808             ; which will point to the monitor's stack area.  The user's program can return
1891   8808             ; to the monitor simply by executing a RETURN (SEP RETPC) instruction.
1892   8808 D4          CALUSR:	CALL(SCANP1)	; in this case a parameter is required...
1892   8809 85 91       
1893   880B D4          	CALL(ISEOL)	; and then no more
TASM 1802 Assembler.              boots.asm                        page 63
BTS1802 -- Monitor for the COSMAC Elf 2000

1893   880C 85 61       
1894   880E CB 85 68    	LBNF	CMDERR	; ...
1895   8811 F8 88       	RLDI(T1,CALUS1)	; execute the rest of the code with P=T1
1895   8813 B9          
1895   8814 F8 18       
1895   8816 A9          
1896   8817 D9          	SEP	T1	; ...
1897   8818             
1898   8818             ; Here to branch to the user's function...
1899   8818 9D          CALUS1:	RCOPY(PC,P2)	; copy the address of the user's code to R3
1899   8819 B3          
1899   881A 8D          
1899   881B A3          
1900   881C D3          	SEP	PC	; and pretend as if we just branched to it...
1901   881D C0 84 C2    	LBR	MAIN	; should never get here!!
1902   8820             
TASM 1802 Assembler.              boots.asm                        page 64
BTS1802 -- Monitor for the COSMAC Elf 2000

1903   8820             	.EJECT
1904   8820             ;	.SBTTL	SHOW EF Command
1905   8820             
1906   8820             ;   The SHOW EF command prints the current state of all four EF inputs.
1907   8820             ; The state printed is the logical status, so EFx=1 implies that the input
1908   8820             ; pin is low and vice versa...
1909   8820             SHOWEF:
1910   8820 D4          	CALL(ISEOL)		; no arguments allowed
1910   8821 85 61       
1911   8823 CB 85 68    	LBNF	CMDERR		; ...
1912   8826             
1913   8826             ; Print EF1...
1914   8826 D4          	INLMES("EF1=")
1914   8827 FF 66       
1914   8829 45 46 31 3D 
1914   882D 00          
1915   882E F8 30       	LDI	'0'		; assume it's zero
1916   8830 3C 34       	BN1	EFS1		; and branch if it really is zero
1917   8832 F8 31       	LDI	'1'		; nope - it's one
1918   8834 D4          EFS1:	CALL(F_TTY)
1918   8835 FF 4E       
1919   8837             
1920   8837             ; Print EF2...
1921   8837 D4          	INLMES(" EF2=")
1921   8838 FF 66       
1921   883A 20 45 46 32 
1921   883E 3D 
1921   883F 00          
1922   8840 F8 30       	LDI	'0'		; assume it's zero
1923   8842 3D 46       	BN2	EFS2		; and branch if it really is zero
1924   8844 F8 31       	LDI	'1'		; nope - it's one
1925   8846 D4          EFS2:	CALL(F_TTY)
1925   8847 FF 4E       
1926   8849             
1927   8849             ; Print EF3...
1928   8849 D4          	INLMES(" EF3=")
1928   884A FF 66       
1928   884C 20 45 46 33 
1928   8850 3D 
1928   8851 00          
1929   8852 F8 30       	LDI	'0'		; assume it's zero
1930   8854 3E 58       	BN3	EFS3		; and branch if it really is zero
1931   8856 F8 31       	LDI	'1'		; nope - it's one
1932   8858 D4          EFS3:	CALL(F_TTY)
1932   8859 FF 4E       
1933   885B             
1934   885B             ; Print EF4...
1935   885B D4          	INLMES(" EF4=")
1935   885C FF 66       
1935   885E 20 45 46 34 
1935   8862 3D 
1935   8863 00          
1936   8864 F8 30       	LDI	'0'		; assume it's zero
1937   8866 3F 6A       	BN4	EFS4		; and branch if it really is zero
1938   8868 F8 31       	LDI	'1'		; nope - it's one
1939   886A D4          EFS4:	CALL(F_TTY)
1939   886B FF 4E       
1940   886D             
1941   886D             ; All done!
TASM 1802 Assembler.              boots.asm                        page 65
BTS1802 -- Monitor for the COSMAC Elf 2000

1942   886D D4          	CALL(TCRLF)
1942   886E 90 D5       
1943   8870 C0 84 C2    	LBR	MAIN
1944   8873             
TASM 1802 Assembler.              boots.asm                        page 66
BTS1802 -- Monitor for the COSMAC Elf 2000

1945   8873             	.EJECT
1946   8873             ;	.SBTTL	SET RESTART Command
1947   8873             
1948   8873             ;   The SET RESTART command allows the user to specify the action taken on a
1949   8873             ; warm start.  A warm start occurs when the basic ELF2K has the memory battery
1950   8873             ; backup option installed and the memory contents are valid on startup, OR if
1951   8873             ; the UART/NVR/RTC card is installed and the NVR contents are valid.  The
1952   8873             ; SET RESTART command has three basic forms:
1953   8873             ;
1954   8873             ;	SET RESTART xxxx	- restart at memory address xxxx
1955   8873             ;	SET RESTART BOOT	- attempt to boot from primary IDE disk
1956   8873             ;	SET RESTART NONE	- no restart action (prompt for monitor command)
1957   8873             ;
1958   8873             
1959   8873             SETRESTA:
1960   8873 D4          	CALL(F_LTRIM)		; skip any spaces
1960   8874 FF 15       
1961   8876 D4          	CALL(ISEOL)		; and there had better be an argument there
1961   8877 85 61       
1962   8879 C3 85 68    	LBDF	CMDERR		; error if none
1963   887C 9F          	RCOPY(T1,P1)		; save a copy of the command line pointer
1963   887D B9          
1963   887E 8F          
1963   887F A9          
1964   8880             
1965   8880             ;   First attempt to scan the hex version of the command.  If this succeeds,
1966   8880             ; then we know that's what we have.  If it fails to parse, then back up and
1967   8880             ; rescan with the NONE or BOOT options instead...
1968   8880 0F          	LDN	P1		; get the first character
1969   8881 D4          	CALL(ISHEX)		; is it a hex number?
1969   8882 91 28       
1970   8884 CB 88 A0    	LBNF	SETRE1		; nope - try NONE or BOOT
1971   8887 D4          	CALL(SCANP1)		; read a hex number
1971   8888 85 91       
1972   888A D4          	CALL(ISEOL)		; and check for end of line
1972   888B 85 61       
1973   888D CB 88 A0    	LBNF	SETRE1		; error - try the other format
1974   8890             
1975   8890             ; Here for the SET RESTART xxxx form.
1976   8890~            #ifdef VIDEO
1977   8890~            	CALL(NOCRTC)		; not allowed with the video card
1977   8890~            	CALL(NOCRTC)		; not allowed with the video card
1978   8890~            	LBDF	CMDERR		; ...
1979   8890             #endif
1980   8890 F8 7F       	RLDI(DP,RESTA+1)	; point to RESTA
1980   8892 B7          
1980   8893 F8 B7       
1980   8895 A7          
1981   8896 E7          	SEX	DP		; and use DP to address memory
1982   8897 8D          	PUSHR(P2)		; save the restart address to RESTA
1982   8898 73          
1982   8899 9D          
1982   889A 73          
1983   889B F8 5A       	LDI	ABTADDR		; finally, set the BOOT FLAG to ABTADDR
1984   889D C0 88 CA    	LBR	SETBO1		; set BOOTF and update NVR
1985   88A0             
1986   88A0             ;   Here to test for the SET RESTART BOOT and SET RESTART NONE forms of the
1987   88A0             ; command.  If it's not one of these, it's wrong :-)
1988   88A0 99          SETRE1:	RCOPY(P1,T1)		; restore the command line pointer
TASM 1802 Assembler.              boots.asm                        page 67
BTS1802 -- Monitor for the COSMAC Elf 2000

1988   88A1 BF          
1988   88A2 89          
1988   88A3 AF          
1989   88A4 F8 88       	RLDI(P2,RESCMD)		; point to the table of restart options
1989   88A6 BD          
1989   88A7 F8 B3       
1989   88A9 AD          
1990   88AA F8 7F       	RLDI(DP,BOOTF)		; and leave DP pointing to BOOTF
1990   88AC B7          
1990   88AD F8 B5       
1990   88AF A7          
1991   88B0 C0 85 12    	LBR	COMND		; parse it (or call CMDERR if it doesn't parse!)
1992   88B3             
1993   88B3             ; Table of SET RESTART commands...
1994   88B3 03 42 4F 4F RESCMD:	CMD(3, "BOOT", SETRBO)	; SET RESTART BOOT
1994   88B7 54 00 
1994   88B9 88 C4       
1995   88BB 02 4E 4F 4E 	CMD(2, "NONE", SETRNO)	; SET RESTART NONE
1995   88BF 45 00 
1995   88C1 88 C8       
1996   88C3 00          	.DB	0		; end of table
1997   88C4             
1998   88C4             
1999   88C4             ; Here for SET RESTART BOOT...
2000   88C4 F8 A5       SETRBO:	LDI	ABTDISK		; set BOOTF to ABTDISK for BOOT IDE
2001   88C6 30 CA       	BR	SETBO1		; and then update the NVR and we're done..
2002   88C8             
2003   88C8             ; Here for SET RESTART NONE...
2004   88C8 F8 FF       SETRNO:	LDI	ABTNONE		; set BOOTF to ABTNONE for no restart action
2005   88CA 57          SETBO1:	STR	DP		; first update BOOTF
2006   88CB F8 00       	RLDI(P1,NVRBOOT)	; offset in NVR of the boot flag byte
2006   88CD BF          
2006   88CE F8 00       
2006   88D0 AF          
2007   88D1 F8 7F       	RLDI(P2,BOOTF)		; pointer to data in main memory
2007   88D3 BD          
2007   88D4 F8 B5       
2007   88D6 AD          
2008   88D7 F8 00       	RLDI(P3,3)		; number of bytes to write
2008   88D9 BC          
2008   88DA F8 03       
2008   88DC AC          
2009   88DD C0 F8 1E    	LBR	F_WRNVR		; write to NVR and return
2010   88E0             
TASM 1802 Assembler.              boots.asm                        page 68
BTS1802 -- Monitor for the COSMAC Elf 2000

2011   88E0             	.EJECT
2012   88E0             ;	.SBTTL	BOOT and SHOW IDE Commands
2013   88E0             
2014   88E0             ;   The BOOT command attempts to bootstrap the IDE master device.  It has no
2015   88E0             ; arguments and there's not much more to it than that!
2016   88E0 D4          BOOTCMD:CALL(ISEOL)		; make sure there are no arguments
2016   88E1 85 61       
2017   88E3 CB 85 68    	LBNF	CMDERR		; fail if there is
2018   88E6             
2019   88E6             ; The SYSINI routine calls here if the boot flag is set to BOOT...
2020   88E6 F8 89       BOOTIDE:OUTSTR(BOOMSG)		; tell the user what we're doing
2020   88E8 BF          
2020   88E9 F8 09       
2020   88EB AF          
2020   88EC D4          
2020   88ED FF 09       
2021   88EF D4          	CALL(F_BOOTIDE)		; and ask the BIOS to bootstrap
2021   88F0 FF 42       
2022   88F2 CB 88 FF    	LBNF	NOBOOT		; hardware OK but no ElfOS boot
2023   88F5 F8 89       	OUTSTR(BADDR1)		; ?DRIVE ERROR
2023   88F7 BF          
2023   88F8 F8 EC       
2023   88FA AF          
2023   88FB D4          
2023   88FC FF 09       
2024   88FE D5          	RETURN			; ...
2025   88FF             
2026   88FF             ; Here if the attached volume is not bootable ...
2027   88FF F8 89       NOBOOT:	OUTSTR(BFAMSG)		; ?NOT BOOTABLE
2027   8901 BF          
2027   8902 F8 23       
2027   8904 AF          
2027   8905 D4          
2027   8906 FF 09       
2028   8908 D5          	RETURN			; ...
2029   8909             
2030   8909             ; IDE bootstrap messages ...
2031   8909 42 6F 6F 74 BOOMSG:	.TEXT	"Booting primary IDE ...\r\n\000"
2031   890D 69 6E 67 20 
2031   8911 70 72 69 6D 
2031   8915 61 72 79 20 
2031   8919 49 44 45 20 
2031   891D 2E 2E 2E 0D 
2031   8921 0A 00 
2032   8923 3F 4E 4F 54 BFAMSG:	.TEXT	"?NOT BOOTABLE\r\n\000"
2032   8927 20 42 4F 4F 
2032   892B 54 41 42 4C 
2032   892F 45 0D 0A 00 
2033   8933             
2034   8933             ;   The SHOW IDE command prints a list of the IDE devices (there are at most
2035   8933             ; two!) attached.  It's the same information printed at startup by SYSINI.
2036   8933 D4          SHOWIDE:CALL(ISEOL)		; arguments are neither required nor allowed
2036   8934 85 61       
2037   8936 CB 85 68    	LBNF	CMDERR		; error if there's more
2038   8939 F8 00       	LDI	$00		; first probe for drive 0 (the master)
2039   893B D4          	CALL(PROBE)		; and print what we find
2039   893C 89 43       
2040   893E F8 01       	LDI	$01		; then probe for drive 1 (slave)
2041   8940 C0 89 43    	LBR	PROBE		; ...
TASM 1802 Assembler.              boots.asm                        page 69
BTS1802 -- Monitor for the COSMAC Elf 2000

2042   8943             
TASM 1802 Assembler.              boots.asm                        page 70
BTS1802 -- Monitor for the COSMAC Elf 2000

2043   8943             	.EJECT
2044   8943             ;	.SBTTL	Probe For IDE Drives
2045   8943             
2046   8943             ;   This routine will probe the IDE bus for the existence of a drive and,
2047   8943             ; if a drive is found, the BIOS will be used to reset and initialize it.
2048   8943             ; Once the drive is initialized the BIOS identify device function is used
2049   8943             ; to determine the drive size and manufacturer.  When called, D should
2050   8943             ; contain zero to test the primary (master) drive or 1 to test the secondary
2051   8943             ; (slave) drive...
2052   8943 73          PROBE:	STXD			; save the unit number on the stack
2053   8944 FE          	SHL\ SHL\ SHL\ SHL	; turn unit 1 to 0x10; unit zero stays zero
2053   8945 FE          
2053   8946 FE          
2053   8947 FE          
2054   8948 F9 E0       	ORI	$E0		; the rest of these bits should be 1
2055   894A 52          	STR	SP		; and save the drive select on the stack
2056   894B E3          	SEX	PC		; and write the IDE drive select register
2057   894C 62          	OUT	IDE_SELECT	; ...
2058   894D 06          	.DB	IDELBA3		; head/drive select register
2059   894E E2          	SEX	SP		; back to the stack
2060   894F 63          	OUT	IDE_DATA	; and write the drive select bit
2061   8950 22          	DEC	SP		; correct for OUT instruction
2062   8951             
2063   8951             ;   Now test two of the LBA/cylinder/sector registers to see if R/W memory
2064   8951             ; actually exists.  If it does, there's probably drive there.  Writing these
2065   8951             ; registers is safe enough because their contents doesn't mean anything until
2066   8951             ; a command is issued, which we won't do!
2067   8951 E3          	SEX	PC		; X=P
2068   8952 62          	WIDE(IDELBA0,$AA)	; write $AA to the low LBA register
2068   8953 03          
2068   8954 63          
2068   8955 AA          
2069   8956 62          	WIDE(IDELBA1,$55)	; and then $55 to the next LBA register
2069   8957 04          
2069   8958 63          
2069   8959 55          
2070   895A E3          	SEX	PC		; X=P
2071   895B 62          	RIDE(IDELBA0)		; then read back LBA0
2071   895C 03          
2071   895D E2          
2071   895E 6B          
2072   895F FB AA       	XRI	$AA		; if we get back what we wrote
2073   8961 CA 89 6E    	LBNZ	NODRIVE		;  ... then there's probably a drive there!
2074   8964 E3          	SEX	PC		; X=P
2075   8965 62          	RIDE(IDELBA1)		; but just to be safe read the other register
2075   8966 04          
2075   8967 E2          
2075   8968 6B          
2076   8969 FB 55       	XRI	$55		; ...
2077   896B 32 72       	BZ	PROBE1		; ...
2078   896D E2          	SEX	SP		; ...
2079   896E             
2080   896E             ; If no drive is found, fix the stack and return DF=1...
2081   896E 60          NODRIVE:IRX			; remove the unit select from the stack
2082   896F FF 00       	SDF			; set DF=1
2083   8971 D5          	RETURN			; and we're outta here
2084   8972             
2085   8972             ; Identify the unit we've found...
2086   8972 60          PROBE1:	IRX\ LDX\ DEC SP	; get the unit number back from the stack
TASM 1802 Assembler.              boots.asm                        page 71
BTS1802 -- Monitor for the COSMAC Elf 2000

2086   8973 F0          
2086   8974 22          
2087   8975 32 89       	BZ	PROB1A		; jump if unit 0 selected
2088   8977 D4          	INLMES("IDE Slave:  ")
2088   8978 FF 66       
2088   897A 49 44 45 20 
2088   897E 53 6C 61 76 
2088   8982 65 3A 20 20 
2088   8986 00          
2089   8987 30 99       	BR	PROB1B
2090   8989 D4          PROB1A:	INLMES("IDE Master: ")
2090   898A FF 66       
2090   898C 49 44 45 20 
2090   8990 4D 61 73 74 
2090   8994 65 72 3A 20 
2090   8998 00          
2091   8999             
2092   8999             ; Call the BIOS to reset the drive and then get its size in Mb...
2093   8999 60          PROB1B:	IRX\ LDX\ DEC SP	; get the unit number back again
2093   899A F0          
2093   899B 22          
2094   899C AD          	PLO	P2		; store it for the BIOS
2095   899D D4          	CALL(F_IDERESET)	; and reset the drive
2095   899E FF 36       
2096   89A0 C3 89 E0    	LBDF	BADDRV		; branch if hard drive error
2097   89A3 60          	IRX\ LDX\ DEC SP	; get the unit number back again
2097   89A4 F0          
2097   89A5 22          
2098   89A6 AD          	PLO	P2		; store it for the BIOS
2099   89A7 D4          	CALL(F_IDESIZE)		; now get the size of the drive
2099   89A8 F8 21       
2100   89AA C2 89 E0    	LBZ	BADDRV		; zero means an unusable drive
2101   89AD D4          	CALL(TDEC16)		; type the size in megabytes
2101   89AE 91 82       
2102   89B0 D4          	INLMES("Mb ")		; ...
2102   89B1 FF 66       
2102   89B3 4D 62 20    
2102   89B6 00          
2103   89B7             
2104   89B7             ;   Now send an IDENTIFY DEVICE command to the drive and print various
2105   89B7             ; interesting tidbits (such as the drive's model number)...
2106   89B7 F8 7D       	RLDI(P1,DSKBUF)		; point to the disk buffer
2106   89B9 BF          
2106   89BA F8 00       
2106   89BC AF          
2107   89BD 60          	IRX\ LDX\ DEC SP	; get the unit number back again
2107   89BE F0          
2107   89BF 22          
2108   89C0 AD          	PLO	P2		; store it for the BIOS
2109   89C1 D4          	CALL(F_IDEID)		; ...
2109   89C2 F8 24       
2110   89C4 C3 89 E0    	LBDF	BADDRV		; this shouldn't fail, but...
2111   89C7 F8 7D       	RLDI(P1,DSKBUF+$36+39)	; make sure the model number is
2111   89C9 BF          
2111   89CA F8 5D       
2111   89CC AF          
2112   89CD F8 00       	LDI	0		; ...
2113   89CF 5F          	STR	P1		; ...
2114   89D0 F8 7D       	OUTSTR(DSKBUF+$36)	; type the model number
TASM 1802 Assembler.              boots.asm                        page 72
BTS1802 -- Monitor for the COSMAC Elf 2000

2114   89D2 BF          
2114   89D3 F8 36       
2114   89D5 AF          
2114   89D6 D4          
2114   89D7 FF 09       
2115   89D9 D4          	CALL(TCRLF)		; and finish the line
2115   89DA 90 D5       
2116   89DC 60          	IRX			; fix the stack
2117   89DD FC 00       	CDF			; set DF=0
2118   89DF D5          	RETURN			; and we're done
2119   89E0             
2120   89E0             ; Here if the drive has some hard error ...
2121   89E0 F8 89       BADDRV:	OUTSTR(BADDR1)		; ?DRIVE ERROR
2121   89E2 BF          
2121   89E3 F8 EC       
2121   89E5 AF          
2121   89E6 D4          
2121   89E7 FF 09       
2122   89E9 C0 89 6E    	LBR	NODRIVE		; return DF=0 and quit
2123   89EC 3F 44 52 49 BADDR1:	.TEXT	"?DRIVE ERROR\r\n\000"
2123   89F0 56 45 20 45 
2123   89F4 52 52 4F 52 
2123   89F8 0D 0A 00 
2124   89FB             
TASM 1802 Assembler.              boots.asm                        page 73
BTS1802 -- Monitor for the COSMAC Elf 2000

2125   89FB             	.EJECT
2126   89FB             ;	.SBTTL	SET Q Command
2127   89FB             
2128   89FB             ;   The "SET Q 0" and "SET Q 1" commands may be used to test the Q output, but
2129   89FB             ; ONLY if the bit banging serial I/O is NOT in use!  The reason should be
2130   89FB             ; obvious :-)
2131   89FB D4          SETQ:	CALL(SCANP1)		; one parameter is required
2131   89FC 85 91       
2132   89FE D4          	CALL(ISEOL)		; no more arguments allowed
2132   89FF 85 61       
2133   8A01 CB 85 68    	LBNF	CMDERR		; error if there are any
2134   8A04 9E          	GHI	BAUD		; is the bit banging port in use?
2135   8A05 FA FE       	ANI	$FE		; ignore the local echo bit
2136   8A07 CA 8A 12    	LBNZ	NOSETQ		; can't do this command if it is
2137   8A0A 8D          	GLO	P2		; get the LSB of the argument
2138   8A0B F6          	SHR			; and put the LSB in DF
2139   8A0C 3B 10       	BNF	RESETQ		; reset Q if the LSB is zero
2140   8A0E 7B          	SEQ			; nope - set Q
2141   8A0F D5          	RETURN			; and return
2142   8A10             
2143   8A10             ; Here for "SET Q 0"...
2144   8A10 7A          RESETQ:	REQ			; reset Q
2145   8A11 D5          	RETURN			; and return
2146   8A12             
2147   8A12             ; Here if the Q output is being used for the console terminal...
2148   8A12 F8 8A       NOSETQ:	RLDI(P1,NOQMSG)		; print an error message
2148   8A14 BF          
2148   8A15 F8 1B       
2148   8A17 AF          
2149   8A18 C0 FF 09    	LBR	F_MSG		;  ... and return
2150   8A1B 3F 43 41 4E NOQMSG:	.TEXT	"?CAN'T - CONSOLE\r\n\000"
2150   8A1F 27 54 20 2D 
2150   8A23 20 43 4F 4E 
2150   8A27 53 4F 4C 45 
2150   8A2B 0D 0A 00 
2151   8A2E             
TASM 1802 Assembler.              boots.asm                        page 74
BTS1802 -- Monitor for the COSMAC Elf 2000

2152   8A2E             	.EJECT
2153   8A2E             ;	.SBTTL	Show the Current Date and Time
2154   8A2E             
2155   8A2E             ;   The "SHOW DA[TIME]" command shows the current date and time.  Needless to
2156   8A2E             ; say, it takes no arguments.  The SHOWNOW routine is called from SYSINI to
2157   8A2E             ; display the current date and time...
2158   8A2E D4          SHOWTIME:CALL(ISEOL)		; no arguments allowed
2158   8A2F 85 61       
2159   8A31 CB 85 68    	LBNF	CMDERR		; error if there are any
2160   8A34 D4          	CALL(SHOWNOW)		; show the current date/time
2160   8A35 8A 3A       
2161   8A37 C0 90 D5    	LBR	TCRLF		; print a CRLF and return
2162   8A3A             
2163   8A3A             ; Here to show the current date/time....
2164   8A3A F8 7F       SHOWNOW:RLDI(P1,TIMBUF)		; point to the six byte buffer
2164   8A3C BF          
2164   8A3D F8 A6       
2164   8A3F AF          
2165   8A40 D4          	CALL(F_GETTOD)		; ask the BIOS to read the clock
2165   8A41 F8 15       
2166   8A43 C3 8A 68    	LBDF	NOTIME		; no RTC or time not set
2167   8A46 F8 7F       	RLDI(P1,CMDBUF)		; point to a temporary string
2167   8A48 BF          
2167   8A49 F8 B8       
2167   8A4B AF          
2168   8A4C F8 7F       	RLDI(P2,TIMBUF)		; and point to the date buffer
2168   8A4E BD          
2168   8A4F F8 A6       
2168   8A51 AD          
2169   8A52 D4          	CALL(F_DTTOAS)		; convert the date to ASCII
2169   8A53 F8 27       
2170   8A55 F8 7F       	RLDI(P2,TIMBUF+3)	; point to the time buffer
2170   8A57 BD          
2170   8A58 F8 A9       
2170   8A5A AD          
2171   8A5B D4          	CALL(F_TMTOAS)		; and then conver the time
2171   8A5C F8 2A       
2172   8A5E F8 7F       	OUTSTR(CMDBUF)		; print the date/time
2172   8A60 BF          
2172   8A61 F8 B8       
2172   8A63 AF          
2172   8A64 D4          
2172   8A65 FF 09       
2173   8A67 D5          	RETURN			; and we're all done
2174   8A68             
2175   8A68             ; Here if no RTC is installed or the clock is not set...
2176   8A68 3A 74       NOTIME:	BNZ	NOTSET
2177   8A6A F8 8A       NORTC:	OUTSTR(RTCMS1)
2177   8A6C BF          
2177   8A6D F8 B1       
2177   8A6F AF          
2177   8A70 D4          
2177   8A71 FF 09       
2178   8A73 D5          	RETURN
2179   8A74 F8 8A       NOTSET:	OUTSTR(RTCMS2)
2179   8A76 BF          
2179   8A77 F8 C6       
2179   8A79 AF          
2179   8A7A D4          
TASM 1802 Assembler.              boots.asm                        page 75
BTS1802 -- Monitor for the COSMAC Elf 2000

2179   8A7B FF 09       
2180   8A7D D5          	RETURN
2181   8A7E             
TASM 1802 Assembler.              boots.asm                        page 76
BTS1802 -- Monitor for the COSMAC Elf 2000

2182   8A7E             	.EJECT
2183   8A7E             ;	.SBTTL	Set Current Date and TIme
2184   8A7E             
2185   8A7E             ;   The "SET DA[TIME] mm/dd/yyyy hh:mm:ss" command sets the RTC clock to the
2186   8A7E             ; date and time given.  Note that the syntax used for the date/time is exactly
2187   8A7E             ; the same as the way it's printed by "SHOW DA[TIME]"...
2188   8A7E D4          SETTIME:CALL(F_LTRIM)	; ignore any leading spaces
2188   8A7F FF 15       
2189   8A81 F8 7F       	RLDI(0AH,TIMBUF); point to the time buffer
2189   8A83 BA          
2189   8A84 F8 A6       
2189   8A86 AA          
2190   8A87 D4          	CALL(F_ASTODT)	; try to parse an ASCII date
2190   8A88 F8 30       
2191   8A8A C3 85 68    	LBDF	CMDERR	; branch if the format is illegal
2192   8A8D 0F          	LDN	P1	; get the break character
2193   8A8E FF 20       	SMI	' '	; it had better be a space
2194   8A90 CA 85 68    	LBNZ	CMDERR	; bad date otherwise
2195   8A93             ;	CALL(F_LTRIM)	; skip the spaces
2196   8A93 D4          	CALL(F_ASTOTM)	; and now parse the time
2196   8A94 F8 33       
2197   8A96 C3 85 68    	LBDF	CMDERR	; bad date
2198   8A99 D4          	CALL(ISEOL)	; that should be the end
2198   8A9A 85 61       
2199   8A9C CB 85 68    	LBNF	CMDERR	; error if it isn't
2200   8A9F             
2201   8A9F             ; If all is well, proceed to set the time...
2202   8A9F F8 7F       	RLDI(P1,TIMBUF)	; point to the tim buffer again
2202   8AA1 BF          
2202   8AA2 F8 A6       
2202   8AA4 AF          
2203   8AA5 D4          	CALL(F_SETTOD)	; set the clock
2203   8AA6 F8 18       
2204   8AA8 C3 8A 68    	LBDF	NOTIME	; branch if error
2205   8AAB D4          	CALL(SHOWNOW)	; echo the new time
2205   8AAC 8A 3A       
2206   8AAE C0 90 D5    	LBR	TCRLF	; finish the line and return...
2207   8AB1             
2208   8AB1             ; RTC mesages...
2209   8AB1 3F 52 54 43 RTCMS1:	.DB	"?RTC NOT INSTALLED\r\n", 0
2209   8AB5 20 4E 4F 54 
2209   8AB9 20 49 4E 53 
2209   8ABD 54 41 4C 4C 
2209   8AC1 45 44 0D 0A 
2209   8AC5 00 
2210   8AC6 3F 52 54 43 RTCMS2:	.DB	"?RTC NOT SET\r\n", 0
2210   8ACA 20 4E 4F 54 
2210   8ACE 20 53 45 54 
2210   8AD2 0D 0A 00 
2211   8AD5             
TASM 1802 Assembler.              boots.asm                        page 77
BTS1802 -- Monitor for the COSMAC Elf 2000

2212   8AD5             	.EJECT
2213   8AD5             ;	.SBTTL	SHOW RTC Comand
2214   8AD5             
2215   8AD5             ;   This routine will dump all 128 bytes of the Elf 2000 disk board real
2216   8AD5             ; time clock and non-volatile RAM chip.  It does this by reading the clock
2217   8AD5             ; chip hardware directly and doesn't use the BIOS, so it's perfect for
2218   8AD5             ; double checking that the software is doing what it's supposed to!
2219   8AD5             SHOWRTC:
2220   8AD5 D4          	CALL(ISEOL)		; no arguments ...
2220   8AD6 85 61       
2221   8AD8 CB 85 68    	LBNF	CMDERR		; ...
2222   8ADB D4          	CALL(F_RTCTEST)		; is the RTC installed?
2222   8ADC F8 2D       
2223   8ADE CB 8A 6A    	LBNF	NORTC		; nope - quit now
2224   8AE1             
2225   8AE1             ; Type the detected NVR size, in bytes ...
2226   8AE1 73          	PUSHD			; save the size for a minute
2227   8AE2 D4          	INLMES("NVR SIZE=")
2227   8AE3 FF 66       
2227   8AE5 4E 56 52 20 
2227   8AE9 53 49 5A 45 
2227   8AED 3D 
2227   8AEE 00          
2228   8AEF 60          	POPD			; recover the size
2228   8AF0 F0          
2229   8AF1 AF          	PLO	P1		; ...
2230   8AF2 F8 00       	LDI	0		; ...
2231   8AF4 BF          	PHI	P1		; ...
2232   8AF5 D4          	CALL(TDEC16)		; and type in decimal
2232   8AF6 91 82       
2233   8AF8             
2234   8AF8             ; Type the computed NVR checksum ...
2235   8AF8 D4          	INLMES(" CHECKSUM=")
2235   8AF9 FF 66       
2235   8AFB 20 43 48 45 
2235   8AFF 43 4B 53 55 
2235   8B03 4D 3D 
2235   8B05 00          
2236   8B06 D4          	CALL(F_NVRCCHK)		; compute the actual checksum
2236   8B07 F8 36       
2237   8B09 D4          	CALL(THEX4)		; print that
2237   8B0A 91 7A       
2238   8B0C D4          	CALL(TCRLF)		; and we're done
2238   8B0D 90 D5       
2239   8B0F             
2240   8B0F             ; Set the RTC to binary mode...
2241   8B0F             ;	SEX	PC		; X=P
2242   8B0F             ;	OUT	NVR_SELECT	; write the expansion board select register
2243   8B0F             ;	.DB	$8B		; select RTC/NVR chip, register B
2244   8B0F             ;	OUT	NVR_DATA	; then write the data
2245   8B0F             ;	.DB	$07		; select 24hr, DST and binary mode
2246   8B0F             
2247   8B0F~            #ifndef BLACK1802
2248   8B0F~            ;   Now copy all 128 bytes of NVR to the disk buffer.  This includes the bytes
2249   8B0F~            ; in the clock/calendar chip and, if we happen to have a 64 byte chip, it
2250   8B0F~            ; actually copies everything twice (because the 64 byte chip doesn't decode
2251   8B0F~            ; A6!)....
2252   8B0F~            	RLDI(P1,DSKBUF)		; point P1 to the disk buffer
2252   8B0F~            	RLDI(P1,DSKBUF)		; point P1 to the disk buffer
TASM 1802 Assembler.              boots.asm                        page 78
BTS1802 -- Monitor for the COSMAC Elf 2000

2252   8B0F~            	RLDI(P1,DSKBUF)		; point P1 to the disk buffer
2252   8B0F~            	RLDI(P1,DSKBUF)		; point P1 to the disk buffer
2253   8B0F~            RTDMP:	ORI	$80		; add the RTC select bit to the address
2254   8B0F~            	SEX	SP		; point to the stack
2255   8B0F~            	STR	SP		; and save the RTC register address
2256   8B0F~            	OUT	NVR_SELECT	; write it to the register select port
2257   8B0F~            	DEC	SP		; (OUT increments the SP)
2258   8B0F~            	SEX	P1		; now point to the data buffer
2259   8B0F~            	INP	NVR_DATA	; and read the addressed byte from NVR
2260   8B0F~            	INC	P1		; increment the address for next time
2261   8B0F~            	GLO	P1		; get the low byte of the address
2262   8B0F~            	ANI	$7F		; have we done 128 bytes?
2263   8B0F~            	LBNZ	RTDMP		; keep going until we have
2264   8B0F             #else
2265   8B0F F8 00       	RLDI(P1,0)
2265   8B11 BF          
2265   8B12 F8 00       
2265   8B14 AF          
2266   8B15 F8 7D       	RLDI(P2,DSKBUF)
2266   8B17 BD          
2266   8B18 F8 00       
2266   8B1A AD          
2267   8B1B F8 00       	RLDI(P3,$7F)
2267   8B1D BC          
2267   8B1E F8 7F       
2267   8B20 AC          
2268   8B21 D4          	CALL(F_RDNVR)
2268   8B22 F8 1B       
2269   8B24             #endif
2270   8B24             
2271   8B24             ; Now use the MEMDMP routine to dump out the DSKBUF that contains the RTC data.
2272   8B24 F8 7D       	RLDI(P3,DSKBUF)		; first address to dump
2272   8B26 BC          
2272   8B27 F8 00       
2272   8B29 AC          
2273   8B2A F8 7D       	RLDI(P4,DSKBUF+$7F)	; last   "   "   "   "
2273   8B2C BB          
2273   8B2D F8 7F       
2273   8B2F AB          
2274   8B30 C0 87 01    	LBR	MEMDMP		; and print it in HEX and ASCII
2275   8B33             
TASM 1802 Assembler.              boots.asm                        page 79
BTS1802 -- Monitor for the COSMAC Elf 2000

2276   8B33             	.EJECT
2277   8B33             ;	.SBTTL	SHOW DP and SHOW MEMORY Commands
2278   8B33             
2279   8B33             ;   The "SHOW DP" command dumps the monitor data page (all 256 bytes of it!).
2280   8B33             ; It's equivalent to "EXAMINE 7F00 7FFF" and is a handy shortcut for debugging.
2281   8B33 D4          DPDUMP:	CALL(ISEOL)
2281   8B34 85 61       
2282   8B36 CB 85 68    	LBNF	CMDERR
2283   8B39 F8 7F       DDUMP1:	RLDI(P3,RAMPAGE)
2283   8B3B BC          
2283   8B3C F8 00       
2283   8B3E AC          
2284   8B3F F8 7F       	RLDI(P4,RAMPAGE+$FF)
2284   8B41 BB          
2284   8B42 F8 FF       
2284   8B44 AB          
2285   8B45 C0 87 01    	LBR	MEMDMP
2286   8B48             
2287   8B48             
2288   8B48             ;   The "SHOW MEMORY" command prints the number of bytes of free RAM, as
2289   8B48             ; returned by the BIOS F_FREEMEM routine...
2290   8B48 D4          SHOMEM:	CALL(ISEOL)		; no arguments allowed
2290   8B49 85 61       
2291   8B4B CB 85 68    	LBNF	CMDERR		; error if there's more
2292   8B4E D4          	CALL(F_FREEMEM)		; ask the BIOS to figure it out
2292   8B4F FF 57       
2293   8B51             ;  The F_FREEMEM function actually returns the address of the last usable byte,
2294   8B51             ; which is one less than the actual number of free bytes!!
2295   8B51 1F          	INC	P1		; correct for that
2296   8B52 D4          	CALL(TDEC16)		; and type in decimal
2296   8B53 91 82       
2297   8B55 F8 8B       	OUTSTR(FREMSG)		; finish the line and
2297   8B57 BF          
2297   8B58 F8 5F       
2297   8B5A AF          
2297   8B5B D4          
2297   8B5C FF 09       
2298   8B5E D5          	RETURN			; ... all done
2299   8B5F 20 62 79 74 FREMSG:	.TEXT	" bytes free\r\n\000"
2299   8B63 65 73 20 66 
2299   8B67 72 65 65 0D 
2299   8B6B 0A 00 
2300   8B6D             
TASM 1802 Assembler.              boots.asm                        page 80
BTS1802 -- Monitor for the COSMAC Elf 2000

2301   8B6D             	.EJECT
2302   8B6D             ;	.SBTTL	SHOW TERMINAL Command
2303   8B6D             
2304   8B6D             ;   The "SHOW TERMINAL" command prints the current terminal settings (i.e.
2305   8B6D             ; BAUD1 and BAUD0).  It doesn't bother to decode them for you, however!
2306   8B6D             ; If BAUD.1 (register RE.1) is 0xFE, then the video card and PS/2 keyboard
2307   8B6D             ; are in use as the console.  In that case, we report the version number
2308   8B6D             ; of the firmware for those two components instead...
2309   8B6D D4          SHOTERM:CALL(ISEOL)		; no arguments
2309   8B6E 85 61       
2310   8B70 CB 85 68    	LBNF	CMDERR		; ...
2311   8B73~            #ifdef VIDEO
2312   8B73~            	GHI	BAUD		; check for a video/PS2 console
2313   8B73~            	ANI	$FE		; ignore the echo bit
2314   8B73~            	XRI	$FE		; is it 0xFE?
2315   8B73~            	LBZ	SHOVID		; yep - go show video/PS2 version instead
2316   8B73             #endif
2317   8B73 D4          	INLMES("BAUD1=0x")
2317   8B74 FF 66       
2317   8B76 42 41 55 44 
2317   8B7A 31 3D 30 78 
2317   8B7E 00          
2318   8B7F F8 7F       	RLDI(DP,BAUD1)		; point to the values saved in memory
2318   8B81 B7          
2318   8B82 F8 A4       
2318   8B84 A7          
2319   8B85 47          	LDA	DP		; and get BAUD1
2320   8B86 D4          	CALL(THEX2)		; type that in hex
2320   8B87 91 6D       
2321   8B89 D4          	INLMES(" BAUD0=0x")
2321   8B8A FF 66       
2321   8B8C 20 42 41 55 
2321   8B90 44 30 3D 30 
2321   8B94 78 
2321   8B95 00          
2322   8B96 47          	LDA	DP		; and now BAUD0
2323   8B97 D4          	CALL(THEX2)		; ...
2323   8B98 91 6D       
2324   8B9A C0 90 D5    	LBR	TCRLF		; type CRLF and return
2325   8B9D             
2326   8B9D~            #ifdef VIDEO
2327   8B9D~            ;   Here if the video card and PS2 keyboard are in use.  Note that the name
2328   8B9D~            ; and copyright notice for the VT1802 firmware (but not the version!) are
2329   8B9D~            ; actually stored, in ASCII, in the VT1802 code.  The third entry point to
2330   8B9D~            ; the video module points at this text...
2331   8B9D~            SHOVID:	RLDI(P2,VIDEO+7)	; point at the third vector
2331   8B9D~            SHOVID:	RLDI(P2,VIDEO+7)	; point at the third vector
2331   8B9D~            SHOVID:	RLDI(P2,VIDEO+7)	; point at the third vector
2331   8B9D~            SHOVID:	RLDI(P2,VIDEO+7)	; point at the third vector
2332   8B9D~            	SEX	P2		; ...
2333   8B9D~            	POPR(P1)		; and then get the address of the notice
2333   8B9D~            	POPR(P1)		; and then get the address of the notice
2333   8B9D~            	POPR(P1)		; and then get the address of the notice
2333   8B9D~            	POPR(P1)		; and then get the address of the notice
2334   8B9D~            	CALL(F_MSG)		; print that
2334   8B9D~            	CALL(F_MSG)		; print that
2335   8B9D~            	CALL(TCRLF)		; and finish the line
2335   8B9D~            	CALL(TCRLF)		; and finish the line
2336   8B9D~            
TASM 1802 Assembler.              boots.asm                        page 81
BTS1802 -- Monitor for the COSMAC Elf 2000

2337   8B9D~            ; Now give the version of the PS/2 keyboard APU ...
2338   8B9D~            	OUTSTR(PS2TX1)		; PS/2 keyboard APU
2338   8B9D~            	OUTSTR(PS2TX1)		; PS/2 keyboard APU
2338   8B9D~            	OUTSTR(PS2TX1)		; PS/2 keyboard APU
2338   8B9D~            	OUTSTR(PS2TX1)		; PS/2 keyboard APU
2338   8B9D~            	OUTSTR(PS2TX1)		; PS/2 keyboard APU
2338   8B9D~            	OUTSTR(PS2TX1)		; PS/2 keyboard APU
2339   8B9D~            	RLDI(P1,PS2VER)		; this time the PS2 APU version
2339   8B9D~            	RLDI(P1,PS2VER)		; this time the PS2 APU version
2339   8B9D~            	RLDI(P1,PS2VER)		; this time the PS2 APU version
2339   8B9D~            	RLDI(P1,PS2VER)		; this time the PS2 APU version
2340   8B9D~            	LDN	P1		; ...
2341   8B9D~            	PLO	P1		; ...
2342   8B9D~            	LDI	0		; (these version are only 1 byte)
2343   8B9D~            	PHI	P1		; ...
2344   8B9D~            	CALL(TDEC16)		; type in decimal
2344   8B9D~            	CALL(TDEC16)		; type in decimal
2345   8B9D~            	LBR	TCRLF		; and we're done
2346   8B9D~            
2347   8B9D~            PS2TX1:	.TEXT	"PS/2 Keyboard APU Firmware V\000"
2348   8B9D             #endif
2349   8B9D             
TASM 1802 Assembler.              boots.asm                        page 82
BTS1802 -- Monitor for the COSMAC Elf 2000

2350   8B9D             	.EJECT
2351   8B9D             ;	.SBTTL	SHOW RESTART Command
2352   8B9D             
2353   8B9D             ; The "SHOW RESTART" command prints the current restart option and address...
2354   8B9D D4          SHORES:	CALL(ISEOL)		; no arguments allowed here!
2354   8B9E 85 61       
2355   8BA0 CB 85 68    	LBNF	CMDERR		; ...
2356   8BA3 F8 7F       	RLDI(DP,BOOTF)		; point to the boot flag
2356   8BA5 B7          
2356   8BA6 F8 B5       
2356   8BA8 A7          
2357   8BA9 07          	LDN	DP		; get the restart option
2358   8BAA FB A5       	XRI	ABTDISK		; test for BOOT
2359   8BAC C2 8B D8    	LBZ	RESBOO		; branch if BOOT
2360   8BAF 47          	LDA	DP		; get BOOTF again
2361   8BB0 FB 5A       	XRI	ABTADDR		; test for RESTART xxxx
2362   8BB2 C2 8B C0    	LBZ	RESADR		; handle that
2363   8BB5             
2364   8BB5             ; Here for RESTART NONE (or unknown) ...
2365   8BB5 D4          RESHLT:	INLMES("NONE")
2365   8BB6 FF 66       
2365   8BB8 4E 4F 4E 45 
2365   8BBC 00          
2366   8BBD C0 90 D5    	LBR	TCRLF
2367   8BC0             
2368   8BC0             ; Here for RESTART xxxx ...
2369   8BC0 D4          RESADR:	INLMES("RESTART @")
2369   8BC1 FF 66       
2369   8BC3 52 45 53 54 
2369   8BC7 41 52 54 20 
2369   8BCB 40 
2369   8BCC 00          
2370   8BCD E7          	SEX	DP		; use DP to address memory
2371   8BCE 72          	POPR(P1)		; and get the restart address
2371   8BCF BF          
2371   8BD0 72          
2371   8BD1 AF          
2372   8BD2 D4          	CALL(THEX4)		; type that in hex
2372   8BD3 91 7A       
2373   8BD5 C0 90 D5    	LBR	TCRLF		; finish the line and return
2374   8BD8             
2375   8BD8             ; And here for RESTART BOOT ...
2376   8BD8 D4          RESBOO:	INLMES("BOOT")
2376   8BD9 FF 66       
2376   8BDB 42 4F 4F 54 
2376   8BDF 00          
2377   8BE0 C0 90 D5    	LBR	TCRLF
2378   8BE3             
TASM 1802 Assembler.              boots.asm                        page 83
BTS1802 -- Monitor for the COSMAC Elf 2000

2379   8BE3             	.EJECT
2380   8BE3             ;	.SBTTL	SHOW CPU Command
2381   8BE3             
2382   8BE3             ;   The SHOW CPU command will figure out whether the CPU is an original
2383   8BE3             ; 1802 or an 1805/6.  Better than that, if this system has the RTC/NVR
2384   8BE3             ; (DS12887) option installed, this command will attempt to determine the
2385   8BE3             ; CPU clock frequency.  This speed measurement is done with interrupts and
2386   8BE3             ; DMA left ON, so it's especially handy if you're using the video card
2387   8BE3             ; because it allows you to estimate the video display overhead.
2388   8BE3             ;
2389   8BE3             ;   BTW, the CPU speed is measured only if the RTC is present because we
2390   8BE3             ; need the RTC's internal clock to give us a measurement of time that's
2391   8BE3             ; independent of the CPU speed.  In principle there are other things that
2392   8BE3             ; could be used as an independent time base (e.g. if the video card is
2393   8BE3             ; installed you could use the VRTC, or you could even use the baud rate
2394   8BE3             ; clock for the UART) but I'm too lazy to code all those options.
2395   8BE3             ;
2396   8BE3             ;   One more thing - in principle the 1804 is the same as the 1805/6, but
2397   8BE3             ; the 1804 had on chip mask programmed ROM and I really doubt that anybody
2398   8BE3             ; is using one of these.  AFAIK, there's no software way to distinguish any
2399   8BE3             ; of the 1804, 1805, or 1806 processors.
2400   8BE3             SHOCPU:
2401   8BE3             
2402   8BE3             ;  The first thing is to figure out whether the CPU is an 1802 or the newer
2403   8BE3             ; 1805/6.  This is pretty easy because the 1805/6 have additional two byte
2404   8BE3             ; opcodes which use 0x68 as the prefix, and on the original 1802 opcode 0x68
2405   8BE3             ; is a no-op.  So the two byte sequence 0x68, 0x68 is just two no-ops on the
2406   8BE3             ; 1802, and on the 1805/6 it's the "RLXA 8" (register load via X and advance)
2407   8BE3             				; instruction.
2408   8BE3             	;;  for emulation we are always an 1802 but it is handy to have
2409   8BE3             	;; SHOW CPU cause a break to the meta monitor
2410   8BE3             	;;  But not twice! So...
2411   8BE3             #ifdef BLACK1802
2412   8BE3 68          	.DB 68H
2413   8BE4~            #else	
2414   8BE4~            	PUSHR(8)	 ;save register 8 just in case it's important
2414   8BE4~            	PUSHR(8)	 ;save register 8 just in case it's important
2414   8BE4~            	PUSHR(8)	 ;save register 8 just in case it's important
2414   8BE4~            	PUSHR(8)	 ;save register 8 just in case it's important
2415   8BE4~            	RCLEAR(P1)		; make P1 be zero
2415   8BE4~            	RCLEAR(P1)		; make P1 be zero
2415   8BE4~            	RCLEAR(P1)		; make P1 be zero
2416   8BE4~            	SEX	P1		; and then use that for X
2417   8BE4~            	.DB	68H, 68H	; then do "RLXA 8"
2418   8BE4~            	SEX	SP		; back to the real stack
2419   8BE4~            	IRX			; and restore R8
2420   8BE4~            	POPRL(8)		; ...
2420   8BE4~            	POPRL(8)		; ...
2420   8BE4~            	POPRL(8)		; ...
2420   8BE4~            	POPRL(8)		; ...
2421   8BE4~            
2422   8BE4~            ;   If P1 is still zero, then the CPU is an 1802.  If P1 has been incremented,
2423   8BE4~            ; then the CPU is a 1805/6...
2424   8BE4~            	GLO	P1		; let's see
2425   8BE4~            	LBZ	CPU02		; branch if it's a 1802
2426   8BE4~            	INLMES("CDP1804/5/6")	; nope - it's a 1805/6 - lucky you!
2426   8BE4~            	INLMES("CDP1804/5/6")	; nope - it's a 1805/6 - lucky you!
2426   8BE4~            	INLMES("CDP1804/5/6")	; nope - it's a 1805/6 - lucky you!
2426   8BE4~            	INLMES("CDP1804/5/6")	; nope - it's a 1805/6 - lucky you!
TASM 1802 Assembler.              boots.asm                        page 84
BTS1802 -- Monitor for the COSMAC Elf 2000

2427   8BE4~            	BR	SHOCP0		; then continue with the speed measurement
2428   8BE4             #endif	
2429   8BE4 D4          CPU02:	INLMES("CDP1802")	; a more traditional type
2429   8BE5 FF 66       
2429   8BE7 43 44 50 31 
2429   8BEB 38 30 32 
2429   8BEE 00          
2430   8BEF             SHOCP0:	
2431   8BEF             
2432   8BEF             ;   See if the RTC is present and, if it is, then turn on the periodic divider
2433   8BEF             ; chain and program it for 2Hz (500ms intervals).  Note that we don't enable
2434   8BEF             ; either the square wave output or the interrupt output so nothing outside
2435   8BEF             ; the RTC is affected, but we can still tell when the flag sets by watching 
2436   8BEF             #ifdef BLACK1802				; the PF bit in status register C.
2437   8BEF C0 8B F2    	LBR SHOCP9				; could use SIM key to pull millis
2438   8BF2~            #else	
2439   8BF2~            	CALL(F_RTCTEST)		; is the NVR/RC chip present?
2439   8BF2~            	CALL(F_RTCTEST)		; is the NVR/RC chip present?
2440   8BF2~            	LBNF	SHOCP9		; nope - just skip all this mess
2441   8BF2~            	INLMES(" - SPEED=")
2441   8BF2~            	INLMES(" - SPEED=")
2441   8BF2~            	INLMES(" - SPEED=")
2441   8BF2~            	INLMES(" - SPEED=")
2442   8BF2~            	RCLEAR(P1)		; clear P1 (we'll use this for counting, later)
2442   8BF2~            	RCLEAR(P1)		; clear P1 (we'll use this for counting, later)
2442   8BF2~            	RCLEAR(P1)		; clear P1 (we'll use this for counting, later)
2443   8BF2~            	SEX	PC		; now we do a bunch of inline outputs
2444   8BF2~            	WNVR(NVRA,DV1+$0F)	; turn on the divider and select 2Hz
2444   8BF2~            	WNVR(NVRA,DV1+$0F)	; turn on the divider and select 2Hz
2444   8BF2~            	WNVR(NVRA,DV1+$0F)	; turn on the divider and select 2Hz
2444   8BF2~            	WNVR(NVRA,DV1+$0F)	; turn on the divider and select 2Hz
2445   8BF2~            	RNVR(NVRC)		; read register C to be sure PF is cleared
2445   8BF2~            	RNVR(NVRC)		; read register C to be sure PF is cleared
2445   8BF2~            	RNVR(NVRC)		; read register C to be sure PF is cleared
2445   8BF2~            	RNVR(NVRC)		; read register C to be sure PF is cleared
2446   8BF2~            
2447   8BF2~            ;   Now wait for the PF bit to set, just to be sure we're synchronized with
2448   8BF2~            ; the NVR clock.  The act of reading register C will clear the PF bit, so
2449   8BF2~            ; after we find it set we can wait for it to set again and have an exactly
2450   8BF2~            ; known interval...
2451   8BF2~            SHOCP1:	SEX	PC		; RNVR does an inline OUT
2452   8BF2~            	RNVR(NVRC)		; read register C
2452   8BF2~            	RNVR(NVRC)		; read register C
2452   8BF2~            	RNVR(NVRC)		; read register C
2452   8BF2~            	RNVR(NVRC)		; read register C
2453   8BF2~            	ANI	PF		; is the PF bit set?
2454   8BF2~            	BZ	SHOCP1		; nope - keep waiting
2455   8BF2~            
2456   8BF2~            ;   Now that we have a known real time interval, measuring the CPU clock is
2457   8BF2~            ; pretty simple.  We simply execute a loop that uses a known number of CPU
2458   8BF2~            ; cycles and count the iterations while we're waiting for the PF flag to
2459   8BF2~            ; set again.
2460   8BF2~            ;
2461   8BF2~            ;   But wait, let's think for a minute first.  Suppose we use a loop something
2462   8BF2~            ; like the one above (at SHOCP1).  This loop will take about 14 machine cycles,
2463   8BF2~            ; including an extra 2 for an "INC P1" instruction, or 112 clocks.  To convert
2464   8BF2~            ; the iteration count to megahertz we just need to multiply by 112 (number of
2465   8BF2~            ; clocks per iteration) and then by 2 (since we only count for 1/2 second).
2466   8BF2~            ; Easy enough on paper, but it will require a 16x16 bit --> 32 bit multiply
TASM 1802 Assembler.              boots.asm                        page 85
BTS1802 -- Monitor for the COSMAC Elf 2000

2467   8BF2~            ; operation and, worse yet, it'll require a 32 bit binary to decimal conversion
2468   8BF2~            ; in order to print the result.  All that on a 1802!  Just thinking about it
2469   8BF2~            ; makes me want to go lie down...
2470   8BF2~            ;
2471   8BF2~            ;   Suppose we were a little bit smarter and made the loop take 500 clocks
2472   8BF2~            ; instead of 112??  Then we'd have to multiply the iteration count by 500x2
2473   8BF2~            ; or 1000.  But wait, multiplying by 1000 is as easy as printing "000" after
2474   8BF2~            ; we type out the original count! No quad precision multiplication or division,
2475   8BF2~            ; and we can use the regular TDEC16 routine to print the result.  Alright!
2476   8BF2~            ;
2477   8BF2~            ;   But, it's not that easy.  On the 1802 the number of clocks per cycle is
2478   8BF2~            ; always 8 and we can't change that, so if we want the loop to take 500 clocks
2479   8BF2~            ; that means it has to take 500/8 = 62.5 machine cycles.  You aren't going to
2480   8BF2~            ; find any instruction that takes 0.5 machine cycles.  Bummer!
2481   8BF2~            ;
2482   8BF2~            ;   However, we can make a loop that takes 2000 clocks because 2000/8=125.
2483   8BF2~            ; For a given clock frequency, a loop that takes 2000 clocks will execute half
2484   8BF2~            ; as many times as one that takes 1000, so all we need to do is multiply the
2485   8BF2~            ; iteration count by 2 before we print it and we're set!
2486   8BF2~            ;
2487   8BF2~            ;   Now aren't you glad we thought about it first???
2488   8BF2~            SHOCP2:	INC	P1		; [2] count iterations
2489   8BF2~            	LDI	26		; [2] set up an inner delay loop
2490   8BF2~            SHOC2A:	SMI	1		;   [2] count down
2491   8BF2~            	BNZ	SHOC2A		;   [2]  ... until we get to zero
2492   8BF2~            	BR	$+2		; [2] we need two more cycles
2493   8BF2~            	NOP			; [3] plus three cycles for an odd total
2494   8BF2~            	SEX	PC		; [2] do an inline OUT
2495   8BF2~            	OUT	NVR_SELECT	; [2] select NVR register C
2496   8BF2~            	.DB	NVRC		; [0]
2497   8BF2~            	SEX	SP		; [2] point X at some RAM
2498   8BF2~            	INP	NVR_DATA	; [2] and read register C
2499   8BF2~            	ANI	PF		; [2] is the PF bit set yet?
2500   8BF2~            	LBZ	SHOCP2		; [2] nope - keep waiting
2501   8BF2~            				; Total = 26*4 + 9*2 + 3 = 125!!!
2502   8BF2~            
2503   8BF2~            ; All done, and the loop count is now in P1.
2504   8BF2~            	SEX	PC		; before anything else 
2505   8BF2~            	WNVR(NVRA,DV1)		;  ... turn off the divider chain again
2505   8BF2~            	WNVR(NVRA,DV1)		;  ... turn off the divider chain again
2505   8BF2~            	WNVR(NVRA,DV1)		;  ... turn off the divider chain again
2505   8BF2~            	WNVR(NVRA,DV1)		;  ... turn off the divider chain again
2506   8BF2~            	RSHL(P1)		; multiply P1 by 2
2506   8BF2~            	RSHL(P1)		; multiply P1 by 2
2506   8BF2~            	RSHL(P1)		; multiply P1 by 2
2506   8BF2~            	RSHL(P1)		; multiply P1 by 2
2506   8BF2~            	RSHL(P1)		; multiply P1 by 2
2506   8BF2~            	RSHL(P1)		; multiply P1 by 2
2507   8BF2~            	CALL(TDEC16)		; and type the result
2507   8BF2~            	CALL(TDEC16)		; and type the result
2508   8BF2~            	INLMES("000")		; multiply by 1000
2508   8BF2~            	INLMES("000")		; multiply by 1000
2508   8BF2~            	INLMES("000")		; multiply by 1000
2508   8BF2~            	INLMES("000")		; multiply by 1000
2509   8BF2             #endif	
2510   8BF2 C0 90 D5    SHOCP9:	LBR	TCRLF		; finish the line and we're done!!!
2511   8BF5             
TASM 1802 Assembler.              boots.asm                        page 86
BTS1802 -- Monitor for the COSMAC Elf 2000

2512   8BF5             	.EJECT
2513   8BF5             ;	.SBTTL	The SHOW VERSION Command
2514   8BF5             
2515   8BF5             ;   The "SHOW VERSION" command prints (what else) the version numbers of the
2516   8BF5             ; monitor and the BIOS along with a list of the features assembled into this
2517   8BF5             ; BIOS...
2518   8BF5 D4          SHOVER:	CALL(ISEOL)		; no arguments
2518   8BF6 85 61       
2519   8BF8 CB 85 68    	LBNF	CMDERR		; ...
2520   8BFB F8 8C       	OUTSTR(VERM1)
2520   8BFD BF          
2520   8BFE F8 4A       
2520   8C00 AF          
2520   8C01 D4          
2520   8C02 FF 09       
2521   8C04 F8 00       	RLDI(P1,MONVER)		; print the EPROM version number
2521   8C06 BF          
2521   8C07 F8 73       
2521   8C09 AF          
2522   8C0A D4          	CALL(TDEC16)		; always in decimal
2522   8C0B 91 82       
2523   8C0D F8 8C       	OUTSTR(VERM2)
2523   8C0F BF          
2523   8C10 F8 54       
2523   8C12 AF          
2523   8C13 D4          
2523   8C14 FF 09       
2524   8C16 F8 FF       	RLDI(DP,F_VERSION)	; point to the version number
2524   8C18 B7          
2524   8C19 F8 F9       
2524   8C1B A7          
2525   8C1C 47          	LDA	DP		; get the first byte
2526   8C1D AF          	PLO	P1		; and type it in decimal
2527   8C1E F8 00       	LDI	0		; (unfortunately it's only 8 bits)
2528   8C20 BF          	PHI	P1		; ...
2529   8C21 D4          	CALL(TDEC16)		; ...
2529   8C22 91 82       
2530   8C24 D4          	INLMES(".")		; ...
2530   8C25 FF 66       
2530   8C27 2E          
2530   8C28 00          
2531   8C29 47          	LDA	DP		; second byte
2532   8C2A AF          	PLO	P1		; ...
2533   8C2B D4          	CALL(TDEC16)		; ...
2533   8C2C 91 82       
2534   8C2E D4          	INLMES(".")		; ...
2534   8C2F FF 66       
2534   8C31 2E          
2534   8C32 00          
2535   8C33 47          	LDA	DP		; and the third byte
2536   8C34 AF          	PLO	P1		; ...
2537   8C35 D4          	CALL(TDEC16)		; ...
2537   8C36 91 82       
2538   8C38 F8 8C       	OUTSTR(VERM3)
2538   8C3A BF          
2538   8C3B F8 5E       
2538   8C3D AF          
2538   8C3E D4          
2538   8C3F FF 09       
TASM 1802 Assembler.              boots.asm                        page 87
BTS1802 -- Monitor for the COSMAC Elf 2000

2539   8C41 D4          	CALL(F_GETDEV)		; get supported devices
2539   8C42 FF 81       
2540   8C44 D4          	CALL(THEX4)		; and type that in hexadecimal
2540   8C45 91 7A       
2541   8C47 C0 90 D5    	LBR	TCRLF		; all done!
2542   8C4A             
2543   8C4A             ; Messages....
2544   8C4A 4D 6F 6E 69 VERM1:	.TEXT	"Monitor V\000"
2544   8C4E 74 6F 72 20 
2544   8C52 56 00 
2545   8C54 20 2D 20 42 VERM2:	.TEXT	" - BIOS V\000"
2545   8C58 49 4F 53 20 
2545   8C5C 56 00 
2546   8C5E 20 66 65 61 VERM3:	.TEXT	" features 0x\000"
2546   8C62 74 75 72 65 
2546   8C66 73 20 30 78 
2546   8C6A 00 
2547   8C6B             
TASM 1802 Assembler.              boots.asm                        page 88
BTS1802 -- Monitor for the COSMAC Elf 2000

2548   8C6B             	.EJECT
2549   8C6B             ;	.SBTTL	VT1802 Video Terminal Test
2550   8C6B             
2551   8C6B~            #ifdef VIDEO
2552   8C6B~            ;   The "TEST VT1802" command displays a test pattern on the VT1802 screen.
2553   8C6B~            ; It's handy for adjusting the monitor, checking that all the video attributes
2554   8C6B~            ; work, viewing the complete character font, and little things like that...
2555   8C6B~            VTTEST:	CALL(ISEOL)		; no more arguments allowed
2555   8C6B~            VTTEST:	CALL(ISEOL)		; no more arguments allowed
2556   8C6B~            	LBNF	CMDERR		; ...
2557   8C6B~            	CALL(ISCRTC)		; is the video card installed?
2557   8C6B~            	CALL(ISCRTC)		; is the video card installed?
2558   8C6B~            	BDF	VTTES0		; yes - go ahead
2559   8C6B~            	INLMES("?NO VIDEO")
2559   8C6B~            	INLMES("?NO VIDEO")
2559   8C6B~            	INLMES("?NO VIDEO")
2559   8C6B~            	INLMES("?NO VIDEO")
2560   8C6B~            	RETURN
2561   8C6B~            
2562   8C6B~            ;   The video test screen couldn't be easier, because all the real work is
2563   8C6B~            ; done by video.asm.  After the screen is displayed, we wait for any character,
2564   8C6B~            ; clear the screen, and then continue...
2565   8C6B~            VTTES0:	OUTSTR(VTTMSG)		; display the test screen
2565   8C6B~            VTTES0:	OUTSTR(VTTMSG)		; display the test screen
2565   8C6B~            VTTES0:	OUTSTR(VTTMSG)		; display the test screen
2565   8C6B~            VTTES0:	OUTSTR(VTTMSG)		; display the test screen
2565   8C6B~            VTTES0:	OUTSTR(VTTMSG)		; display the test screen
2565   8C6B~            VTTES0:	OUTSTR(VTTMSG)		; display the test screen
2566   8C6B~            	CALL(F_READ)		; wait for any character
2566   8C6B~            	CALL(F_READ)		; wait for any character
2567   8C6B~            	OUTSTR(CLSMSG)		; clear the screen
2567   8C6B~            	OUTSTR(CLSMSG)		; clear the screen
2567   8C6B~            	OUTSTR(CLSMSG)		; clear the screen
2567   8C6B~            	OUTSTR(CLSMSG)		; clear the screen
2567   8C6B~            	OUTSTR(CLSMSG)		; clear the screen
2567   8C6B~            	OUTSTR(CLSMSG)		; clear the screen
2568   8C6B~            	RETURN			; and we're done
2569   8C6B~            
2570   8C6B~            ; Test messages...
2571   8C6B~            VTTMSG:	.TEXT	"\033T\033Y2:[PRESS ANY KEY TO CONTINUE]\033Y3G\000"
2572   8C6B~            CLSMSG:	.TEXT	"\033E\000"
2573   8C6B             #endif
2574   8C6B             
TASM 1802 Assembler.              boots.asm                        page 89
BTS1802 -- Monitor for the COSMAC Elf 2000

2575   8C6B             	.EJECT
2576   8C6B             ;	.SBTTL	SET NVR Command
2577   8C6B             
2578   8C6B             ;   The command "SET NVR DEFAULT" will return all NVR settings to their default
2579   8C6B             ; values.  It's a useful way to get back to a known state after things have 
2580   8C6B             ; been fiddled with.  When we get here, only the "SET NVR" part of the command
2581   8C6B             ; has been parsed - before proceeding, we need to parse the "DEFAULT" part,
2582   8C6B             ; even thought there is no other option.  It acts as a kind of confirmation -
2583   8C6B             ; saying "SET NVR <anything else>" is an error...
2584   8C6B D4          SETNVR:	CALL(F_LTRIM)		; ignore any leading spaces
2584   8C6C FF 15       
2585   8C6E D4          	CALL(ISEOL)		; and there'd bettter be more out there
2585   8C6F 85 61       
2586   8C71 C3 85 68    	LBDF	CMDERR		; nope - error
2587   8C74 F8 8C       	RLDI(P2,NVRCMD)		; point to the list of options
2587   8C76 BD          
2587   8C77 F8 7D       
2587   8C79 AD          
2588   8C7A C0 85 12    	LBR	COMND		; parse it and continue
2589   8C7D             
2590   8C7D             ;   Table of "SET NVR" arguments - currently there's only one!  Note that
2591   8C7D             ; "DEFAULT" can't be abbreviated (it's a sort of safety feature).
2592   8C7D 07 44 45 46 NVRCMD:	CMD(7, "DEFAULT", NVRCLR)
2592   8C81 41 55 4C 54 
2592   8C85 00 
2592   8C86 8C 89       
2593   8C88 00          	.DB	0
2594   8C89             
2595   8C89             ; Here when the command has been parsed...
2596   8C89 D4          NVRCLR:	CALL(ISEOL)		; this has to be the end
2596   8C8A 85 61       
2597   8C8C CB 85 68    	LBNF	CMDERR		; ...
2598   8C8F             
2599   8C8F             ; Reset all the NVR locations (the ones we actually use, at least) to default.
2600   8C8F F8 00       	RLDI(P1,NVRBASE)	; offset of monitor data in NVR
2600   8C91 BF          
2600   8C92 F8 00       
2600   8C94 AF          
2601   8C95 F8 80       	RLDI(P2,NVRDEFAULT)	; pointer to default NVR data in ROM
2601   8C97 BD          
2601   8C98 F8 94       
2601   8C9A AD          
2602   8C9B F8 00       	RLDI(P3,NVRSIZE)	; count of bytes to write
2602   8C9D BC          
2602   8C9E F8 06       
2602   8CA0 AC          
2603   8CA1 D4          	CALL(F_WRNVR)		; attempt to save it
2603   8CA2 F8 1E       
2604   8CA4             
2605   8CA4             ;   Clear the BOOTF location in memory so that it agrees with what is now in
2606   8CA4             ; NVR.  This isn't really necessary, but it ensures that if the user gives
2607   8CA4             ; a "SHOW RESTART" command he'll actually see the correct value...
2608   8CA4 F8 7F       	RLDI(P1,BOOTF)		; where to store the data in SRAM
2608   8CA6 BF          
2608   8CA7 F8 B5       
2608   8CA9 AF          
2609   8CAA F8 00       	LDI	0		; ...
2610   8CAC 5F          	STR	P1		; ...
2611   8CAD             
TASM 1802 Assembler.              boots.asm                        page 90
BTS1802 -- Monitor for the COSMAC Elf 2000

2612   8CAD             ;   And lastly, although it isn't strictly necessary, trash the "key" that's
2613   8CAD             ; stored in SRAM too.  This ensures that, if the SRAM battery backup is
2614   8CAD             ; installed, it will also look uninitialized next time we reboot...
2615   8CAD F8 7F       	RLDI(P1,KEY)		; point to the key
2615   8CAF BF          
2615   8CB0 F8 78       
2615   8CB2 AF          
2616   8CB3 F8 00       	LDI	0		; and trash it
2617   8CB5 5F          	STR	P1		; just one byte is enough
2618   8CB6 D5          	RETURN			; that's all!
2619   8CB7             
TASM 1802 Assembler.              boots.asm                        page 91
BTS1802 -- Monitor for the COSMAC Elf 2000

2620   8CB7             	.EJECT
2621   8CB7             ;	.SBTTL	Load Intel HEX Records
2622   8CB7             
2623   8CB7             ; Parse an Intel hex file record and, if it's valid, deposit it in memory...
2624   8CB7             ;
2625   8CB7             ;	P1   - pointer to CMDBUF (contains the HEX record)
2626   8CB7             ;	P2   - Load address
2627   8CB7             ;	P3.0 - record length
2628   8CB7             ;	P3.1 - record type
2629   8CB7             ;	P4.0 - record checksum (8 bits only!)
2630   8CB7             
2631   8CB7 D4          IHEX:	CALL(GHEX2)	; first two characters are the record length
2631   8CB8 90 FD       
2632   8CBA CB 85 68    	LBNF	CMDERR	; syntax error
2633   8CBD AC          	PLO	P3	; save the record length in P2.0
2634   8CBE D4          	CALL(GHEX4)	; the next four characters are the load address
2634   8CBF 90 EE       
2635   8CC1 CB 85 68    	LBNF	CMDERR	; syntax error
2636   8CC4             ;	RCOPY(P3,P2)	; save the load address in P3
2637   8CC4 D4          	CALL(GHEX2)	; and the next two characters are the record type
2637   8CC5 90 FD       
2638   8CC7 BC          	PHI	P3	; save that just in case we need it
2639   8CC8             
2640   8CC8             ; The only allowed record types are 0 (data) and 1 (EOF)....
2641   8CC8 C2 8C DA    	LBZ	IHEX1	; branch if a data record
2642   8CCB FC FF       	ADI	$FF	; is it one?
2643   8CCD C2 8D 21    	LBZ	IHEX4	; yes - EOF record
2644   8CD0             
2645   8CD0             ; Here for an unknown record type...
2646   8CD0 F8 8D       	OUTSTR(URCMSG)
2646   8CD2 BF          
2646   8CD3 F8 54       
2646   8CD5 AF          
2646   8CD6 D4          
2646   8CD7 FF 09       
2647   8CD9 D5          	RETURN
2648   8CDA             
2649   8CDA             ;   For a data record, check the address and be sure that it's not on the
2650   8CDA             ; monitor's data page.  Downloading the monitor's data page could corrupt
2651   8CDA             ; the stack, the command line buffer, and cause all sorts of confusion!
2652   8CDA 9D          IHEX1:	GHI	P2	; get the high byte of the address
2653   8CDB FF 7F       	SMI HIGH(RAMPAGE); is it the same as the monitor's data page?
2654   8CDD CA 8C EA    	LBNZ	IHEX1A	; nope - keep going
2655   8CE0 F8 8D       	OUTSTR(OVMMSG)	; ?WOULD OVERWRITE MONITOR
2655   8CE2 BF          
2655   8CE3 F8 6F       
2655   8CE5 AF          
2655   8CE6 D4          
2655   8CE7 FF 09       
2656   8CE9 D5          	RETURN		; yes - refuse to load it
2657   8CEA             
2658   8CEA             ;   Here for a data record - begin by accumulating the checksum.  Remember
2659   8CEA             ; that the record checksum includes the four bytes (length, type and address)
2660   8CEA             ; we already read, although we can safely skip the record type since we know
2661   8CEA             ; it's zero!
2662   8CEA 8C          IHEX1A:	GLO	P3	; get the record length
2663   8CEB 73          	STXD		; push in on the stack for a moment
2664   8CEC 9D          	GHI	P2	; and the high address byte
2665   8CED 52          	STR	SP	; stack it too
TASM 1802 Assembler.              boots.asm                        page 92
BTS1802 -- Monitor for the COSMAC Elf 2000

2666   8CEE 8D          	GLO	P2	; now the low address byte
2667   8CEF F4          	ADD		; add the high address byte
2668   8CF0 60          	IRX		; ...
2669   8CF1 F4          	ADD		; and add the record length
2670   8CF2 AB          	PLO	P4	; accumulate the checksum here
2671   8CF3             
2672   8CF3             ; Now read the number of data bytes specified by P3.0...
2673   8CF3 8C          IHEX2:	GLO	P3	; any more bytes to read???
2674   8CF4 C2 8D 0C    	LBZ	IHEX3	; nope - test the checksum
2675   8CF7 D4          	CALL(GHEX2)	; yes - get another data value
2675   8CF8 90 FD       
2676   8CFA CB 85 68    	LBNF	CMDERR	; syntax error
2677   8CFD 52          	STR	SP	; save the byte on the stack for a minute
2678   8CFE 8B          	GLO	P4	; and accumulate the checksum
2679   8CFF F4          	ADD		; ...
2680   8D00 AB          	PLO	P4	; ...
2681   8D01 F0          	LDX		; get the data again
2682   8D02 5D          	STR	P2	; and store it in memory at the record address
2683   8D03 4D          	LDA	P2	; get the byte we just stored and advance P3
2684   8D04 F7          	SM		; did memory really change
2685   8D05 CA 8D 2B    	LBNZ	IHEX5	; memory error
2686   8D08 2C          	DEC	P3	; count another byte read
2687   8D09 C0 8C F3    	LBR	IHEX2	; and keep going
2688   8D0C             
2689   8D0C             ; Here when we've read all the data - verify the checksum byte...
2690   8D0C D4          IHEX3:	CALL(GHEX2)	; one more time
2690   8D0D 90 FD       
2691   8D0F CB 85 68    	LBNF	CMDERR	; synxtax error
2692   8D12 52          	STR	SP	; save checksum byte on the stack
2693   8D13 8B          	GLO	P4	; get the running total so far
2694   8D14 F4          	ADD		; that plus this should be zero
2695   8D15 CA 8D 35    	LBNZ	IHEX6	; checksum error
2696   8D18 D4          	INLMES("OK\r\n"); successful (believe it or not!!)
2696   8D19 FF 66       
2696   8D1B 4F 4B 0D 0A 
2696   8D1F 00          
2697   8D20 D5          	RETURN
2698   8D21             
2699   8D21             ; Here for an EOF record...
2700   8D21 D4          IHEX4:	INLMES("EOF\r\n")
2700   8D22 FF 66       
2700   8D24 45 4F 46 0D 
2700   8D28 0A 
2700   8D29 00          
2701   8D2A D5          	RETURN
2702   8D2B             
2703   8D2B             ;   Here if the memory doesn't change - that could be because the .HEX
2704   8D2B             ; file attempted to load into EPROM or non-existent memory...
2705   8D2B F8 87       IHEX5:	OUTSTR(MERMSG)
2705   8D2D BF          
2705   8D2E F8 D2       
2705   8D30 AF          
2705   8D31 D4          
2705   8D32 FF 09       
2706   8D34 D5          	RETURN
2707   8D35             
2708   8D35             ;   And here if the record checksum doesn't add up.  Ideally we should just
2709   8D35             ; ignore this entire record, but unfortunatley we've already stuffed all or
2710   8D35             ; part of it into memory.  It's too late now!
TASM 1802 Assembler.              boots.asm                        page 93
BTS1802 -- Monitor for the COSMAC Elf 2000

2711   8D35 F8 8D       IHEX6:	OUTSTR(HCKMSG)
2711   8D37 BF          
2711   8D38 F8 3F       
2711   8D3A AF          
2711   8D3B D4          
2711   8D3C FF 09       
2712   8D3E D5          	RETURN
2713   8D3F             
2714   8D3F             ; HEX file parsing messages ...
2715   8D3F 3F 43 48 45 HCKMSG:	.TEXT	"?CHECKSUM MISMATCH\r\n\000"
2715   8D43 43 4B 53 55 
2715   8D47 4D 20 4D 49 
2715   8D4B 53 4D 41 54 
2715   8D4F 43 48 0D 0A 
2715   8D53 00 
2716   8D54 3F 55 4E 4B URCMSG:	.TEXT	"?UNKNOWN HEX RECORD TYPE\r\n\000"
2716   8D58 4E 4F 57 4E 
2716   8D5C 20 48 45 58 
2716   8D60 20 52 45 43 
2716   8D64 4F 52 44 20 
2716   8D68 54 59 50 45 
2716   8D6C 0D 0A 00 
2717   8D6F 3F 57 4F 55 OVMMSG:	.TEXT	"?WOULD OVERWRITE MONITOR\r\n\000"
2717   8D73 4C 44 20 4F 
2717   8D77 56 45 52 57 
2717   8D7B 52 49 54 45 
2717   8D7F 20 4D 4F 4E 
2717   8D83 49 54 4F 52 
2717   8D87 0D 0A 00 
2718   8D8A             
TASM 1802 Assembler.              boots.asm                        page 94
BTS1802 -- Monitor for the COSMAC Elf 2000

2719   8D8A             	.EJECT
2720   8D8A             ;	.SBTTL	Continue Execution after a Break Point
2721   8D8A             
2722   8D8A             ;   This routine handles the CONTINUE command which will attempt to restore
2723   8D8A             ; the original user's context at the time of a break point and continue exec-
2724   8D8A             ; ution at the next step.  It'll actually work (believe it or not!) provided
2725   8D8A             ; the user's program meets all the necessary restrictions: 1) the contents
2726   8D8A             ; of R0 and R1 are not restored, 2) interrupts are disabled, and 3) there
2727   8D8A             ; must be a valid stack pointer in R2...
2728   8D8A             CONTINUE:
2729   8D8A D4          	CALL(ISEOL)		; there are no arguments to this command
2729   8D8B 85 61       
2730   8D8D CB 85 68    	LBNF	CMDERR		; ...
2731   8D90~            #ifdef VIDEO
2732   8D90~            	CALL(NOCRTC)		; not allowed when the video card is active
2732   8D90~            	CALL(NOCRTC)		; not allowed when the video card is active
2733   8D90~            	LBDF	CONT0		;  ...
2734   8D90             #endif
2735   8D90 F8 8D       	RLDI(1,CONT1)		; use R1 as the PC from now on
2735   8D92 B1          
2735   8D93 F8 98       
2735   8D95 A1          
2736   8D96 D1          	SEP	1		; ...
2737   8D97 D5          CONT0:	RETURN			; here if error
2738   8D98             
2739   8D98             ; Here to restore the user's registers R2 thru RF...
2740   8D98 F8 7F       CONT1:	RLDI(0,REGS+4)		; point R0 at the saved registers
2740   8D9A B0          
2740   8D9B F8 85       
2740   8D9D A0          
2741   8D9E E0          	SEX	0		; use that as a stack pointer
2742   8D9F 72          	POPR(2)			; ...
2742   8DA0 B2          
2742   8DA1 72          
2742   8DA2 A2          
2743   8DA3 72          	POPR(3)			; ... 
2743   8DA4 B3          
2743   8DA5 72          
2743   8DA6 A3          
2744   8DA7 72          	POPR(4)			; ...
2744   8DA8 B4          
2744   8DA9 72          
2744   8DAA A4          
2745   8DAB 72          	POPR(5)			; ...
2745   8DAC B5          
2745   8DAD 72          
2745   8DAE A5          
2746   8DAF 72          	POPR(6)			; ...
2746   8DB0 B6          
2746   8DB1 72          
2746   8DB2 A6          
2747   8DB3 72          	POPR(7)			; ...
2747   8DB4 B7          
2747   8DB5 72          
2747   8DB6 A7          
2748   8DB7 72          	POPR(8)			; ...
2748   8DB8 B8          
2748   8DB9 72          
2748   8DBA A8          
TASM 1802 Assembler.              boots.asm                        page 95
BTS1802 -- Monitor for the COSMAC Elf 2000

2749   8DBB 72          	POPR(9)			; ...
2749   8DBC B9          
2749   8DBD 72          
2749   8DBE A9          
2750   8DBF 72          	POPR($A)		; ...
2750   8DC0 BA          
2750   8DC1 72          
2750   8DC2 AA          
2751   8DC3 72          	POPR($B)		; ...
2751   8DC4 BB          
2751   8DC5 72          
2751   8DC6 AB          
2752   8DC7 72          	POPR($C)		; ...
2752   8DC8 BC          
2752   8DC9 72          
2752   8DCA AC          
2753   8DCB 72          	POPR($D)		; ...
2753   8DCC BD          
2753   8DCD 72          
2753   8DCE AD          
2754   8DCF 72          	POPR($E)		; ...
2754   8DD0 BE          
2754   8DD1 72          
2754   8DD2 AE          
2755   8DD3 72          	POPR($F)		; ...
2755   8DD4 BF          
2755   8DD5 72          
2755   8DD6 AF          
2756   8DD7             
2757   8DD7             ;   Now recover (X,P), D and DF.  Unfortunately the only way to do this is to
2758   8DD7             ; temporarily push them on the user's stack first, which works so long as
2759   8DD7             ; R2 points to a valid stack...
2760   8DD7 F8 7F       	RLDI(0,SAVEXP)		; point R0 at (X,P), D and DF...
2760   8DD9 B0          
2760   8DDA F8 7E       
2760   8DDC A0          
2761   8DDD 72          	LDXA			; get (X,P)
2762   8DDE             ;  Note that the final instruction we execute, DIS (or RET - it doesn't matter)
2763   8DDE             ; is a little backwards in that it does M(R(X))->(X,P) FIRST, and then R(X)+1
2764   8DDE             ; second.  So we have to decrement the user's stack pointer first, which has
2765   8DDE             ; the effect of wasting a byte, so that in the end it comes out right.
2766   8DDE 22          	DEC	2		; and save them on the user's stack
2767   8DDF 52          	STR	2		; ...
2768   8DE0 72          	LDXA			; now load D from SAVED
2769   8DE1 22          	DEC	2		; and temporarily save that ...
2770   8DE2 52          	STR	2		; ... on the user's stack
2771   8DE3 72          	LDXA			; and finally load SAVEDF
2772   8DE4 76          	SHRC			; restore DF
2773   8DE5 E2          	SEX	2		; switch to the user's stack
2774   8DE6 72          	LDXA			; and restore D
2775   8DE7             
2776   8DE7             ;  The last instruction is a minor trick - we have to restore (X,P) from the
2777   8DE7             ; user's stack while at the same time leaving R1 (our current PC) pointing
2778   8DE7             ; to TRAP:.  The contents of R0 are never restored...
2779   8DE7             ;;RLA;;	RCLEAR(0)		; always clear R0 for Tiny BASIC
2780   8DE7 C0 8D EA    	LBR	TRAPX		; go restore (X,P)
2781   8DEA             
TASM 1802 Assembler.              boots.asm                        page 96
BTS1802 -- Monitor for the COSMAC Elf 2000

2782   8DEA             	.EJECT
2783   8DEA             ;	.SBTTL	Save User Context after Breakpoint
2784   8DEA             
2785   8DEA             ;   Whenever the monitor starts a user program running, it will initialize R1
2786   8DEA             ; with the address of this routine.  Provided that the user program does not 
2787   8DEA             ; use R1 or R0 for anything, a break point can be placed in the program with a
2788   8DEA             ; two byte sequence:
2789   8DEA             ;
2790   8DEA             ;	MARK	; $79
2791   8DEA             ;	SEP  R1	; $D1
2792   8DEA             ;
2793   8DEA             ; R1, as you may remember, normally points to an  interrupt service routine
2794   8DEA             ; and R0 is the DMA pointer.  This code will save all of the users registers,
2795   8DEA             ; except R0, R1, but it does mange to save X, P, D and DF...
2796   8DEA             
2797   8DEA             ;   The CONTINUE command (read on - it's coming up in a page or two!) branches
2798   8DEA             ; here as the final step in restoring the user's context.  This restores the
2799   8DEA             ; original X and P registers while leaving R1 pointing at TRAP: once again..
2800   8DEA 71          TRAPX:	DIS		; restore (X,P) and turn interrupts off
2801   8DEB             
2802   8DEB             ;   Save the current D and DF by assuming that there's a valid stack pointer
2803   8DEB             ; (and that it points to a valid stack!) in R(2)...  The MARK instruction
2804   8DEB             ; executed by the caller already pushed (X,P)...
2805   8DEB E2          TRAP:	SEX	2	; and assume there's a stack pointer in R(2)
2806   8DEC 73          	STXD		; save D assuming that the user has a valid stack
2807   8DED F8 00       	LDI	0	; put DF into the LSB of D
2808   8DEF 7E          	SHLC		; ...
2809   8DF0 52          	STR	2	; and then save that too
2810   8DF1             
2811   8DF1             ; Save registers R(F) thru R(2) in memory at REGS:...
2812   8DF1 F8 7F       	RLDI(R0,REGS+32-1)
2812   8DF3 B0          
2812   8DF4 F8 A0       
2812   8DF6 A0          
2813   8DF7 E0          	SEX	0
2814   8DF8 8F          	PUSHR($F)
2814   8DF9 73          
2814   8DFA 9F          
2814   8DFB 73          
2815   8DFC 8E          	PUSHR($E)
2815   8DFD 73          
2815   8DFE 9E          
2815   8DFF 73          
2816   8E00 8D          	PUSHR($D)
2816   8E01 73          
2816   8E02 9D          
2816   8E03 73          
2817   8E04 8C          	PUSHR($C)
2817   8E05 73          
2817   8E06 9C          
2817   8E07 73          
2818   8E08 8B          	PUSHR($B)
2818   8E09 73          
2818   8E0A 9B          
2818   8E0B 73          
2819   8E0C 8A          	PUSHR($A)
2819   8E0D 73          
2819   8E0E 9A          
2819   8E0F 73          
TASM 1802 Assembler.              boots.asm                        page 97
BTS1802 -- Monitor for the COSMAC Elf 2000

2820   8E10 89          	PUSHR(9)
2820   8E11 73          
2820   8E12 99          
2820   8E13 73          
2821   8E14 88          	PUSHR(8)
2821   8E15 73          
2821   8E16 98          
2821   8E17 73          
2822   8E18 87          	PUSHR(7)
2822   8E19 73          
2822   8E1A 97          
2822   8E1B 73          
2823   8E1C 86          	PUSHR(6)
2823   8E1D 73          
2823   8E1E 96          
2823   8E1F 73          
2824   8E20 85          	PUSHR(5)
2824   8E21 73          
2824   8E22 95          
2824   8E23 73          
2825   8E24 84          	PUSHR(4)
2825   8E25 73          
2825   8E26 94          
2825   8E27 73          
2826   8E28 83          	PUSHR(3)
2826   8E29 73          
2826   8E2A 93          
2826   8E2B 73          
2827   8E2C 82          	PUSHR(2)
2827   8E2D 73          
2827   8E2E 92          
2827   8E2F 73          
2828   8E30             
2829   8E30             ;   The next two registers, R1 and R0, don't really contain useful data but
2830   8E30             ; we need to skip over those before we can save D, DF and X...
2831   8E30 F8 00       	LDI	00
2832   8E32 73          	STXD\ STXD	; save R1 as all zeros
2832   8E33 73          
2833   8E34 73          	STXD\ STXD	; and save R0 as all zeros
2833   8E35 73          
2834   8E36             
2835   8E36             ; Recover DF, D and X from the user's stack and save them in our memory...
2836   8E36 02          	LDN	2	; get the DF
2837   8E37 73          	STXD		; store that at SAVEDF:
2838   8E38 12          	INC	2	; ..
2839   8E39 02          	LDN	2	; then get D
2840   8E3A 73          	STXD		; and store that at SAVED:
2841   8E3B 12          	INC	2	; and lastly get X
2842   8E3C 02          	LDN	2	; ...
2843   8E3D 73          	STXD		; and store it at SAVEXP:
2844   8E3E             
2845   8E3E             ;   Finally, update the value of register 2 that we saved so that it shows the
2846   8E3E             ; current (and correct) value, before we pushed three bytes onto the stack...
2847   8E3E F8 7F       	RLDI(R0,REGS+5)
2847   8E40 B0          
2847   8E41 F8 86       
2847   8E43 A0          
2848   8E44 82          	PUSHR(2)
2848   8E45 73          
TASM 1802 Assembler.              boots.asm                        page 98
BTS1802 -- Monitor for the COSMAC Elf 2000

2848   8E46 92          
2848   8E47 73          
2849   8E48             
2850   8E48             ;   We're all done saving stuff - now intialize enough of the real monitor
2851   8E48             ; context so that things will work (e.g. OUTCHR, THEX4, etc)...
2852   8E48 F8 7F       	RLDI(SP,STACK)		; initialize the stack
2852   8E4A B2          
2852   8E4B F8 77       
2852   8E4D A2          
2853   8E4E F8 8E       	RLDI(A,TRAP2)		; continue processing from TRAP2:
2853   8E50 B6          
2853   8E51 F8 57       
2853   8E53 A6          
2854   8E54 C0 FF 3F    	LBR	F_INITCALL	; and initialize the SCRT routines
2855   8E57             
2856   8E57             ;   We get here once all the context has been saved after a breakpoint.
2857   8E57             ; At this time the normal BOOTS context has been re-established and things
2858   8E57             ; should work pretty much as we expect.  Nwo we type out the user's registers
2859   8E57             ; (the same as the "SHOW REGISTERS" command) and then rejoin the main monitor
2860   8E57             ; loop...
2861   8E57 D4          TRAP2:	CALL(TTYINI)		; reset the terminal baud rate
2861   8E58 90 5D       
2862   8E5A D4          	CALL(SHORE1)		; print the registers 
2862   8E5B 8E 66       
2863   8E5D C0 84 C2    	LBR	MAIN		; and go print a monitor prompt
TASM 1802 Assembler.              boots.asm                        page 99
BTS1802 -- Monitor for the COSMAC Elf 2000

2864   8E60             	.EJECT
2865   8E60             ;	.SBTTL	Display the User Context after a Break
2866   8E60             
2867   8E60             ;   This routine will display the contents of the user's registers that were
2868   8E60             ; saved after the last break point.  It's used by the "SHOW REGISTERS" command,
2869   8E60             ; and also is called directly whenever a break point is encountered.
2870   8E60             
2871   8E60             ; Here for the "SHOW REGISTERS" command...
2872   8E60 D4          SHOREG:	CALL(ISEOL)		; should be the end of the line
2872   8E61 85 61       
2873   8E63 CB 85 68    	LBNF	CMDERR		; error if not
2874   8E66             ; Fall into SHORE1 ....
2875   8E66             
2876   8E66             ; Here to display the registers after a break point....
2877   8E66 F8 7F       SHORE1:	RLDI(DP,SAVEXP)		; point DP at the user's context info
2877   8E68 B7          
2877   8E69 F8 7E       
2877   8E6B A7          
2878   8E6C F8 8E       	OUTSTR(BPTMSG)		; print "BREAKPOINT ..."
2878   8E6E BF          
2878   8E6F F8 CF       
2878   8E71 AF          
2878   8E72 D4          
2878   8E73 FF 09       
2879   8E75             
2880   8E75             ; Print a couple of CRLFs and then display X, D and DF...
2881   8E75 D4          	INLMES(" @ XP=")	; ...
2881   8E76 FF 66       
2881   8E78 20 40 20 58 
2881   8E7C 50 3D 
2881   8E7E 00          
2882   8E7F E7          	SEX	DP		; get the value of (X,P)
2883   8E80 72          	LDXA			; ...
2884   8E81 D4          	CALL(THEX2)		; ...
2884   8E82 91 6D       
2885   8E84 D4          	INLMES(" D=")		; ...
2885   8E85 FF 66       
2885   8E87 20 44 3D    
2885   8E8A 00          
2886   8E8B E7          	SEX	DP		; now display D
2887   8E8C 72          	LDXA			; ...
2888   8E8D D4          	CALL(THEX2)		; that's easy
2888   8E8E 91 6D       
2889   8E90 D4          	INLMES(" DF=")		; ...
2889   8E91 FF 66       
2889   8E93 20 44 46 3D 
2889   8E97 00          
2890   8E98 E7          	SEX	DP		; and lastly get DF
2891   8E99 72          	LDXA			; it should be just one bit
2892   8E9A D4          	CALL(THEX1)		; but it's already positioned correctly
2892   8E9B 91 5E       
2893   8E9D D4          	CALL(TCRLF)		; finish that line
2893   8E9E 90 D5       
2894   8EA0             
2895   8EA0             ;   Print the registers R(0) thru R(F) (remembering, of course, that R0 and
2896   8EA0             ; R1 aren't really valid) on four lines, four registers per line...
2897   8EA0 F8 00       	LDI	0		; start counting the registers
2898   8EA2 AC          	PLO	P3		; here...
2899   8EA3 F8 52       TRAP2A:	OUTCHR('R')		; type "Rn="
TASM 1802 Assembler.              boots.asm                        page 100
BTS1802 -- Monitor for the COSMAC Elf 2000

2899   8EA5 D4          
2899   8EA6 FF 4E       
2900   8EA8 8C          	GLO	P3		; get the register number
2901   8EA9 D4          	CALL(THEX1)		; ...
2901   8EAA 91 5E       
2902   8EAC F8 3D       	OUTCHR('=')		; ...
2902   8EAE D4          
2902   8EAF FF 4E       
2903   8EB1 E7          	SEX	DP		; now load the register contents from REGS:
2904   8EB2 72          	LDXA			; high byte first
2905   8EB3 BF          	PHI	P1		; ...
2906   8EB4 72          	LDXA			; then low
2907   8EB5 AF          	PLO	P1		; ...
2908   8EB6 D4          	CALL(THEX4)		; type the value
2908   8EB7 91 7A       
2909   8EB9 D4          	CALL(TTABC)		; finish with a tab
2909   8EBA 90 E4       
2910   8EBC 1C          	INC	P3		; on to the next register
2911   8EBD 8C          	GLO	P3		; get the register number
2912   8EBE FA 03       	ANI	$3		; have we done a multiple of four?
2913   8EC0 CA 8E A3    	LBNZ	TRAP2A		; nope - keep going
2914   8EC3             
2915   8EC3             ; Here to end the line...
2916   8EC3 D4          	CALL(TCRLF)		; finish off this line
2916   8EC4 90 D5       
2917   8EC6 8C          	GLO	P3		; and get the register number again
2918   8EC7 FA 0F       	ANI	$F		; have we done all sixteen??
2919   8EC9 CA 8E A3    	LBNZ	TRAP2A		; nope - not yet
2920   8ECC C0 90 D5    	LBR	TCRLF		; yes - print another CRLF and return
2921   8ECF             
2922   8ECF             ; Messages...
2923   8ECF 0D 0A 42 52 BPTMSG:	.TEXT	"\r\nBREAKPOINT \000"
2923   8ED3 45 41 4B 50 
2923   8ED7 4F 49 4E 54 
2923   8EDB 20 00 
2924   8EDD             
TASM 1802 Assembler.              boots.asm                        page 101
BTS1802 -- Monitor for the COSMAC Elf 2000

2925   8EDD             	.EJECT
2926   8EDD             ;	.SBTTL	PIXIE Test Command
2927   8EDD             
2928   8EDD~            #ifdef PIXIE
2929   8EDD~            ;   The EF1 test ensures that the CDP1861 chip is isntalled and that it's
2930   8EDD~            ; counter chain is running at something like the correct rate.  Remember
2931   8EDD~            ; that the 1861 asserts EF1 at the end of every scan line, and this test
2932   8EDD~            ; works because the 1861 divider chain and the EF1 output continue to run
2933   8EDD~            ; all the time, regardless of whether the video or DMA is enabled or not.
2934   8EDD~            PIXTEST:CALL(ISEOL)		; there should be no more text
2934   8EDD~            PIXTEST:CALL(ISEOL)		; there should be no more text
2935   8EDD~            	LBNF	CMDERR		; ... after the command
2936   8EDD~            #ifdef VIDEO
2937   8EDD~            	CALL(NOCRTC)		; not allowed if the real video card is active
2937   8EDD~            	CALL(NOCRTC)		; not allowed if the real video card is active
2938   8EDD~            	BNF	PIXIE0		; Ok - go start
2939   8EDD~            	RETURN			; not OK - give up now
2940   8EDD~            #endif
2941   8EDD~            PIXIE0:	PIXIE_ON		; enable the display 
2941   8EDD~            PIXIE0:	PIXIE_ON		; enable the display 
2941   8EDD~            PIXIE0:	PIXIE_ON		; enable the display 
2941   8EDD~            PIXIE0:	PIXIE_ON		; enable the display 
2942   8EDD~            	INLMES("EF1 ... ")
2942   8EDD~            	INLMES("EF1 ... ")
2942   8EDD~            	INLMES("EF1 ... ")
2942   8EDD~            	INLMES("EF1 ... ")
2943   8EDD~            
2944   8EDD~            ;   Count the number of cycles in a complete period, low then high then
2945   8EDD~            ; low again, in EF1.  If the count overflows, then something's wrong...
2946   8EDD~            EF1T1:	RLDI(P1,$FFFF)		; initialize P1 to $FFFF
2946   8EDD~            EF1T1:	RLDI(P1,$FFFF)		; initialize P1 to $FFFF
2946   8EDD~            EF1T1:	RLDI(P1,$FFFF)		; initialize P1 to $FFFF
2946   8EDD~            EF1T1:	RLDI(P1,$FFFF)		; initialize P1 to $FFFF
2947   8EDD~            EF1T2:	B1	EF1T3		; wait for the positive edge on EF1
2948   8EDD~            	DEC	P1		; count down as we wait
2949   8EDD~            	GHI	P1		; have we waited too long?
2950   8EDD~            	BNZ	EF1T2		; nope - keep waiting
2951   8EDD~            	RLDI(P1,NO1861)		; no CDP1861 detected\r\n
2951   8EDD~            	RLDI(P1,NO1861)		; no CDP1861 detected\r\n
2951   8EDD~            	RLDI(P1,NO1861)		; no CDP1861 detected\r\n
2951   8EDD~            	RLDI(P1,NO1861)		; no CDP1861 detected\r\n
2952   8EDD~            	LBR	F_MSG		; just give up if there's no chip
2953   8EDD~            
2954   8EDD~            ; Count for a complete cycle (both high and low parts) of EF1...
2955   8EDD~            EF1T3:	RCLEAR(P1)		; found the rising edge - reset the counter
2955   8EDD~            EF1T3:	RCLEAR(P1)		; found the rising edge - reset the counter
2955   8EDD~            EF1T3:	RCLEAR(P1)		; found the rising edge - reset the counter
2956   8EDD~            EF1T4:	INC	P1		; count while we wait
2957   8EDD~            	B1	EF1T4		; and keep counting 'till the falling edge
2958   8EDD~            EF1T5:	INC	P1		; keep counting for the low part of EF1
2959   8EDD~            	BN1	EF1T5		; and keep counting 'till the rising edge
2960   8EDD~            
2961   8EDD~            ;   Empirically, this should give a count somewhere between 440 and 475 in
2962   8EDD~            ; P1.  Since the CDP8161 shares the same oscillator as the CPU, this count
2963   8EDD~            ; is independent of the crystal frequency and (sadly) can't be used to detect
2964   8EDD~            ; whether the wrong crystal is installed.
2965   8EDD~            	CALL(TDEC16)
2965   8EDD~            	CALL(TDEC16)
2966   8EDD~            	INLMES(" OK\r\n");
TASM 1802 Assembler.              boots.asm                        page 102
BTS1802 -- Monitor for the COSMAC Elf 2000

2966   8EDD~            	INLMES(" OK\r\n");
2966   8EDD~            	INLMES(" OK\r\n");
2966   8EDD~            	INLMES(" OK\r\n");
2967   8EDD~            	OUTSTR(VIDMSG)
2967   8EDD~            	OUTSTR(VIDMSG)
2967   8EDD~            	OUTSTR(VIDMSG)
2967   8EDD~            	OUTSTR(VIDMSG)
2967   8EDD~            	OUTSTR(VIDMSG)
2967   8EDD~            	OUTSTR(VIDMSG)
2968   8EDD~            
2969   8EDD~            ; For the "special" CHM mode startup, we jump here directly from SYSINI.
2970   8EDD~            PIXCHM:	RLDI(INTPC,INT1PG)	; ISR -> 64x32 video interrupt service routine
2970   8EDD~            PIXCHM:	RLDI(INTPC,INT1PG)	; ISR -> 64x32 video interrupt service routine
2970   8EDD~            PIXCHM:	RLDI(INTPC,INT1PG)	; ISR -> 64x32 video interrupt service routine
2970   8EDD~            PIXCHM:	RLDI(INTPC,INT1PG)	; ISR -> 64x32 video interrupt service routine
2971   8EDD~            	RLDI(P1,NCC1701)	; P1 -> bitmap to display
2971   8EDD~            	RLDI(P1,NCC1701)	; P1 -> bitmap to display
2971   8EDD~            	RLDI(P1,NCC1701)	; P1 -> bitmap to display
2971   8EDD~            	RLDI(P1,NCC1701)	; P1 -> bitmap to display
2972   8EDD~            ;	RLDI(P1,INT1RT)
2973   8EDD~            
2974   8EDD~            ; Turn on the display and hold your breath!!!
2975   8EDD~            	INT_ON			; interrupts on
2975   8EDD~            	INT_ON			; interrupts on
2975   8EDD~            	INT_ON			; interrupts on
2976   8EDD~            	PIXIE_ON		; and enable the display
2976   8EDD~            	PIXIE_ON		; and enable the display
2976   8EDD~            	PIXIE_ON		; and enable the display
2976   8EDD~            	PIXIE_ON		; and enable the display
2977   8EDD~            PIXIE1:	;CALL(F_BRKTEST)	; check for a break on the console
2978   8EDD~            	;BDF	PIXIE2		; yes - quit now
2979   8EDD~            	BN4	PIXIE1		; or break when INPUT is pressed
2980   8EDD~            PIXIE2:	PIXIE_OFF		; turn the display off
2980   8EDD~            PIXIE2:	PIXIE_OFF		; turn the display off
2980   8EDD~            PIXIE2:	PIXIE_OFF		; turn the display off
2981   8EDD~            	INT_OFF			; now disable interrupts again
2981   8EDD~            	INT_OFF			; now disable interrupts again
2981   8EDD~            	INT_OFF			; now disable interrupts again
2982   8EDD~            	LBR	TCRLF		; finish the line and back to the monitor
2983   8EDD~            
2984   8EDD~            ; Messages...
2985   8EDD~            NO1861:	.TEXT	"?NO CDP1861 DETECTED\r\n\000"
2986   8EDD~            VIDMSG:	.TEXT	"The COSMAC Elf Enterprise - Joeseph Weisbecker P-E 1976\r\n"
2987   8EDD~            	.TEXT	"[Toggle INPUT to end]\000"
2988   8EDD             #endif
2989   8EDD             
TASM 1802 Assembler.              boots.asm                        page 103
BTS1802 -- Monitor for the COSMAC Elf 2000

2990   8EDD             	.EJECT
2991   8EDD             ;	.SBTTL	Video (CDP1861) Interrupt Service routines
2992   8EDD             
2993   8EDD~            #ifdef PIXIE
2994   8EDD~            ;   This is the classic CDP1861 interrupt service routine for 64x32 resolution
2995   8EDD~            ; displays, stolen right out of the CDP1861 data sheet.  Yes, that's 64 pixels
2996   8EDD~            ; by 32 pixels, for a whopping total of 256 bytes (1 page!) of display memory.
2997   8EDD~            ; The background code must keep a display buffer pointer in P1 while this code
2998   8EDD~            ; is active - at the start of every new frame it will re-initialize the DMA
2999   8EDD~            ; register (R0) from P1.  Of course, nothing prevents the background code from
3000   8EDD~            ; changing P1 betwen frames; this allows for scrolling or animation effects.
3001   8EDD~            INT1RT:	LDXA			; restore the D register from the stack
3002   8EDD~            	RET			; and return from the interrupt
3003   8EDD~            				;  ... while leaving R1 pointing to INT1PG!
3004   8EDD~            ;   A reasonable person might ask how this works - in principle it's very easy;
3005   8EDD~            ; we simply repeat each scan line (consisting of 64 pixels or 8 bytes) a total
3006   8EDD~            ; of four times, thus reducing the native 1861 vertical resolution from 128 to
3007   8EDD~            ; 32 lines.  The puzzling thing is that there's no flag or other test to find
3008   8EDD~            ; the start of a scan line - the code simply "knows" when it happens.  This
3009   8EDD~            ; works because the 1861 clock is locked to the 1802's and every scan line
3010   8EDD~            ; simply locks out the processor completely (i.e. no 1802 instructions get
3011   8EDD~            ; executed!) while the 1861 uses DMA to fetch 8 bytes.  By very carefully count-
3012   8EDD~            ; int cycles, this code always stays synchronized with the 1861.
3013   8EDD~            INT1PG:	NOP			; correct for the S3 (interrupt ACK) timing
3014   8EDD~            	DEC	SP		; make a space on the stack
3015   8EDD~            	SAV			; and push T (the saved X,P)
3016   8EDD~            	DEC	SP		; make another spot
3017   8EDD~            	STR	SP		; and now save the D register too
3018   8EDD~            	RCOPY(DMAPTR,P1)	; copy R0 <= P1
3018   8EDD~            	RCOPY(DMAPTR,P1)	; copy R0 <= P1
3018   8EDD~            	RCOPY(DMAPTR,P1)	; copy R0 <= P1
3018   8EDD~            	RCOPY(DMAPTR,P1)	; copy R0 <= P1
3019   8EDD~            	NOP\ NOP		; correct the timing
3019   8EDD~            	NOP\ NOP		; correct the timing
3020   8EDD~            DSP1PG:	SEX	SP		; two cycle delay (NOP is 3 cycles!)
3021   8EDD~            	GLO	DMAPTR		; save start of line address in D
3022   8EDD~            	SEX	SP		; (the 1861 DMAs 8 bytes now!!!)
3023   8EDD~            	DEC	DMAPTR		; reset R0.1 if we passed a page
3024   8EDD~            	PLO	DMAPTR		; and reset R0.0
3025   8EDD~            	SEX	SP		; do it all over again
3026   8EDD~            	DEC	DMAPTR		; ...
3027   8EDD~            	PLO	DMAPTR		; ...
3028   8EDD~            	SEX	SP		; and one more time!
3029   8EDD~            	DEC	DMAPTR		; ...
3030   8EDD~            	PLO	DMAPTR		; ...
3031   8EDD~            	BN1	DSP1PG		; keep going until the end of frame
3032   8EDD~            ;   At the end of each frame (when the timing is no longer critical!)
3033   8EDD~            ; increment the vertical retrace counter (CRTC) in the monitor's data
3034   8EDD~            ; page.  This can be used to count frames and keep track of the time
3035   8EDD~            ; of day, and it also serves as a simple "video running" test.  Note
3036   8EDD~            ; that since the 1861 is done for a while, it's safe to use DMAPTR to
3037   8EDD~            ; address memory.  This saves the need to store another register on
3038   8EDD~            ; the stack!  Sadly, there's no way to increment the byte without also
3039   8EDD~            ; trashing DF, which isn't cool, so we have to save and restore that bit
3040   8EDD~            ; too...
3041   8EDD~            ;	SHLC			; DF -> LSB of D
3042   8EDD~            ;	DEC	SP		; stack DF too
3043   8EDD~            ;	STR	SP		; ...
3044   8EDD~            ;	RLDI(DMAPTR,VRTC)	; point to the vertical retrace counter
TASM 1802 Assembler.              boots.asm                        page 104
BTS1802 -- Monitor for the COSMAC Elf 2000

3045   8EDD~            ;	LDA	DMAPTR		; get the current value
3046   8EDD~            ;	DEC	DMAPTR
3047   8EDD~            ;	SMI	59		; have we done sixty frames?
3048   8EDD~            ;	BNF	INT2		; store zero if yes
3049   8EDD~            ;	ADI	59+1		; restore and increment the count
3050   8EDD~            ;INT2:	STR	DMAPTR		; put the count back in memory
3051   8EDD~            ;	LDXA			; retrieve DF from the stack
3052   8EDD~            ;	SHRC			; and restore it
3053   8EDD~            	BR	INT1RT		; and return when the frame is finished
3054   8EDD             #endif
3055   8EDD             
TASM 1802 Assembler.              boots.asm                        page 105
BTS1802 -- Monitor for the COSMAC Elf 2000

3056   8EDD             	.EJECT
3057   8EDD             ;	.SBTTL	Help Command
3058   8EDD             
3059   8EDD             ;   The HELP command prints a canned help file, which is stored in EPROM in
3060   8EDD             ; plain ASCII.  If the current console is a VT1802, then we do some extra
3061   8EDD             ; work to paginate the output in the style of the Un*x "more" command - this
3062   8EDD             ; prevents the good stuff from scrolling off the top of the screen before
3063   8EDD             ; you can see it!
3064   8EDD D4          PHELP:	CALL(ISEOL)		; HELP has no arguments
3064   8EDE 85 61       
3065   8EE0 CB 85 68    	LBNF	CMDERR		; error if it does
3066   8EE3~            #ifdef VIDEO
3067   8EE3~            	CALL(ISCRTC)		; is the VT1802 in use ??
3067   8EE3~            	CALL(ISCRTC)		; is the VT1802 in use ??
3068   8EE3~            	LBDF	PHELP0		; branch if so
3069   8EE3             #endif
3070   8EE3 F8 94       	RLDI(P1,HELP)		; nope - just print the whole text
3070   8EE5 BF          
3070   8EE6 F8 00       
3070   8EE8 AF          
3071   8EE9 C0 FF 09    	LBR	F_MSG		; ... print it and return
3072   8EEC             
3073   8EEC~            #ifdef VIDEO
3074   8EEC~            ;  We get here if the VT1802 video terminal is in use as the console.
3075   8EEC~            PHELP0:	RLDI(P2,HELP)		; point to the help text
3075   8EEC~            PHELP0:	RLDI(P2,HELP)		; point to the help text
3075   8EEC~            PHELP0:	RLDI(P2,HELP)		; point to the help text
3075   8EEC~            PHELP0:	RLDI(P2,HELP)		; point to the help text
3076   8EEC~            PHELP1:	LDI	0		; keep count of the number of lines
3077   8EEC~            	PLO	P3		;  ... here ...
3078   8EEC~            PHELP2:	LDA	P2		; get a byte from the message
3079   8EEC~            	LBZ	PHELP9		; quit at the end of the string
3080   8EEC~            	CALL(F_TTY)		; type it out
3080   8EEC~            	CALL(F_TTY)		; type it out
3081   8EEC~            	XRI	CHLFD		; was it a line feed?
3082   8EEC~            	BNZ	PHELP2		; nope - nothing special
3083   8EEC~            
3084   8EEC~            ; Count the lines ...
3085   8EEC~            	INC	P3		; count the lines
3086   8EEC~            	GLO	P3		; ...
3087   8EEC~            	SMI	23		; have we done a full screen?
3088   8EEC~            	BL	PHELP2		; nope - keep going just the same
3089   8EEC~            
3090   8EEC~            ; We've done a full screen - say MORE and wait for input...
3091   8EEC~            	OUTSTR(MORMSG)		; "--More--"
3091   8EEC~            	OUTSTR(MORMSG)		; "--More--"
3091   8EEC~            	OUTSTR(MORMSG)		; "--More--"
3091   8EEC~            	OUTSTR(MORMSG)		; "--More--"
3091   8EEC~            	OUTSTR(MORMSG)		; "--More--"
3091   8EEC~            	OUTSTR(MORMSG)		; "--More--"
3092   8EEC~            	CALL(F_READ)		; wait for input
3092   8EEC~            	CALL(F_READ)		; wait for input
3093   8EEC~            	XRI	CHCTC		; is it a Control-C ??
3094   8EEC~            	LBZ	PHELP9		; yes - just quit now
3095   8EEC~            	OUTSTR(EELMSG)		; nope - erase the More message
3095   8EEC~            	OUTSTR(EELMSG)		; nope - erase the More message
3095   8EEC~            	OUTSTR(EELMSG)		; nope - erase the More message
3095   8EEC~            	OUTSTR(EELMSG)		; nope - erase the More message
3095   8EEC~            	OUTSTR(EELMSG)		; nope - erase the More message
TASM 1802 Assembler.              boots.asm                        page 106
BTS1802 -- Monitor for the COSMAC Elf 2000

3095   8EEC~            	OUTSTR(EELMSG)		; nope - erase the More message
3096   8EEC~            	LBR	PHELP1		; and keep typing
3097   8EEC~            
3098   8EEC~            ; Here when we're done...
3099   8EEC~            PHELP9:	OUTSTR(EELMSG)
3099   8EEC~            PHELP9:	OUTSTR(EELMSG)
3099   8EEC~            PHELP9:	OUTSTR(EELMSG)
3099   8EEC~            PHELP9:	OUTSTR(EELMSG)
3099   8EEC~            PHELP9:	OUTSTR(EELMSG)
3099   8EEC~            PHELP9:	OUTSTR(EELMSG)
3100   8EEC~            	RETURN
3101   8EEC~            
3102   8EEC~            ; Messages...
3103   8EEC~            MORMSG:	.TEXT	"          \033N@\015\033NP--More--\000"
3104   8EEC~            EELMSG:	.TEXT	"\015\033K\000"
3105   8EEC             #endif
3106   8EEC~            #ifndef HELP
3107   8EEC~            HELP:	.TEXT	"?NO HELP\000"
3108   8EEC             #endif
3109   8EEC             
TASM 1802 Assembler.              boots.asm                        page 107
BTS1802 -- Monitor for the COSMAC Elf 2000

3110   8EEC             	.EJECT
3111   8EEC             ;	.SBTTL	Clear Screen Command
3112   8EEC             
3113   8EEC             ;  This little command clears the screen on the VT1802.  All it really
3114   8EEC             ; has to do is to send the right escape sequence to the VT1802 firmware -
3115   8EEC             ; all the rest is just a matter of parsing the command line...
3116   8EEC~            #ifdef VIDEO
3117   8EEC~            CLSCMD:	CALL(ISEOL)		; no arguments allowed
3117   8EEC~            CLSCMD:	CALL(ISEOL)		; no arguments allowed
3118   8EEC~            	LBNF	CMDERR		; quit if it's wrong
3119   8EEC~            	CALL(ISCRTC)		; and the VT1802 has to be in use
3119   8EEC~            	CALL(ISCRTC)		; and the VT1802 has to be in use
3120   8EEC~            	LBNF	CMDERR		; just ignore it if not
3121   8EEC~            	OUTSTR(CLSMSG)		; the rest is easy
3121   8EEC~            	OUTSTR(CLSMSG)		; the rest is easy
3121   8EEC~            	OUTSTR(CLSMSG)		; the rest is easy
3121   8EEC~            	OUTSTR(CLSMSG)		; the rest is easy
3121   8EEC~            	OUTSTR(CLSMSG)		; the rest is easy
3121   8EEC~            	OUTSTR(CLSMSG)		; the rest is easy
3122   8EEC~            	RETURN			; ...
3123   8EEC             #else
3124   8EEC             CLSCMD0:
3125   8EEC D4          	CALL(ISEOL)
3125   8EED 85 61       
3126   8EEF CB 85 68    	LBNF CMDERR
3127   8EF2 D4          	CALL(F_INMSG)
3127   8EF3 FF 66       
3128   8EF5 1B          	.DB $1B
3129   8EF6 5B 32 4A    	.TEXT "[2J"
3130   8EF9 1B          	.DB $1B
3131   8EFA 5B 48       	.TEXT "[H"
3132   8EFC 00          	.DB 0
3133   8EFD D5          	RETURN
3134   8EFE             #endif
3135   8EFE             
TASM 1802 Assembler.              boots.asm                        page 108
BTS1802 -- Monitor for the COSMAC Elf 2000

3136   8EFE             	.EJECT
3137   8EFE             ;	.SBTTL	Exhaustive Memory Test
3138   8EFE             
3139   8EFE             ;   This routine will perform an exhaustive test on memory using the "Knaizuk
3140   8EFE             ; and Hartmann" algorithm (Proceedings of the IEEE April 1977).  This algorithm
3141   8EFE             ; first fills memory with all ones ($FF bytes) and then writes a byte of zeros
3142   8EFE             ; to every third location.  These values are read back and tested for errors,
3143   8EFE             ; and then the procedure is repeated twice more, changing the positon of the
3144   8EFE             ; 00 bytes each time.  After that, the entire algorithm is repeated three
3145   8EFE             ; more times, this time using a memory fill of $00 and every third byte is
3146   8EFE             ; written with $FF.  Strange as it may seem, this test can actually detect
3147   8EFE             ; any combination of stuck data and/or stuck address bits.  Each pass (six
3148   8EFE             ; iterations) requires about 30 seconds for 32K RAM on a 1.7Mhz CDP1802.
3149   8EFE             ;
3150   8EFE             ; Register usage:
3151   8EFE             ;	P2   = memory address
3152   8EFE             ;	P3.1 = filler byte
3153   8EFE             ;	P3.0 = test byte
3154   8EFE             ;	P4.0 = modulo 3 counter (current)
3155   8EFE             ;	P4.1 = iteration number (modulo 3 counter for this pass)
3156   8EFE             ;
3157   8EFE             ; NOTE
3158   8EFE             ;   The memory test assumes that the monitor's data page occupies the top 256
3159   8EFE             ; bytes of memory and it tests all memory from $0000 to RAMPAGE-1.
3160   8EFE             
3161   8EFE             ; RAM test messages...
3162   8EFE 54 65 73 74 RTSMSG:	.TEXT	"Testing RAM \000"
3162   8F02 69 6E 67 20 
3162   8F06 52 41 4D 20 
3162   8F0A 00 
3163   8F0B 0D 0A 3F 52 REAMSG:	.TEXT	"\r\n?RAM ERROR AT \000"
3163   8F0F 41 4D 20 45 
3163   8F13 52 52 4F 52 
3163   8F17 20 41 54 20 
3163   8F1B 00 
3164   8F1C             
3165   8F1C             ; Start the memory test ...
3166   8F1C D4          RAMTEST:CALL(ISEOL)		; there should be no more text
3166   8F1D 85 61       
3167   8F1F CB 85 68    	LBNF	CMDERR		; ... after the command		
3168   8F22 D4          	CALL(CLRPEK)		; clear PASSK and ERRORK
3168   8F23 8F D7       
3169   8F25             
3170   8F25             ;   It's not safe to test the monitor's RAM page, nor is it a good idea to
3171   8F25             ; scribble over the frame buffer if the video card is active.  Compute the
3172   8F25             ; top of RAM as either RAMPAGE or SCREEN and push it onto the stack...
3173   8F25~            #ifdef VIDEO
3174   8F25~            	CALL(ISCRTC)		; is the video card active?
3174   8F25~            	CALL(ISCRTC)		; is the video card active?
3175   8F25~            	BDF	RAMTE0		; yes - test only up to SCREEN
3176   8F25             #endif
3177   8F25 F8 7F       	LDI	HIGH(RAMPAGE)	; nope - test all the way up to RAMPAGE
3178   8F27~            #ifdef VIDEO
3179   8F27~            	BR	RAMTE1		; ...
3180   8F27~            RAMTE0:	LDI	HIGH(SCREEN)	; put the memory size on the stack
3181   8F27             #endif
3182   8F27 73          RAMTE1:	STXD			; ...
3183   8F28 D4          	CALL(PRTSBM)		; print the memory size 
3183   8F29 90 1D       
TASM 1802 Assembler.              boots.asm                        page 109
BTS1802 -- Monitor for the COSMAC Elf 2000

3184   8F2B             				;  ... and "press BREAK to abort"
3185   8F2B             
3186   8F2B             ; Here to start another complete pass (six iterations per pass)...
3187   8F2B F8 8E       RAMT0:	OUTSTR(RTSMSG)		; "Testing RAM "
3187   8F2D BF          
3187   8F2E F8 FE       
3187   8F30 AF          
3187   8F31 D4          
3187   8F32 FF 09       
3188   8F34 F8 FF       	RLDI(P3,$FF00)		; load the first test pattern
3188   8F36 BC          
3188   8F37 F8 00       
3188   8F39 AC          
3189   8F3A F8 02       RAMT0A:	LDI	2		; initialize the modulo 3 counter
3190   8F3C BB          	PHI	P4		; ...
3191   8F3D             
3192   8F3D             ; Loop 1 - fill memory with the filler byte...
3193   8F3D E2          RAMT1:	SEX	SP		; point at the stack
3194   8F3E 60          	IRX			; point to the memory size on the TOS
3195   8F3F F0          	LDX			; get that
3196   8F40 FF 01       	SMI	1		; minus 1
3197   8F42 BD          	PHI	P2		; and point P2 at the top of memory
3198   8F43 22          	DEC	SP		; protect the TOS
3199   8F44 F8 FF       	LDI	$FF		; and the low byte is always FF
3200   8F46 AD          	PLO	P2		; ...
3201   8F47 9C          RAMT1A:	GHI	P3		; get the filler byte
3202   8F48 ED          	SEX	P2		; and use P2 to address memory
3203   8F49 73          	STXD			; and store it
3204   8F4A 9D          	GHI	P2		; check the high address byte
3205   8F4B FA 80       	ANI	$80		; have we rolled over from $0000 to $FFFF?
3206   8F4D C2 8F 47    	LBZ	RAMT1A		; nope - keep filling
3207   8F50 D4          	CALL(F_BRKTEST)		; does the user want to stop now?
3207   8F51 FF 6C       
3208   8F53 C3 84 C2    	LBDF	MAIN		; yes - quit now
3209   8F56             
3210   8F56             ; Loop 2 - fill every third byte with the test byte...
3211   8F56 F8 00       RAMT2:	RCLEAR(P2)		; this time start at $0000
3211   8F58 BD          
3211   8F59 AD          
3212   8F5A 9B          	GHI	P4		; reset the modulo 3 counter
3213   8F5B AB          	PLO	P4		; ...
3214   8F5C 8B          RAMT2A:	GLO	P4		; get the modulo 3 counter
3215   8F5D CA 8F 65    	LBNZ	RAMT2B		; branch if not the third iteration
3216   8F60 8C          	GLO	P3		; third byte - get the test byte
3217   8F61 5D          	STR	P2		; and store it in memory
3218   8F62 F8 03       	LDI	3		; then re-initialize the modulo 3 counter
3219   8F64 AB          	PLO	P4		; ...
3220   8F65 2B          RAMT2B:	DEC	P4		; decremement the modulo 3 counter
3221   8F66 1D          	INC	P2		; and increment the address
3222   8F67 9D          	GHI	P2		; get the high address byte
3223   8F68 E2          	SEX	SP		; point at the stack
3224   8F69 60          	IRX			; point to the memory size on the TOS
3225   8F6A F3          	XOR			; are they equal?
3226   8F6B 22          	DEC	SP		; (protect the TOS)
3227   8F6C CA 8F 5C    	LBNZ	RAMT2A		; nope - keep going
3228   8F6F D4          	CALL(F_BRKTEST)		; does the user want to stop now?
3228   8F70 FF 6C       
3229   8F72 C3 84 C2    	LBDF	MAIN		; yes - quit now
3230   8F75             
TASM 1802 Assembler.              boots.asm                        page 110
BTS1802 -- Monitor for the COSMAC Elf 2000

3231   8F75             ; Loop 3 - nearly the same as Loop2, except this time we test the bytes...
3232   8F75 F8 00       RAMT3:	RCLEAR(P2)		; start at $0000
3232   8F77 BD          
3232   8F78 AD          
3233   8F79 9B          	GHI	P4		; reset the modulo 3 counter
3234   8F7A AB          	PLO	P4		; ...
3235   8F7B 8B          RAMT3A:	GLO	P4		; get the modulo 3 counter
3236   8F7C CA 8F 84    	LBNZ	RAMT3B		; branch if not the third iteration
3237   8F7F F8 03       	LDI	3		; re-initialize the modulo 3 counter
3238   8F81 AB          	PLO	P4		; ...
3239   8F82 8C          	GLO	P3		; and get the test byte
3240   8F83 38          	SKP			; ...
3241   8F84 9C          RAMT3B:	GHI	P3		; not third byte - test against fill byte
3242   8F85 ED          	SEX	P2		; address memory with P2
3243   8F86 F3          	XOR			; does this byte match??
3244   8F87 C2 8F A0    	LBZ	RAMT3C		; branch if success
3245   8F8A             
3246   8F8A             ; Here if a test fails...
3247   8F8A F8 8F       	OUTSTR(REAMSG)
3247   8F8C BF          
3247   8F8D F8 0B       
3247   8F8F AF          
3247   8F90 D4          
3247   8F91 FF 09       
3248   8F93 9D          	RCOPY(P1,P2)
3248   8F94 BF          
3248   8F95 8D          
3248   8F96 AF          
3249   8F97 D4          	CALL(THEX4)
3249   8F98 91 7A       
3250   8F9A D4          	CALL(TCRLF)
3250   8F9B 90 D5       
3251   8F9D D4          	CALL(INERRK)
3251   8F9E 8F E5       
3252   8FA0             
3253   8FA0             ; Here if the test passes - on to the next location...
3254   8FA0 2B          RAMT3C:	DEC	P4		; decremement the modulo 3 counter
3255   8FA1 1D          	INC	P2		; and increment the address
3256   8FA2 9D          	GHI	P2		; get the high address byte
3257   8FA3 E2          	SEX	SP		; address the stack
3258   8FA4 60          	IRX			; point to the memory size on the TOS
3259   8FA5 F3          	XOR			; are they equal??
3260   8FA6 22          	DEC	SP		; (protect the TOS)
3261   8FA7 CA 8F 7B    	LBNZ	RAMT3A		; nope - keep going
3262   8FAA D4          	CALL(F_BRKTEST)		; does the user want to stop now?
3262   8FAB FF 6C       
3263   8FAD C3 84 C2    	LBDF	MAIN		; yes - quit now
3264   8FB0             
3265   8FB0             ; This pass is completed - move the position of the test byte and repeat...
3266   8FB0 F8 2E       	OUTCHR('.')
3266   8FB2 D4          
3266   8FB3 FF 4E       
3267   8FB5 9B          	GHI	P4		; get the current modulo counter
3268   8FB6 FF 01       	SMI	1		; decrement it
3269   8FB8 3B BE       	BL	RAMT4		; branch if we've done three passes
3270   8FBA BB          	PHI	P4		; nope - try it again
3271   8FBB C0 8F 3D    	LBR	RAMT1		; and do another pass
3272   8FBE             
3273   8FBE             ;   We've done three passes with this test pattern.  Swap the filler and
TASM 1802 Assembler.              boots.asm                        page 111
BTS1802 -- Monitor for the COSMAC Elf 2000

3274   8FBE             ; test bytes and repeat...
3275   8FBE 8C          RAMT4:	GLO	P3		; is the test byte $00??
3276   8FBF CA 8F CB    	LBNZ	RAMT5		; nope - we've been here before
3277   8FC2 F8 00       	RLDI(P3,$00FF)		; yes - use 00 as the fill and FF as the test
3277   8FC4 BC          
3277   8FC5 F8 FF       
3277   8FC7 AC          
3278   8FC8 C0 8F 3A    	LBR	RAMT0A		; reset the modulo counter and test again
3279   8FCB             
3280   8FCB             ; One complete test (six passes total) are completed..
3281   8FCB D4          RAMT5:	CALL(INPASK)		; increment PASSK
3281   8FCC 8F E2       
3282   8FCE D4          	CALL(PRTPEK)		; print the pass/error count
3282   8FCF 8F F2       
3283   8FD1 D4          	CALL(TCRLF)		; finish the line
3283   8FD2 90 D5       
3284   8FD4 C0 8F 2B    	LBR	RAMT0		; and go start another pass
3285   8FD7             
TASM 1802 Assembler.              boots.asm                        page 112
BTS1802 -- Monitor for the COSMAC Elf 2000

3286   8FD7             	.EJECT
3287   8FD7             ;	.SBTTL	Diagnostic Support Routines
3288   8FD7             
3289   8FD7             ; We assume these two items are in order!
3290   8FD7~            #if ((ERRORK-PASSK) != 2)
3291   8FD7~            	.ECHO	"**** ERROR **** PASSK/ERRORK out of order!"
3292   8FD7             #endif
3293   8FD7             
3294   8FD7             ;   This little routine will clear the current diagnostic pass and error
3295   8FD7             ; counts (PASSK: and ERRORK:).  It's called at the start of most diagnostics.
3296   8FD7 F8 B1       CLRPEK:	LDI	LOW(PASSK+3)	; PASSK is first, then ERRORK
3297   8FD9 A7          	PLO	DP		; ...
3298   8FDA E7          	SEX	DP		; ...
3299   8FDB F8 00       	LDI	0		; ...
3300   8FDD 73          	STXD\ STXD		; clear ERRORK
3300   8FDE 73          
3301   8FDF 73          	STXD\ STXD		; and clear PASSK
3301   8FE0 73          
3302   8FE1 D5          	RETURN			; all done
3303   8FE2             
3304   8FE2             ; Incrememnt the current diagnostic pass counter...
3305   8FE2 F8 AF       INPASK:	LDI	LOW(PASSK+1)	; point to the LSB first
3306   8FE4 C8          	LSKP			; and fall into INERRK...
3307   8FE5             
3308   8FE5             ; Increment the current diagnostic error counter...
3309   8FE5 F8 B1       INERRK:	LDI	LOW(ERRORK+1)	; point to ERRORK this time
3310   8FE7 A7          	PLO	DP		; ...
3311   8FE8 E7          	SEX	DP		; ...
3312   8FE9 F0          	LDX			; get the lest significant byte
3313   8FEA FC 01       	ADI	1		; increment it
3314   8FEC 73          	STXD			; and put it back
3315   8FED F0          	LDX			; now get the high byte
3316   8FEE 7C 00       	ADCI	0		; include the carry (if any)
3317   8FF0 57          	STR	DP		; put it back
3318   8FF1 D5          	RETURN			; and we're done
3319   8FF2             
3320   8FF2             ; Print the current diagnostic pass and error count...
3321   8FF2 D4          PRTPEK:	INLMES(" Pass ")
3321   8FF3 FF 66       
3321   8FF5 20 50 61 73 
3321   8FF9 73 20 
3321   8FFB 00          
3322   8FFC F8 AE       	LDI	LOW(PASSK)	; point DP at the pass counter
3323   8FFE A7          	PLO	DP		; ...
3324   8FFF E7          	SEX	DP		; and use DP to address memory
3325   9000 72          	POPR(P1)		; load PASSK into P1
3325   9001 BF          
3325   9002 72          
3325   9003 AF          
3326   9004 27          	DEC	DP		; point at the low byte again
3327   9005 64          	OUT	LEDS		; display the pass count on the LEDs
3328   9006 D4          	CALL(TDEC16)		; print the pass count in decimal
3328   9007 91 82       
3329   9009 D4          	INLMES(" Errors ")	; ...
3329   900A FF 66       
3329   900C 20 45 72 72 
3329   9010 6F 72 73 20 
3329   9014 00          
3330   9015 E7          	SEX	DP		; (SCRT changes X!)
TASM 1802 Assembler.              boots.asm                        page 113
BTS1802 -- Monitor for the COSMAC Elf 2000

3331   9016 72          	POPR(P1)		; and now get ERRORK
3331   9017 BF          
3331   9018 72          
3331   9019 AF          
3332   901A C0 91 82    	LBR	TDEC16		; print that and return
3333   901D             
3334   901D             ; Print memory size and break message...
3335   901D 73          PRTSBM:	PUSHD			; save the upper byte of the size
3336   901E D4          	INLMES("Testing ")
3336   901F FF 66       
3336   9021 54 65 73 74 
3336   9025 69 6E 67 20 
3336   9029 00          
3337   902A 60          	POPD			; and get the number of pages back
3337   902B F0          
3338   902C BF          	PHI	P1		; into P1
3339   902D F8 00       	LDI	0		; the bottom byte is always zero
3340   902F AF          	PLO	P1		; ...
3341   9030 D4          	CALL(TDEC16)		; type the memory size
3341   9031 91 82       
3342   9033 F8 90       	OUTSTR(RTMSG1)
3342   9035 BF          
3342   9036 F8 3F       
3342   9038 AF          
3342   9039 D4          
3342   903A FF 09       
3343   903C C0 90 D5    	LBR	TCRLF
3344   903F             
3345   903F             ; Messages (some) ...
3346   903F 20 62 79 74 RTMSG1:	.TEXT	" bytes - press BREAK to abort\000"
3346   9043 65 73 20 2D 
3346   9047 20 70 72 65 
3346   904B 73 73 20 42 
3346   904F 52 45 41 4B 
3346   9053 20 74 6F 20 
3346   9057 61 62 6F 72 
3346   905B 74 00 
3347   905D             
TASM 1802 Assembler.              boots.asm                        page 114
BTS1802 -- Monitor for the COSMAC Elf 2000

3348   905D             	.EJECT
3349   905D             ;	.SBTTL	Initialize the Console Terminal
3350   905D             
3351   905D             ;   This routine will (re) initialize the console terminal.  It first restores
3352   905D             ; the contents of BAUD1 to the upper byte of register E.  The low order bit of
3353   905D             ; this value is the local echo flag and is ignored, however the rest of it is
3354   905D             ; the software bit rate for the bit banging console and is non-zero any time
3355   905D             ; the software serial console is in use.
3356   905D             ;
3357   905D             ;   If the software baud rate is zero, then this routine examines BAUD0 for a
3358   905D             ; non-zero value and, if it finds one, the UART is being used for a console
3359   905D             ; terminal. This byte represents the hardware UART settings and the console baud
3360   905D             ; rate is restored by a call to F_SETBD).
3361   905D             ;
3362   905D             ;   If BAUD1 is 0xFE (again, ignoring the LSB local echo bit) then the PS/2
3363   905D             ; keyboard and 80 column video card are in use as the console and we don't
3364   905D             ; need to do anything further (beyond restoring RE.1) to enable the console.
3365   905D             ;
3366   905D             ;   If BAUD0 and BAUD1 are both zero, or if both are $FF, then the NVR has been
3367   905D             ; (re)initialized and we need to autobaud again.  Once the autobaud is done the
3368   905D             ; serial parameters are saved in BAUD0/1, and in NVR if present, for next time.
3369   905D             
3370   905D             TTYINI:
3371   905D             ;   If BOTH the GPIO PS/2 interface and the 80 column video card are installed
3372   905D             ; on this system then we always use them for the console, no matter what UARTs
3373   905D             ; or NVRs or whatever else may be installed.
3374   905D             #ifdef ELF2K
3375   905D F8 7F       	RLDI(P1,PS2VER)		; point to the PS/2 keyboard status
3375   905F BF          
3375   9060 F8 B3       
3375   9062 AF          
3376   9063 EF          	SEX	P1		; ...
3377   9064 72          	LDXA			; load the PS/2 version
3378   9065 32 73       	BZ	TTYIN0		;  if it's zero then there's no PS2 keyboard
3379   9067 F0          	LDX			; now get the video card version
3380   9068 32 73       	BZ	TTYIN0		;  if that's zero then there's no video card
3381   906A F8 FF       	RLDI(BAUD,$FF00)	; force the BIOS to use the PS2/video
3381   906C BE          
3381   906D F8 00       
3381   906F AE          
3382   9070 C0 90 B5    	LBR	TTYAU1		; save that in BAUD1/0 and return
3383   9073             #endif
3384   9073             
3385   9073             ;   If there's an NVR (aka CMOS) on this system, then attempt to reload
3386   9073             ; BAUD1 and BAUD0 from CMOS.  Note that if this doesn't work (no NVR or the
3387   9073             ; NVR contents are invalid) then BAUD1 and BAUD0 in RAM will be unchanged.
3388   9073 F8 00       TTYIN0:	RLDI(P1,NVRBAUD)	; offset of baud rate data in NVR
3388   9075 BF          
3388   9076 F8 03       
3388   9078 AF          
3389   9079 F8 7F       	RLDI(P2,BAUD1)		; pointer to data area in main SRAM
3389   907B BD          
3389   907C F8 A4       
3389   907E AD          
3390   907F F8 00       	RLDI(P3,2)		; count of bytes to read
3390   9081 BC          
3390   9082 F8 02       
3390   9084 AC          
3391   9085 D4          	CALL(F_RDNVR)		; attempt to read NVR first
TASM 1802 Assembler.              boots.asm                        page 115
BTS1802 -- Monitor for the COSMAC Elf 2000

3391   9086 F8 1B       
3392   9088             ; We don't care whether this works or not!
3393   9088             
3394   9088             ; Reload the baud registers from memory...
3395   9088 F8 7F       	RLDI(DP,BAUD1)		; point to BAUD1 first
3395   908A B7          
3395   908B F8 A4       
3395   908D A7          
3396   908E 47          	LDA	DP		; and get it
3397   908F BE          	PHI	BAUD		; reload that register
3398   9090             ;   If BAUD.1 is $FE or $FF, then either the RAM/NVR was initialized, OR the
3399   9090             ; PS/2 keyboard and 80 column video card was in use last time.  Either way,
3400   9090             ; we need to autobaud now.  Likewise, if BAUD.1 is zero then either the RAM/NVR
3401   9090             ; was initialized OR the hardware UART was in use last time around ...
3402   9090 FA FE       	ANI	$FE		; ignore the local echo bit
3403   9092 C2 90 9B    	LBZ	TTYIN1		; branch if we need to try the UART
3404   9095 FB FE       	XRI	$FE		; test for $FF or $FE
3405   9097 C2 90 AE    	LBZ	TTYAUT		; branch if we need to autobaud
3406   909A             ; Otherwis the software serial console was in use last time around ...
3407   909A D5          	RETURN			; there's nothing more to do!
3408   909B             
3409   909B             ;   Here if BAUD1 is zero; now check BAUD0.  If the latter is nonzero then the
3410   909B             ; UART was in use last time.  We need to make sure the UART is still present
3411   909B             ; and, provided that it is, restore the UART settings.  If both BAUD1 and BAUD0
3412   909B             ; are zero, then the NVR/RAM was just initialized and we need autobaud ...
3413   909B 47          TTYIN1:	LDA	DP		; load BAUD0 next
3414   909C AF          	PLO	P1		; save it for a minute
3415   909D C2 90 AE    	LBZ	TTYAUT		; if both are zero, then autobaud
3416   90A0 F8 7F       	RLDI(DP,UARTOK)		; check the UART flag
3416   90A2 B7          
3416   90A3 F8 B2       
3416   90A5 A7          
3417   90A6 07          	LDN	DP		; ... to see if the UART is installed
3418   90A7 C2 90 AE    	LBZ	TTYAUT		; go autobaud if it isn't
3419   90AA 8F          	GLO	P1		; get the UART settings back
3420   90AB C0 F8 12    	LBR	F_USETBD	; and re-initialize the hardware UART settings
3421   90AE             
3422   90AE             ;   Here if there's no record of which UART was in use; we'll have to call the
3423   90AE             ; BIOS auto baud routine to determine which port and what speed.  Note that
3424   90AE             ; this label can also be used as an alternate entry point to force an autobaud
3425   90AE             ; regardless of the current settings!
3426   90AE E3          TTYAUT:	OUTI(LEDS,$16)		; show "16" on the data LEDs
3426   90AF 64          
3426   90B0 16          
3426   90B1 E2          
3427   90B2 D4          	CALL(F_SETBD)		; and then let the BIOS auto baud
3427   90B3 FF 2D       
3428   90B5 F8 7F       TTYAU1:	RLDI(DP,BAUD1)		; (F_SETBD trashes DP!)
3428   90B7 B7          
3428   90B8 F8 A4       
3428   90BA A7          
3429   90BB 9E          	GHI	BAUD		; store BAUD1
3430   90BC 57          	STR	DP		; ...
3431   90BD 17          	INC	DP		; and store BAUD0 too
3432   90BE 8F          	GLO	P1		; ...
3433   90BF 57          	STR	DP		; ...
3434   90C0             
3435   90C0             ;   And lastly, if there is a NVR/CMOS on this system, attempt to save the UART
3436   90C0             ; settings for next time around!
TASM 1802 Assembler.              boots.asm                        page 116
BTS1802 -- Monitor for the COSMAC Elf 2000

3437   90C0 F8 00       	RLDI(P1,NVRBAUD)	; offset of baud rate data in NVR
3437   90C2 BF          
3437   90C3 F8 03       
3437   90C5 AF          
3438   90C6 F8 7F       	RLDI(P2,BAUD1)		; pointer to data area in main SRAM
3438   90C8 BD          
3438   90C9 F8 A4       
3438   90CB AD          
3439   90CC F8 00       	RLDI(P3,2)		; count of bytes to write
3439   90CE BC          
3439   90CF F8 02       
3439   90D1 AC          
3440   90D2 C0 F8 1E    	LBR	F_WRNVR		; attempt to save it and return
3441   90D5             
TASM 1802 Assembler.              boots.asm                        page 117
BTS1802 -- Monitor for the COSMAC Elf 2000

3442   90D5             	.EJECT
3443   90D5             ;	.SBTTL	Elf Video Card and PS/2 Keyboard Routines
3444   90D5             
3445   90D5             ;   This routine will return with DF=1 if the Elf 2000 video board is
3446   90D5             ; installed and active and DF=0 if it is not.  Note that "installed and
3447   90D5             ; active" doesn't necessarily mean that the video is being used as the
3448   90D5             ; console - if there's no PS/2 keyboard present, then it's possible for
3449   90D5             ; the video to be active even though the UART is used as the console.
3450   90D5             ;
3451   90D5             ;   Why is this important?  Well, the video requires that interrupts and
3452   90D5             ; DMA be in constant use so that it can refresh the display and that's
3453   90D5             ; incompatible with some monitor commands (e.g. RUN, break points, CONTINUE,
3454   90D5             ; etc).
3455   90D5~            #ifdef VIDEO
3456   90D5~            ISCRTC:	RLDI(T1,VIDVER)		; get the version number of the video firmware
3456   90D5~            ISCRTC:	RLDI(T1,VIDVER)		; get the version number of the video firmware
3456   90D5~            ISCRTC:	RLDI(T1,VIDVER)		; get the version number of the video firmware
3456   90D5~            ISCRTC:	RLDI(T1,VIDVER)		; get the version number of the video firmware
3457   90D5~            	LDN	T1		; ...
3458   90D5~            	CDF			; set DF=0
3459   90D5~            	BZ	ISCRT1		;  and return that if there's no video
3460   90D5~            	SDF			; not zero - return DF=1
3461   90D5~            ISCRT1:	RETURN			; and done
3462   90D5             #endif
3463   90D5             
3464   90D5             ;   This is the same as ISCRTC except that it actually prints an error message
3465   90D5             ; before it returns if the video card is present...
3466   90D5~            #ifdef VIDEO
3467   90D5~            NOCRTC:	CALL(ISCRTC)		; see if the video card is installed
3467   90D5~            NOCRTC:	CALL(ISCRTC)		; see if the video card is installed
3468   90D5~            	LBNF	ISCRT1		; nope - just return now
3469   90D5~            	OUTSTR(NOCRT1)		; print an error message
3469   90D5~            	OUTSTR(NOCRT1)		; print an error message
3469   90D5~            	OUTSTR(NOCRT1)		; print an error message
3469   90D5~            	OUTSTR(NOCRT1)		; print an error message
3469   90D5~            	OUTSTR(NOCRT1)		; print an error message
3469   90D5~            	OUTSTR(NOCRT1)		; print an error message
3470   90D5~            	SDF			; be sure DF is still 1
3471   90D5~            	RETURN			; and return
3472   90D5~            NOCRT1:	.TEXT	"?VIDEO ACTIVE\r\n\000"
3473   90D5             #endif
3474   90D5             
TASM 1802 Assembler.              boots.asm                        page 118
BTS1802 -- Monitor for the COSMAC Elf 2000

3475   90D5             	.EJECT
3476   90D5             ;	.SBTTL	Type Various Special Characters
3477   90D5             
3478   90D5             ; This routine will type a carriage return/line feed pair on the console...
3479   90D5 F8 0D       TCRLF:	LDI	CHCRT		; type carriage return
3480   90D7 D4          	CALL(F_TTY)		; ...
3480   90D8 FF 4E       
3481   90DA F8 0A       	LDI	CHLFD		; and then line feed
3482   90DC C0 FF 4E    	LBR	F_TTY		; ...
3483   90DF             
3484   90DF             ; Type a single space on the console...
3485   90DF F8 20       TSPACE:	LDI	' '		; this is what we want
3486   90E1 C0 FF 4E    	LBR	F_TTY		; and this is where we want it
3487   90E4             
3488   90E4             ; Type a (horizontal) tab...
3489   90E4 F8 09       TTABC:	LDI	CHTAB		; ...
3490   90E6 C0 FF 4E    	LBR	F_TTY		; ...
3491   90E9             
3492   90E9             ; Type a question mark...
3493   90E9 F8 3F       TQUEST:	LDI	'?'		; ...
3494   90EB C0 FF 4E    	LBR	F_TTY		; ...
3495   90EE             
TASM 1802 Assembler.              boots.asm                        page 119
BTS1802 -- Monitor for the COSMAC Elf 2000

3496   90EE             	.EJECT
3497   90EE             ;	.SBTTL	Scan Two and Four Digit Hex Values
3498   90EE             
3499   90EE             ;   This routine will read a four digit hex number pointed to by P1 and return
3500   90EE             ; its value in P2.  Other than a doubling of precision, it's exactly the same
3501   90EE             ; as GHEX2...
3502   90EE D4          GHEX4:	CALL(GHEX2)	; get the first two digits
3502   90EF 90 FD       
3503   90F1 3B FC       	BNF	GHEX40	; quit if we don't find them
3504   90F3 BD          	PHI	P2	; then save those values for a minute
3505   90F4 D4          	CALL(GHEX2)	; then the next two digits
3505   90F5 90 FD       
3506   90F7 3B FC       	BNF	GHEX40	; not there
3507   90F9 AD          	PLO	P2	; put them with the low
3508   90FA FF 00       	SDF		; and return with DF set
3509   90FC D5          GHEX40:	RETURN		; all done
3510   90FD             
3511   90FD             ;   This routine will scan a two hex number pointed to by P1 and return its
3512   90FD             ; value in D.  Unlike F_HEXIN, which will scan an arbitrary number of digits,
3513   90FD             ; in this case the number must contain exactly two digits - no more, and no
3514   90FD             ; less.  If we don't find two hex digits in the string addressed by P1, the
3515   90FD             ; DF bit will be cleared on return and P1 left pointing to the non-hex char.
3516   90FD 0F          GHEX2:	LDN	P1	; get the first character
3517   90FE D4          	CALL(ISHEX)	; is it a hex digit???
3517   90FF 91 28       
boots.asm line 3518: Branch off of current page. 
3518   9101 3B FC       	BNF	GHEX40	; nope - quit now
3519   9103 FE          	SHL\ SHL	; shift the first nibble left 4 bits
3519   9104 FE          
3520   9105 FE          	SHL\ SHL	; ...
3520   9106 FE          
3521   9107 A9          	PLO	T1	; and save it temporarily in T1
3522   9108 1F          	INC	P1	; ...
3523   9109 0F          	LDN	P1	; then get the next character
3524   910A D4          	CALL(ISHEX)	; is it a hex digit?
3524   910B 91 28       
3525   910D 3B 16       	BNF	GHEX20	; not there - quit now
3526   910F 73          	STXD		; stack the second digit
3527   9110 60          	IRX		; and then address it
3528   9111 89          	GLO	T1	; get the first four bits
3529   9112 F1          	OR		; and put them together
3530   9113 1F          	INC	P1	; on to the next digit
3531   9114 FF 00       	SDF		; return with DF set
3532   9116 D5          GHEX20:	RETURN		; and we're all done
3533   9117             
TASM 1802 Assembler.              boots.asm                        page 120
BTS1802 -- Monitor for the COSMAC Elf 2000

3534   9117             	.EJECT
3535   9117             ;	.SBTTL	Arithmetic Comparisons
3536   9117             
3537   9117             ;   This routine will examine the ASCII character in D and, if it is a lower
3538   9117             ; case letter 'a'..'z', it will fold it to upper case.  All other ASCII
3539   9117             ; characters are left unchanged...
3540   9117 FA 7F       FOLD:	ANI	$7F	; only use seven bits
3541   9119 AE          	PLO	BAUD	; save the character (very) temporarily
3542   911A FF 61       	SMI	'a'	; is it a lower case letter ???
3543   911C 3B 26       	BL	FOLD1	; not this time
3544   911E FF 1A       	SMI   'z'-'a'+1	; check it against both ends of the range
3545   9120 33 26       	BGE	FOLD1	; nope -- it's not a letter
3546   9122 8E          	GLO	BAUD	; it is lower case - get the original character
3547   9123 FF 20       	SMI	$20	; convert it to upper case
3548   9125 D5          	RETURN		; and return that
3549   9126 8E          FOLD1:	GLO	BAUD	; it's not lower case ...
3550   9127 D5          	RETURN		; ... return the original character
3551   9128             
3552   9128             
3553   9128             ;   This routine will examine the ASCII character in D and, if it is a hex
3554   9128             ; character '0'..'9' or 'A'..'Z', it will convert it to the equivalent binary
3555   9128             ; value and return it in D.  If the character in D is not a hex digit, then
3556   9128             ; the DF will be cleared on return.
3557   9128 FA 7F       ISHEX:	ANI	$7F	; ...
3558   912A AE          	PLO	BAUD	; save the character temporarily
3559   912B FF 30       	SMI	'0'	; is the character a digit '0'..'9'??
3560   912D 3B 46       	BL	ISHEX3	; nope - there's no hope...
3561   912F FF 0A       	SMI	10	; check the other end of the range
3562   9131 3B 41       	BL	ISHEX2	; it's a decimal digit - that's fine
3563   9133 8E          	GLO	BAUD	; It isn't a decimal digit, so try again...
3564   9134 D4          	CALL(FOLD)	; convert lower case 'a'..'z' to upper
3564   9135 91 17       
3565   9137 FF 41       	SMI	'A'	; ... check for a letter from A - F
3566   9139 3B 46       	BL	ISHEX3	; nope -- not a hex digit
3567   913B FF 06       	SMI	6	; check the other end of the range
3568   913D 33 46       	BGE	ISHEX3	; no way this isn't a hex digit
3569   913F             ; Here for a letter 'A' .. 'F'...
3570   913F FC 06       	ADI	6	; convert 'A' back to the value 10
3571   9141             ; Here for a digit '0' .. '9'...
3572   9141 FC 0A       ISHEX2:	ADI	10	; convert '0' back to the value 0
3573   9143 FF 00       	SDF		; just in case
3574   9145 D5          	RETURN		; return with DF=1!
3575   9146             ; Here if the character isn't a hex digit at all...
3576   9146 8E          ISHEX3:	GLO	BAUD	; get the original character back
3577   9147 FC 00       	CDF		; and return with DF=0
3578   9149 D5          	RETURN		; ...
3579   914A             
3580   914A             
3581   914A             ; This routine will return DF=1 if (P3 .LE. P4) and DF=0 if it is not...
3582   914A 9C          P3LEP4: GHI	P3	; First compare the high bytes
3583   914B 52          	STR	SP	; ....
3584   914C 9B          	GHI	P4	; ....
3585   914D F7          	SM		; See if P4-P3 < 0 (which implies that P3 > P4)
3586   914E 3B 5B       	BL	P3GTP4	; because it is an error if so
3587   9150 3A 58       	BNZ	P3LE0	; Return if the high bytes are not the same
3588   9152 8C          	GLO	P3	; The high bytes are the same, so we must
3589   9153 52          	STR	SP	; repeat the test for the low bytes
3590   9154 8B          	GLO	P4	; ....
3591   9155 F7          	SM		; ....
TASM 1802 Assembler.              boots.asm                        page 121
BTS1802 -- Monitor for the COSMAC Elf 2000

3592   9156 3B 5B       	BL	P3GTP4	; ....
3593   9158 FF 00       P3LE0:	SDF		; return DF=1
3594   915A D5          	RETURN		; Everything is in the right order...
3595   915B FC 00       P3GTP4:	CDF		; return DF=0
3596   915D D5          	RETURN		; ...
3597   915E             
TASM 1802 Assembler.              boots.asm                        page 122
BTS1802 -- Monitor for the COSMAC Elf 2000

3598   915E             	.EJECT
3599   915E             ;	.SBTTL	Output Decimal and Hexadecimal Numbers
3600   915E             
3601   915E             ;   This routine will convert a four bit value in D (0..15) to a single hex
3602   915E             ; digit and then type it on the console...
3603   915E FA 0F       THEX1:	ANI	$0F		; trim to just 4 bits
3604   9160 FC 30       	ADI	'0'		; convert to ASCII
3605   9162 FF 3A       	SMI	'9'+1		; is this digit A..F?
3606   9164 3B 68       	BL	THEX11		; branch if not
3607   9166 FC 07       	ADI	'A'-'9'-1	; yes - adjust the range
3608   9168 FC 3A       THEX11:	ADI	'9'+1		; and restore the original character
3609   916A C0 FF 4E    	LBR	F_TTY		; type it and return
3610   916D             
3611   916D             ; This routine will type a two digit (1 byte) hex value from D...
3612   916D 73          THEX2:	PUSHD			; save the whole byte for a minute
3613   916E F6          	SHR\ SHR\ SHR\ SHR	; and type type MSD first
3613   916F F6          
3613   9170 F6          
3613   9171 F6          
3614   9172 D4          	CALL(THEX1)		; ...
3614   9173 91 5E       
3615   9175 60          	POPD			; pop the original byte
3615   9176 F0          
3616   9177 C0 91 5E    	LBR	THEX1		; and type the least significant digit
3617   917A             
3618   917A             ; This routine will type a four digit (16 bit) hex value from P1...
3619   917A 9F          THEX4:	GHI	P1		; get the high byte
3620   917B D4          	CALL(THEX2)		; and type that first
3620   917C 91 6D       
3621   917E 8F          	GLO	P1		; then type the low byte next
3622   917F C0 91 6D    	LBR	THEX2		; and we're done
3623   9182             
3624   9182             ;   And finally, this routine will type an unsigned 16 bit value from P1 as
3625   9182             ; a decimal number.  It's a pretty straight forward recursive routine and
3626   9182             ; depends heavily on the BIOS F_DIVIDE function!
3627   9182 F8 00       TDEC16:	RLDI(P2,10)		; set the divisor
3627   9184 BD          
3627   9185 F8 0A       
3627   9187 AD          
3628   9188 D4          	CALL(F_DIV16)		; divide P1 by ten
3628   9189 FF 33       
3629   918B 8F          	GLO	P1		; get the remainder
3630   918C 73          	PUSHD			; and stack that for a minute
3631   918D 9B          	RCOPY(P1,P4)		; transfer the quotient back to P1
3631   918E BF          
3631   918F 8B          
3631   9190 AF          
3632   9191 3A 96       	BNZ	TDEC1A		; if the quotient isn't zero ...
3633   9193 9F          	GHI	P1		;  ... then keep dividing
3634   9194 32 99       	BZ	TDEC1B		;  ...
3635   9196 D4          TDEC1A:	CALL(TDEC16)		; keep typing P1 recursively
3635   9197 91 82       
3636   9199 60          TDEC1B:	POPD			; then get back the remainder
3636   919A F0          
3637   919B C0 91 5E    	LBR	THEX1		; type it in ASCII and return
3638   919E             
TASM 1802 Assembler.              boots.asm                        page 123
BTS1802 -- Monitor for the COSMAC Elf 2000

3639   919E             	.EJECT
3640   919E             ;	.SBTTL	BASIC, Forth, ASM, VISUAL and SEDIT Commands
3641   919E             
3642   919E             ;   Each of these commands invokes the corresponding software package in the
3643   919E             ; EPROM (if it's present, that is).  Each one of these languages has the
3644   919E             ; ability to either create a new program (the normal case) or to recover a
3645   919E             ; program already stored in SRAM.  This latter case is particularly useful
3646   919E             ; with battery backup for the SRAM, because you can enter you long BASIC,
3647   919E             ; Forth or assembly program today and it'll still be there tomorrow!  This
3648   919E             ; alternate function is accessed by an alternate entry point at the main
3649   919E             ; entry point +3 bytes.
3650   919E             #ifdef BASIC
3651   919E F8 BA       RBASIC:	RLDI(T2,BASIC)
3651   91A0 BA          
3651   91A1 F8 00       
3651   91A3 AA          
3652   91A4             #endif
3653   91A4             
3654   91A4             ;   Here's the common code for all cases...  When we get here, the main entry
3655   91A4             ; point for the language should be in T2...
3656   91A4 D4          RBAS1:	CALL(ISEOL)	; is there more on the command line
3656   91A5 85 61       
3657   91A7 CB 91 CB    	LBNF	RBAS2	; if there is more, check for NEW or OLD argument
3658   91AA F8 91       	OUTSTR(NEWOLD)	; ask "New or Old ?"
3658   91AC BF          
3658   91AD F8 F5       
3658   91AF AF          
3658   91B0 D4          
3658   91B1 FF 09       
3659   91B3 F8 7F       	RLDI(P1,CMDBUF)	; read another command line
3659   91B5 BF          
3659   91B6 F8 B8       
3659   91B8 AF          
3660   91B9 F8 00       	RLDI(P3,CMDMAX)	; ...
3660   91BB BC          
3660   91BC F8 40       
3660   91BE AC          
3661   91BF D4          	CALL(F_INPUTL)	; ...
3661   91C0 FF 69       
3662   91C2 D4          	CALL(TCRLF)	; ...
3662   91C3 90 D5       
3663   91C5 F8 7F       	RLDI(P1,CMDBUF)	; setup P1 to point to the new "command"
3663   91C7 BF          
3663   91C8 F8 B8       
3663   91CA AF          
3664   91CB D4          RBAS2:	CALL(F_LTRIM)	; skip any leading spaces
3664   91CC FF 15       
3665   91CE F8 91       	RLDI(P2,BASCMD)	; try to parse either "NEW" or "OLD"
3665   91D0 BD          
3665   91D1 F8 D7       
3665   91D3 AD          
3666   91D4 C0 85 12    	LBR	COMND	; (and call CMDERR if we can't!)
3667   91D7             
3668   91D7             ; Table of NEW and OLD options...
3669   91D7 03 4E 45 57 BASCMD:	CMD(3, "NEW", BASNEW)
3669   91DB 00 
3669   91DC 91 E9       
3670   91DE 03 4F 4C 44 	CMD(3, "OLD", BASOLD)
3670   91E2 00 
TASM 1802 Assembler.              boots.asm                        page 124
BTS1802 -- Monitor for the COSMAC Elf 2000

3670   91E3 91 E6       
3671   91E5 00          	.DB	0
3672   91E6             
3673   91E6             ;   Here for the "BASIC OLD" command.  Adjust the entry point (passed in T1)
3674   91E6             ; by three bytes.  Since we know the entry points are always aligned on at
3675   91E6             ; least a page boundary, we can take the easy way out on this...
3676   91E6 F8 03       BASOLD:	LDI	3	; set the entry point offset
3677   91E8 AA          	PLO	T2	; ... in T2
3678   91E9             ; Here for the "BASIC NEW" command...
3679   91E9 F8 91       BASNEW:	RLDI(T1,BASGO)	; we can't use R3 as the PC right now
3679   91EB B9          
3679   91EC F8 F0       
3679   91EE A9          
3680   91EF D9          	SEP	T1	; so we'll go back to R0
3681   91F0 9A          BASGO:	RCOPY(PC,T2)	; put the address in R3
3681   91F1 B3          
3681   91F2 8A          
3681   91F3 A3          
3682   91F4 D3          	SEP	PC	; and then branch to the interpreter
3683   91F5             
3684   91F5             ; Messages...
3685   91F5 4E 65 77 20 NEWOLD:	.TEXT	"New or Old ?\000"
3685   91F9 6F 72 20 4F 
3685   91FD 6C 64 20 3F 
3685   9201 00 
3686   9202             
3687   9202             
3688   9202             ; The ASM command is pretty much the same...
3689   9202             #ifdef EDTASM
3690   9202 F8 9C       RASM:	RLDI(T2,EDTASM)
3690   9204 BA          
3690   9205 F8 00       
3690   9207 AA          
3691   9208 C0 91 A4    	LBR	RBAS1
3692   920B             #endif
3693   920B             
3694   920B             ; And Forth...
3695   920B             #ifdef FORTH
3696   920B F8 D7       RFORTH:	RLDI(T2,FORTH)
3696   920D BA          
3696   920E F8 00       
3696   9210 AA          
3697   9211 C0 91 A4    	LBR	RBAS1
3698   9214             #endif
3699   9214             
3700   9214             ; The SEDIT command is even easier - there's no new or old nonsense...
3701   9214~            #ifdef SEDIT
3702   9214~            RSEDIT:	CALL(ISEOL)	; should be no arguments
3702   9214~            RSEDIT:	CALL(ISEOL)	; should be no arguments
3703   9214~            	LBNF	CMDERR	; error if there are
3704   9214~            	LBR	SEDIT	; start SEDIT ...
3705   9214             #endif
3706   9214             
3707   9214             ; And lastly, Visual/02 ...
3708   9214             #ifdef VISUAL
3709   9214 D4          RVISUAL:CALL(ISEOL)	; there are no arguments
3709   9215 85 61       
3710   9217 CB 85 68    	LBNF	CMDERR	; error if there are
3711   921A C0 A9 00    	LBR	VISUAL	; start Visual/02 ...
TASM 1802 Assembler.              boots.asm                        page 125
BTS1802 -- Monitor for the COSMAC Elf 2000

3712   921D             #endif
3713   921D             
TASM 1802 Assembler.              boots.asm                        page 126
BTS1802 -- Monitor for the COSMAC Elf 2000

3714   921D             	.EJECT
3715   921D             ;	.SBTTL	Primary Command Table
3716   921D             
3717   921D             ;   The command table contains one or more command entries organized like
3718   921D             ; this:
3719   921D             ;
3720   921D             ;	.DB	2, "BASIC", 0
3721   921D             ;	.DW	BASIC
3722   921D             ;
3723   921D             ;  The first byte, 2 in this case, is the minimum number of characters that
3724   921D             ; must match the command name ("BA" for "BASIC" in this case).  The next
3725   921D             ; bytes are the full name of the command, terminated by a zero byte, and
3726   921D             ; the last two bytes are the address of the routine that processes this
3727   921D             ; command.
3728   921D             
3729   921D             ; Here's the table of monitor commands....
3730   921D 04 43 4F 4E CMDTBL:	CMD(4, "CONTINUE", CONTINUE)	; continue after a breakpoint
3730   9221 54 49 4E 55 
3730   9225 45 00 
3730   9227 8D 8A       
3731   9229             #ifdef FORTH
3732   9229 03 46 4F 52 	CMD(3, "FORTH",    RFORTH)	;  "     "   "  Forth   "   "
3732   922D 54 48 00 
3732   9230 92 0B       
3733   9232             #endif
3734   9232~            #ifdef SEDIT
3735   9232~            	CMD(3, "SEDIT",    RSEDIT)	; SEDIT
3735   9232~            	CMD(3, "SEDIT",    RSEDIT)	; SEDIT
3736   9232             #endif
3737   9232             #ifdef EDTASM
3738   9232 03 41 53 4D 	CMD(3, "ASM",	   RASM)	; editor/assembler
3738   9236 00 
3738   9237 92 02       
3739   9239             #endif
3740   9239             #ifdef VISUAL
3741   9239 02 56 49 53 	CMD(2, "VISUAL",   RVISUAL)	; Visual/02 debugger
3741   923D 55 41 4C 00 
3741   9241 92 14       
3742   9243             #endif
3743   9243 02 4F 55 54 	CMD(2, "OUTPUT",   OUTPUT)	;  "   output  "
3743   9247 50 55 54 00 
3743   924B 86 9E       
3744   924D 02 49 4E 50 	CMD(2, "INPUT",    INPUT)	; test input port
3744   9251 55 54 00 
3744   9254 86 5F       
3745   9256 02 43 41 4C 	CMD(2, "CALL",     CALUSR)	; "call" a user's program
3745   925A 4C 00 
3745   925C 88 08       
3746   925E 02 52 55 4E 	CMD(2, "RUN",      RUNUSR)	; "run"  "   "     "   "
3746   9262 00 
3746   9263 87 E2       
3747   9265 02 48 45 4C 	CMD(2, "HELP",	   PHELP)	; print help text
3747   9269 50 00 
3747   926B 8E DD       
3748   926D 02 53 45 54 	CMD(2, "SET",      SET)
3748   9271 00 
3748   9272 86 13       
3749   9274 02 53 48 4F 	CMD(2, "SHOW",     SHOW)
3749   9278 57 00 
TASM 1802 Assembler.              boots.asm                        page 127
BTS1802 -- Monitor for the COSMAC Elf 2000

3749   927A 85 9E       
3750   927C 02 54 45 53 	CMD(2, "TEST",	   TEST)
3750   9280 54 00 
3750   9282 86 45       
3751   9284             #ifdef BASIC
3752   9284 02 42 41 53 	CMD(2, "BASIC",    RBASIC)	; start the ROM BASIC
3752   9288 49 43 00 
3752   928B 91 9E       
3753   928D             #endif
3754   928D 01 42 4F 4F 	CMD(1, "BOOT",     BOOTCMD)	; boot from the primary IDE disk
3754   9291 54 00 
3754   9293 88 E0       
3755   9295 01 45 58 41 	CMD(1, "EXAMINE",  EXAM)	; examine/dump memory bytes
3755   9299 4D 49 4E 45 
3755   929D 00 
3755   929E 86 C4       
3756   92A0 01 44 45 50 	CMD(1, "DEPOSIT",  DEPOSIT)	; deposit data in memory
3756   92A4 4F 53 49 54 
3756   92A8 00 
3756   92A9 87 A3       
3757   92AB 01 3A 00    	CMD(1, ":",        IHEX)	; load Intel .HEX format files
3757   92AE 8C B7       
3758   92B0 01 3B 00    	CMD(1, ";",	   MAIN)	; a comment
3758   92B3 84 C2       
3759   92B5~            #ifdef VIDEO
3760   92B5~            	CMD(3, "CLS",      CLSCMD)	; clear the VT1802 screen
3760   92B5~            	CMD(3, "CLS",      CLSCMD)	; clear the VT1802 screen
3761   92B5             #else
3762   92B5 03 43 4C 53 	CMD(3, "CLS",      CLSCMD0) ; normal BIOS clearscreen
3762   92B9 00 
3762   92BA 8E EC       
3763   92BC             #endif
3764   92BC             
3765   92BC             ; The table always ends with a zero byte...
3766   92BC 00          	.DB	0
3767   92BD             
TASM 1802 Assembler.              boots.asm                        page 128
BTS1802 -- Monitor for the COSMAC Elf 2000

3768   92BD             	.EJECT
3769   92BD             ;	.SBTTL	Sample Bitmaps for CDP1861 Display
3770   92BD             
3771   92BD             ;   The classic "Starship Enterprise" outline for the CDP1861 by Joseph
3772   92BD             ; Weisbecker.  Note that the bitmap must be aligned on a multiple of
3773   92BD             ; sixteen bytes in order for it to be positioned correctly on the CRT...
3774   92BD             	
3775   92BD             
3776   92BD~            #ifdef PIXIE
3777   92BD~            	PAGE
3778   92BD~            NCC1701:
3779   92BD~            ; SPARE TIME GIZMOS...
3780   92BD~            	.DB	$EE,$EE,$E3,$BA,$B8,$E7,$75,$77
3781   92BD~            	.DB	$8A,$AA,$81,$13,$A0,$82,$17,$54
3782   92BD~            	.DB	$EE,$EC,$C1,$12,$B0,$A2,$25,$57
3783   92BD~            	.DB	$28,$AA,$81,$12,$A0,$92,$45,$51
3784   92BD~            	.DB	$E8,$AA,$E1,$3A,$B8,$E7,$75,$77
3785   92BD~            	.DB	$00,$00,$00,$00,$00,$00,$00,$00
3786   92BD~            	.DB	$00,$00,$00,$00,$00,$00,$00,$00
3787   92BD~            	.DB	$FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
3788   92BD~            
3789   92BD~            ; The original NCC1701 starts here....
3790   92BD~            	.DB	$00,$00,$00,$00,$00,$00,$00,$00
3791   92BD~            	.DB	$00,$00,$00,$00,$00,$00,$00,$00
3792   92BD~            	.DB	$7B,$DE,$DB,$DE,$00,$00,$00,$00
3793   92BD~            	.DB	$4A,$50,$DA,$52,$00,$00,$00,$00
3794   92BD~            	.DB	$42,$5E,$AB,$D0,$00,$00,$00,$00
3795   92BD~            	.DB	$4A,$42,$8A,$52,$00,$00,$00,$00
3796   92BD~            	.DB	$7B,$DE,$8A,$5E,$00,$00,$00,$00
3797   92BD~            	.DB	$00,$00,$00,$00,$00,$00,$00,$00
3798   92BD~            	.DB	$00,$00,$00,$00,$00,$00,$07,$E0
3799   92BD~            	.DB	$00,$00,$00,$00,$FF,$FF,$FF,$FF
3800   92BD~            	.DB	$00,$06,$00,$01,$00,$00,$00,$01
3801   92BD~            	.DB	$00,$7F,$E0,$01,$00,$00,$00,$02
3802   92BD~            	.DB	$7F,$C0,$3F,$E0,$FC,$FF,$FF,$FE
3803   92BD~            	.DB	$40,$0F,$00,$10,$04,$80,$00,$00
3804   92BD~            	.DB	$7F,$C0,$3F,$E0,$04,$80,$00,$00
3805   92BD~            	.DB	$00,$3F,$D0,$40,$04,$80,$00,$00
3806   92BD~            	.DB	$00,$0F,$08,$20,$04,$80,$7A,$1E
3807   92BD~            	.DB	$00,$00,$07,$90,$04,$80,$42,$10
3808   92BD~            	.DB	$00,$00,$18,$7F,$FC,$F0,$72,$1C
3809   92BD~            	.DB	$00,$00,$30,$00,$00,$10,$42,$10
3810   92BD~            	.DB	$00,$00,$73,$FC,$00,$10,$7B,$D0
3811   92BD~            	.DB	$00,$00,$30,$00,$3F,$F0,$00,$00
3812   92BD~            	.DB	$00,$00,$18,$0F,$C0,$00,$00,$00
3813   92BD~            	.DB	$00,$00,$07,$F0,$00,$00,$00,$00
3814   92BD             #endif
3815   92BD             
TASM 1802 Assembler.              boots.asm                        page 129
BTS1802 -- Monitor for the COSMAC Elf 2000

3816   92BD             	.EJECT
3817   92BD             	.END
3818   92BD             



Label        Value      Label        Value      Label        Value
------------------      ------------------      ------------------
ABTNONE       00FF      ABTADDR       005A      ABTDISK       00A5      
A             0006      ASTART        8452      ASTAR1        847C      
ASTAR2        849A      BAUD          000E      BAUD1         7FA4      
BAUD0         7FA5      BATTOK        7FAC      BOOTF         7FB5      
BOOTCMD       88E0      BOOTIDE       88E6      BOOMSG        8909      
BFAMSG        8923      BADDRV        89E0      BADDR1        89EC      
BPTMSG        8ECF      BASCMD        91D7      BASOLD        91E6      
BASNEW        91E9      BASGO         91F0      CDP1861       0001      
CRTCP         0001      CRTCC         0005      CRTC_RESET    0000      
CRTC_START    0020      CRTC_STOP     0040      CRTC_LDCURS   0080      
CRTC_EI       00A0      CRTC_DI       00C0      CRTC_PRESET   00E0      
CRTCS         0005      CRTC_IE       0040      CRTC_IR       0020      
CRTC_LP       0010      CRTC_IC       0008      CRTC_VE       0004      
CRTC_DU       0002      CRTC_FO       0001      CALLPC        0004      
CHCTC         0003      CHBSP         0008      CHTAB         0009      
CHLFD         000A      CHCRT         000D      CHFFD         000C      
CHESC         001B      CHRUB         007F      CMDMAX        0040      
CMDBUF        7FB8      CHKSUM        FFFE      CLRRAM        816A      
COMND         8512      COMND1        8516      COMND2        851F      
COMND3        8531      COMN3A        8536      COMND4        8542      
COMND5        8549      CMDERR        8568      CALUSR        8808      
CALUS1        8818      CPU02         8BE4      CONTINUE      8D8A      
CONT0         8D97      CONT1         8D98      CLSCMD0       8EEC      
CLRPEK        8FD7      CMDTBL        921D      DLL           0010      
DLH           0011      DLAB          0080      DR            0001      
DV2           0040      DV1           0020      DV0           0010      
DM            0004      DSE           0001      DMAPTR        0000      
DP            0007      DSKBUF        7D00      DPTEST        8141      
DPTES1        814C      DPTES2        8156      DPDONE        8191      
DEPOSIT       87A3      DEP1          87B0      DEP2          87C7      
DEP3          87C8      DPDUMP        8B33      DDUMP1        8B39      
ERRORK        7FB0      ERRALL        856C      EXAM          86C4      
EXAM1         86EA      EFS1          8834      EFS2          8846      
EFS3          8858      EFS4          886A      FCR           0012      
FE            0008      F_BOOT        FF00      F_TYPE        FF03      
F_READ        FF06      F_MSG         FF09      F_TYPEX       FF0C      
F_INPUT       FF0F      F_STRCMP      FF12      F_LTRIM       FF15      
F_STRCPY      FF18      F_MEMCPY      FF1B      F_WRTSEC      FF1E      
F_RDSEC       FF21      F_SEEK0       FF24      F_SEEK        FF27      
F_DRIVE       FF2A      F_SETBD       FF2D      F_MUL16       FF30      
F_DIV16       FF33      F_IDERESET    FF36      F_IDEWRITE    FF39      
F_IDEREAD     FF3C      F_INITCALL    FF3F      F_BOOTIDE     FF42      
F_HEXIN       FF45      F_HEXOUT2     FF48      F_HEXOUT4     FF4B      
F_TTY         FF4E      F_MOVER       FF51      F_MINIMON     FF54      
F_FREEMEM     FF57      F_ISNUM       FF5A      F_ATOI        FF5D      
F_UINTOUT     FF60      F_INTOUT      FF63      F_INMSG       FF66      
F_INPUTL      FF69      F_BRKTEST     FF6C      F_FINDTKN     FF6F      
F_ISALPHA     FF72      F_ISHEX       FF75      F_ISALNUM     FF78      
F_IDNUM       FF7B      F_ISTERM      FF7E      F_GETDEV      FF81      
F_VERSION     FFF9      F_BREAD       F800      F_BTYPE       F803      
F_BTEST       F806      F_UTYPE       F809      F_UREAD       F80C      
TASM 1802 Assembler.              boots.asm                        page 130
BTS1802 -- Monitor for the COSMAC Elf 2000

F_UTEST       F80F      F_USETBD      F812      F_GETTOD      F815      
F_SETTOD      F818      F_RDNVR       F81B      F_WRNVR       F81E      
F_IDESIZE     F821      F_IDEID       F824      F_TMTOAS      F82A      
F_DTTOAS      F827      F_RTCTEST     F82D      F_ASTODT      F830      
F_ASTOTM      F833      F_NVRCCHK     F836      FORHLP        84A3      
FREMSG        8B5F      FOLD          9117      FOLD1         9126      
GPIO          0007      GHEX4         90EE      GHEX40        90FC      
GHEX2         90FD      GHEX20        9116      HR24          0002      
HCKMSG        8D3F      IDE_SELECT    0002      IDE_DATA      0003      
IER           0011      IIR           0012      IDEDATA       0000      
IDEERR        0001      IDESCT        0002      IDELBA0       0003      
IDELBA1       0004      IDELBA2       0005      IDELBA3       0006      
IDECMD        0007      IDESTS        0007      INTPC         0001      
IOT           7FA1      ISSPAC        8550      ISSPA1        855E      
ISEOL         8561      INPUT         865F      IHEX          8CB7      
IHEX1         8CDA      IHEX1A        8CEA      IHEX2         8CF3      
IHEX3         8D0C      IHEX4         8D21      IHEX5         8D2B      
IHEX6         8D35      INPASK        8FE2      INERRK        8FE5      
ISHEX         9128      ISHEX2        9141      ISHEX3        9146      
KEY           7F78      LEDS          0004      LCR           0013      
LSR           0015      MCR           0014      MSR           0016      
MONVER        0073      MAIN0         84B6      MAIN2         84BF      
MAIN          84C2      MAIN1         84C6      MAIN10        84DB      
MEMDMP        8701      MEMDM2        8745      MEMDM3        8753      
MEMDM4        875B      MEMDM5        8763      MEMDM6        876E      
MEMDM7        8785      MEMDM8        878A      MEMDM9        87A2      
MERMSG        87D2      NVR_SELECT    0002      NVR_DATA      0003      
NVRA          008A      NVRB          008B      NVRC          008C      
NVRD          008D      NVRFREE       008E      NVRBASE       0000      
NVRBOOT       0000      NVRBAUD       0003      NVRVERS       0005      
NVRSIZE       0006      NVRVER        7F7D      NVRDEFAULT    8094      
NVRL1         81CA      NVRL2         81EE      NVRL3         81F7      
NONVR         8209      NOUART        829F      NOPPI         8319      
NOKBD         834B      NOBOOT        88FF      NODRIVE       896E      
NOSETQ        8A12      NOQMSG        8A1B      NOTIME        8A68      
NORTC         8A6A      NOTSET        8A74      NVRCMD        8C7D      
NVRCLR        8C89      NEWOLD        91F5      OE            0002      
OUTPUT        869E      OVMMSG        8D6F      PE            0004      
PF            0040      PS2KBD        0007      PPI           0006      
PPIEN         0004      PPIA1         0002      PPIA0         0001      
PPIPA         0004      PPIPB         0005      PPIPC         0006      
PPICTL        0007      PC0           0000      PC            0003      
P1            000F      P2            000D      P3            000C      
P4            000B      PASSK         7FAE      PS2VER        7FB3      
PROBE         8943      PROBE1        8972      PROB1A        8989      
PROB1B        8999      PHELP         8EDD      PRTPEK        8FF2      
PRTSBM        901D      P3LEP4        914A      P3LE0         9158      
P3GTP4        915B      RBR           0010      RETPC         0005      
REGS          7F81      RESTA         7FB6      RIGHTS        8019      
ROMCHK        809F      ROMCK1        80AD      RAMTS1        80F7      
RTCINI        8191      RAMSIZE       0020      RUNUSR        87E2      
RUN0          87F8      RUN1          87F9      RUN2          87FD      
RESCMD        88B3      RESETQ        8A10      RTCMS1        8AB1      
RTCMS2        8AC6      RESHLT        8BB5      RESADR        8BC0      
RESBOO        8BD8      RTSMSG        8EFE      REAMSG        8F0B      
RAMTEST       8F1C      RAMTE1        8F27      RAMT0         8F2B      
RAMT0A        8F3A      RAMT1         8F3D      RAMT1A        8F47      
RAMT2         8F56      RAMT2A        8F5C      RAMT2B        8F65      
RAMT3         8F75      RAMT3A        8F7B      RAMT3B        8F84      
TASM 1802 Assembler.              boots.asm                        page 131
BTS1802 -- Monitor for the COSMAC Elf 2000

RAMT3C        8FA0      RAMT4         8FBE      RAMT5         8FCB      
RTMSG1        903F      RBASIC        919E      RBAS1         91A4      
RBAS2         91CB      RASM          9202      RFORTH        920B      
RVISUAL       9214      SWITCHES      0004      SCR           0017      
SQWE          0008      SPEN          0020      SP1           0010      
SP0           0008      SPOFF         0020      SPQ           0030      
SPTONE        0028      SPON          0038      SP            0002      
STACK         7F77      SAVEXP        7F7E      SAVED         7F7F      
SAVEDF        7F80      SYSTEM        8006      SYSINI        809A      
SIZMEM        80CE      SIZME1        80D6      SIZME2        80E8      
SPTST1        82AA      SYSI2B        834B      SYSIN3        835E      
SYSI3A        8393      SYSI3B        83A8      SYSI30        83AB      
SYSIN4        841F      SYSI4A        842E      SYSI5A        843A      
SYSI5B        8452      SCANP2        8584      SCANP1        8591      
SHOW          859E      SHOCMD        85B0      SET           8613      
SETCMD        8625      SHOWEF        8820      SETRESTA      8873      
SETRE1        88A0      SETRBO        88C4      SETRNO        88C8      
SETBO1        88CA      SHOWIDE       8933      SETQ          89FB      
SHOWTIME      8A2E      SHOWNOW       8A3A      SETTIME       8A7E      
SHOWRTC       8AD5      SHOMEM        8B48      SHOTERM       8B6D      
SHORES        8B9D      SHOCPU        8BE3      SHOCP0        8BEF      
SHOCP9        8BF2      SHOVER        8BF5      SETNVR        8C6B      
SHOREG        8E60      SHORE1        8E66      THR           0010      
THRE          0020      TEMT          0040      T1            0009      
T2            000A      TIMBUF        7FA6      TSTPS2        8319      
TPS21         8325      TPS22         832E      TPS23         8335      
TPS24         833E      TEST          8645      TSTCMD        8657      
TRAPX         8DEA      TRAP          8DEB      TRAP2         8E57      
TRAP2A        8EA3      TTYINI        905D      TTYIN0        9073      
TTYIN1        909B      TTYAUT        90AE      TTYAU1        90B5      
TCRLF         90D5      TSPACE        90DF      TTABC         90E4      
TQUEST        90E9      THEX1         915E      THEX11        9168      
THEX2         916D      THEX4         917A      TDEC16        9182      
TDEC1A        9196      TDEC1B        9199      UART_SELECT   0002      
UART_DATA     0003      UIP           0080      UARTOK        7FB2      
UINI          8209      UINI2         825B      UINI4         826E      
UINI5         8286      URCMSG        8D54      VRT           0080      
VRTC          7FAD      VIDVER        7FB4      VERM1         8C4A      
VERM2         8C54      VERM3         8C5E      

tasm: Number of errors = 1
