1802 -> Native
2 Classes read.
186 Patterns read.
    1 0000:             ; *******************************************************************
    2 0000:             ; *** This software is copyright 2020 by Michael H Riley          ***
    3 0000:             ; *** You have permission to use, modify, copy, and distribute    ***
    4 0000:             ; *** this software so long as this copyright notice is retained. ***
    5 0000:             ; *** This software may not be used in commercial applications    ***
    6 0000:             ; *** without express written permission from the author.         ***
    7 0000:             ; *******************************************************************
    8 0000:             
    9 0000:             ;[RLA] These are defined on the rcasm command line!
   10 0000:             ;[RLA] #define ELFOS            ; build the version that runs under Elf/OS
   11 0000:             ;[RLA] #define STGROM           ; build the STG EPROM version
   12 0000:             ;[RLA] #define PICOROM          ; define for Mike's PIcoElf version
   13 0000:             
   14 0000:             ;[RLA]   rcasm doesn't have any way to do a logical "OR" of assembly
   15 0000:             ;[RLA] options, so define a master "ANYROM" option that's true for
   16 0000:             ;[RLA] any of the ROM conditions...
   17 0000:             
            #endif
   21 0000:             
            #ifdef STGROM
            #define ANYROM
            #endif
   25 0000:             
            #ifdef STGROM
   27 0000:             ;[RLA] STG ROM addresses and options
   28 0000:             include config.inc
   29 0000:             ; DO NOT EDIT THIS FILE - EDIT CONFIG. INSTEAD!!
            #define BOOTS	 08000H
            #define WARMB	 (08000H+3)
            #define HELP	 09400H
            #define RAMPAGE	 07F00H
            #define BIOS	 0FF00H
            #define EBIOS	 0F800H
            #define FORTH	 0D700H
            #define EDTASM	 09C00H
            #define BASIC	 0BA00H
            #define VISUAL	 0A900H
            #define XMODEM	 0D400H
            #endif
   42 0000:             
   43 0000:             include    bios.inc
   44 0000:             ; *******************************************************************
   45 0000:             ; *** This software is copyright 2006 by Michael H Riley          ***
   46 0000:             ; *** You have permission to use, modify, copy, and distribute    ***
   47 0000:             ; *** this software so long as this copyright notice is retained. ***
   48 0000:             ; *** This software may not be used in commercial applications    ***
   49 0000:             ; *** without express written permission from the author.         ***
   50 0000:             ; *******************************************************************
   51 0000:             
            #endif
   55 0000:             
   56 0000:             ; Define address for standard BIOS vectors
            #endif
   60 0000:             
   61 0000:             ; Define address for extended BIOS vectors
            #endif
   65 0000:             
            #ifndef TASM
   67 0000:             scall:      equ  r4                    ; register for SCALL
   68 0000:             sret:       equ  r5                    ; register for SRET
   69 0000:             
   70 0000:             call:       equ  0ffe0h                ; depricated
   71 0000:             ret:        equ  0fff1h                ; depricated
            #endif
   73 0000:             
   74 0000:             f_boot:     equ  (BIOS+00h)            ; boot from ide device
   75 0000:             f_type:     equ  (BIOS+03h)            ; type 1 character to console
   76 0000:             f_read:     equ  (BIOS+06h)            ; read 1 character from console
   77 0000:             f_msg:      equ  (BIOS+09h)            ; type asciiz string to console
   78 0000:             f_typex:    equ  (BIOS+0ch)            ; depricated, just returns now
   79 0000:             f_input:    equ  (BIOS+0fh)            ; read asciiz from console
   80 0000:             f_strcmp:   equ  (BIOS+12h)            ; compare 2 strings
   81 0000:             f_ltrim:    equ  (BIOS+15h)            ; trim leading spaces
   82 0000:             f_strcpy:   equ  (BIOS+18h)            ; copy an asciiz string
   83 0000:             f_memcpy:   equ  (BIOS+1bh)            ; copy memory
   84 0000:             f_wrtsec:   equ  (BIOS+1eh)            ; write floppy sector (depricated)
   85 0000:             f_rdsec:    equ  (BIOS+21h)            ; read floppy sector (depricated)
   86 0000:             f_seek0:    equ  (BIOS+24h)            ; floppy seek to track 0 (depricated)
   87 0000:             f_seek:     equ  (BIOS+27h)            ; floopy track seek (depricated)
   88 0000:             f_drive:    equ  (BIOS+2ah)            ; select floppy drive (depricated)
   89 0000:             f_setbd:    equ  (BIOS+2dh)            ; set console baud rate
   90 0000:             f_mul16:    equ  (BIOS+30h)            ; 16-bit multiply
   91 0000:             f_div16:    equ  (BIOS+33h)            ; 16-bit division
   92 0000:             f_idereset: equ  (BIOS+36h)            ; reset ide device
   93 0000:             f_idewrite: equ  (BIOS+39h)            ; write ide sector
   94 0000:             f_ideread:  equ  (BIOS+3ch)            ; read ide sector
   95 0000:             f_initcall: equ  (BIOS+3fh)            ; initialize R4 and R5
   96 0000:             f_bootide:  equ  (BIOS+42h)            ; boot from ide device
   97 0000:             f_hexin:    equ  (BIOS+45h)            ; convert ascii number to hex
   98 0000:             f_hexout2:  equ  (BIOS+48h)            ; convert hex to 2-digit ascii
   99 0000:             f_hexout4:  equ  (BIOS+4bh)            ; convert hex to 4-digit ascii
  100 0000:             f_tty:      equ  (BIOS+4eh)            ; type character to console
  101 0000:             f_mover:    equ  (BIOS+51h)            ; program relocator
  102 0000:             f_minimon:  equ  (BIOS+54h)            ; mini monitor
  103 0000:             f_freemem:  equ  (BIOS+57h)            ; determine memory size
  104 0000:             F_isnum:    equ  (BIOS+5ah)            ; determine if D is numeric
  105 0000:             f_atoi:     equ  (BIOS+5dh)            ; convert ascii to integer
  106 0000:             f_uintout:  equ  (BIOS+60h)            ; convert unsigned integer to ascii
  107 0000:             f_intout:   equ  (BIOS+63h)            ; convert signed integer to ascii
  108 0000:             f_inmsg:    equ  (BIOS+66h)            ; type in-line message
  109 0000:             f_inputl:   equ  (BIOS+69h)            ; read limited line from console
  110 0000:             f_brktest:  equ  (BIOS+6ch)            ; check for serial break
  111 0000:             f_findtkn:  equ  (BIOS+6fh)            ; find token in a token table
  112 0000:             f_isalpha:  equ  (BIOS+72h)            ; determine if D is alphabetic
  113 0000:             f_ishex:    equ  (BIOS+75h)            ; determine if D is hexadecimal
  114 0000:             f_isalnum:  equ  (BIOS+78h)            ; determine if D is alpha or numeric
  115 0000:             f_idnum:    equ  (BIOS+7bh)            ; determine type of ascii number
  116 0000:             f_isterm:   equ  (BIOS+7eh)            ; determine if D is a termination char
  117 0000:             f_getdev:   equ  (BIOS+81h)            ; get supported devices
  118 0000:             
  119 0000:             f_version:  equ  (BIOS+0f9h)           ; 3 bytes holding bios version number
  120 0000:             
  121 0000:             ; "Extended" BIOS vectors
  122 0000:             
  123 0000:             f_bread:     equ  (EBIOS+00h)        ; read from onboard serial port
  124 0000:             f_btype:     equ  (EBIOS+03h)        ; write to onboard serial port
  125 0000:             f_btest:     equ  (EBIOS+06h)        ; test onboard serial port
  126 0000:             f_utype:     equ  (EBIOS+09h)        ; write to disk board UART
  127 0000:             f_uread:     equ  (EBIOS+0ch)        ; read from disk board UART
  128 0000:             f_utest:     equ  (EBIOS+0fh)        ; test disk board UART
  129 0000:             f_usetbd:    equ  (EBIOS+12h)        ; set disk board UART baud rate and format
  130 0000:             f_gettod:    equ  (EBIOS+15h)        ; read time of day clock
  131 0000:             f_settod:    equ  (EBIOS+18h)        ; set time of day clock
  132 0000:             f_rdnvr:     equ  (EBIOS+1bh)        ; read non volatile RAM
  133 0000:             f_wrnvr:     equ  (EBIOS+1eh)        ; write non volatile RAM
  134 0000:             f_idesize:   equ  (EBIOS+21h)        ; return size of attached IDE drive(s)
  135 0000:             f_ideid:     equ  (EBIOS+24h)        ; return device data for IDE drive(s)
  136 0000:             f_tmtoas:    equ  (EBIOS+2ah)        ; time to ASCII string
  137 0000:             f_dttoas:    equ  (EBIOS+27h)        ; date to ASCII string
  138 0000:             f_rtctest:   equ  (EBIOS+2dh)        ; test size and presence of RTC/NVR
  139 0000:             f_astodt:    equ  (EBIOS+30h)        ; convert ASCII string to date
  140 0000:             f_astotm:    equ  (EBIOS+33h)        ; convert ASCII string to time
  141 0000:             f_nvrcchk:   equ  (EBIOS+36h)	    ; [RLA] compute NVR checksum
  142 0000:             
  143 0000:             
            #endif
  147 0000:             
  148 0000:             ; R7 - pointer to R[]
  149 0000:             ; R8.0 - D
  150 0000:             ; R8.1 - DF
  151 0000:             ; R9.0 - P
  152 0000:             ; R9.1 - X
  153 0000:             ; RF - temporary use
  154 0000:             ; RA - Set R7 routine
  155 0000:             ; RB - Retrieve R[r7] into rf
  156 0000:             
            #else
            #ifdef STGROM
  162 0000:                        org     VISUAL
  163 a900:             ;[RLA]  So, for the STGROM we don't actually need to define edtasm.  That's
  164 a900:             ;[RLA] because the config.inc file defines EDTASM, and the current rcasm
  165 a900:             ;[RLA] implementation is case INSENSITIVE for macro substitutions.  The code
  166 a900:             ;[RLA] down below at asm: will just naturally do the right thing without any
  167 a900:             ;[RLA] additional help.  If Mike ever changes rcasm to make #defines case
  168 a900:             ;[RLA] sensitive, then you'll need this line.
  169 a900:             ;[RLA]edtasm:      equ     EDTASM
  170 a900:             
            #endif
            #endif
  179 a900:             
  180 a900:             
  181 a900: c0 a9 06    start:     lbr     start2            ; jump past warm start
  182 a903: c0 b1 58               lbr     begin             ; do not need initcall
  183 a906: f8 7e       start2:    ldi     r0.1              ; get data segment
  184 a908: b2                     phi     r2                ; set into stack register
  185 a909: f8 ff                  ldi     0ffh              ; stack will be at end of segment
  186 a90b: a2                     plo     r2
  187 a90c: e2                     sex     r2                ; set x to 2
  188 a90d: f8 b1                  ldi     high begin
  189 a90f: b6                     phi     r6
  190 a910: f8 58                  ldi     low begin
  191 a912: a6                     plo     r6
  192 a913: c0 ff 3f               lbr     f_initcall
  193 a916:             
  194 a916:             
  195 a916: da          incr:      sep     ra                ; set R7 to correct register
  196 a917: db          incr2:     sep     rb                ; retrieve R register value into rf
  197 a918: 1f                     inc     rf                ; increment value
  198 a919: 17                     inc     r7
  199 a91a: 8f                     glo     rf                ; write value back to R register
  200 a91b: 57                     str     r7
  201 a91c: 27                     dec     r7
  202 a91d: 9f                     ghi     rf
  203 a91e: 57                     str     r7
  204 a91f: d5                     sep     sret
  205 a920:             
  206 a920: 00 41 44 43 
            20 00                  db      0,'ADC ',0
  207 a926: 99          doadc:     ghi     r9                ; get X
  208 a927: da                     sep     ra                ; set R7 to correct R register
  209 a928: db                     sep     rb                ; retrieve value into rf
  210 a929: ef                     sex     rf                ; point x to RF
  211 a92a: 98                     ghi     r8                ; get DF
  212 a92b: f6                     shr                       ; shift bit into df
  213 a92c: 88                     glo     r8                ; get D
  214 a92d: 74                     adc                       ; perform add
  215 a92e: a8                     plo     r8                ; put back into D
  216 a92f: 7e                     shlc                      ; get DF
  217 a930: b8                     phi     r8                ; store DF
  218 a931: e2                     sex     r2                ; restore x
  219 a932: c0 b1 91               lbr     instdn
  220 a935:             
  221 a935: 02 41 44 43 
            49 00                  db      2,'ADCI',0
  222 a93b: 89          doadci:    glo     r9                ; get P
  223 a93c: da                     sep     ra                ; set R7 to correct R register
  224 a93d: db                     sep     rb                ; retrieve value into rf
  225 a93e: ef                     sex     rf                ; point x to RF
  226 a93f: 98                     ghi     r8                ; get DF
  227 a940: f6                     shr                       ; shift bit into df
  228 a941: 88                     glo     r8                ; get D
  229 a942: 74                     adc                       ; perform add
  230 a943: a8                     plo     r8                ; put back into D
  231 a944: 7e                     shlc                      ; get DF
  232 a945: b8                     phi     r8                ; store DF
  233 a946: e2                     sex     r2                ; restore x
  234 a947: c0 ae c4               lbr     incp
  235 a94a:             
  236 a94a: 00 41 44 44 
            20 00                  db      0,'ADD ',0
  237 a950: 99          doadd:     ghi     r9                ; get X
  238 a951: da                     sep     ra                ; set R7 to correct R register
  239 a952: db                     sep     rb                ; retrieve value into rf
  240 a953: ef                     sex     rf                ; point x to RF
  241 a954: 88                     glo     r8                ; get D
  242 a955: f4                     add                       ; perform add
  243 a956: a8                     plo     r8                ; put back into D
  244 a957: 7e                     shlc                      ; get DF
  245 a958: b8                     phi     r8                ; store DF
  246 a959: e2                     sex     r2                ; restore x
  247 a95a: c0 b1 91               lbr     instdn
  248 a95d:             
  249 a95d: 02 41 44 49 
            20 00                  db      2,'ADI ',0
  250 a963: 89          doadi:     glo     r9                ; get P
  251 a964: da                     sep     ra                ; set R7 to correct R register
  252 a965: db                     sep     rb                ; retrieve value into rf
  253 a966: ef                     sex     rf                ; point x to RF
  254 a967: 88                     glo     r8                ; get D
  255 a968: f4                     add                       ; perform add
  256 a969: a8                     plo     r8                ; put back into D
  257 a96a: 7e                     shlc                      ; get DF
  258 a96b: b8                     phi     r8                ; store DF
  259 a96c: e2                     sex     r2                ; restore x
  260 a96d: c0 ae c4               lbr     incp              ; then increment p
  261 a970:             
  262 a970: 00 41 4e 44 
            20 00                  db      0,'AND ',0
  263 a976: 99          doand:     ghi     r9                ; get X
  264 a977: da                     sep     ra                ; set R7 to correct R register
  265 a978: db                     sep     rb                ; retrieve value into rf
  266 a979: ef                     sex     rf                ; point x to RF
  267 a97a: 88                     glo     r8                ; get D
  268 a97b: f2                     and                       ; perform and
  269 a97c: a8                     plo     r8                ; put back into D
  270 a97d: e2                     sex     r2                ; restore x
  271 a97e: c0 b1 91               lbr     instdn
  272 a981:             
  273 a981: 02 41 4e 49 
            20 00                  db      2,'ANI ',0
  274 a987: 89          doani:     glo     r9                ; get P
  275 a988: da                     sep     ra                ; set R7 to correct R register
  276 a989: db                     sep     rb                ; retrieve value into rf
  277 a98a: ef                     sex     rf                ; point x to RF
  278 a98b: 88                     glo     r8                ; get D
  279 a98c: f2                     and                       ; perform and
  280 a98d: a8                     plo     r8                ; put back into D
  281 a98e: e2                     sex     r2                ; restore x
  282 a98f: c0 ae c4               lbr     incp
  283 a992:             
  284 a992: 02 42 31 20 
            20 00                  db      2,'B1  ',0
  285 a998: 34 9d       dob1:      b1      dob1_yes
  286 a99a: c0 ae c4               lbr     incp              ; otherwise increment R[P]
  287 a99d: c0 aa 45    dob1_yes:  lbr     dobr              ; branch
  288 a9a0:             
  289 a9a0: 02 42 32 20 
            20 00                  db      2,'B2  ',0
  290 a9a6: 35 9d       dob2:      b2      dob1_yes          ; branch if b1 set
  291 a9a8: c0 ae c4               lbr     incp              ; otherwise increment R[P]
  292 a9ab:             
  293 a9ab: 02 42 33 20 
            20 00                  db      2,'B3  ',0
  294 a9b1: 36 9d       dob3:      b3      dob1_yes          ; branch if b1 set
  295 a9b3: c0 ae c4               lbr     incp              ; otherwise increment R[P]
  296 a9b6:             
  297 a9b6: 02 42 34 20 
            20 00                  db      2,'B4  ',0
  298 a9bc: 37 9d       dob4:      b4      dob1_yes          ; branch if b1 set
  299 a9be: c0 ae c4               lbr     incp              ; otherwise increment R[P]
  300 a9c1:             
  301 a9c1: 02 42 4e 31 
            20 00                  db      2,'BN1 ',0
  302 a9c7: 3c 9d       dobn1:     bn1     dob1_yes 
  303 a9c9: c0 ae c4               lbr     incp              ; otherwise increment
  304 a9cc:             
  305 a9cc: 02 42 4e 32 
            20 00                  db      2,'BN2 ',0
  306 a9d2: 3d 9d       dobn2:     bn2     dob1_yes 
  307 a9d4: c0 ae c4               lbr     incp              ; otherwise increment
  308 a9d7:             
  309 a9d7: 02 42 4e 33 
            20 00                  db      2,'BN3 ',0
  310 a9dd: 3e 9d       dobn3:     bn3     dob1_yes 
  311 a9df: c0 ae c4               lbr     incp              ; otherwise increment
  312 a9e2:             
  313 a9e2: 02 42 4e 34 
            20 00                  db      2,'BN4 ',0
  314 a9e8: 3f 9d       dobn4:     bn4     dob1_yes 
  315 a9ea: c0 ae c4               lbr     incp              ; otherwise increment
  316 a9ed:             
  317 a9ed: 01 4e 42 52 
            20 00                  db      1,'NBR ',0
  318 a9f3: c0 ae c4    donbr:     lbr     incp 
  319 a9f6:             
  320 a9f6: 02 42 44 46 
            20 00                  db      2,'BDF ',0
  321 a9fc: 98          dobdf:     ghi     r8                ; get DF
  322 a9fd: f6                     shr                       ; shift into df
  323 a9fe: c3 aa 45               lbdf    dobr              ; branch if df is set
  324 aa01: c0 ae c4               lbr     incp              ; otherwise increment R[P]
  325 aa04:             
  326 aa04: 02 42 4e 46 
            20 00                  db      2,'BNF ',0
  327 aa0a: 98          dobnf:     ghi     r8                ; get DF
  328 aa0b: f6                     shr                       ; shift into df
  329 aa0c: cb aa 45               lbnf    dobr              ; branch if df not set
  330 aa0f: c0 ae c4               lbr     incp              ; otherwise increment R[P]
  331 aa12:             
  332 aa12: 02 42 4e 51 
            20 00                  db      2,'BNQ ',0
  333 aa18: f8 20       dobnq:     ldi     q.0               ; address of Q
  334 aa1a: a7                     plo     r7                ; set register pointer
  335 aa1b: 07                     ldn     r7                ; retrieve Q
  336 aa1c: c2 aa 45               lbz     dobr              ; branch if zero
  337 aa1f: c0 ae c4               lbr     incp              ; otherwise increment R[P]
  338 aa22:             
  339 aa22: 02 42 4e 5a 
            20 00                  db      2,'BNZ ',0
  340 aa28: 88          dobnz:     glo     r8                ; get D
  341 aa29: ca aa 45               lbnz    dobr              ; jump if D<>0
  342 aa2c: c0 ae c4               lbr     incp              ; otherwise increment R[P]
  343 aa2f:             
  344 aa2f: 02 42 51 20 
            20 00                  db      2,'BQ  ',0
  345 aa35: f8 20       dobq:      ldi     q.0               ; address of Q
  346 aa37: a7                     plo     r7                ; set register pointer
  347 aa38: 07                     ldn     r7                ; retrieve Q
  348 aa39: ca aa 45               lbnz    dobr              ; branch if nonzero
  349 aa3c: c0 ae c4               lbr     incp              ; otherwise increment R[P]
  350 aa3f:             
  351 aa3f: 02 42 52 20 
            20 00                  db      2,'BR  ',0
  352 aa45: 89          dobr:      glo     r9                ; get P
  353 aa46: da                     sep     ra                ; point r7 to R[P]
  354 aa47: 47                     lda     r7                ; retrieve R[P]
  355 aa48: bf                     phi     rf
  356 aa49: 07                     ldn     r7                ; low byte
  357 aa4a: af                     plo     rf
  358 aa4b: 0f                     ldn     rf                ; get branch address
  359 aa4c: 57                     str     r7                ; write to R[P]
  360 aa4d: c0 b1 91               lbr     instdn
  361 aa50:             
  362 aa50: 02 42 5a 20 
            20 00                  db      2,'BZ  ',0
  363 aa56: 88          dobz:      glo     r8                ; get D
  364 aa57: c2 aa 45               lbz     dobr              ; jump if D=0
  365 aa5a: c0 ae c4               lbr     incp              ; otherwise increment R[P]
  366 aa5d:             
  367 aa5d: 01 44 45 43 
            20 00                  db      1,'DEC ',0
  368 aa63: da          dodec:     sep     ra                ; set R7 to correct register
  369 aa64: db                     sep     rb                ; retrieve into rf
  370 aa65: 2f                     dec     rf                ; decrement value
  371 aa66: 17                     inc     r7
  372 aa67: 8f                     glo     rf                ; write value back to R register
  373 aa68: 57                     str     r7
  374 aa69: 27                     dec     r7
  375 aa6a: 9f                     ghi     rf
  376 aa6b: 57                     str     r7
  377 aa6c: c0 b1 91               lbr     instdn
  378 aa6f:             
  379 aa6f: 00 44 49 53 
            20 00                  db      0,'DIS ',0
  380 aa75: 99          dodis:     ghi     r9                ; get X
  381 aa76: da                     sep     ra                ; set R7 to correct R register
  382 aa77: db                     sep     rb                ; retrieve value into rf
  383 aa78: 99                     ghi     r9                ; need to keep original X
  384 aa79: ae                     plo     re
  385 aa7a: 0f                     ldn     rf                ; get value from memory
  386 aa7b: fa 0f                  ani     0fh               ; keep only low nybble
  387 aa7d: a9                     plo     r9                ; put into P
  388 aa7e: 0f                     ldn     rf                ; get value from memory again
  389 aa7f: f6                     shr                       ; shift high nybble to low
  390 aa80: f6                     shr
  391 aa81: f6                     shr
  392 aa82: f6                     shr
  393 aa83: b9                     phi     r9                ; and store into X
  394 aa84: f8 22                  ldi     ie.0              ; address of ie register
  395 aa86: a7                     plo     r7
  396 aa87: f8 00                  ldi     0                 ; need to disable
  397 aa89: 57                     str     r7
  398 aa8a: 8e                     glo     re                ; recover original X
  399 aa8b: c0 aa 9d               lbr     doinc             ; then increment x
  400 aa8e:             
  401 aa8e: 00 49 44 4c 
            20 00                  db      0,'IDL ',0
  402 aa94: c0 b1 91    doidl:     lbr     instdn
  403 aa97:             
  404 aa97: 01 49 4e 43 
            20 00                  db      1,'INC ',0
  405 aa9d: d4          doinc:     sep     scall             ; Call increment R
  406 aa9e: a9 16                  dw      incr
  407 aaa0: c0 b1 91               lbr     instdn
  408 aaa3:             
  409 aaa3: 00 49 4e 50 
            31 00                  db      0,'INP1',0
  410 aaa9: 99          doinp1:    ghi     r9                ; get X
  411 aaaa: da                     sep     ra                ; set R7 to correct R register
  412 aaab: db                     sep     rb                ; retrieve value into rf
  413 aaac: ef                     sex     rf                ; point x to RF
  414 aaad: 69                     inp     1                 ; perform out
  415 aaae: e2                     sex     r2                ; restore x
  416 aaaf: a8                     plo     r8                ; store D
  417 aab0: c0 b1 91               lbr     instdn            ; done
  418 aab3:             
  419 aab3: 00 49 4e 50 
            32 00                  db      0,'INP2',0
  420 aab9: 99          doinp2:    ghi     r9                ; get X
  421 aaba: da                     sep     ra                ; set R7 to correct R register
  422 aabb: db                     sep     rb                ; retrieve value into rf
  423 aabc: ef                     sex     rf                ; point x to RF
  424 aabd: 6a                     inp     2                 ; perform out
  425 aabe: e2                     sex     r2                ; restore x
  426 aabf: a8                     plo     r8                ; store D
  427 aac0: c0 b1 91               lbr     instdn            ; done
  428 aac3:             
  429 aac3: 00 49 4e 50 
            33 00                  db      0,'INP3',0
  430 aac9: 99          doinp3:    ghi     r9                ; get X
  431 aaca: da                     sep     ra                ; set R7 to correct R register
  432 aacb: db                     sep     rb                ; retrieve value into rf
  433 aacc: ef                     sex     rf                ; point x to RF
  434 aacd: 6b                     inp     3                 ; perform out
  435 aace: e2                     sex     r2                ; restore x
  436 aacf: a8                     plo     r8                ; store D
  437 aad0: c0 b1 91               lbr     instdn            ; done
  438 aad3:             
  439 aad3: 00 49 4e 50 
            34 00                  db      0,'INP4',0
  440 aad9: 99          doinp4:    ghi     r9                ; get X
  441 aada: da                     sep     ra                ; set R7 to correct R register
  442 aadb: db                     sep     rb                ; retrieve value into rf
  443 aadc: ef                     sex     rf                ; point x to RF
  444 aadd: 6c                     inp     4                 ; perform out
  445 aade: e2                     sex     r2                ; restore x
  446 aadf: a8                     plo     r8                ; store D
  447 aae0: c0 b1 91               lbr     instdn            ; done
  448 aae3:             
  449 aae3: 00 49 4e 50 
            35 00                  db      0,'INP5',0
  450 aae9: 99          doinp5:    ghi     r9                ; get X
  451 aaea: da                     sep     ra                ; set R7 to correct R register
  452 aaeb: db                     sep     rb                ; retrieve value into rf
  453 aaec: ef                     sex     rf                ; point x to RF
  454 aaed: 69                     inp     1                 ; perform out
  455 aaee: e2                     sex     r2                ; restore x
  456 aaef: a8                     plo     r8                ; store D
  457 aaf0: c0 b1 91               lbr     instdn            ; done
  458 aaf3:             
  459 aaf3: 00 49 4e 50 
            36 00                  db      0,'INP6',0
  460 aaf9: 99          doinp6:    ghi     r9                ; get X
  461 aafa: da                     sep     ra                ; set R7 to correct R register
  462 aafb: db                     sep     rb                ; retrieve value into rf
  463 aafc: ef                     sex     rf                ; point x to RF
  464 aafd: 6e                     inp     6                 ; perform out
  465 aafe: e2                     sex     r2                ; restore x
  466 aaff: a8                     plo     r8                ; store D
  467 ab00: c0 b1 91               lbr     instdn            ; done
  468 ab03:             
  469 ab03: 00 49 4e 50 
            37 00                  db      0,'INP7',0
  470 ab09: 99          doinp7:    ghi     r9                ; get X
  471 ab0a: da                     sep     ra                ; set R7 to correct R register
  472 ab0b: db                     sep     rb                ; retrieve value into rf
  473 ab0c: ef                     sex     rf                ; point x to RF
  474 ab0d: 6f                     inp     7                 ; perform out
  475 ab0e: e2                     sex     r2                ; restore x
  476 ab0f: a8                     plo     r8                ; store D
  477 ab10: c0 b1 91               lbr     instdn            ; done
  478 ab13:             
  479 ab13: 00 49 52 58 
            20 00                  db      0,'IRX ',0
  480 ab19: 99          doirx:     ghi     r9                ; get x
  481 ab1a: d4                     sep     scall             ; call increment register
  482 ab1b: a9 16                  dw      incr
  483 ab1d: c0 b1 91               lbr     instdn            ; finished
  484 ab20:             
  485 ab20: 01 47 48 49 
            20 00                  db      1,'GHI ',0
  486 ab26: da          doghi:     sep     ra                ; set R7 to correct R register
  487 ab27: 07                     ldn     r7                ; retrieve msb
  488 ab28: a8                     plo     r8                ; put into D
  489 ab29: c0 b1 91               lbr     instdn
  490 ab2c:             
  491 ab2c: 01 47 4c 4f 
            20 00                  db      1,'GLO ',0
  492 ab32: da          doglo:     sep     ra                ; set R7 to correct R register
  493 ab33: 17                     inc     r7                ; point to lsb
  494 ab34: 07                     ldn     r7                ; retrieve it
  495 ab35: a8                     plo     r8                ; put into D
  496 ab36: c0 b1 91               lbr     instdn
  497 ab39:             
  498 ab39: 04 4c 42 44 
            46 00                  db      4,'LBDF',0
  499 ab3f: 98          dolbdf:    ghi     r8                ; get DF
  500 ab40: f6                     shr                       ; shift into df
  501 ab41: c3 ab 95               lbdf    dolbr             ; perform branch if DF is set
  502 ab44: c0 ac 7f               lbr     donlbr            ; otherwise skip
  503 ab47:             
  504 ab47: 04 4c 42 4e 
            46 00                  db      4,'LBNF',0
  505 ab4d: 98          dolbnf:    ghi     r8                ; get DF
  506 ab4e: f6                     shr                       ; shift into df
  507 ab4f: cb ab 95               lbnf    dolbr             ; perform branch if DF is zero
  508 ab52: c0 ac 7f               lbr     donlbr            ; otherwise skip
  509 ab55:             
  510 ab55: 04 4c 42 4e 
            51 00                  db      4,'LBNQ',0
  511 ab5b: f8 20       dolbnq:    ldi     q.0               ; point to Q 
  512 ab5d: a7                     plo     r7                ; store into register pointer
  513 ab5e: 07                     ldn     r7                ; get Q
  514 ab5f: c9 ab 95               lbnq    dolbr             ; perform branch if Q is zero
  515 ab62: c0 ac 7f               lbr     donlbr            ; otherwise skip
  516 ab65:             
  517 ab65: 04 4c 42 4e 
            5a 00                  db      4,'LBNZ',0
  518 ab6b: 88          dolbnz:    glo     r8                ; get D
  519 ab6c: ca ab 95               lbnz    dolbr             ; perform branch if Z is nonzero
  520 ab6f: c0 ac 7f               lbr     donlbr            ; otherwise skip
  521 ab72:             
  522 ab72: 04 4c 42 51 
            20 00                  db      4,'LBQ ',0
  523 ab78: f8 20       dolbq:     ldi     q.0               ; point to Q 
  524 ab7a: a7                     plo     r7                ; store into register pointer
  525 ab7b: 07                     ldn     r7                ; get Q
  526 ab7c: c1 ab 95               lbq     dolbr             ; perform branch if Q is set
  527 ab7f: c0 ac 7f               lbr     donlbr            ; otherwise skip
  528 ab82:             
  529 ab82: 04 4c 42 5a 
            20 00                  db      4,'LBZ ',0
  530 ab88: 88          dolbz:     glo     r8                ; get D
  531 ab89: c2 ab 95               lbz     dolbr             ; perform branch if Z is zero
  532 ab8c: c0 ac 7f               lbr     donlbr            ; otherwise skip
  533 ab8f:             
  534 ab8f: 04 4c 42 52 
            20 00                  db      4,'LBR ',0
  535 ab95: 89          dolbr:     glo     r9                ; get P
  536 ab96: da                     sep     ra                ; set R7 to correct R register
  537 ab97: db                     sep     rb                ; retrieve into rf
  538 ab98: 0f                     ldn     rf                ; read high byte
  539 ab99: 57                     str     r7                ; store into R[P]
  540 ab9a: 1f                     inc     rf                ; point to low byte
  541 ab9b: 17                     inc     r7
  542 ab9c: 0f                     ldn     rf                ; read low byte
  543 ab9d: 57                     str     r7                ; store into R[P]
  544 ab9e: c0 b1 91               lbr     instdn
  545 aba1:                     
  546 aba1: 01 4c 44 41 
            20 00                  db      1,'LDA ',0
  547 aba7: da          dolda:     sep     ra                ; set R7 to correct R register
  548 aba8: db                     sep     rb                ; retrieve into rf
  549 aba9: 0f                     ldn     rf
  550 abaa: a8                     plo     r8
  551 abab: d4                     sep     scall             ; now increment R
  552 abac: a9 17                  dw      incr2
  553 abae: c0 b1 91               lbr     instdn
  554 abb1:             
  555 abb1: 02 4c 44 49 
            20 00                  db      2,'LDI ',0
  556 abb7: 89          doldi:     glo     r9                ; get P
  557 abb8: da                     sep     ra                ; set R7 to correct R register
  558 abb9: db                     sep     rb                ; retrieve value into rf
  559 abba: 0f                     ldn     rf                ; retrieve value from memory
  560 abbb: a8                     plo     r8                ; store into D
  561 abbc: c0 ae c4               lbr     incp              ; increment P
  562 abbf:             
  563 abbf: 01 4c 44 4e 
            20 00                  db      1,'LDN ',0
  564 abc5: da          doldn:     sep     ra                ; set R7 to correct R register
  565 abc6: db                     sep     rb                ; retrieve into rf
  566 abc7: 0f                     ldn     rf
  567 abc8: a8                     plo     r8
  568 abc9: c0 b1 91               lbr     instdn
  569 abcc:             
  570 abcc: 00 4c 44 58 
            20 00                  db      0,'LDX ',0
  571 abd2: 99          doldx:     ghi     r9                ; get X
  572 abd3: da                     sep     ra                ; set R7 to correct R register
  573 abd4: db                     sep     rb                ; retrieve value into rf
  574 abd5: 0f                     ldn     rf                ; retrieve value from memory
  575 abd6: a8                     plo     r8                ; store into D
  576 abd7: c0 b1 91               lbr     instdn
  577 abda:             
  578 abda: 00 4c 44 58 
            41 00                  db      0,'LDXA',0
  579 abe0: 99          doldxa:    ghi     r9                ; get X
  580 abe1: da                     sep     ra                ; set R7 to correct R register
  581 abe2: db                     sep     rb                ; retrieve value into rf
  582 abe3: 0f                     ldn     rf                ; retrieve value from memory
  583 abe4: a8                     plo     r8                ; store into D
  584 abe5: c0 ab 19               lbr     doirx             ; then increment R[X]
  585 abe8:             
  586 abe8: 00 4c 53 44 
            46 00                  db      0,'LSDF',0
  587 abee: 98          dolsdf:    ghi     r8                ; get DF
  588 abef: f6                     shr                       ; shift into df
  589 abf0: c3 ac 7f               lbdf    donlbr            ; perform skip if DF is nonzero
  590 abf3: c0 b1 91               lbr     instdn            ; otherwise done
  591 abf6:             
  592 abf6: 00 4c 53 49 
            45 00                  db      0,'LSIE',0
  593 abfc: f8 22       dolsie:    ldi     ie.0              ; point to IE 
  594 abfe: a7                     plo     r7                ; store into register pointer
  595 abff: 07                     ldn     r7                ; get Q
  596 ac00: ca ac 7f               lbnz    donlbr            ; perform skip if IE is nonzero
  597 ac03: c0 b1 91               lbr     instdn            ; otherwise done
  598 ac06:             
  599 ac06: 00 4c 53 4e 
            46 00                  db      0,'LSNF',0
  600 ac0c: 98          dolsnf:    ghi     r8                ; get DF
  601 ac0d: f6                     shr                       ; shift into df
  602 ac0e: cb ac 7f               lbnf    donlbr            ; perform skip if DF is zero
  603 ac11: c0 b1 91               lbr     instdn            ; otherwise done
  604 ac14:             
  605 ac14: 00 4c 53 4e 
            51 00                  db      0,'LSNQ',0
  606 ac1a: f8 20       dolsnq:    ldi     q.0               ; point to Q 
  607 ac1c: a7                     plo     r7                ; store into register pointer
  608 ac1d: 07                     ldn     r7                ; get Q
  609 ac1e: c2 ac 7f               lbz     donlbr            ; perform skip if Q is zero
  610 ac21: c0 b1 91               lbr     instdn            ; otherwise done
  611 ac24:             
  612 ac24: 00 4c 53 4e 
            5a 00                  db      0,'LSNZ',0
  613 ac2a: 88          dolsnz:    glo     r8                ; get D
  614 ac2b: ca ac 7f               lbnz    donlbr            ; perform skip if Q is zero
  615 ac2e: c0 b1 91               lbr     instdn            ; otherwise done
  616 ac31:             
  617 ac31: 00 4c 53 51 
            20 00                  db      0,'LSQ ',0
  618 ac37: f8 20       dolsq:     ldi     q.0               ; point to Q 
  619 ac39: a7                     plo     r7                ; store into register pointer
  620 ac3a: 07                     ldn     r7                ; get Q
  621 ac3b: ca ac 7f               lbnz    donlbr            ; perform skip if Q is nonzero
  622 ac3e: c0 b1 91               lbr     instdn            ; otherwise done
  623 ac41:             
  624 ac41: 00 4c 53 5a 
            20 00                  db      0,'LSZ ',0
  625 ac47: 88          dolsz:     glo     r8                ; get D
  626 ac48: c2 ac 7f               lbz     donlbr            ; perform skip if D is zero
  627 ac4b: c0 b1 91               lbr     instdn            ; otherwise done
  628 ac4e:             
  629 ac4e:             
  630 ac4e:             
  631 ac4e:             
  632 ac4e: 00 4d 41 52 
            4b 00                  db      0,'MARK',0
  633 ac54: f8 21       domark:    ldi     t.0               ; Point to T register
  634 ac56: a7                     plo     r7                ; put into register pointer
  635 ac57: 89                     glo     r9                ; get P
  636 ac58: 57                     str     r7                ; put into T
  637 ac59: 99                     ghi     r9                ; get X
  638 ac5a: fe                     shl                       ; move over 1 nybble
  639 ac5b: fe                     shl
  640 ac5c: fe                     shl
  641 ac5d: fe                     shl
  642 ac5e: e7                     sex     r7                ; point x to T
  643 ac5f: f1                     or                        ; combine with P
  644 ac60: 57                     str     r7                ; and store it
  645 ac61: e2                     sex     r2                ; point x back
  646 ac62: f8 02                  ldi     2                 ; need register 2
  647 ac64: da                     sep     ra                ; set r7
  648 ac65: db                     sep     rb                ; read into rf
  649 ac66: f8 21                  ldi     t.0               ; point to T
  650 ac68: a7                     plo     r7                ; set into register pointer
  651 ac69: 07                     ldn     r7                ; read t
  652 ac6a: 5f                     str     rf                ; and write to M(R[2])
  653 ac6b: 89                     glo     r9                ; get P
  654 ac6c: b9                     phi     r9                ; and copy to X
  655 ac6d: 2f                     dec     rf                ; R[2] - 1
  656 ac6e: f8 02                  ldi     2                 ; need to point to R2
  657 ac70: da                     sep     ra                ; set r7 to register
  658 ac71: 9f                     ghi     rf                ; write value of R[2] back
  659 ac72: 57                     str     r7
  660 ac73: 17                     inc     r7
  661 ac74: 8f                     glo     rf
  662 ac75: 57                     str     r7
  663 ac76: c0 b1 91               lbr     instdn
  664 ac79:             
  665 ac79: 02 4e 4c 42 
            52 00                  db      2,'NLBR',0
  666 ac7f: 89          donlbr:    glo     r9                ; get P
  667 ac80: da                     sep     ra                ; set R7 to correct R register
  668 ac81: db                     sep     rb                ; retrieve into rf
  669 ac82: 1f                     inc     rf                ; add 2
  670 ac83: 1f                     inc     rf
  671 ac84: 9f                     ghi     rf                ; write back to R[P]
  672 ac85: 57                     str     r7
  673 ac86: 17                     inc     r7
  674 ac87: 8f                     glo     rf                ; get low byte
  675 ac88: 57                     str     r7                ; write to R[P]
  676 ac89: c0 b1 91               lbr     instdn
  677 ac8c:             
  678 ac8c: 00 4e 4f 50 
            20 00                  db      0,'NOP ',0
  679 ac92: c0 b1 91    donop:     lbr     instdn
  680 ac95:             
  681 ac95: 00 4f 52 20 
            20 00                  db      0,'OR  ',0
  682 ac9b: 99          door:      ghi     r9                ; get X
  683 ac9c: da                     sep     ra                ; set R7 to correct R register
  684 ac9d: db                     sep     rb                ; retrieve value into rf
  685 ac9e: ef                     sex     rf                ; point x to RF
  686 ac9f: 88                     glo     r8                ; get D
  687 aca0: f1                     or                        ; perform or
  688 aca1: a8                     plo     r8                ; put back into D
  689 aca2: e2                     sex     r2                ; restore x
  690 aca3: c0 b1 91               lbr     instdn
  691 aca6:             
  692 aca6: 02 4f 52 49 
            20 00                  db      2,'ORI ',0
  693 acac: 89          doori:     glo     r9                ; get P
  694 acad: da                     sep     ra                ; set R7 to correct R register
  695 acae: db                     sep     rb                ; retrieve value into rf
  696 acaf: ef                     sex     rf                ; point x to RF
  697 acb0: 88                     glo     r8                ; get D
  698 acb1: f1                     or                        ; perform or
  699 acb2: a8                     plo     r8                ; put back into D
  700 acb3: e2                     sex     r2                ; restore x
  701 acb4: c0 ae c4               lbr     incp              ; then increment P
  702 acb7:             
  703 acb7: 00 4f 55 54 
            31 00                  db      0,'OUT1',0
  704 acbd: 99          doout1:    ghi     r9                ; get X
  705 acbe: da                     sep     ra                ; set R7 to correct R register
  706 acbf: db                     sep     rb                ; retrieve value into rf
  707 acc0: ef                     sex     rf                ; point x to RF
  708 acc1: 61                     out     1                 ; perform out
  709 acc2: e2                     sex     r2                ; restore x
  710 acc3: c0 ab 19               lbr     doirx             ; then increment R[X]
  711 acc6:             
  712 acc6: 00 4f 55 54 
            32 00                  db      0,'OUT2',0
  713 accc: 99          doout2:    ghi     r9                ; get X
  714 accd: da                     sep     ra                ; set R7 to correct R register
  715 acce: db                     sep     rb                ; retrieve value into rf
  716 accf: ef                     sex     rf                ; point x to RF
  717 acd0: 62                     out     2                 ; perform out
  718 acd1: e2                     sex     r2                ; restore x
  719 acd2: c0 ab 19               lbr     doirx             ; then increment R[X]
  720 acd5:             
  721 acd5: 00 4f 55 54 
            33 00                  db      0,'OUT3',0
  722 acdb: 99          doout3:    ghi     r9                ; get X
  723 acdc: da                     sep     ra                ; set R7 to correct R register
  724 acdd: db                     sep     rb                ; retrieve value into rf
  725 acde: ef                     sex     rf                ; point x to RF
  726 acdf: 63                     out     3                 ; perform out
  727 ace0: e2                     sex     r2                ; restore x
  728 ace1: c0 ab 19               lbr     doirx             ; then increment R[X]
  729 ace4:             
  730 ace4: 00 4f 55 54 
            34 00                  db      0,'OUT4',0
  731 acea: 99          doout4:    ghi     r9                ; get X
  732 aceb: da                     sep     ra                ; set R7 to correct R register
  733 acec: db                     sep     rb                ; retrieve value into rf
  734 aced: ef                     sex     rf                ; point x to RF
  735 acee: 64                     out     4                 ; perform out
  736 acef: e2                     sex     r2                ; restore x
  737 acf0: c0 ab 19               lbr     doirx             ; then increment R[X]
  738 acf3:             
  739 acf3: 00 4f 55 54 
            35 00                  db      0,'OUT5',0
  740 acf9: 99          doout5:    ghi     r9                ; get X
  741 acfa: da                     sep     ra                ; set R7 to correct R register
  742 acfb: db                     sep     rb                ; retrieve value into rf
  743 acfc: ef                     sex     rf                ; point x to RF
  744 acfd: 65                     out     5                 ; perform out
  745 acfe: e2                     sex     r2                ; restore x
  746 acff: c0 ab 19               lbr     doirx             ; then increment R[X]
  747 ad02:             
  748 ad02: 00 4f 55 54 
            36 00                  db      0,'OUT6',0
  749 ad08: 99          doout6:    ghi     r9                ; get X
  750 ad09: da                     sep     ra                ; set R7 to correct R register
  751 ad0a: db                     sep     rb                ; retrieve value into rf
  752 ad0b: ef                     sex     rf                ; point x to RF
  753 ad0c: 66                     out     6                 ; perform out
  754 ad0d: e2                     sex     r2                ; restore x
  755 ad0e: c0 ab 19               lbr     doirx             ; then increment R[X]
  756 ad11:             
  757 ad11: 00 4f 55 54 
            37 00                  db      0,'OUT7',0
  758 ad17: 99          doout7:    ghi     r9                ; get X
  759 ad18: da                     sep     ra                ; set R7 to correct R register
  760 ad19: db                     sep     rb                ; retrieve value into rf
  761 ad1a: ef                     sex     rf                ; point x to RF
  762 ad1b: 67                     out     7                 ; perform out
  763 ad1c: e2                     sex     r2                ; restore x
  764 ad1d: c0 ab 19               lbr     doirx             ; then increment R[X]
  765 ad20:             
  766 ad20: 01 50 48 49 
            20 00                  db      1,'PHI ',0
  767 ad26: da          dophi:     sep     ra                ; set R7 to correct R register
  768 ad27: 88                     glo     r8                ; get D
  769 ad28: 57                     str     r7                ; store into R register
  770 ad29: c0 b1 91               lbr     instdn
  771 ad2c:             
  772 ad2c: 01 50 4c 4f 
            20 00                  db      1,'PLO ',0
  773 ad32: da          doplo:     sep     ra                ; set R7 to correct R register
  774 ad33: 17                     inc     r7                ; point to lsb
  775 ad34: 88                     glo     r8                ; get D
  776 ad35: 57                     str     r7                ; store into R register
  777 ad36: c0 b1 91               lbr     instdn
  778 ad39:             
  779 ad39: 00 52 45 54 
            20 00                  db      0,'RET ',0
  780 ad3f: 99          doret:     ghi     r9                ; get X
  781 ad40: da                     sep     ra                ; set R7 to correct R register
  782 ad41: db                     sep     rb                ; retrieve value into rf
  783 ad42: 99                     ghi     r9                ; save current X
  784 ad43: ae                     plo     re
  785 ad44: 0f                     ldn     rf                ; get value from memory
  786 ad45: fa 0f                  ani     0fh               ; keep only low nybble
  787 ad47: a9                     plo     r9                ; put into P
  788 ad48: 0f                     ldn     rf                ; get value from memory again
  789 ad49: f6                     shr                       ; shift high nybble to low
  790 ad4a: f6                     shr
  791 ad4b: f6                     shr
  792 ad4c: f6                     shr
  793 ad4d: b9                     phi     r9                ; and store into X
  794 ad4e: f8 22                  ldi     ie.0              ; address of ie register
  795 ad50: a7                     plo     r7
  796 ad51: f8 01                  ldi     1                 ; need to enable
  797 ad53: 57                     str     r7
  798 ad54: 8e                     glo     re                ; recover original X
  799 ad55: c0 aa 9d               lbr     doinc             ; then increment x
  800 ad58:             
  801 ad58: 00 52 45 51 
            20 00                  db      0,'REQ ',0
  802 ad5e: f8 20       doreq:     ldi     q.0               ; need address of Q
  803 ad60: a7                     plo     r7                ; set into register pointer
  804 ad61: f8 00                  ldi     0                 ; need zero
  805 ad63: 57                     str     r7                ; save to Q
  806 ad64: c0 b1 91               lbr     instdn
  807 ad67:             
  808 ad67: 00 53 41 56 
            20 00                  db      0,'SAV ',0
  809 ad6d: 99          dosav:     ghi     r9                ; get X
  810 ad6e: da                     sep     ra                ; set R7 to correct R register
  811 ad6f: db                     sep     rb                ; retrieve value into rf
  812 ad70: f8 21                  ldi     t.0               ; point to T register
  813 ad72: a7                     plo     r7                ; put into register pointer
  814 ad73: 07                     ldn     r7                ; read value of T
  815 ad74: 5f                     str     rf                ; store to M(R[X])
  816 ad75: c0 b1 91               lbr     instdn
  817 ad78:             
  818 ad78: 00 53 44 20 
            20 00                  db      0,'SD  ',0
  819 ad7e: 99          dosd:      ghi     r9                ; get X
  820 ad7f: da                     sep     ra                ; set R7 to correct R register
  821 ad80: db                     sep     rb                ; retrieve value into rf
  822 ad81: ef                     sex     rf                ; point x to RF
  823 ad82: 88                     glo     r8                ; get D
  824 ad83: f5                     sd                        ; perform subtraction
  825 ad84: a8                     plo     r8                ; put back into D
  826 ad85: 7e                     shlc                      ; get DF
  827 ad86: b8                     phi     r8                ; store DF
  828 ad87: e2                     sex     r2                ; restore x
  829 ad88: c0 b1 91               lbr     instdn
  830 ad8b:             
  831 ad8b: 00 53 44 42 
            20 00                  db      0,'SDB ',0
  832 ad91: 99          dosdb:     ghi     r9                ; get X
  833 ad92: da                     sep     ra                ; set R7 to correct R register
  834 ad93: db                     sep     rb                ; retrieve value into rf
  835 ad94: ef                     sex     rf                ; point x to RF
  836 ad95: 98                     ghi     r8                ; get DF
  837 ad96: f6                     shr                       ; shift bit into df
  838 ad97: 88                     glo     r8                ; get D
  839 ad98: 75                     sdb                       ; perform subtraction
  840 ad99: a8                     plo     r8                ; put back into D
  841 ad9a: 7e                     shlc                      ; get DF
  842 ad9b: b8                     phi     r8                ; store DF
  843 ad9c: e2                     sex     r2                ; restore x
  844 ad9d: c0 b1 91               lbr     instdn
  845 ada0:             
  846 ada0: 02 53 44 42 
            49 00                  db      2,'SDBI',0
  847 ada6: 89          dosdbi:    glo     r9                ; get P
  848 ada7: da                     sep     ra                ; set R7 to correct R register
  849 ada8: db                     sep     rb                ; retrieve value into rf
  850 ada9: ef                     sex     rf                ; point x to RF
  851 adaa: 98                     ghi     r8                ; get DF
  852 adab: f6                     shr                       ; shift bit into df
  853 adac: 88                     glo     r8                ; get D
  854 adad: 75                     sdb                       ; perform subtraction
  855 adae: a8                     plo     r8                ; put back into D
  856 adaf: 7e                     shlc                      ; get DF
  857 adb0: b8                     phi     r8                ; store DF
  858 adb1: e2                     sex     r2                ; restore x
  859 adb2: c0 ae c4               lbr     incp
  860 adb5:             
  861 adb5: 02 53 44 49 
            20 00                  db      2,'SDI ',0
  862 adbb: 89          dosdi:     glo     r9                ; get P
  863 adbc: da                     sep     ra                ; set R7 to correct R register
  864 adbd: db                     sep     rb                ; retrieve value into rf
  865 adbe: ef                     sex     rf                ; point x to RF
  866 adbf: 88                     glo     r8                ; get D
  867 adc0: f5                     sd                        ; perform subtraction
  868 adc1: a8                     plo     r8                ; put back into D
  869 adc2: 7e                     shlc                      ; get DF
  870 adc3: b8                     phi     r8                ; store DF
  871 adc4: e2                     sex     r2                ; restore x
  872 adc5: c0 ae c4               lbr     incp              ; then increment p
  873 adc8:             
  874 adc8: 01 53 45 50 
            20 00                  db      1,'SEP ',0
  875 adce: a9          dosep:     plo     r9                ; store into P
  876 adcf: c0 b1 91               lbr     instdn
  877 add2:             
  878 add2: 00 53 45 51 
            20 00                  db      0,'SEQ ',0
  879 add8: f8 20       doseq:     ldi     q.0               ; need address of Q
  880 adda: a7                     plo     r7                ; set into register pointer
  881 addb: f8 01                  ldi     1                 ; need one
  882 addd: 57                     str     r7                ; save to Q
  883 adde: c0 b1 91               lbr     instdn
  884 ade1:             
  885 ade1: 01 53 45 58 
            20 00                  db      1,'SEX ',0
  886 ade7: b9          dosex:     phi     r9                ; store into X
  887 ade8: c0 b1 91               lbr     instdn
  888 adeb:             
  889 adeb: 00 53 48 4c 
            20 00                  db      0,'SHL ',0
  890 adf1: 88          doshl:     glo     r8                ; get D
  891 adf2: fe                     shl                       ; shift left
  892 adf3: a8                     plo     r8                ; put it back
  893 adf4: 7e                     shlc                      ; shift df into d
  894 adf5: b8                     phi     r8                ; store into DF
  895 adf6: c0 b1 91               lbr     instdn
  896 adf9:             
  897 adf9: 00 53 48 4c 
            43 00                  db      0,'SHLC',0
  898 adff: 98          doshlc:    ghi     r8                ; get DF
  899 ae00: f6                     shr                       ; shift bit into df
  900 ae01: 88                     glo     r8                ; get D
  901 ae02: 7e                     shlc                      ; shift right
  902 ae03: a8                     plo     r8                ; put it back
  903 ae04: 7e                     shlc                      ; shift df into d
  904 ae05: b8                     phi     r8                ; store into DF
  905 ae06: c0 b1 91               lbr     instdn
  906 ae09:             
  907 ae09: 00 53 48 52 
            20 00                  db      0,'SHR ',0
  908 ae0f: 88          doshr:     glo     r8                ; get D
  909 ae10: f6                     shr                       ; shift right
  910 ae11: a8                     plo     r8                ; put it back
  911 ae12: 7e                     shlc                      ; shift df into d
  912 ae13: b8                     phi     r8                ; store into DF
  913 ae14: c0 b1 91               lbr     instdn
  914 ae17:             
  915 ae17: 00 53 48 52 
            43 00                  db      0,'SHRC',0
  916 ae1d: 98          doshrc:    ghi     r8                ; get DF
  917 ae1e: f6                     shr                       ; shift bit into df
  918 ae1f: 88                     glo     r8                ; get D
  919 ae20: 76                     shrc                      ; shift right
  920 ae21: a8                     plo     r8                ; put it back
  921 ae22: 7e                     shlc                      ; shift df into d
  922 ae23: b8                     phi     r8                ; store into DF
  923 ae24: c0 b1 91               lbr     instdn
  924 ae27:             
  925 ae27: 00 53 4d 20 
            20 00                  db      0,'SM  ',0
  926 ae2d: 99          dosm:      ghi     r9                ; get X
  927 ae2e: da                     sep     ra                ; set R7 to correct R register
  928 ae2f: db                     sep     rb                ; retrieve value into rf
  929 ae30: ef                     sex     rf                ; point x to RF
  930 ae31: 88                     glo     r8                ; get D
  931 ae32: f7                     sm                        ; perform subtraction
  932 ae33: a8                     plo     r8                ; put back into D
  933 ae34: 7e                     shlc                      ; get DF
  934 ae35: b8                     phi     r8                ; store DF
  935 ae36: e2                     sex     r2                ; restore x
  936 ae37: c0 b1 91               lbr     instdn
  937 ae3a:             
  938 ae3a: 00 53 4d 42 
            20 00                  db      0,'SMB ',0
  939 ae40: 99          dosmb:     ghi     r9                ; get X
  940 ae41: da                     sep     ra                ; set R7 to correct R register
  941 ae42: db                     sep     rb                ; retrieve value into rf
  942 ae43: ef                     sex     rf                ; point x to RF
  943 ae44: 98                     ghi     r8                ; get DF
  944 ae45: f6                     shr                       ; shift bit into df
  945 ae46: 88                     glo     r8                ; get D
  946 ae47: 77                     smb                       ; perform subtraction
  947 ae48: a8                     plo     r8                ; put back into D
  948 ae49: 7e                     shlc                      ; get DF
  949 ae4a: b8                     phi     r8                ; store DF
  950 ae4b: e2                     sex     r2                ; restore x
  951 ae4c: c0 b1 91               lbr     instdn
  952 ae4f:             
  953 ae4f: 02 53 4d 42 
            49 00                  db      2,'SMBI',0
  954 ae55: 89          dosmbi:    glo     r9                ; get P
  955 ae56: da                     sep     ra                ; set R7 to correct R register
  956 ae57: db                     sep     rb                ; retrieve value into rf
  957 ae58: ef                     sex     rf                ; point x to RF
  958 ae59: 98                     ghi     r8                ; get DF
  959 ae5a: f6                     shr                       ; shift bit into df
  960 ae5b: 88                     glo     r8                ; get D
  961 ae5c: 77                     smb                       ; perform subtraction
  962 ae5d: a8                     plo     r8                ; put back into D
  963 ae5e: 7e                     shlc                      ; get DF
  964 ae5f: b8                     phi     r8                ; store DF
  965 ae60: e2                     sex     r2                ; restore x
  966 ae61: c0 ae c4               lbr     incp
  967 ae64:             
  968 ae64: 02 53 4d 49 
            20 00                  db      2,'SMI ',0
  969 ae6a: 89          dosmi:     glo     r9                ; get P
  970 ae6b: da                     sep     ra                ; set R7 to correct R register
  971 ae6c: db                     sep     rb                ; retrieve value into rf
  972 ae6d: ef                     sex     rf                ; point x to RF
  973 ae6e: 88                     glo     r8                ; get D
  974 ae6f: f7                     sm                        ; perform subtraction
  975 ae70: a8                     plo     r8                ; put back into D
  976 ae71: 7e                     shlc                      ; get DF
  977 ae72: b8                     phi     r8                ; store DF
  978 ae73: e2                     sex     r2                ; restore x
  979 ae74: c0 ae c4               lbr     incp              ; then increment p
  980 ae77:             
  981 ae77: 01 53 54 52 
            20 00                  db      1,'STR ',0
  982 ae7d: da          dostr:     sep     ra                ; set R7 to correct R register
  983 ae7e: db                     sep     rb                ; retrieve into rf
  984 ae7f: 88                     glo     r8                ; get D
  985 ae80: 5f                     str     rf                ; store into memory
  986 ae81: c0 b1 91               lbr     instdn
  987 ae84:             
  988 ae84: 00 53 54 58 
            44 00                  db      0,'STXD',0
  989 ae8a: 99          dostxd:    ghi     r9                ; get X
  990 ae8b: da                     sep     ra                ; set R7 to correct R register
  991 ae8c: db                     sep     rb                ; retrieve into rf
  992 ae8d: 88                     glo     r8                ; get D
  993 ae8e: 5f                     str     rf                ; store into memory
  994 ae8f: 99                     ghi     r9                ; get X
  995 ae90: c0 aa 63               lbr     dodec             ; then decrement R[X]
  996 ae93:             
  997 ae93: 00 58 4f 52 
            20 00                  db      0,'XOR ',0
  998 ae99: 99          doxor:     ghi     r9                ; get X
  999 ae9a: da                     sep     ra                ; set R7 to correct R register
 1000 ae9b: db                     sep     rb                ; retrieve value into rf
 1001 ae9c: ef                     sex     rf                ; point x to RF
 1002 ae9d: 88                     glo     r8                ; get D
 1003 ae9e: f3                     xor                       ; perform xor
 1004 ae9f: a8                     plo     r8                ; put back into D
 1005 aea0: e2                     sex     r2                ; restore x
 1006 aea1: c0 b1 91               lbr     instdn
 1007 aea4:             
 1008 aea4: 02 58 52 49 
            20 00                  db      2,'XRI ',0
 1009 aeaa: 89          doxri:     glo     r9                ; get P
 1010 aeab: da                     sep     ra                ; set R7 to correct R register
 1011 aeac: db                     sep     rb                ; retrieve value into rf
 1012 aead: ef                     sex     rf                ; point x to RF
 1013 aeae: 88                     glo     r8                ; get D
 1014 aeaf: f3                     xor                       ; perform xor
 1015 aeb0: a8                     plo     r8                ; put back into D
 1016 aeb1: e2                     sex     r2                ; restore x
 1017 aeb2: c0 ae c4               lbr     incp              ; and increment P
 1018 aeb5:             
 1019 aeb5: d3          setr7ret:  sep     r3                ; Return to caller
 1020 aeb6: fe          setr7:     shl                       ; each R register is two bytes
 1021 aeb7: a7                     plo     r7                ; put into R register pointer
 1022 aeb8: c0 ae b5               lbr     setr7ret          ; and return to caller
 1023 aebb:                        
 1024 aebb: d3          retrr7ret: sep     r3                ; Return to caller
 1025 aebc: 47          retrr7:    lda     r7                ; get high value
 1026 aebd: bf                     phi     rf
 1027 aebe: 07                     ldn     r7
 1028 aebf: af                     plo     rf
 1029 aec0: 27                     dec     r7
 1030 aec1: c0 ae bb               lbr     retrr7ret
 1031 aec4:             
 1032 aec4: 89          incp:      glo     r9                ; get p
 1033 aec5: d4                     sep     scall             ; increment it
 1034 aec6: a9 16                  dw      incr
 1035 aec8: c0 b1 91               lbr     instdn            ; jump to instruction done
 1036 aecb:             
 1037 aecb:             ; ******************************************
 1038 aecb:             ; ***** Done with instruction handlers *****
 1039 aecb:             ; ******************************************
 1040 aecb:                        
 1041 aecb:             ; *********************************************************
 1042 aecb:             ; ***** Takes value in D and makes 2 char ascii in RF *****
 1043 aecb:             ; *********************************************************
 1044 aecb: af          itoa:      plo     rf                ; save value
 1045 aecc: f8 00                  ldi     0                 ; clear high byte
 1046 aece: bf                     phi     rf
 1047 aecf: 8f                     glo     rf                ; recover low
 1048 aed0: ff 0a       itoalp:    smi     10                ; see if greater than 10
 1049 aed2: cb ae de               lbnf    itoadn            ; jump if not
 1050 aed5: af                     plo     rf                ; store new value
 1051 aed6: 9f                     ghi     rf                ; get high character
 1052 aed7: fc 01                  adi     1                 ; add 1
 1053 aed9: bf                     phi     rf                ; and put it back
 1054 aeda: 8f                     glo     rf                ; retrieve low character
 1055 aedb: c0 ae d0               lbr     itoalp            ; and keep processing
 1056 aede: 8f          itoadn:    glo     rf                ; get low character
 1057 aedf: fc 30                  adi     030h              ; convert to ascii
 1058 aee1: af                     plo     rf                ; put it back
 1059 aee2: 9f                     ghi     rf                ; get high character
 1060 aee3: fc 30                  adi     030h              ; convert to ascii
 1061 aee5: bf                     phi     rf                ; put it back
 1062 aee6: d5                     sep     sret              ; return to caller
 1063 aee7:             
 1064 aee7:             ; *********************************************
 1065 aee7:             ; ***** Send vt100 sequence to set cursor *****
 1066 aee7:             ; ***** RD.0 = y                          *****
 1067 aee7:             ; ***** RD.1 = x                          *****
 1068 aee7:             ; *********************************************
 1069 aee7: f8 1b       gotoxy:    ldi     27                ; escape character
 1070 aee9: d4                     sep     scall             ; write it
 1071 aeea: ff 03                  dw      f_type
 1072 aeec: f8 5b                  ldi     '['               ; square bracket
 1073 aeee: d4                     sep     scall             ; write it
 1074 aeef: ff 03                  dw      f_type
 1075 aef1: 8d                     glo     rd                ; get x
 1076 aef2: d4                     sep     scall             ; convert to ascii
 1077 aef3: ae cb                  dw      itoa
 1078 aef5: 9f                     ghi     rf                ; high character
 1079 aef6: d4                     sep     scall             ; write it
 1080 aef7: ff 03                  dw      f_type
 1081 aef9: 8f                     glo     rf                ; low character
 1082 aefa: d4                     sep     scall             ; write it
 1083 aefb: ff 03                  dw      f_type
 1084 aefd: f8 3b                  ldi     ';'               ; need separator
 1085 aeff: d4                     sep     scall             ; write it
 1086 af00: ff 03                  dw      f_type
 1087 af02: 9d                     ghi     rd                ; get y
 1088 af03: d4                     sep     scall             ; convert to ascii
 1089 af04: ae cb                  dw      itoa
 1090 af06: 9f                     ghi     rf                ; high character
 1091 af07: d4                     sep     scall             ; write it
 1092 af08: ff 03                  dw      f_type
 1093 af0a: 8f                     glo     rf                ; low character
 1094 af0b: d4                     sep     scall             ; write it
 1095 af0c: ff 03                  dw      f_type
 1096 af0e: f8 48                  ldi     'H'               ; need terminator for position
 1097 af10: d4                     sep     scall             ; write it
 1098 af11: ff 03                  dw      f_type
 1099 af13: d5                     sep     sret              ; return to caller
 1100 af14:             
 1101 af14: d4          invert:    sep     scall             ; send sequence
 1102 af15: ff 66                  dw      f_inmsg
 1103 af17: 1b 37 6d 00            db      27,'7m',0
 1104 af1b: d5                     sep     sret              ; return to caller
 1105 af1c:             
 1106 af1c: d4          normal:    sep     scall             ; send sequence
 1107 af1d: ff 66                  dw      f_inmsg
 1108 af1f: 1b 32 37 6d 
            00                     db      27,'27m',0
 1109 af24: d5                     sep     sret              ; return to caller
 1110 af25:             
 1111 af25:             ; ***********************************
 1112 af25:             ; ***** Display low nybble in D *****
 1113 af25:             ; ***********************************
 1114 af25: fa 0f       disp4:     ani     0fh               ; strip high nybble
 1115 af27: ff 0a                  smi     10                ; check for letters
 1116 af29: c3 af 32               lbdf    disp42            ; jump if so
 1117 af2c: fc 3a                  adi     03ah              ; add 10 back and convert to ascii
 1118 af2e: d4                     sep     scall             ; display it
 1119 af2f: ff 03                  dw      f_type
 1120 af31: d5                     sep     sret              ; and return
 1121 af32: fc 41       disp42:    adi     'A'               ; convert to ascii letter
 1122 af34: d4                     sep     scall             ; display it
 1123 af35: ff 03                  dw      f_type
 1124 af37: d5                     sep     sret              ; and return
 1125 af38:             
 1126 af38:             ; ************************************
 1127 af38:             ; ***** Display 8-bit value in D *****
 1128 af38:             ; ************************************
 1129 af38: 73          disp8:     stxd                      ; save D
 1130 af39: f6                     shr                       ; get high nybble
 1131 af3a: f6                     shr
 1132 af3b: f6                     shr
 1133 af3c: f6                     shr
 1134 af3d: d4                     sep     scall             ; display it
 1135 af3e: af 25                  dw      disp4
 1136 af40: 60                     irx                       ; recover D
 1137 af41: f0                     ldx
 1138 af42: d4                     sep     scall             ; display low nybble
 1139 af43: af 25                  dw      disp4
 1140 af45: d5                     sep     sret               ; return to caller
 1141 af46:             
 1142 af46:             ; **************************************
 1143 af46:             ; ***** Dispaly 16-bit value in RF *****
 1144 af46:             ; **************************************
 1145 af46: 9f          disp16:    ghi     rf                ; get high byte
 1146 af47: d4                     sep     scall             ; display it
 1147 af48: af 38                  dw      disp8
 1148 af4a: 8f                     glo     rf                ; get low byte
 1149 af4b: d4                     sep     scall             ; display it
 1150 af4c: af 38                  dw      disp8
 1151 af4e: d5                     sep     sret              ; return to caller
 1152 af4f:             
 1153 af4f:             ; ************************************
 1154 af4f:             ; ***** Draw all register values *****
 1155 af4f:             ; ************************************
 1156 af4f: f8 02       drawregs:  ldi     2                 ; start at first row
 1157 af51: ad                     plo     rd                ; put into position
 1158 af52: f8 07                  ldi     7                 ; column
 1159 af54: bd                     phi     rd                ; put into position
 1160 af55: f8 00                  ldi     r0.0              ; point to R[0]
 1161 af57: a7                     plo     r7                ; put into register pointer
 1162 af58: f8 00                  ldi     0                 ; set count to 0
 1163 af5a: ac                     plo     rc                ; in rc
 1164 af5b: d4          regslp:    sep     scall             ; position cursor
 1165 af5c: ae e7                  dw      gotoxy
 1166 af5e: 47                     lda     r7                ; get high byte of next register
 1167 af5f: bf                     phi     rf                ; put into rf
 1168 af60: 47                     lda     r7                ; get low byte of next register
 1169 af61: af                     plo     rf                ; put into rf
 1170 af62: d4                     sep     scall             ; display 16 bit value
 1171 af63: af 46                  dw      disp16
 1172 af65: 1d                     inc     rd                ; point to next row
 1173 af66: 1c                     inc     rc                ; increment count
 1174 af67: 8c                     glo     rc                ; put it back
 1175 af68: fa f0                  ani     0f0h              ; see if done
 1176 af6a: c2 af 5b               lbz     regslp            ; jump if not
 1177 af6d: f8 02                  ldi     2                 ; row 2
 1178 af6f: ad                     plo     rd
 1179 af70: f8 13                  ldi     19                ; column for data
 1180 af72: bd                     phi     rd
 1181 af73: d4                     sep     scall             ; set position
 1182 af74: ae e7                  dw      gotoxy
 1183 af76: 88                     glo     r8                ; get D
 1184 af77: d4                     sep     scall             ; and display it
 1185 af78: af 38                  dw      disp8
 1186 af7a: 1d                     inc     rd                ; point to X box
 1187 af7b: 1d                     inc     rd
 1188 af7c: 1d                     inc     rd
 1189 af7d: d4                     sep     scall             ; set cursor position
 1190 af7e: ae e7                  dw      gotoxy
 1191 af80: 99                     ghi     r9                ; get X
 1192 af81: d4                     sep     scall             ; display it
 1193 af82: af 25                  dw      disp4
 1194 af84: 1d                     inc     rd                ; point to T box
 1195 af85: 1d                     inc     rd
 1196 af86: 1d                     inc     rd
 1197 af87: d4                     sep     scall             ; set cursor position
 1198 af88: ae e7                  dw      gotoxy
 1199 af8a: f8 21                  ldi     t.0               ; need low address
 1200 af8c: a7                     plo     r7                ; put into register pointer
 1201 af8d: 07                     ldn     r7                ; retrieve T
 1202 af8e: d4                     sep     scall             ; and display it
 1203 af8f: af 38                  dw      disp8
 1204 af91: 1d                     inc     rd                ; point to Q box
 1205 af92: 1d                     inc     rd
 1206 af93: 1d                     inc     rd
 1207 af94: d4                     sep     scall             ; set cursor position
 1208 af95: ae e7                  dw      gotoxy
 1209 af97: f8 20                  ldi     q.0               ; need low address
 1210 af99: a7                     plo     r7                ; put into register pointer
 1211 af9a: 07                     ldn     r7                ; retrieve Q
 1212 af9b: fa 01                  ani     1                 ; keep only low bit
 1213 af9d: d4                     sep     scall             ; and display it
 1214 af9e: af 25                  dw      disp4
 1215 afa0: 1d                     inc     rd                ; point to IE box
 1216 afa1: 1d                     inc     rd
 1217 afa2: 1d                     inc     rd
 1218 afa3: d4                     sep     scall             ; set cursor position
 1219 afa4: ae e7                  dw      gotoxy
 1220 afa6: f8 22                  ldi     ie.0               ; need low address
 1221 afa8: a7                     plo     r7                ; put into register pointer
 1222 afa9: 07                     ldn     r7                ; retrieve IE
 1223 afaa: fa 01                  ani     1                 ; keep only low bit
 1224 afac: d4                     sep     scall             ; and display it
 1225 afad: af 25                  dw      disp4
 1226 afaf: f8 02                  ldi     2                 ; row 2
 1227 afb1: ad                     plo     rd
 1228 afb2: f8 1d                  ldi     29                ; column for data
 1229 afb4: bd                     phi     rd
 1230 afb5: d4                     sep     scall             ; set position
 1231 afb6: ae e7                  dw      gotoxy
 1232 afb8: 98                     ghi     r8                ; get DF
 1233 afb9: fa 01                  ani     1                 ; keep only low bit
 1234 afbb: d4                     sep     scall             ; and display it
 1235 afbc: af 25                  dw      disp4
 1236 afbe: 1d                     inc     rd                ; point to P box
 1237 afbf: 1d                     inc     rd
 1238 afc0: 1d                     inc     rd
 1239 afc1: d4                     sep     scall             ; set cursor position
 1240 afc2: ae e7                  dw      gotoxy
 1241 afc4: 89                     glo     r9                ; get P
 1242 afc5: d4                     sep     scall             ; display it
 1243 afc6: af 25                  dw      disp4
 1244 afc8:             
 1245 afc8: d5                     sep     sret              ; otherwise return
 1246 afc9:             
 1247 afc9:             ; ************************************
 1248 afc9:             ; ***** Draw single register box *****
 1249 afc9:             ; ************************************
 1250 afc9: d4          drawbox:   sep     scall             ; set cursor position
 1251 afca: ae e7                  dw      gotoxy
 1252 afcc: d4                     sep     scall             ; display message
 1253 afcd: ff 66                  dw      f_inmsg
 1254 afcf: 2b 2d 2d 2d 
            2d 2d 2d 2d 
            2b 00                  db      '+-------+',0
 1255 afd9: 1d                     inc     rd                ; next row
 1256 afda: d4                     sep     scall             ; set position
 1257 afdb: ae e7                  dw      gotoxy
 1258 afdd: d4                     sep     scall             ; display message
 1259 afde: ff 66                  dw      f_inmsg
 1260 afe0: 7c 20 00               db      '| ',0
 1261 afe3: 9c                     ghi     rc                ; get first passed character
 1262 afe4: d4                     sep     scall             ; and display it
 1263 afe5: ff 03                  dw      f_type
 1264 afe7: 8c                     glo     rc                ; get second passed character
 1265 afe8: d4                     sep     scall
 1266 afe9: ff 03                  dw      f_type
 1267 afeb: d4                     sep     scall             ; now finish line
 1268 afec: ff 66                  dw      f_inmsg
 1269 afee: 20 20 20 20 
            7c 00                  db      '    |',0
 1270 aff4: 1d                     inc     rd
 1271 aff5: d4                     sep     scall             ; set position
 1272 aff6: ae e7                  dw      gotoxy
 1273 aff8: d4                     sep     scall             ; display message
 1274 aff9: ff 66                  dw      f_inmsg
 1275 affb: 2b 2d 2d 2d 
            2d 2d 2d 2d 
            2b 00                  db      '+-------+',0
 1276 b005: 1d                     inc     rd                ; increment row
 1277 b006: d5                     sep     sret              ; return to caller
 1278 b007:             
 1279 b007:             ; *********************************************************
 1280 b007:             ; ***** Draw larger boxes for disassembly/memory dump *****
 1281 b007:             ; *********************************************************
 1282 b007: d4          drawbig:   sep     scall             ; set cursor position
 1283 b008: ae e7                  dw      gotoxy
 1284 b00a: d4                     sep     scall             ; draw top line
 1285 b00b: ff 66                  dw      f_inmsg
 1286 b00d: 2b 2d 2d 2d 
            2d 2d 2d 2d 
            2d 2d 2d 2d 
            2d 2d 2d 2d 
            2d 2d 2d 2d 
            2d 2d 2d 2d 
            2d 2d 2d 2d 
            2d 2d 2d 2b 
            00                     db      '+------------------------------+',0
 1287 b02e: 1d                     inc     rd                ; point to next line
 1288 b02f: f8 07                  ldi     7                 ; need 7 lines
 1289 b031: ac                     plo     rc
 1290 b032: d4          biglp:     sep     scall             ; position cursor
 1291 b033: ae e7                  dw      gotoxy
 1292 b035: f8 7c                  ldi     '|'               ; frame character
 1293 b037: d4                     sep     scall             ; display it
 1294 b038: ff 03                  dw      f_type
 1295 b03a: 9d                     ghi     rd                ; get x coordinate
 1296 b03b: fc 1f                  adi     31                ; point to right side
 1297 b03d: bd                     phi     rd                ; put back into coordinates
 1298 b03e: d4                     sep     scall             ; position cursor
 1299 b03f: ae e7                  dw      gotoxy
 1300 b041: f8 7c                  ldi     '|'               ; border character
 1301 b043: d4                     sep     scall             ; display it
 1302 b044: ff 03                  dw      f_type
 1303 b046: 9d                     ghi     rd                ; get x coordinate
 1304 b047: ff 1f                  smi     31                ; move it back
 1305 b049: bd                     phi     rd
 1306 b04a: 1d                     inc     rd                ; point to next line
 1307 b04b: 2c                     dec     rc                ; decrement count 
 1308 b04c: 8c                     glo     rc                ; need to see if done
 1309 b04d: ca b0 32               lbnz    biglp             ; jump if not
 1310 b050: d4                     sep     scall             ; set cursor position
 1311 b051: ae e7                  dw      gotoxy
 1312 b053: d4                     sep     scall             ; draw bottom line
 1313 b054: ff 66                  dw      f_inmsg
 1314 b056: 2b 2d 2d 2d 
            2d 2d 2d 2d 
            2d 2d 2d 2d 
            2d 2d 2d 2d 
            2d 2d 2d 2d 
            2d 2d 2d 2d 
            2d 2d 2d 2d 
            2d 2d 2d 2b 
            00                     db      '+------------------------------+',0
 1315 b077: d5                     sep     sret              ; return to caller
 1316 b078:             
 1317 b078:             ; *****************************
 1318 b078:             ; ***** Draw basic screen *****
 1319 b078:             ; *****************************
 1320 b078: f8 01       drawscn:   ldi     1                 ; start at first row
 1321 b07a: bd                     phi     rd
 1322 b07b: ad                     plo     rd
 1323 b07c: f8 10                  ldi     16
 1324 b07e: ac                     plo     rc
 1325 b07f: d4                     sep     scall             ; position cursor
 1326 b080: ae e7                  dw      gotoxy
 1327 b082: d4                     sep     scall             ; draw first part
 1328 b083: ff 66                  dw      f_inmsg
 1329 b085: 2b 2d 2d 2d 
            2d 2d 2d 2d 
            2d 2d 2d 2b 
            00                     db      '+----------+',0
 1330 b092: 1d                     inc     rd                ; point to 2nd row
 1331 b093: d4          drawlp1:   sep     scall
 1332 b094: ae e7                  dw      gotoxy
 1333 b096: d4                     sep     scall             ; draw row
 1334 b097: ff 66                  dw      f_inmsg
 1335 b099: 7c 20 20 20 
            20 20 20 20 
            20 20 20 7c 
            00                     db      '|          |',0
 1336 b0a6: 1d                     inc     rd                ; next row
 1337 b0a7: 2c                     dec     rc                ; decrement row count
 1338 b0a8: 8c                     glo     rc                ; get count
 1339 b0a9: ca b0 93               lbnz    drawlp1           ; loop back if not done
 1340 b0ac: d4                     sep     scall             ; position cursor for last row
 1341 b0ad: ae e7                  dw      gotoxy
 1342 b0af: d4                     sep     scall             ; draw last row
 1343 b0b0: ff 66                  dw      f_inmsg
 1344 b0b2: 2b 2d 2d 2d 
            2d 2d 2d 2d 
            2d 2d 2d 2b 
            00                     db      '+----------+',0
 1345 b0bf: f8 02                  ldi     2                 ; start at first row
 1346 b0c1: ad                     plo     rd                ; put into position
 1347 b0c2: f8 03                  ldi     3                 ; column 3
 1348 b0c4: bd                     phi     rd
 1349 b0c5: f8 00                  ldi     0                 ; start with 0
 1350 b0c7: ac                     plo     rc                ; store it
 1351 b0c8: d4          drawlp:    sep     scall             ; set cursor position
 1352 b0c9: ae e7                  dw      gotoxy
 1353 b0cb: f8 52                  ldi     'R'               ; need R
 1354 b0cd: d4                     sep     scall             ; display it
 1355 b0ce: ff 03                  dw      f_type
 1356 b0d0: 8c                     glo     rc                ; get current count
 1357 b0d1: d4                     sep     scall             ; and display it
 1358 b0d2: af 25                  dw      disp4
 1359 b0d4: 1d                     inc     rd                ; next row
 1360 b0d5: 8c                     glo     rc                ; get count
 1361 b0d6: fc 01                  adi     1                 ; add 1
 1362 b0d8: ac                     plo     rc                ; put it back
 1363 b0d9: fa f0                  ani     0f0h              ; did we draw all 16
 1364 b0db: c2 b0 c8               lbz     drawlp            ; loop back if not
 1365 b0de: f8 01                  ldi     1                 ; row 1
 1366 b0e0: ad                     plo     rd
 1367 b0e1: f8 0e                  ldi     14                ; set column
 1368 b0e3: bd                     phi     rd 
 1369 b0e4: f8 44                  ldi     'D'               ; draw D register box
 1370 b0e6: bc                     phi     rc
 1371 b0e7: f8 20                  ldi     ' '
 1372 b0e9: ac                     plo     rc
 1373 b0ea: d4                     sep     scall
 1374 b0eb: af c9                  dw      drawbox
 1375 b0ed: f8 58                  ldi     'X'               ; draw X register box
 1376 b0ef: bc                     phi     rc
 1377 b0f0: f8 20                  ldi     ' '
 1378 b0f2: ac                     plo     rc
 1379 b0f3: d4                     sep     scall
 1380 b0f4: af c9                  dw      drawbox
 1381 b0f6: f8 54                  ldi     'T'               ; draw T register box
 1382 b0f8: bc                     phi     rc
 1383 b0f9: f8 20                  ldi     ' '
 1384 b0fb: ac                     plo     rc
 1385 b0fc: d4                     sep     scall
 1386 b0fd: af c9                  dw      drawbox
 1387 b0ff: f8 51                  ldi     'Q'               ; draw Q box
 1388 b101: bc                     phi     rc
 1389 b102: f8 20                  ldi     ' '
 1390 b104: ac                     plo     rc
 1391 b105: d4                     sep     scall
 1392 b106: af c9                  dw      drawbox
 1393 b108: f8 49                  ldi     'I'               ; draw IE box
 1394 b10a: bc                     phi     rc
 1395 b10b: f8 45                  ldi     'E'
 1396 b10d: ac                     plo     rc
 1397 b10e: d4                     sep     scall
 1398 b10f: af c9                  dw      drawbox
 1399 b111: f8 18                  ldi     24                ; setup position for second column
 1400 b113: bd                     phi     rd
 1401 b114: f8 01                  ldi     1
 1402 b116: ad                     plo     rd
 1403 b117: f8 44                  ldi     'D'               ; draw DF box
 1404 b119: bc                     phi     rc
 1405 b11a: f8 46                  ldi     'F'
 1406 b11c: ac                     plo     rc
 1407 b11d: d4                     sep     scall
 1408 b11e: af c9                  dw      drawbox
 1409 b120: f8 50                  ldi     'P'               ; draw P register box
 1410 b122: bc                     phi     rc
 1411 b123: f8 20                  ldi     ' '
 1412 b125: ac                     plo     rc
 1413 b126: d4                     sep     scall
 1414 b127: af c9                  dw      drawbox
 1415 b129: 1d                     inc     rd                ; next row
 1416 b12a: d4                     sep     scall             ; set cursor position
 1417 b12b: ae e7                  dw      gotoxy
 1418 b12d: d4                     sep     scall             ; display breakpoint label
 1419 b12e: ff 66                  dw      f_inmsg
 1420 b130: 20 20 20 42 
            52 4b 3a 00            db      '   BRK:',0
 1421 b138: f8 43                  ldi     67                ; position for traps label
 1422 b13a: bd                     phi     rd
 1423 b13b: f8 02                  ldi     2
 1424 b13d: ad                     plo     rd
 1425 b13e: d4                     sep     scall             ; set cursor position
 1426 b13f: ae e7                  dw      gotoxy
 1427 b141: d4                     sep     scall             ; now draw label
 1428 b142: ff 66                  dw      f_inmsg
 1429 b144: 54 52 41 50 
            53 00                  db      'TRAPS',0
 1430 b14a: f8 22                  ldi     34                ; X address of disassembly box
 1431 b14c: bd                     phi     rd
 1432 b14d: f8 01                  ldi     1                 ; Y address of disassembly box
 1433 b14f: ad                     plo     rd
 1434 b150: d4                     sep     scall             ; draw disassembly box
 1435 b151: b0 07                  dw      drawbig
 1436 b153: 1d                     inc     rd                ; move down a line
 1437 b154: d4                     sep     scall             ; draw memory dump box
 1438 b155: b0 07                  dw      drawbig
 1439 b157: d5                     sep     sret              ; otherwise return to caller
 1440 b158:             
 1441 b158: f8 7e       begin:     ldi     r0.1              ; Get address of register array
 1442 b15a: b7                     phi     r7                ; and set R7
 1443 b15b: f8 b6 aa f8 
            ae ba                  mov     ra,setr7          ; set RA to set r7 routine
 1444 b161: f8 bc ab f8 
            ae bb                  mov     rb,retrr7         ; get RB to R[r7]->rf
 1445 b167: f8 7e                  ldi     r0.1              ; get data segment
 1446 b169: b2                     phi     r2                ; set into stack register
 1447 b16a: f8 ff                  ldi     0ffh              ; stack will be at end of segment
 1448 b16c: a2                     plo     r2
 1449 b16d: f8 28                  ldi     nbp.0             ; number of breakpoints
 1450 b16f: a7                     plo     r7
 1451 b170: f8 00                  ldi     0                 ; set to zero
 1452 b172: 57                     str     r7
 1453 b173: f8 39                  ldi     ntraps.0          ; number of traps
 1454 b175: a7                     plo     r7
 1455 b176: f8 00                  ldi     0                 ; set to zero
 1456 b178: a7                     plo     r7
 1457 b179: f8 25                  ldi     multi.0           ; point to multi execution flag
 1458 b17b: a7                     plo     r7
 1459 b17c: f8 00                  ldi     0                 ; set to zero
 1460 b17e: 57                     str     r7
 1461 b17f: a9                     plo     r9                ; set P=0
 1462 b180: b9                     phi     r9                ; set X=0
 1463 b181:             
 1464 b181:             
 1465 b181: f8 0c                  ldi     0ch               ; clear screen
 1466 b183: d4                     sep     scall
 1467 b184: ff 03                  dw      f_type
 1468 b186:             
 1469 b186: d4                     sep     scall             ; draw screen
 1470 b187: b0 78                  dw      drawscn
 1471 b189:             	
 1472 b189:             	;; added for illegal instruction decode
 1473 b189: 30 91       	   br	   instdn
 1474 b18b: 00 49 4c 4c 
            20 00       	   db	   0,'ILL ',0
 1475 b191:             	
 1476 b191: f8 25       instdn:    ldi     multi.0           ; point to multi execution flags
 1477 b193: a7                     plo     r7
 1478 b194: 07                     ldn     r7                ; check for multi-execution
 1479 b195: c2 b1 ff               lbz     showregs          ; jump if not
 1480 b198: d4                     sep     scall             ; check for break
 1481 b199: b1 b8                  dw      checkbp           ; check for break point
 1482 b19b: c3 b1 ff               lbdf    showregs          ; jump if breakpoint hit
 1483 b19e: d4                     sep     scall             ; check for traps
 1484 b19f: b1 dd                  dw      checktp
 1485 b1a1: c3 b1 ff               lbdf    showregs          ; jump if trap hit
 1486 b1a4: f8 26                  ldi     mcount.0          ; get address of instruction count
 1487 b1a6: a7                     plo     r7                ; put into data pointer
 1488 b1a7: db                     sep     rb                ; retrieve current count
 1489 b1a8: 2f                     dec     rf                ; decrement count
 1490 b1a9: 9f                     ghi     rf                ; put it back
 1491 b1aa: 57                     str     r7
 1492 b1ab: 17                     inc     r7                ; point to low byte
 1493 b1ac: 8f                     glo     rf
 1494 b1ad: 57                     str     r7
 1495 b1ae: ca b2 b0               lbnz    cycle             ; jump if more to execute
 1496 b1b1: 9f                     ghi     rf                ; get high byte of count
 1497 b1b2: c2 b1 ff               lbz     showregs          ; jump if done
 1498 b1b5: c0 b2 b0               lbr     cycle             ; otherwise begin another cycle
 1499 b1b8:             
 1500 b1b8: 89          checkbp:   glo     r9                ; need P
 1501 b1b9: da                     sep     ra                ; set r7 to correct register
 1502 b1ba: db                     sep     rb                ; retrieve register value
 1503 b1bb: f8 28                  ldi     nbp.0             ; need number of breakpoints
 1504 b1bd: a7                     plo     r7 
 1505 b1be: 07                     ldn     r7                ; retrieve breakpoint count
 1506 b1bf: c2 b1 f7               lbz     cont              ; continue if there are no breakpoints
 1507 b1c2: ac                     plo     rc                ; save count
 1508 b1c3: f8 29                  ldi     bp.0              ; point to breakpoint table
 1509 b1c5: a7                     plo     r7                ; r7 now points to breakpoints
 1510 b1c6: 9f          checkbp1:  ghi     rf                ; get high of address
 1511 b1c7: 52                     str     r2                ; save it
 1512 b1c8: 47                     lda     r7                ; get high from breakpoint table
 1513 b1c9: f7                     sm                        ; compare to address
 1514 b1ca: ca b1 d4               lbnz    checkbp2          ; jump if not the same
 1515 b1cd: 8f                     glo     rf                ; get low of address
 1516 b1ce: 52                     str     r2                ; save it
 1517 b1cf: 07                     ldn     r7                ; get low byte from breakpoint table
 1518 b1d0: f7                     sm                        ; and compare
 1519 b1d1: c2 b1 fb               lbz     stop              ; break point found, so stop
 1520 b1d4: 17          checkbp2:  inc     r7                ; point to next break point
 1521 b1d5: 2c                     dec     rc                ; decrement count
 1522 b1d6: 8c                     glo     rc                ; get count
 1523 b1d7: ca b1 c6               lbnz    checkbp1          ; loop back if more to check
 1524 b1da: c0 b1 f7               lbr     cont              ; if not, continue execution
 1525 b1dd:             
 1526 b1dd: 89          checktp:   glo     r9                ; need P
 1527 b1de: da                     sep     ra                ; set r7 to correct register
 1528 b1df: db                     sep     rb                ; retrieve register value
 1529 b1e0: 0f                     ldn     rf                ; get next instruction
 1530 b1e1: 52                     str     r2                ; save it
 1531 b1e2: f8 39                  ldi     ntraps.0          ; need number of traps
 1532 b1e4: a7                     plo     r7  
 1533 b1e5: 07                     ldn     r7                ; get number of traps
 1534 b1e6: c2 b1 f7               lbz     cont              ; continue of no traps defined
 1535 b1e9: ac                     plo     rc                ; place into count
 1536 b1ea: f8 3a                  ldi     traps.0           ; now point to traps
 1537 b1ec: a7                     plo     r7
 1538 b1ed: 47          checktp1:  lda     r7                ; get trap
 1539 b1ee: f7                     sm                        ; check against current instruction
 1540 b1ef: c2 b1 fb               lbz     stop              ; stop if a match
 1541 b1f2: 2c                     dec     rc                ; decrement count
 1542 b1f3: 8c                     glo     rc                ; need to see if more to check
 1543 b1f4: ca b1 ed               lbnz    checktp1          ; loop back if more
 1544 b1f7: f8 00       cont:      ldi     0                 ; none found, continue execution
 1545 b1f9: f6                     shr
 1546 b1fa: d5                     sep     sret
 1547 b1fb:             
 1548 b1fb: f8 01       stop:      ldi     1
 1549 b1fd: f6                     shr
 1550 b1fe: d5                     sep     sret
 1551 b1ff:             
 1552 b1ff: d4          showregs:  sep     scall             ; display registers
 1553 b200: af 4f                  dw      drawregs
 1554 b202: f8 15       instdn1:   ldi     21                ; set position for next inst disassembly
 1555 b204: ad                     plo     rd
 1556 b205: f8 01                  ldi     1
 1557 b207: bd                     phi     rd
 1558 b208: d4                     sep     scall             ; set cursor position
 1559 b209: ae e7                  dw      gotoxy
 1560 b20b: f8 3e                  ldi     '>'               ; marker for next instruction
 1561 b20d: d4                     sep     scall             ; display it
 1562 b20e: ff 03                  dw      f_type
 1563 b210: 89                     glo     r9                ; get P
 1564 b211: da                     sep     ra                ; set into r7
 1565 b212: db                     sep     rb                ; retrieve value into rf
 1566 b213: d4                     sep     scall             ; disassemble next instruction
 1567 b214: b3 57                  dw      disassem
 1568 b216: 2d                     dec     rd                ; point to previous line
 1569 b217: d4                     sep     scall             ; set cursor position
 1570 b218: ae e7                  dw      gotoxy
 1571 b21a: f8 20                  ldi     ' '               ; move over 1 space
 1572 b21c: d4                     sep     scall             ; display it
 1573 b21d: ff 03                  dw      f_type
 1574 b21f: f8 23                  ldi     last.0            ; address of last instruction
 1575 b221: a7                     plo     r7                ; set into register pointer
 1576 b222: db                     sep     rb                ; retrieve address
 1577 b223: d4                     sep     scall             ; disassemble last instruction executed
 1578 b224: b3 57                  dw      disassem
 1579 b226:             
 1580 b226: f8 17       main:      ldi     23                ; position for prompt
 1581 b228: ad                     plo     rd
 1582 b229: f8 01                  ldi     1
 1583 b22b: bd                     phi     rd
 1584 b22c: d4                     sep     scall             ; set cursor position
 1585 b22d: ae e7                  dw      gotoxy
 1586 b22f:             
 1587 b22f: f8 0c af f8 
            b9 bf                  mov     rf,prompt
 1588 b235: d4                     sep     scall             ; display prompt
 1589 b236: ff 09                  dw      f_msg
 1590 b238: f8 7e                  ldi     buffer.1          ; point to input buffer
 1591 b23a: bf                     phi     rf
 1592 b23b: f8 4a                  ldi     buffer.0
 1593 b23d: af                     plo     rf
 1594 b23e: d4                     sep     scall             ; get input from user
 1595 b23f: ff 0f                  dw      f_input
 1596 b241: f8 4a af f8 
            7e bf                  mov     rf,buffer         ; convert to uppercase
 1597 b247: d4                     sep     scall
 1598 b248: b6 e2                  dw      touc
 1599 b24a: f8 7e                  ldi     buffer.1          ; point to input buffer
 1600 b24c: bf                     phi     rf
 1601 b24d: f8 4a                  ldi     buffer.0
 1602 b24f: af                     plo     rf
 1603 b250: 0f                     ldn     rf                ; get first input byte
 1604 b251: ff 3f                  smi     '?'               ; check for dump command
 1605 b253: c2 b4 22               lbz     dump              ; jump if so
 1606 b256: 0f                     ldn     rf                ; recover input byte
 1607 b257: ff 24                  smi     '$'               ; check for disassembly command
 1608 b259: c2 b3 f8               lbz     disasm            ; jump if disassembly
 1609 b25c: 0f                     ldn     rf                ; recover input byte
 1610 b25d: ff 21                  smi     '!'               ; check for store command
 1611 b25f: c2 b4 5a               lbz     store             ; jump if store
 1612 b262: 0f                     ldn     rf                ; recover input byte
 1613 b263: ff 40                  smi     '@'               ; see if run command
 1614 b265: c2 b4 8e               lbz     run               ; jump if so
 1615 b268: 0f                     ldn     rf                ; recover input byte
 1616 b269: ff 50                  smi     'P'               ; check for P= command
 1617 b26b: c2 b4 a1               lbz     setp              ; jump if so
 1618 b26e: 0f                     ldn     rf                ; recover input byte
 1619 b26f: ff 58                  smi     'X'               ; check for X= command
 1620 b271: c2 b4 b2               lbz     setx              ; jump if so
 1621 b274: 0f                     ldn     rf                ; recover input byte
 1622 b275: ff 44                  smi     'D'               ; check for D= command
 1623 b277: c2 b4 c3               lbz     setd              ; jump if so
 1624 b27a: 0f                     ldn     rf                ; recover input byte
 1625 b27b: ff 51                  smi     'Q'               ; check for Q= command
 1626 b27d: c2 b4 e9               lbz     setq              ; jump if so
 1627 b280: 0f                     ldn     rf                ; recover input byte
 1628 b281: ff 49                  smi     'I'               ; check for I command
 1629 b283: c2 b5 21               lbz     doint             ; jump if so
 1630 b286: 0f                     ldn     rf                ; recover input byte
 1631 b287: ff 54                  smi     'T'               ; check for T= command
 1632 b289: c2 b4 fd               lbz     sett              ; jump if so
 1633 b28c: 0f                     ldn     rf                ; recover input byte
 1634 b28d: ff 52                  smi     'R'               ; check for R= command
 1635 b28f: c2 b5 66               lbz     setr              ; jump if so
 1636 b292: 0f                     ldn     rf                ; recover input byte
 1637 b293: ff 42                  smi     'B'               ; check for breakpoint commands
 1638 b295: c2 b5 c2               lbz     breakp            ; jump if so
 1639 b298: 0f                     ldn     rf                ; recover input byte
 1640 b299: ff 47                  smi     'G'               ; check for go command
 1641 b29b: c2 b2 e3               lbz     go                ; jump if so
 1642 b29e: 0f                     ldn     rf                ; recover input byte
 1643 b29f: ff 45                  smi     'E'               ; check for exit command
 1644 b2a1: c2 b2 f2               lbz     exit              ; jump if so
            #ifdef ANYROM
 1646 b2a4: 0f                     ldn     rf                ; recover input byte
 1647 b2a5: ff 41                  smi     'A'               ; check for assember command
 1648 b2a7: c2 b2 fa               lbz     asm               ; jump if so
            #endif
 1650 b2aa:             
 1651 b2aa: f8 25                  ldi     multi.0           ; address of multi-execute flag
 1652 b2ac: a7                     plo     r7                ; put into data pointer
 1653 b2ad: f8 00                  ldi     0                 ; need to clear it
 1654 b2af: 57                     str     r7
 1655 b2b0:             
 1656 b2b0: 89          cycle:     glo     r9                ; get P
 1657 b2b1: da                     sep     ra                ; Set register pointer
 1658 b2b2: db                     sep     rb                ; read register into rf
 1659 b2b3: 87                     glo     r7                ; save pointer to R[P]
 1660 b2b4: ae                     plo     re
 1661 b2b5: f8 23                  ldi     last.0            ; location for last address
 1662 b2b7: a7                     plo     r7                ; set register pointer
 1663 b2b8: 9f                     ghi     rf                ; get high byte of address
 1664 b2b9: 57                     str     r7                ; and save it
 1665 b2ba: 17                     inc     r7                ; point to low byte
 1666 b2bb: 8f                     glo     rf                ; low byte of address
 1667 b2bc: 57                     str     r7                ; save it
 1668 b2bd: 8e                     glo     re                ; recover R[P] address
 1669 b2be: a7                     plo     r7
 1670 b2bf: 4f                     lda     rf                ; get program byte
 1671 b2c0: ae                     plo     re                ; save it for now
 1672 b2c1: 9f                     ghi     rf                ; write new value of R[P]
 1673 b2c2: 57                     str     r7
 1674 b2c3: 17                     inc     r7
 1675 b2c4: 8f                     glo     rf
 1676 b2c5: 57                     str     r7
 1677 b2c6: 8e                     glo     re                ; get instruction
 1678 b2c7: fe                     shl                       ; multiply by 2
 1679 b2c8: af                     plo     rf                ; put here for now
 1680 b2c9: f8 00                  ldi     0                 ; need zero
 1681 b2cb: 7e                     shlc                      ; shift in carry bit
 1682 b2cc: bf                     phi     rf                ; rd now had instruction offset
 1683 b2cd: 8f                     glo     rf                ; get lsb
 1684 b2ce: 52                     str     r2                ; save it
 1685 b2cf: f8 0c                  ldi     inst.0            ; low byte of instruction table
 1686 b2d1: f4                     add                       ; add instruction offset lsb
 1687 b2d2: af                     plo     rf                ; move to rf
 1688 b2d3: 9f                     ghi     rf                ; get high byte
 1689 b2d4: 52                     str     r2                ; store it for add
 1690 b2d5: f8 b7                  ldi     inst.1            ; high byte of instruction gtable
 1691 b2d7: 74                     adc                       ; add msb of instruction offset
 1692 b2d8: bf                     phi     rf                ; rf now points to instruction address
 1693 b2d9: 4f                     lda     rf                ; get high byte of address
 1694 b2da: b6                     phi     r6                ; put into r6 for sret
 1695 b2db: 0f                     ldn     rf                ; get low byte of address
 1696 b2dc: a6                     plo     r6                ; put into r6 for sret
 1697 b2dd: 22                     dec     r2                ; subtract 2 from x for sret
 1698 b2de: 22                     dec     r2
 1699 b2df: 8e                     glo     re                ; recover instruction byte
 1700 b2e0: fa 0f                  ani     0fh               ; keep only low nybble
 1701 b2e2: d5                     sep     sret              ; return into instruction handler
 1702 b2e3:             
 1703 b2e3:             ; **********************
 1704 b2e3:             ; ***** Go command *****
 1705 b2e3:             ; **********************
 1706 b2e3: f8 25       go:        ldi     multi.0           ; need multi-execution flag
 1707 b2e5: a7                     plo     r7
 1708 b2e6: f8 01                  ldi     1                 ; need to turn it on
 1709 b2e8: 57                     str     r7
 1710 b2e9: f8 00                  ldi     0                 ; clear count
 1711 b2eb: 17                     inc     r7                ; point to instruction count
 1712 b2ec: 57                     str     r7                ; and store it
 1713 b2ed: 17                     inc     r7                ; point to low byte
 1714 b2ee: 57                     str     r7
 1715 b2ef: c0 b2 b0               lbr     cycle             ; now start cycling
 1716 b2f2:             
 1717 b2f2:             ; ************************
 1718 b2f2:             ; ***** Exit command *****
 1719 b2f2:             ; ************************
 1720 b2f2: f8 0c       exit:      ldi     0ch               ; clear screen
 1721 b2f4: d4                     sep     scall
 1722 b2f5: ff 03                  dw      f_type
            #ifdef ANYROM
 1724 b2f7: c0 80 03               lbr     08003h            ; Pico ROM warm start
            #endif
 1733 b2fa:             
            #ifdef ANYROM
 1735 b2fa:             ; ***********************
 1736 b2fa:             ; ***** Asm command *****
 1737 b2fa:             ; ***********************
 1738 b2fa: f8 03 a0 f8 
            9c b0       asm:       mov     r0,edtasm+3
 1739 b300: d0                     sep     r0
            #endif
 1741 b301:             
 1742 b301:             ; ******************************************
 1743 b301:             ; ***** Move memory RF->RD, RC.0 count *****
 1744 b301:             ; ******************************************
 1745 b301: 4f          move:      lda     rf                ; get source byte
 1746 b302: 5d                     str     rd                ; store into destination
 1747 b303: 1d                     inc     rd                ; increment destination
 1748 b304: 2c                     dec     rc                ; decrement count
 1749 b305: 8c                     glo     rc                ; see if done
 1750 b306: ca b3 01               lbnz    move              ; jump if not
 1751 b309: d5                     sep     sret              ; return to caller
 1752 b30a:             
 1753 b30a:             ; ****************************************
 1754 b30a:             ; ***** Convert ascii hex to binary  *****
 1755 b30a:             ; ***** RF - Pointer to ascii string *****
 1756 b30a:             ; ***** Returns: RC - binary value   *****
 1757 b30a:             ; ****************************************
 1758 b30a: f8 00       tohex:     ldi     0h                ; clear return value
 1759 b30c: ac                     plo     rc
 1760 b30d: bc                     phi     rc
 1761 b30e: 0f          tohexlp:   ldn     rf                ; get next byte
 1762 b30f: ff 30                  smi     '0'               ; check for bottom of range
 1763 b311: cb b3 56               lbnf    tohexdn           ; jump if non-numeric
 1764 b314: 0f                     ldn     rf                ; recover byte
 1765 b315: ff 3a                  smi     '9'+1             ; upper range of digits
 1766 b317: cb b3 3e               lbnf    tohexd            ; jump if digit
 1767 b31a: 0f                     ldn     rf                ; recover character
 1768 b31b: ff 41                  smi     'A'               ; check below uc A
 1769 b31d: cb b3 56               lbnf    tohexdn           ; jump if not hex character
 1770 b320: 0f                     ldn     rf                ; recover character
 1771 b321: ff 47                  smi     'F'+1             ; check for uppercase hex
 1772 b323: cb b3 38               lbnf    tohexuc           ; jump if so
 1773 b326: 0f                     ldn     rf                ; recover character
 1774 b327: ff 61                  smi     'a'               ; check below lc A
 1775 b329: cb b3 56               lbnf    tohexdn           ; jump if not hex character
 1776 b32c: 0f                     ldn     rf                ; recover character
 1777 b32d: ff 67                  smi     'f'+1             ; check for lowercase hex
 1778 b32f: c3 b3 56               lbdf    tohexdn           ; jump if not
 1779 b332: 4f          tohexlc:   lda     rf                ; recover character
 1780 b333: ff 57                  smi     87                ; convert to binary
 1781 b335: c0 b3 41               lbr     tohexad           ; and add it in
 1782 b338: 4f          tohexuc:   lda     rf                ; recover character
 1783 b339: ff 37                  smi     55                ; convert to binary
 1784 b33b: c0 b3 41               lbr     tohexad
 1785 b33e: 4f          tohexd:    lda     rf                ; recover character
 1786 b33f: ff 30                  smi     030h              ; convert to binary       
 1787 b341: 52          tohexad:   str     r2                ; store value to add
 1788 b342: f8 04                  ldi     4                 ; need to shift 4 times
 1789 b344: ae                     plo     re
 1790 b345: 8c fe ac 9c 
            7e bc       tohexal:   shl     rc
 1791 b34b: 2e                     dec     re                ; decrement count
 1792 b34c: 8e                     glo     re                ; get count
 1793 b34d: ca b3 45               lbnz    tohexal           ; loop until done
 1794 b350: 8c                     glo     rc                ; now add in new value
 1795 b351: f1                     or                        ; or with stored byte
 1796 b352: ac                     plo     rc
 1797 b353: c0 b3 0e               lbr     tohexlp           ; loop back for next character
 1798 b356: d5          tohexdn:   sep     sret              ; return to caller
 1799 b357:             
 1800 b357:             
 1801 b357:             ; *****************************************
 1802 b357:             ; ***** Disassemble instruction at rf *****
 1803 b357:             ; *****************************************
 1804 b357: 8f 73 9f 73 disassem:  push    rf                ; save address
 1805 b35b: d4                     sep     scall             ; display address
 1806 b35c: af 46                  dw      disp16
 1807 b35e: f8 20                  ldi     ' '               ; display a space
 1808 b360: d4                     sep     scall
 1809 b361: ff 03                  dw      f_type
 1810 b363: 0f                     ldn     rf                ; get instruction byte
 1811 b364: fe                     shl                       ; multiply by 2
 1812 b365: ac                     plo     rc                ; put into rc
 1813 b366: f8 00                  ldi     0                 ; need the carry
 1814 b368: 7e                     shlc 
 1815 b369: bc                     phi     rc                ; rc now has instruction offset
 1816 b36a: 8c                     glo     rc                ; get low byte
 1817 b36b: fc 0c                  adi     inst.0            ; add in instruction table
 1818 b36d: ac                     plo     rc
 1819 b36e: 9c                     ghi     rc                ; get high byte
 1820 b36f: 7c b7                  adci    inst.1            ; add
 1821 b371: bc                     phi     rc                ; rc now points to instruction offset
 1822 b372: 4c                     lda     rc                ; get high byte of offset
 1823 b373: bf                     phi     rf                ; put into rf
 1824 b374: 0c                     ldn     rc                ; get low byte
 1825 b375: af                     plo     rf                ; put into rf
 1826 b376: 2f                     dec     rf                ; move to disassembly record
 1827 b377: 2f                     dec     rf
 1828 b378: 2f                     dec     rf
 1829 b379: 2f                     dec     rf
 1830 b37a: 2f                     dec     rf
 1831 b37b: 2f                     dec     rf
 1832 b37c: 4f                     lda     rf                ; get instruction type
 1833 b37d: ac                     plo     rc                ; save it
 1834 b37e: d4                     sep     scall             ; display instruction name
 1835 b37f: ff 09                  dw      f_msg
 1836 b381: f8 20                  ldi     ' '               ; following space
 1837 b383: d4                     sep     scall             ; display it
 1838 b384: ff 03                  dw      f_type
 1839 b386: 60 72 bf f0 
            af                     pop     rf                ; recover address
 1840 b38b: 8c                     glo     rc                ; get argument type
 1841 b38c: c2 b3 be               lbz     dadone            ; jump if no argument
 1842 b38f: ff 01                  smi     1                 ; need to check for type 1
 1843 b391: c2 b3 b0               lbz     da1               ; jump if type 1
 1844 b394: ff 01                  smi     1                 ; need to check for type 2
 1845 b396: c2 b3 b9               lbz     da2               ; jump if type 2
 1846 b399: 1f                     inc     rf                ; move past instruction byte
 1847 b39a: 8f 73 9f 73            push    rf                ; save address
 1848 b39e: 4f                     lda     rf                ; get high byte of argument
 1849 b39f: ac                     plo     rc                ; save for a moment
 1850 b3a0: 0f                     ldn     rf                ; get low byte
 1851 b3a1: af                     plo     rf                ; put into rf
 1852 b3a2: 8c                     glo     rc                ; get high byte
 1853 b3a3: bf                     phi     rf                ; rf now has 16-bit argument
 1854 b3a4: d4                     sep     scall             ; display it
 1855 b3a5: af 46                  dw      disp16
 1856 b3a7: 60 72 bf f0 
            af                     pop     rf                ; recover address
 1857 b3ac: 1f                     inc     rf                ; move past argument
 1858 b3ad: c0 b3 be               lbr     dadone            ; done
 1859 b3b0: 0f          da1:       ldn     rf                ; get instruction byte
 1860 b3b1: fa 0f                  ani     0fh               ; keep only low nybble
 1861 b3b3: d4                     sep     scall             ; display it
 1862 b3b4: af 25                  dw      disp4
 1863 b3b6: c0 b3 be               lbr     dadone            ; done
 1864 b3b9: 1f          da2:       inc     rf                ; move past instruction byte
 1865 b3ba: 0f                     ldn     rf                ; get argument byte
 1866 b3bb: d4                     sep     scall             ; display it
 1867 b3bc: af 38                  dw      disp8
 1868 b3be: d4          dadone:    sep     scall             ; clear any trailing bytes
 1869 b3bf: ff 66                  dw      f_inmsg
 1870 b3c1: 20 20 20 20 
            20 20 20 20 
            00                     db      '        ',0
 1871 b3ca: 1f                     inc     rf                ; move rf past instruction
 1872 b3cb: d5                     sep     sret              ; return to caller
 1873 b3cc:             
 1874 b3cc:             ; *****************************************
 1875 b3cc:             ; ***** Get address from command line *****
 1876 b3cc:             ; ***** RF = fist byte of address     *****
 1877 b3cc:             ; ***** Returns RF: address           *****
 1878 b3cc:             ; *****************************************
 1879 b3cc: 0f          getaddr:   ldn     rf                ; get byte from command line
 1880 b3cd: ff 50                  smi     'P'               ; check for P
 1881 b3cf: c2 b3 e6               lbz     getaddrp          ; jump if so
 1882 b3d2: 0f                     ldn     rf                ; recover byte
 1883 b3d3: ff 58                  smi     'X'               ; check for X
 1884 b3d5: c2 b3 ea               lbz     getaddrx          ; jump if so
 1885 b3d8: 0f                     ldn     rf                ; recover byte
 1886 b3d9: ff 52                  smi     'R'               ; check for R
 1887 b3db: c2 b3 ee               lbz     getaddrr          ; jump if so
 1888 b3de: d4                     sep     scall             ; from from ascii
 1889 b3df: b3 0a                  dw      tohex
 1890 b3e1: 8c af 9c bf            mov     rf,rc             ; transfer address to rf
 1891 b3e5: d5                     sep     sret              ; returnturn
 1892 b3e6: 89          getaddrp:  glo     r9                ; get P
 1893 b3e7: da          getaddrgo: sep     ra                ; set r7 to correct register
 1894 b3e8: db                     sep     rb                ; retrieve value into rf
 1895 b3e9: d5                     sep     sret              ; and return to caller
 1896 b3ea: 99          getaddrx:  ghi     r9                ; get X
 1897 b3eb: c0 b3 e7               lbr     getaddrgo         ; and then retrieve
 1898 b3ee: 1f          getaddrr:  inc     rf                ; point to next character
 1899 b3ef: d4                     sep     scall             ; get number from input
 1900 b3f0: b3 0a                  dw      tohex
 1901 b3f2: 8c                     glo     rc                ; get lowest byte
 1902 b3f3: fa 0f                  ani     0fh               ; and only lowest nybble
 1903 b3f5: c0 b3 e7               lbr     getaddrgo         ; and retrieve value
 1904 b3f8:             
 1905 b3f8:             ; ******************************************
 1906 b3f8:             ; ***** Handle disassemble ($) command *****
 1907 b3f8:             ; ******************************************
 1908 b3f8: 1f          disasm:    inc     rf                ; point to next byte
 1909 b3f9: d4                     sep     scall             ; retrieve address
 1910 b3fa: b3 cc                  dw      getaddr
 1911 b3fc: f8 24       dodisasm:  ldi     36                ; position of dump box
 1912 b3fe: bd                     phi     rd                ; set position
 1913 b3ff: f8 02                  ldi     2                 ; row
 1914 b401: ad                     plo     rd
 1915 b402: f8 07                  ldi     7                 ; 7 lines to display
 1916 b404: ac                     plo     rc
 1917 b405: 8f 73 9f 73 disasmlp:  push    rf                ; save address
 1918 b409: d4                     sep     scall             ; position cursor
 1919 b40a: ae e7                  dw      gotoxy
 1920 b40c: 60 72 bf f0 
            af                     pop     rf                ; recover address
 1921 b411: 8c                     glo     rc                ; save count
 1922 b412: 73                     stxd
 1923 b413: d4                     sep     scall             ; disassemble line
 1924 b414: b3 57                  dw      disassem
 1925 b416: 60                     irx                       ; recover count
 1926 b417: f0                     ldx
 1927 b418: ac                     plo     rc
 1928 b419: 1d                     inc     rd                ; move to next row
 1929 b41a: 2c                     dec     rc                ; decrement line count
 1930 b41b: 8c                     glo     rc                ; get count
 1931 b41c: ca b4 05               lbnz    disasmlp          ; loop back if not done
 1932 b41f: c0 b2 26               lbr     main
 1933 b422:             
 1934 b422:             
 1935 b422:             
 1936 b422:             ; ***********************************
 1937 b422:             ; ***** Handle dump (?) command *****
 1938 b422:             ; ***********************************
 1939 b422: 1f          dump:      inc     rf                ; point to next byte
 1940 b423: d4                     sep     scall             ; get address
 1941 b424: b3 cc                  dw      getaddr
 1942 b426: f8 24       dodump:    ldi     36                ; position of dump box
 1943 b428: bd                     phi     rd
 1944 b429: f8 0b                  ldi     11
 1945 b42b: ad                     plo     rd
 1946 b42c: f8 07                  ldi     7                 ; seven lines to dump
 1947 b42e: bc                     phi     rc                ; place into counter
 1948 b42f: 8f 73 9f 73 dumplpy:   push    rf                ; save address
 1949 b433: d4                     sep     scall             ; position cursor
 1950 b434: ae e7                  dw      gotoxy
 1951 b436: 60 72 bf f0 
            af                     pop     rf                ; recover address
 1952 b43b: d4                     sep     scall             ; display address
 1953 b43c: af 46                  dw      disp16
 1954 b43e: f8 08                  ldi     8                 ; 8 bytes to write
 1955 b440: ac                     plo     rc
 1956 b441: f8 20       dumplpx:   ldi     ' '               ; need a space
 1957 b443: d4                     sep     scall             ; display it
 1958 b444: ff 03                  dw      f_type
 1959 b446: 4f                     lda     rf                ; get next byte
 1960 b447: d4                     sep     scall             ; display it
 1961 b448: af 38                  dw      disp8
 1962 b44a: 2c                     dec     rc                ; decrement x count
 1963 b44b: 8c                     glo     rc                ; are we done?
 1964 b44c: ca b4 41               lbnz    dumplpx           ; loop back if not
 1965 b44f: 1d                     inc     rd                ; move to next row
 1966 b450: 9c                     ghi     rc                ; get row count
 1967 b451: ff 01                  smi     1                 ; subtract 1
 1968 b453: bc                     phi     rc                ; put it back
 1969 b454: ca b4 2f               lbnz    dumplpy           ; loop back if not done
 1970 b457: c0 b2 26               lbr     main              ; done, so jump back
 1971 b45a:             
 1972 b45a:             ; *****************************
 1973 b45a:             ; ***** Store (!) command *****
 1974 b45a:             ; *****************************
 1975 b45a: 1f          store:     inc     rf                ; point to next byte
 1976 b45b: 8f 73 9f 73            push    rf                ; save buffer postion
 1977 b45f: d4                     sep     scall             ; get address
 1978 b460: b3 cc                  dw      getaddr
 1979 b462: 8f                     glo     rf                ; transfer address to rd
 1980 b463: ad                     plo     rd
 1981 b464: 9f                     ghi     rf
 1982 b465: bd                     phi     rd
 1983 b466: 60 72 bf f0 
            af                     pop     rf                ; recover buffer address
 1984 b46b: 0f          store1:    ldn     rf                ; get character from buffer
 1985 b46c: c2 b2 26               lbz     main              ; jump if end of input
 1986 b46f: ff 20                  smi     ' '               ; look for a space
 1987 b471: c2 b4 78               lbz     storelp           ; jump if found
 1988 b474: 1f                     inc     rf                ; otherwise move to next character
 1989 b475: c0 b4 6b               lbr     store1            ; and keep looking
 1990 b478: 0f          storelp:   ldn     rf                ; get next character
 1991 b479: c2 b2 02               lbz     instdn1           ; jump if end of string
 1992 b47c: ff 20                  smi     ' '               ; check for space
 1993 b47e: ca b4 85               lbnz    store2            ; jump if not
 1994 b481: 1f                     inc     rf                ; move past space
 1995 b482: c0 b4 78               lbr     storelp           ; and loop back
 1996 b485: d4          store2:    sep     scall             ; retrieve next value
 1997 b486: b3 0a                  dw      tohex
 1998 b488: 8c                     glo     rc                ; get only lowest byte
 1999 b489: 5d                     str     rd                ; store into destination
 2000 b48a: 1d                     inc     rd                ; increment pointer
 2001 b48b: c0 b4 78               lbr     storelp           ; loop back for next byte
 2002 b48e:                        
 2003 b48e:             ; ***************************
 2004 b48e:             ; ***** Run (@) command *****
 2005 b48e:             ; ***************************
 2006 b48e: 1f          run:       inc     rf                ; move to address
 2007 b48f: d4                     sep     scall             ; get address
 2008 b490: b3 cc                  dw      getaddr
 2009 b492: f8 00                  ldi     r0.0              ; need to set into R[0]
 2010 b494: a7                     plo     r7                ; set register pointer
 2011 b495: 9f                     ghi     rf                ; get high byte of address
 2012 b496: 57                     str     r7                ; and store it
 2013 b497: 17                     inc     r7                ; point to low byte
 2014 b498: 8f                     glo     rf                ; get low byte of address
 2015 b499: 57                     str     r7                ; and store it
 2016 b49a: f8 00                  ldi     0                 ; need to zero
 2017 b49c: a9                     plo     r9                ; P
 2018 b49d: b9                     phi     r9                ; and X
 2019 b49e: c0 b1 91               lbr     instdn            ; back to main loop
 2020 b4a1:             
 2021 b4a1:             ; *****************************
 2022 b4a1:             ; **** Set P (P=) command *****
 2023 b4a1:             ; *****************************
 2024 b4a1: 1f          setp:      inc     rf                ; point to next character
 2025 b4a2: 4f                     lda     rf                ; retrieve it
 2026 b4a3: ff 3d                  smi     '='               ; must be =
 2027 b4a5: ca b2 26               lbnz    main              ; loop back to main if not
 2028 b4a8: d4                     sep     scall             ; get value
 2029 b4a9: b3 0a                  dw      tohex
 2030 b4ab: 8c                     glo     rc                ; get lowest byte
 2031 b4ac: fa 0f                  ani     0fh               ; lowest nybble
 2032 b4ae: a9                     plo     r9                ; set P
 2033 b4af: c0 b1 ff               lbr     showregs          ; then back to main
 2034 b4b2:             
 2035 b4b2:             ; *****************************
 2036 b4b2:             ; **** Set X (X=) command *****
 2037 b4b2:             ; *****************************
 2038 b4b2: 1f          setx:      inc     rf                ; point to next character
 2039 b4b3: 4f                     lda     rf                ; retrieve it
 2040 b4b4: ff 3d                  smi     '='               ; must be =
 2041 b4b6: ca b2 26               lbnz    main              ; loop back to main if not
 2042 b4b9: d4                     sep     scall             ; get value
 2043 b4ba: b3 0a                  dw      tohex
 2044 b4bc: 8c                     glo     rc                ; get lowest byte
 2045 b4bd: fa 0f                  ani     0fh               ; lowest nybble
 2046 b4bf: b9                     phi     r9                ; set X
 2047 b4c0: c0 b1 ff               lbr     showregs          ; then back to main
 2048 b4c3:             
 2049 b4c3:             ; ******************************
 2050 b4c3:             ; ***** Set D (D=) command *****
 2051 b4c3:             ; ******************************
 2052 b4c3: 1f          setd:      inc     rf                ; point to next character
 2053 b4c4: 0f                     ldn     rf                ; retrieve next character
 2054 b4c5: ff 46                  smi     'F'               ; check for DF= command
 2055 b4c7: c2 b4 d8               lbz     setdf             ; jump if so
 2056 b4ca: 4f                     lda     rf                ; retrieve character
 2057 b4cb: ff 3d                  smi     '='               ; must be =
 2058 b4cd: ca b2 26               lbnz    main              ; loop back to main if not
 2059 b4d0: d4                     sep     scall             ; get value
 2060 b4d1: b3 0a                  dw      tohex
 2061 b4d3: 8c                     glo     rc                ; get lowest byte
 2062 b4d4: a8                     plo     r8                ; set D
 2063 b4d5: c0 b1 ff               lbr     showregs          ; then back to main
 2064 b4d8:             
 2065 b4d8:             ; ********************************
 2066 b4d8:             ; ***** Set DF (DF=) command *****
 2067 b4d8:             ; ********************************
 2068 b4d8: 1f          setdf:     inc     rf                ; point to next character
 2069 b4d9: 4f                     lda     rf                ; retrieve it
 2070 b4da: ff 3d                  smi     '='               ; must be =
 2071 b4dc: ca b2 26               lbnz    main              ; loop back to main if not
 2072 b4df: d4                     sep     scall             ; get value
 2073 b4e0: b3 0a                  dw      tohex
 2074 b4e2: 8c                     glo     rc                ; get lowest byte
 2075 b4e3: fa 01                  ani     01h               ; lowest bit
 2076 b4e5: b8                     phi     r8                ; set DF
 2077 b4e6: c0 b1 ff               lbr     showregs          ; then back to main
 2078 b4e9:             
 2079 b4e9:             ; ******************************
 2080 b4e9:             ; ***** Set Q (Q=) command *****
 2081 b4e9:             ; ******************************
 2082 b4e9: 1f          setq:      inc     rf                ; point to next character
 2083 b4ea: 4f                     lda     rf                ; retrieve it
 2084 b4eb: ff 3d                  smi     '='               ; must be =
 2085 b4ed: ca b2 26               lbnz    main              ; loop back to main if not
 2086 b4f0: d4                     sep     scall             ; get value
 2087 b4f1: b3 0a                  dw      tohex
 2088 b4f3: f8 20                  ldi     q.0               ; need to point to Q register
 2089 b4f5: a7                     plo     r7                ; put into register pointer
 2090 b4f6: 8c                     glo     rc                ; get lowest byte
 2091 b4f7: fa 01                  ani     01h               ; lowest bit
 2092 b4f9: 57                     str     r7                ; set Q
 2093 b4fa: c0 b1 ff               lbr     showregs          ; then back to main
 2094 b4fd:             
 2095 b4fd:             ; ******************************
 2096 b4fd:             ; ***** Set T (T=) command *****
 2097 b4fd:             ; ******************************
 2098 b4fd: 1f          sett:      inc     rf                ; point to next character
 2099 b4fe: 0f                     ldn     rf                ; get next character
 2100 b4ff: ff 43                  smi     'C'               ; check for TC command
 2101 b501: c2 b6 81               lbz     trapc             ; jump if so
 2102 b504: 0f                     ldn     rf                ; retrieve character
 2103 b505: ff 2b                  smi     '+'               ; check for T+
 2104 b507: c2 b6 8a               lbz     trapadd           ; jump if add
 2105 b50a: 0f                     ldn     rf                ; retrieve character
 2106 b50b: ff 2d                  smi     '-'               ; check for T-
 2107 b50d: c2 b6 a7               lbz     trapsub           ; jump if remove
 2108 b510: 4f                     lda     rf                ; retrieve character
 2109 b511: ff 3d                  smi     '='               ; must be =
 2110 b513: ca b2 26               lbnz    main              ; loop back to main if not
 2111 b516: d4                     sep     scall             ; get value
 2112 b517: b3 0a                  dw      tohex
 2113 b519: f8 21                  ldi     t.0               ; point to T register
 2114 b51b: a7                     plo     r7                ; put into register index
 2115 b51c: 8c                     glo     rc                ; get lowest byte
 2116 b51d: 57                     str     r7                ; set T
 2117 b51e: c0 b1 ff               lbr     showregs          ; then back to main
 2118 b521:             
 2119 b521:             ; *****************************************
 2120 b521:             ; ***** Trigger interrupt (I) command *****
 2121 b521:             ; *****************************************
 2122 b521: 1f          doint:     inc     rf                ; point to next character
 2123 b522: 0f                     ldn     rf                ; retrieve it
 2124 b523: c2 b5 2e               lbz     doint1            ; jump if I command
 2125 b526: ff 45                  smi     'E'               ; Check for IE= command
 2126 b528: c2 b5 52               lbz     setie             ; jump if so
 2127 b52b: c0 b2 26               lbr     main              ; back to main if not valid command
 2128 b52e: f8 22       doint1:    ldi     ie.0              ; need IE register
 2129 b530: a7                     plo     r7                ; set register index
 2130 b531: 07                     ldn     r7                ; get IE
 2131 b532: c2 b2 26               lbz     main              ; Back to main if interrupts disabled
 2132 b535: f8 21                  ldi     t.0               ; Point to T register
 2133 b537: a7                     plo     r7                ; put into register pointer
 2134 b538: 89                     glo     r9                ; get P
 2135 b539: 57                     str     r7                ; put into T
 2136 b53a: 99                     ghi     r9                ; get X
 2137 b53b: fe                     shl                       ; move over 1 nybble
 2138 b53c: fe                     shl
 2139 b53d: fe                     shl
 2140 b53e: fe                     shl
 2141 b53f: e7                     sex     r7                ; point x to T
 2142 b540: f1                     or                        ; combine with P
 2143 b541: 57                     str     r7                ; and store it
 2144 b542: e2                     sex     r2                ; put x back to 2
 2145 b543: f8 02                  ldi     2                 ; need to set x=2
 2146 b545: b9                     phi     r9                ; set X
 2147 b546: f8 01                  ldi     1                 ; need to set p=1
 2148 b548: a9                     plo     r9                ; set P
 2149 b549: f8 22                  ldi     ie.0              ; need to clear IE
 2150 b54b: a7                     plo     r7                ; set register pointer
 2151 b54c: f8 00                  ldi     0
 2152 b54e: 57                     str     r7                ; set IE
 2153 b54f: c0 b1 ff               lbr     showregs          ; then back to main loop
 2154 b552:             
 2155 b552:             
 2156 b552:             ; ********************************
 2157 b552:             ; ***** Set DF (DF=) command *****
 2158 b552:             ; ********************************
 2159 b552: 1f          setie:     inc     rf                ; point to next character
 2160 b553: 4f                     lda     rf                ; retrieve it
 2161 b554: ff 3d                  smi     '='               ; must be =
 2162 b556: ca b2 26               lbnz    main              ; loop back to main if not
 2163 b559: d4                     sep     scall             ; get value
 2164 b55a: b3 0a                  dw      tohex
 2165 b55c: f8 22                  ldi     ie.0              ; Need IE register
 2166 b55e: a7                     plo     r7                ; set into register index
 2167 b55f: 8c                     glo     rc                ; get lowest byte
 2168 b560: fa 01                  ani     01h               ; lowest bit
 2169 b562: 57                     str     r7                ; set IE
 2170 b563: c0 b1 ff               lbr     showregs          ; then back to main
 2171 b566:             
 2172 b566:             ; ******************************
 2173 b566:             ; **** Set R (Rn=) command *****
 2174 b566:             ; ******************************
 2175 b566: 1f          setr:      inc     rf                ; point to next character
 2176 b567: d4                     sep     scall             ; get register number
 2177 b568: b3 0a                  dw      tohex
 2178 b56a: 8c                     glo     rc                ; get number
 2179 b56b: fa 0f                  ani     0fh               ; keep only low nybble
 2180 b56d: da                     sep     ra                ; setup register address
 2181 b56e: 4f                     lda     rf                ; retrieve next character
 2182 b56f: ff 3d                  smi     '='               ; must be =
 2183 b571: ca b2 26               lbnz    main              ; loop back to main if not
 2184 b574: d4                     sep     scall             ; get value
 2185 b575: b3 0a                  dw      tohex
 2186 b577: 9c                     ghi     rc                ; get high byte of value
 2187 b578: 57                     str     r7                ; store into R register
 2188 b579: 17                     inc     r7                ; point to low byte
 2189 b57a: 8c                     glo     rc                ; get low byte of value
 2190 b57b: 57                     str     r7                ; and store to R register
 2191 b57c: c0 b1 ff               lbr     showregs          ; then back to main
 2192 b57f:             
 2193 b57f:             ; ********************************
 2194 b57f:             ; ***** Show breakpoint list *****
 2195 b57f:             ; ********************************
 2196 b57f: f8 28       showbp:    ldi     nbp.0             ; get number of breakpoints
 2197 b581: a7                     plo     r7                ; point into data pointer
 2198 b582: 07                     ldn     r7                ; get number of breakpoints
 2199 b583: ac                     plo     rc                ; place into counter
 2200 b584: fd 08                  sdi     8                 ; find number of empty places
 2201 b586: bc                     phi     rc                ; keep count for later
 2202 b587: f8 29                  ldi     bp.0              ; address of breakpoints
 2203 b589: a7                     plo     r7                ; place into r7
 2204 b58a: f8 1b                  ldi     27                ; setup screen position
 2205 b58c: bd                     phi     rd
 2206 b58d: f8 09                  ldi     9
 2207 b58f: ad                     plo     rd
 2208 b590: 8c                     glo     rc                ; Are there any breakpoints
 2209 b591: ca b5 99               lbnz    showbplp1         ; jump if so
 2210 b594: 9c                     ghi     rc                ; move blank count
 2211 b595: ac                     plo     rc                ; to rc
 2212 b596: c0 b5 ae               lbr     showbplp2         ; now show blank lines
 2213 b599: d4          showbplp1: sep     scall             ; set cursor position
 2214 b59a: ae e7                  dw      gotoxy
 2215 b59c: 47                     lda     r7                ; get high byte of next bp
 2216 b59d: bf                     phi     rf                ; store into rf
 2217 b59e: 47                     lda     r7                ; get low byte of next bp
 2218 b59f: af                     plo     rf                ; and store it
 2219 b5a0: d4                     sep     scall             ; now display it
 2220 b5a1: af 46                  dw      disp16
 2221 b5a3: 1d                     inc     rd                ; next row
 2222 b5a4: 2c                     dec     rc                ; decrement count
 2223 b5a5: 8c                     glo     rc                ; get it
 2224 b5a6: ca b5 99               lbnz    showbplp1         ; loop until all shown
 2225 b5a9: 9c                     ghi     rc                ; get empty count
 2226 b5aa: ac                     plo     rc                ; place in counter
 2227 b5ab: c2 b2 26               lbz     main              ; jump if no blank lines needed
 2228 b5ae: d4          showbplp2: sep     scall             ; set cursor position
 2229 b5af: ae e7                  dw      gotoxy
 2230 b5b1: d4                     sep     scall             ; draw 4 spaces
 2231 b5b2: ff 66                  dw      f_inmsg
 2232 b5b4: 20 20 20 20 
            00                     db      '    ',0
 2233 b5b9: 1d                     inc     rd                ; increment row
 2234 b5ba: 2c                     dec     rc                ; decrement count
 2235 b5bb: 8c                     glo     rc                ; get count
 2236 b5bc: ca b5 ae               lbnz    showbplp2         ; jump if not done
 2237 b5bf: c0 b2 26               lbr     main              ; then return to main
 2238 b5c2:             
 2239 b5c2:             ; *******************************
 2240 b5c2:             ; ***** Breakpoint commands *****
 2241 b5c2:             ; *******************************
 2242 b5c2: 1f          breakp:    inc     rf                ; point to next character
 2243 b5c3: 0f                     ldn     rf                ; get character
 2244 b5c4: ff 43                  smi     'C'               ; check for clear command
 2245 b5c6: c2 b6 3a               lbz     breakc            ; jump to clear breakpoints
 2246 b5c9: 0f                     ldn     rf                ; get character back
 2247 b5ca: ff 2b                  smi     '+'               ; see if add
 2248 b5cc: c2 b6 19               lbz     breakadd          ; jump if so
 2249 b5cf: 0f                     ldn     rf                ; recover character
 2250 b5d0: ff 2d                  smi     '-'               ; see if remove
 2251 b5d2: ca b2 26               lbnz    main              ; jump if not
 2252 b5d5: 1f                     inc     rf                ; move past -
 2253 b5d6: d4                     sep     scall             ; get address
 2254 b5d7: b3 0a                  dw      tohex             ; into rc
 2255 b5d9: f8 28                  ldi     nbp.0             ; need number of breakpoints
 2256 b5db: a7                     plo     r7                ; put into data pointer
 2257 b5dc: 07                     ldn     r7                ; get number
 2258 b5dd: c2 b2 26               lbz     main              ; jump if no breakpoints
 2259 b5e0: ae                     plo     re                ; save count
 2260 b5e1: f8 29                  ldi     bp.0              ; point to breakpoint table
 2261 b5e3: a7                     plo     r7                ; setup data pointer
 2262 b5e4: e7                     sex     r7                ; need to use for comparisons
 2263 b5e5: 9c          breaksub1: ghi     rc                ; get high byte of address
 2264 b5e6: f7                     sm                        ; see if matches
 2265 b5e7: 17                     inc     r7                ; point to low byte
 2266 b5e8: ca b5 f0               lbnz    breaksub2         ; jump if no match
 2267 b5eb: 8c                     glo     rc                ; get low byte of address
 2268 b5ec: f7                     sm                        ; see if matches
 2269 b5ed: c2 b5 fa               lbz     breaksub3         ; jump if address found
 2270 b5f0: 17          breaksub2: inc     r7                ; point to next entry
 2271 b5f1: 2e                     dec     re                ; decrement count
 2272 b5f2: 8e                     glo     re                ; see if done
 2273 b5f3: ca b5 e5               lbnz    breaksub1         ; loop if more to check
 2274 b5f6: e2                     sex     r2                ; point x back to R[2]
 2275 b5f7: c2 b2 26               lbz     main              ; otherwise return to caller
 2276 b5fa: e2          breaksub3: sex     r2                ; point x back to R[2]
 2277 b5fb: 27                     dec     r7                ; r7 now has pointer
 2278 b5fc: 97                     ghi     r7                ; r7 becomes destination
 2279 b5fd: bd                     phi     rd
 2280 b5fe: bf                     phi     rf                ; put here too
 2281 b5ff: 87                     glo     r7                ; low byte of destination
 2282 b600: ad                     plo     rd
 2283 b601: af                     plo     rf
 2284 b602: 1f                     inc     rf                ; rf needs to be 1 entry up
 2285 b603: 1f                     inc     rf
 2286 b604: 8e                     glo     re                ; get count remaining
 2287 b605: c2 b6 0f               lbz     breaksub4         ; jump if it was last entry, nothing to move
 2288 b608: ff 01                  smi     1                 ; 1 entry less
 2289 b60a: fe                     shl                       ; 2 bytes per entry
 2290 b60b: ac                     plo     rc                ; rc now has count
 2291 b60c: d4                     sep     scall             ; call move memory routine
 2292 b60d: b3 01                  dw      move
 2293 b60f: f8 28       breaksub4: ldi     nbp.0             ; point to number of breakpoints
 2294 b611: a7                     plo     r7                ; put into data pointer
 2295 b612: 07                     ldn     r7                ; get count
 2296 b613: ff 01                  smi     1                 ; decrement
 2297 b615: 57                     str     r7                ; and put it back
 2298 b616: c0 b5 7f               lbr     showbp            ; show remaining breakpoints
 2299 b619: f8 28       breakadd:  ldi     nbp.0             ; point to number of breakpoints
 2300 b61b: a7                     plo     r7
 2301 b61c: 07                     ldn     r7                ; get current number
 2302 b61d: fa f8                  ani     0f8h              ; check count
 2303 b61f: ca b2 26               lbnz    main              ; jump if 8 breakpoints already defined
 2304 b622: 07                     ldn     r7                ; recover count
 2305 b623: fc 01                  adi     1                 ; 1 more breakpoint
 2306 b625: 57                     str     r7                ; put back into count
 2307 b626: ff 01                  smi     1                 ; back to original to compute offset
 2308 b628: fe                     shl                       ; two bytes per breakpoint
 2309 b629: 52                     str     r2                ; save for add
 2310 b62a: f8 29                  ldi     bp.0              ; get offset for bps
 2311 b62c: f4                     add                       ; add offset
 2312 b62d: a7                     plo     r7                ; put into destination register
 2313 b62e: 1f                     inc     rf                ; most past +
 2314 b62f: d4                     sep     scall             ; now get address
 2315 b630: b3 0a                  dw      tohex
 2316 b632: 9c                     ghi     rc                ; get high byte of address
 2317 b633: 57                     str     r7                ; store it
 2318 b634: 17                     inc     r7                ; point to low byte
 2319 b635: 8c                     glo     rc                ; get low byte of address
 2320 b636: 57                     str     r7                ; and store it
 2321 b637: c0 b5 7f               lbr     showbp            ; show breakpoints
 2322 b63a: f8 28       breakc:    ldi     nbp.0             ; point to number of breakpoints
 2323 b63c: a7                     plo     r7
 2324 b63d: f8 00                  ldi     0                 ; clear them out
 2325 b63f: 57                     str     r7
 2326 b640: c0 b5 7f               lbr     showbp            ; then show them
 2327 b643:             
 2328 b643:             
 2329 b643:             ; ********************************
 2330 b643:             ; ***** Show breakpoint list *****
 2331 b643:             ; ********************************
 2332 b643: f8 39       showtp:    ldi     ntraps.0          ; get number of traps
 2333 b645: a7                     plo     r7                ; point into data pointer
 2334 b646: 07                     ldn     r7                ; get number of traps
 2335 b647: ac                     plo     rc                ; place into counter
 2336 b648: fd 10                  sdi     16                ; find number of empty places
 2337 b64a: bc                     phi     rc                ; keep count for later
 2338 b64b: f8 3a                  ldi     traps.0           ; address of traps
 2339 b64d: a7                     plo     r7                ; place into r7
 2340 b64e: f8 44                  ldi     68                ; setup screen position
 2341 b650: bd                     phi     rd
 2342 b651: f8 03                  ldi     3
 2343 b653: ad                     plo     rd
 2344 b654: 8c                     glo     rc                ; Are there any traps
 2345 b655: ca b6 5d               lbnz    showtplp1         ; jump if so
 2346 b658: 9c                     ghi     rc                ; move blank count
 2347 b659: ac                     plo     rc                ; to rc
 2348 b65a: c0 b6 6f               lbr     showtplp2         ; now show blank lines
 2349 b65d: d4          showtplp1: sep     scall             ; set cursor position
 2350 b65e: ae e7                  dw      gotoxy
 2351 b660: 47                     lda     r7                ; get trap byte
 2352 b661: d4                     sep     scall             ; now display it
 2353 b662: af 38                  dw      disp8
 2354 b664: 1d                     inc     rd                ; next row
 2355 b665: 2c                     dec     rc                ; decrement count
 2356 b666: 8c                     glo     rc                ; get it
 2357 b667: ca b6 5d               lbnz    showtplp1         ; loop until all shown
 2358 b66a: 9c                     ghi     rc                ; get empty count
 2359 b66b: ac                     plo     rc                ; place in counter
 2360 b66c: c2 b2 26               lbz     main              ; jump if no blank lines needed
 2361 b66f: d4          showtplp2: sep     scall             ; set cursor position
 2362 b670: ae e7                  dw      gotoxy
 2363 b672: d4                     sep     scall             ; draw 2 spaces
 2364 b673: ff 66                  dw      f_inmsg
 2365 b675: 20 20 00               db      '  ',0
 2366 b678: 1d                     inc     rd                ; increment row
 2367 b679: 2c                     dec     rc                ; decrement count
 2368 b67a: 8c                     glo     rc                ; get count
 2369 b67b: ca b6 6f               lbnz    showtplp2         ; jump if not done
 2370 b67e: c0 b2 26               lbr     main              ; then return to main
 2371 b681:             
 2372 b681:             ; ***************************
 2373 b681:             ; ***** Clear all traps *****
 2374 b681:             ; ***************************
 2375 b681: f8 39       trapc:     ldi     ntraps.0          ; need address of trap count
 2376 b683: a7                     plo     r7                ; put into data pointer
 2377 b684: f8 00                  ldi     0                 ; need to clear
 2378 b686: 57                     str     r7                ; write to trap count
 2379 b687: c0 b6 43               lbr     showtp            ; show trap list
 2380 b68a:             
 2381 b68a:             ; ********************
 2382 b68a:             ; ***** Add trap *****
 2383 b68a:             ; ********************
 2384 b68a: f8 39       trapadd:   ldi     ntraps.0          ; point to number of traps
 2385 b68c: a7                     plo     r7
 2386 b68d: 07                     ldn     r7                ; get current number
 2387 b68e: fa f0                  ani     0f0h              ; check count
 2388 b690: ca b2 26               lbnz    main              ; jump if 16 traps already defined
 2389 b693: 07                     ldn     r7                ; recover count
 2390 b694: fc 01                  adi     1                 ; 1 more trap
 2391 b696: 57                     str     r7                ; put back into count
 2392 b697: ff 01                  smi     1                 ; back to original to compute offset
 2393 b699: 52                     str     r2                ; save for add
 2394 b69a: f8 3a                  ldi     traps.0           ; get offset for bps
 2395 b69c: f4                     add                       ; add offset
 2396 b69d: a7                     plo     r7                ; put into destination register
 2397 b69e: 1f                     inc     rf                ; most past +
 2398 b69f: d4                     sep     scall             ; now get value
 2399 b6a0: b3 0a                  dw      tohex
 2400 b6a2: 8c                     glo     rc                ; get value
 2401 b6a3: 57                     str     r7                ; and store it
 2402 b6a4: c0 b6 43               lbr     showtp            ; show traps
 2403 b6a7:             
 2404 b6a7:             ; ***********************
 2405 b6a7:             ; ***** Remove trap *****
 2406 b6a7:             ; ***********************
 2407 b6a7: 1f          trapsub:   inc     rf                ; move past -
 2408 b6a8: d4                     sep     scall             ; get value
 2409 b6a9: b3 0a                  dw      tohex             ; into rc
 2410 b6ab: f8 39                  ldi     ntraps.0          ; need number of traps
 2411 b6ad: a7                     plo     r7                ; put into data pointer
 2412 b6ae: 07                     ldn     r7                ; get number
 2413 b6af: c2 b2 26               lbz     main              ; jump if no traps
 2414 b6b2: ae                     plo     re                ; save count
 2415 b6b3: f8 3a                  ldi     traps.0           ; point to trap table
 2416 b6b5: a7                     plo     r7                ; setup data pointer
 2417 b6b6: e7                     sex     r7                ; need to use for comparisons
 2418 b6b7: 8c          trapsub1:  glo     rc                ; get value
 2419 b6b8: f7                     sm                        ; see if matches
 2420 b6b9: c2 b6 c6               lbz     trapsub3          ; jump if address found
 2421 b6bc: 17          trapsub2:  inc     r7                ; point to next entry
 2422 b6bd: 2e                     dec     re                ; decrement count
 2423 b6be: 8e                     glo     re                ; see if done
 2424 b6bf: ca b6 b7               lbnz    trapsub1          ; loop if more to check
 2425 b6c2: e2                     sex     r2                ; point x back to R[2]
 2426 b6c3: c2 b2 26               lbz     main              ; otherwise return to caller
 2427 b6c6: e2          trapsub3:  sex     r2                ; point x back to R[2]
 2428 b6c7: 97                     ghi     r7                ; r7 becomes destination
 2429 b6c8: bd                     phi     rd
 2430 b6c9: bf                     phi     rf                ; put here too
 2431 b6ca: 87                     glo     r7                ; low byte of destination
 2432 b6cb: ad                     plo     rd
 2433 b6cc: af                     plo     rf
 2434 b6cd: 1f                     inc     rf                ; rf needs to be 1 entry up
 2435 b6ce: 8e                     glo     re                ; get count remaining
 2436 b6cf: c2 b6 d8               lbz     trapsub4          ; jump if it was last entry, nothing to move
 2437 b6d2: ff 01                  smi     1                 ; 1 entry less
 2438 b6d4: ac                     plo     rc                ; rc now has count
 2439 b6d5: d4                     sep     scall             ; call move memory routine
 2440 b6d6: b3 01                  dw      move
 2441 b6d8: f8 39       trapsub4:  ldi     ntraps.0          ; point to number of traps
 2442 b6da: a7                     plo     r7                ; put into data pointer
 2443 b6db: 07                     ldn     r7                ; get count
 2444 b6dc: ff 01                  smi     1                 ; decrement
 2445 b6de: 57                     str     r7                ; and put it back
 2446 b6df: c0 b6 43               lbr     showtp            ; show remaining traps
 2447 b6e2:             
 2448 b6e2:             ; **********************************************************
 2449 b6e2:             ; ***** Convert string to uppercase, honor quoted text *****
 2450 b6e2:             ; **********************************************************
 2451 b6e2: 0f          touc:      ldn     rf                  ; check for quote
 2452 b6e3: ff 27                  smi     027h
 2453 b6e5: c2 b6 ff               lbz     touc_qt             ; jump if quote
 2454 b6e8: 0f                     ldn     rf                  ; get byte from string
 2455 b6e9: c2 b6 fe               lbz     touc_dn             ; jump if done
 2456 b6ec: ff 61                  smi     'a'                 ; check if below lc
 2457 b6ee: cb b6 fa               lbnf    touc_nxt            ; jump if so
 2458 b6f1: ff 1b                  smi     27                  ; check upper rage
 2459 b6f3: c3 b6 fa               lbdf    touc_nxt            ; jump if above lc
 2460 b6f6: 0f                     ldn     rf                  ; otherwise convert character to lc
 2461 b6f7: ff 20                  smi     32
 2462 b6f9: 5f                     str     rf
 2463 b6fa: 1f          touc_nxt:  inc     rf                  ; point to next character
 2464 b6fb: c0 b6 e2               lbr     touc                ; loop to check rest of string
 2465 b6fe: d5          touc_dn:   sep     sret                ; return to caller
 2466 b6ff: 1f          touc_qt:   inc     rf                  ; move past quote
 2467 b700: 4f          touc_qlp:  lda     rf                  ; get next character
 2468 b701: c2 b6 fe               lbz     touc_dn             ; exit if terminator found
 2469 b704: ff 27                  smi     027h                ; check for quote charater
 2470 b706: c2 b6 e2               lbz     touc                ; back to main loop if quote
 2471 b709: c0 b7 00               lbr     touc_qlp            ; otherwise keep looking
 2472 b70c:             
 2473 b70c: aa 94       inst:      dw      doidl             ; 00 - IDL
 2474 b70e: ab c5                  dw      doldn             ; 01 - LDN R1
 2475 b710: ab c5                  dw      doldn             ; 02 - LDN R2
 2476 b712: ab c5                  dw      doldn             ; 03 - LDN R3
 2477 b714: ab c5                  dw      doldn             ; 04 - LDN R4
 2478 b716: ab c5                  dw      doldn             ; 05 - LDN R5
 2479 b718: ab c5                  dw      doldn             ; 06 - LDN R6
 2480 b71a: ab c5                  dw      doldn             ; 07 - LDN R7
 2481 b71c: ab c5                  dw      doldn             ; 08 - LDN R8
 2482 b71e: ab c5                  dw      doldn             ; 09 - LDN R9
 2483 b720: ab c5                  dw      doldn             ; 0A - LDN RA
 2484 b722: ab c5                  dw      doldn             ; 0B - LDN RB
 2485 b724: ab c5                  dw      doldn             ; 0C - LDN RC
 2486 b726: ab c5                  dw      doldn             ; 0D - LDN RD
 2487 b728: ab c5                  dw      doldn             ; 0E - LDN RE
 2488 b72a: ab c5                  dw      doldn             ; 0F - LDN RF
 2489 b72c: aa 9d                  dw      doinc             ; 10 - INC R0
 2490 b72e: aa 9d                  dw      doinc             ; 11 - INC R1
 2491 b730: aa 9d                  dw      doinc             ; 12 - INC R2
 2492 b732: aa 9d                  dw      doinc             ; 13 - INC R3
 2493 b734: aa 9d                  dw      doinc             ; 14 - INC R4
 2494 b736: aa 9d                  dw      doinc             ; 15 - INC R5
 2495 b738: aa 9d                  dw      doinc             ; 16 - INC R6
 2496 b73a: aa 9d                  dw      doinc             ; 17 - INC R7
 2497 b73c: aa 9d                  dw      doinc             ; 18 - INC R8
 2498 b73e: aa 9d                  dw      doinc             ; 19 - INC R9
 2499 b740: aa 9d                  dw      doinc             ; 1A - INC RA
 2500 b742: aa 9d                  dw      doinc             ; 1B - INC RB
 2501 b744: aa 9d                  dw      doinc             ; 1C - INC RC
 2502 b746: aa 9d                  dw      doinc             ; 1D - INC RD
 2503 b748: aa 9d                  dw      doinc             ; 1E - INC RE
 2504 b74a: aa 9d                  dw      doinc             ; 1F - INC RF
 2505 b74c: aa 63                  dw      dodec             ; 20 - DEC R0
 2506 b74e: aa 63                  dw      dodec             ; 21 - DEC R1
 2507 b750: aa 63                  dw      dodec             ; 22 - DEC R2
 2508 b752: aa 63                  dw      dodec             ; 23 - DEC R3
 2509 b754: aa 63                  dw      dodec             ; 24 - DEC R4
 2510 b756: aa 63                  dw      dodec             ; 25 - DEC R5
 2511 b758: aa 63                  dw      dodec             ; 26 - DEC R6
 2512 b75a: aa 63                  dw      dodec             ; 27 - DEC R7
 2513 b75c: aa 63                  dw      dodec             ; 28 - DEC R8
 2514 b75e: aa 63                  dw      dodec             ; 29 - DEC R9
 2515 b760: aa 63                  dw      dodec             ; 2A - DEC RA
 2516 b762: aa 63                  dw      dodec             ; 2B - DEC RB
 2517 b764: aa 63                  dw      dodec             ; 2C - DEC RC
 2518 b766: aa 63                  dw      dodec             ; 2D - DEC RD
 2519 b768: aa 63                  dw      dodec             ; 2E - DEC RE
 2520 b76a: aa 63                  dw      dodec             ; 2F - DEC RF
 2521 b76c: aa 45                  dw      dobr              ; 30 - BR
 2522 b76e: aa 35                  dw      dobq              ; 31 - BQ
 2523 b770: aa 56                  dw      dobz              ; 32 - BZ
 2524 b772: a9 fc                  dw      dobdf             ; 33 - BDF
 2525 b774: a9 98                  dw      dob1              ; 34 - B1 
 2526 b776: a9 a6                  dw      dob2              ; 35 - B2 
 2527 b778: a9 b1                  dw      dob3              ; 36 - B3 
 2528 b77a: a9 bc                  dw      dob4              ; 37 - B4 
 2529 b77c: a9 f3                  dw      donbr             ; 38 - NBR
 2530 b77e: aa 18                  dw      dobnq             ; 39 - BNQ
 2531 b780: aa 28                  dw      dobnz             ; 3A - BNZ
 2532 b782: aa 0a                  dw      dobnf             ; 3B - BNF
 2533 b784: a9 c7                  dw      dobn1             ; 3C - BN1
 2534 b786: a9 d2                  dw      dobn2             ; 3D - BN2
 2535 b788: a9 dd                  dw      dobn3             ; 3E - BN3
 2536 b78a: a9 e8                  dw      dobn4             ; 3F - BN4
 2537 b78c: ab a7                  dw      dolda             ; 40 - LDA R0
 2538 b78e: ab a7                  dw      dolda             ; 41 - LDA R1
 2539 b790: ab a7                  dw      dolda             ; 42 - LDA R2
 2540 b792: ab a7                  dw      dolda             ; 43 - LDA R3
 2541 b794: ab a7                  dw      dolda             ; 44 - LDA R4
 2542 b796: ab a7                  dw      dolda             ; 45 - LDA R5
 2543 b798: ab a7                  dw      dolda             ; 46 - LDA R6
 2544 b79a: ab a7                  dw      dolda             ; 47 - LDA R7
 2545 b79c: ab a7                  dw      dolda             ; 48 - LDA R8
 2546 b79e: ab a7                  dw      dolda             ; 49 - LDA R9
 2547 b7a0: ab a7                  dw      dolda             ; 4A - LDA RA
 2548 b7a2: ab a7                  dw      dolda             ; 4B - LDA RB
 2549 b7a4: ab a7                  dw      dolda             ; 4C - LDA RC
 2550 b7a6: ab a7                  dw      dolda             ; 4D - LDA RD
 2551 b7a8: ab a7                  dw      dolda             ; 4E - LDA RE
 2552 b7aa: ab a7                  dw      dolda             ; 4F - LDA RF
 2553 b7ac: ae 7d                  dw      dostr             ; 50 - STR R0
 2554 b7ae: ae 7d                  dw      dostr             ; 51 - STR R1
 2555 b7b0: ae 7d                  dw      dostr             ; 52 - STR R2
 2556 b7b2: ae 7d                  dw      dostr             ; 53 - STR R3
 2557 b7b4: ae 7d                  dw      dostr             ; 54 - STR R4
 2558 b7b6: ae 7d                  dw      dostr             ; 55 - STR R5
 2559 b7b8: ae 7d                  dw      dostr             ; 56 - STR R6
 2560 b7ba: ae 7d                  dw      dostr             ; 57 - STR R7
 2561 b7bc: ae 7d                  dw      dostr             ; 58 - STR R8
 2562 b7be: ae 7d                  dw      dostr             ; 59 - STR R9
 2563 b7c0: ae 7d                  dw      dostr             ; 5A - STR RA
 2564 b7c2: ae 7d                  dw      dostr             ; 5B - STR RB
 2565 b7c4: ae 7d                  dw      dostr             ; 5C - STR RC
 2566 b7c6: ae 7d                  dw      dostr             ; 5D - STR RD
 2567 b7c8: ae 7d                  dw      dostr             ; 5E - STR RE
 2568 b7ca: ae 7d                  dw      dostr             ; 5F - STR RF
 2569 b7cc: ab 19                  dw      doirx             ; 60 - IRX
 2570 b7ce: ac bd                  dw      doout1            ; 61 - OUT 1
 2571 b7d0: ac cc                  dw      doout2            ; 62 - OUT 2
 2572 b7d2: ac db                  dw      doout3            ; 63 - OUT 3
 2573 b7d4: ac ea                  dw      doout4            ; 64 - OUT 4
 2574 b7d6: ac f9                  dw      doout5            ; 65 - OUT 5
 2575 b7d8: ad 08                  dw      doout6            ; 66 - OUT 6
 2576 b7da: ad 17                  dw      doout7            ; 67 - OUT 7
 2577 b7dc: b1 91                  dw      instdn            ; 68 - (illegal on 1802)
 2578 b7de: aa a9                  dw      doinp1            ; 69 - INP 1
 2579 b7e0: aa b9                  dw      doinp2            ; 6A - INP 2
 2580 b7e2: aa c9                  dw      doinp3            ; 6B - INP 3
 2581 b7e4: aa d9                  dw      doinp4            ; 6C - INP 4
 2582 b7e6: aa e9                  dw      doinp5            ; 6D - INP 5
 2583 b7e8: aa f9                  dw      doinp6            ; 6E - INP 6
 2584 b7ea: ab 09                  dw      doinp7            ; 6F - INP 7
 2585 b7ec: ad 3f                  dw      doret             ; 70 - RET
 2586 b7ee: aa 75                  dw      dodis             ; 71 - DIS
 2587 b7f0: ab e0                  dw      doldxa            ; 72 - LDXA
 2588 b7f2: ae 8a                  dw      dostxd            ; 73 - STXD
 2589 b7f4: a9 26                  dw      doadc             ; 74 - ADC
 2590 b7f6: ad 91                  dw      dosdb             ; 75 - SDB
 2591 b7f8: ae 1d                  dw      doshrc            ; 76 - SHRC
 2592 b7fa: ae 40                  dw      dosmb             ; 77 - SMB
 2593 b7fc: ad 6d                  dw      dosav             ; 78 - SAV
 2594 b7fe: ac 54                  dw      domark            ; 79 - MARK
 2595 b800: ad 5e                  dw      doreq             ; 7A - REQ
 2596 b802: ad d8                  dw      doseq             ; 7B - SEQ
 2597 b804: a9 3b                  dw      doadci            ; 7C - ADCI
 2598 b806: ad a6                  dw      dosdbi            ; 7D - SDBI
 2599 b808: ad ff                  dw      doshlc            ; 7E - SHLC
 2600 b80a: ae 55                  dw      dosmbi            ; 7F - SMBI
 2601 b80c: ab 32                  dw      doglo             ; 80 - GLO R0
 2602 b80e: ab 32                  dw      doglo             ; 81 - GLO R1
 2603 b810: ab 32                  dw      doglo             ; 82 - GLO R2
 2604 b812: ab 32                  dw      doglo             ; 83 - GLO R3
 2605 b814: ab 32                  dw      doglo             ; 84 - GLO R4
 2606 b816: ab 32                  dw      doglo             ; 85 - GLO R5
 2607 b818: ab 32                  dw      doglo             ; 86 - GLO R6
 2608 b81a: ab 32                  dw      doglo             ; 87 - GLO R7
 2609 b81c: ab 32                  dw      doglo             ; 88 - GLO R8
 2610 b81e: ab 32                  dw      doglo             ; 89 - GLO R9
 2611 b820: ab 32                  dw      doglo             ; 8A - GLO RA
 2612 b822: ab 32                  dw      doglo             ; 8B - GLO RB
 2613 b824: ab 32                  dw      doglo             ; 8C - GLO RC
 2614 b826: ab 32                  dw      doglo             ; 8D - GLO RD
 2615 b828: ab 32                  dw      doglo             ; 8E - GLO RE
 2616 b82a: ab 32                  dw      doglo             ; 8F - GLO RF
 2617 b82c: ab 26                  dw      doghi             ; 90 - GHI R0
 2618 b82e: ab 26                  dw      doghi             ; 91 - GHI R1
 2619 b830: ab 26                  dw      doghi             ; 92 - GHI R2
 2620 b832: ab 26                  dw      doghi             ; 93 - GHI R3
 2621 b834: ab 26                  dw      doghi             ; 94 - GHI R4
 2622 b836: ab 26                  dw      doghi             ; 95 - GHI R5
 2623 b838: ab 26                  dw      doghi             ; 96 - GHI R6
 2624 b83a: ab 26                  dw      doghi             ; 97 - GHI R7
 2625 b83c: ab 26                  dw      doghi             ; 98 - GHI R8
 2626 b83e: ab 26                  dw      doghi             ; 99 - GHI R9
 2627 b840: ab 26                  dw      doghi             ; 9A - GHI RA
 2628 b842: ab 26                  dw      doghi             ; 9B - GHI RB
 2629 b844: ab 26                  dw      doghi             ; 9C - GHI RC
 2630 b846: ab 26                  dw      doghi             ; 9D - GHI RD
 2631 b848: ab 26                  dw      doghi             ; 9E - GHI RE
 2632 b84a: ab 26                  dw      doghi             ; 9F - GHI RF
 2633 b84c: ad 32                  dw      doplo             ; A0 - PLO R0
 2634 b84e: ad 32                  dw      doplo             ; A1 - PLO R1
 2635 b850: ad 32                  dw      doplo             ; A2 - PLO R2
 2636 b852: ad 32                  dw      doplo             ; A3 - PLO R3
 2637 b854: ad 32                  dw      doplo             ; A4 - PLO R4
 2638 b856: ad 32                  dw      doplo             ; A5 - PLO R5
 2639 b858: ad 32                  dw      doplo             ; A6 - PLO R6
 2640 b85a: ad 32                  dw      doplo             ; A7 - PLO R7
 2641 b85c: ad 32                  dw      doplo             ; A8 - PLO R8
 2642 b85e: ad 32                  dw      doplo             ; A9 - PLO R9
 2643 b860: ad 32                  dw      doplo             ; AA - PLO RA
 2644 b862: ad 32                  dw      doplo             ; AB - PLO RB
 2645 b864: ad 32                  dw      doplo             ; AC - PLO RC
 2646 b866: ad 32                  dw      doplo             ; AD - PLO RD
 2647 b868: ad 32                  dw      doplo             ; AE - PLO RE
 2648 b86a: ad 32                  dw      doplo             ; AF - PLO RF
 2649 b86c: ad 26                  dw      dophi             ; B0 - PHI R0
 2650 b86e: ad 26                  dw      dophi             ; B1 - PHI R1
 2651 b870: ad 26                  dw      dophi             ; B2 - PHI R2
 2652 b872: ad 26                  dw      dophi             ; B3 - PHI R3
 2653 b874: ad 26                  dw      dophi             ; B4 - PHI R4
 2654 b876: ad 26                  dw      dophi             ; B5 - PHI R5
 2655 b878: ad 26                  dw      dophi             ; B6 - PHI R6
 2656 b87a: ad 26                  dw      dophi             ; B7 - PHI R7
 2657 b87c: ad 26                  dw      dophi             ; B8 - PHI R8
 2658 b87e: ad 26                  dw      dophi             ; B9 - PHI R9
 2659 b880: ad 26                  dw      dophi             ; BA - PHI RA
 2660 b882: ad 26                  dw      dophi             ; BB - PHI RB
 2661 b884: ad 26                  dw      dophi             ; BC - PHI RC
 2662 b886: ad 26                  dw      dophi             ; BD - PHI RD
 2663 b888: ad 26                  dw      dophi             ; BE - PHI RE
 2664 b88a: ad 26                  dw      dophi             ; BF - PHI RF
 2665 b88c: ab 95                  dw      dolbr             ; C0 - LBR
 2666 b88e: ab 78                  dw      dolbq             ; C1 - LBQ
 2667 b890: ab 88                  dw      dolbz             ; C2 - LBZ
 2668 b892: ab 3f                  dw      dolbdf            ; C3 - LBDF
 2669 b894: ac 92                  dw      donop             ; C4 - NOP
 2670 b896: ac 1a                  dw      dolsnq            ; C5 - LSNQ
 2671 b898: ac 2a                  dw      dolsnz            ; C6 - LSNZ
 2672 b89a: ac 0c                  dw      dolsnf            ; C6 - LSNF
 2673 b89c: ac 7f                  dw      donlbr            ; C8 - NLBR
 2674 b89e: ab 5b                  dw      dolbnq            ; C9 - LBNQ
 2675 b8a0: ab 6b                  dw      dolbnz            ; CA - LBNZ
 2676 b8a2: ab 4d                  dw      dolbnf            ; CB - LBNF
 2677 b8a4: ab fc                  dw      dolsie            ; CC - LSIE
 2678 b8a6: ac 37                  dw      dolsq             ; CD - LSQ
 2679 b8a8: ac 47                  dw      dolsz             ; CE - LSZ
 2680 b8aa: ab ee                  dw      dolsdf            ; CF - LSDF
 2681 b8ac: ad ce                  dw      dosep             ; D0 - SEP R0
 2682 b8ae: ad ce                  dw      dosep             ; D1 - SEP R1
 2683 b8b0: ad ce                  dw      dosep             ; D2 - SEP R2
 2684 b8b2: ad ce                  dw      dosep             ; D3 - SEP R3
 2685 b8b4: ad ce                  dw      dosep             ; D4 - SEP R4
 2686 b8b6: ad ce                  dw      dosep             ; D5 - SEP R5
 2687 b8b8: ad ce                  dw      dosep             ; D6 - SEP R6
 2688 b8ba: ad ce                  dw      dosep             ; D7 - SEP R7
 2689 b8bc: ad ce                  dw      dosep             ; D8 - SEP R8
 2690 b8be: ad ce                  dw      dosep             ; D9 - SEP R9
 2691 b8c0: ad ce                  dw      dosep             ; DA - SEP RA
 2692 b8c2: ad ce                  dw      dosep             ; DB - SEP RB
 2693 b8c4: ad ce                  dw      dosep             ; DC - SEP RC
 2694 b8c6: ad ce                  dw      dosep             ; DD - SEP RD
 2695 b8c8: ad ce                  dw      dosep             ; DE - SEP RE
 2696 b8ca: ad ce                  dw      dosep             ; DF - SEP RF
 2697 b8cc: ad e7                  dw      dosex             ; E0 - SEX R0
 2698 b8ce: ad e7                  dw      dosex             ; E1 - SEX R1
 2699 b8d0: ad e7                  dw      dosex             ; E2 - SEX R2
 2700 b8d2: ad e7                  dw      dosex             ; E3 - SEX R3
 2701 b8d4: ad e7                  dw      dosex             ; E4 - SEX R4
 2702 b8d6: ad e7                  dw      dosex             ; E5 - SEX R5
 2703 b8d8: ad e7                  dw      dosex             ; E6 - SEX R6
 2704 b8da: ad e7                  dw      dosex             ; E7 - SEX R7
 2705 b8dc: ad e7                  dw      dosex             ; E8 - SEX R8
 2706 b8de: ad e7                  dw      dosex             ; E9 - SEX R9
 2707 b8e0: ad e7                  dw      dosex             ; EA - SEX RA
 2708 b8e2: ad e7                  dw      dosex             ; EB - SEX RB
 2709 b8e4: ad e7                  dw      dosex             ; EC - SEX RC
 2710 b8e6: ad e7                  dw      dosex             ; ED - SEX RD
 2711 b8e8: ad e7                  dw      dosex             ; EE - SEX RE
 2712 b8ea: ad e7                  dw      dosex             ; EF - SEX RF
 2713 b8ec: ab d2                  dw      doldx             ; F0 - LDX
 2714 b8ee: ac 9b                  dw      door              ; F1 - OR
 2715 b8f0: a9 76                  dw      doand             ; F2 - AND
 2716 b8f2: ae 99                  dw      doxor             ; F3 - XOR
 2717 b8f4: a9 50                  dw      doadd             ; F4 - ADD
 2718 b8f6: ad 7e                  dw      dosd              ; F5 - SD
 2719 b8f8: ae 0f                  dw      doshr             ; F6 - SHR
 2720 b8fa: ae 2d                  dw      dosm              ; F7 - SM
 2721 b8fc: ab b7                  dw      doldi             ; F8 - LDI
 2722 b8fe: ac ac                  dw      doori             ; F9 - ORI
 2723 b900: a9 87                  dw      doani             ; FA - ANI
 2724 b902: ae aa                  dw      doxri             ; FB - XRI
 2725 b904: a9 63                  dw      doadi             ; FC - ADI
 2726 b906: ad bb                  dw      dosdi             ; FD - SDI
 2727 b908: ad f1                  dw      doshl             ; FE - SHL
 2728 b90a: ae 6a                  dw      dosmi             ; FF - SMI
 2729 b90c: 1b 5b 4a 56 
            30 32 3e 00 prompt:    db      27,'[JV02>',0
 2730 b914:             
            #else
            #ifdef STGROM
 2735 b914:             ;[RLA] The Visual/02 data segment is always just below the monitor's data page.
 2736 b914:                        org     RAMPAGE-0100h
            #endif
            #endif
 2741 7e00:             
 2742 7e00:             r0:        equ     $
 2743 7e00:             r1:        equ     r0+2
 2744 7e00:             r2:        equ     r1+2
 2745 7e00:             r3:        equ     r2+2
 2746 7e00:             r4:        equ     r3+2
 2747 7e00:             r5:        equ     r4+2
 2748 7e00:             r6:        equ     r5+2
 2749 7e00:             r7:        equ     r6+2
 2750 7e00:             r8:        equ     r7+2
 2751 7e00:             r9:        equ     r8+2
 2752 7e00:             ra:        equ     r9+2
 2753 7e00:             rb:        equ     ra+2
 2754 7e00:             rc:        equ     rb+2
 2755 7e00:             rd:        equ     rc+2
 2756 7e00:             re:        equ     rd+2
 2757 7e00:             rf:        equ     re+2
 2758 7e00:             q:         equ     rf+2
 2759 7e00:             t:         equ     q+1
 2760 7e00:             ie:        equ     t+1
 2761 7e00:             last:      equ     ie+1
 2762 7e00:             multi:     equ     last+2
 2763 7e00:             mcount:    equ     multi+1
 2764 7e00:             nbp:       equ     mcount+2
 2765 7e00:             bp:        equ     nbp+1
 2766 7e00:             ntraps:    equ     bp+16
 2767 7e00:             traps:     equ     ntraps+1
 2768 7e00:             buffer:    equ     traps+16
 2769 7e00:             

b2fah: ASM              - <  1738>   1648 
b158h: BEGIN            - <  1441>    182    188    190 
b032h: BIGLP            - <  1290>   1309 
7e29h: BP               - <  2765>   1508   2202   2260   2310   2766 
b619h: BREAKADD         - <  2299>   2248 
b63ah: BREAKC           - <  2322>   2245 
b5c2h: BREAKP           - <  2242>   1638 
b5e5h: BREAKSUB1        - <  2263>   2273 
b5f0h: BREAKSUB2        - <  2270>   2266 
b5fah: BREAKSUB3        - <  2276>   2269 
b60fh: BREAKSUB4        - <  2293>   2287 
7e4ah: BUFFER           - <  2768>   1590   1592   1596   1599   1601 
ffe0h: CALL             - <    70> 
b1b8h: CHECKBP          - <  1500>   1481 
b1c6h: CHECKBP1         - <  1510>   1523 
b1d4h: CHECKBP2         - <  1520>   1514 
b1ddh: CHECKTP          - <  1526>   1484 
b1edh: CHECKTP1         - <  1538>   1543 
b1f7h: CONT             - <  1544>   1506   1524   1534 
b2b0h: CYCLE            - <  1656>   1495   1498   1715 
b3b0h: DA1              - <  1859>   1843 
b3b9h: DA2              - <  1864>   1845 
b3beh: DADONE           - <  1868>   1841   1858   1863 
b3f8h: DISASM           - <  1908>   1608 
b405h: DISASMLP         - <  1917>   1931 
b357h: DISASSEM         - <  1804>   1567   1578   1924 
af46h: DISP16           - <  1145>   1171   1806   1855   1953   2220 
af25h: DISP4            - <  1114>   1135   1139   1193   1214   1225   1235 
         1243   1358   1862 
af32h: DISP42           - <  1121>   1116 
af38h: DISP8            - <  1129>   1147   1150   1185   1203   1867   1961 
         2353 
a926h: DOADC            - <   207>   2589 
a93bh: DOADCI           - <   222>   2597 
a950h: DOADD            - <   237>   2717 
a963h: DOADI            - <   250>   2725 
a976h: DOAND            - <   263>   2715 
a987h: DOANI            - <   274>   2723 
a998h: DOB1             - <   285>   2525 
a99dh: DOB1_YES         - <   287>    285    290    294    298    302    306 
          310    314 
a9a6h: DOB2             - <   290>   2526 
a9b1h: DOB3             - <   294>   2527 
a9bch: DOB4             - <   298>   2528 
a9fch: DOBDF            - <   321>   2524 
a9c7h: DOBN1            - <   302>   2533 
a9d2h: DOBN2            - <   306>   2534 
a9ddh: DOBN3            - <   310>   2535 
a9e8h: DOBN4            - <   314>   2536 
aa0ah: DOBNF            - <   327>   2532 
aa18h: DOBNQ            - <   333>   2530 
aa28h: DOBNZ            - <   340>   2531 
aa35h: DOBQ             - <   345>   2522 
aa45h: DOBR             - <   352>    287    323    329    336    341    348 
          364   2521 
aa56h: DOBZ             - <   363>   2523 
aa63h: DODEC            - <   368>    995   2505   2506   2507   2508   2509 
         2510   2511   2512   2513   2514   2515   2516   2517   2518   2519 
         2520 
aa75h: DODIS            - <   380>   2586 
b3fch: DODISASM         - <  1911> 
b426h: DODUMP           - <  1942> 
ab26h: DOGHI            - <   486>   2617   2618   2619   2620   2621   2622 
         2623   2624   2625   2626   2627   2628   2629   2630   2631   2632 
ab32h: DOGLO            - <   492>   2601   2602   2603   2604   2605   2606 
         2607   2608   2609   2610   2611   2612   2613   2614   2615   2616 
aa94h: DOIDL            - <   402>   2473 
aa9dh: DOINC            - <   405>    399    799   2489   2490   2491   2492 
         2493   2494   2495   2496   2497   2498   2499   2500   2501   2502 
         2503   2504 
aaa9h: DOINP1           - <   410>   2578 
aab9h: DOINP2           - <   420>   2579 
aac9h: DOINP3           - <   430>   2580 
aad9h: DOINP4           - <   440>   2581 
aae9h: DOINP5           - <   450>   2582 
aaf9h: DOINP6           - <   460>   2583 
ab09h: DOINP7           - <   470>   2584 
b521h: DOINT            - <  2122>   1629 
b52eh: DOINT1           - <  2128>   2124 
ab19h: DOIRX            - <   480>    584    710    719    728    737    746 
          755    764   2569 
ab3fh: DOLBDF           - <   499>   2668 
ab4dh: DOLBNF           - <   505>   2676 
ab5bh: DOLBNQ           - <   511>   2674 
ab6bh: DOLBNZ           - <   518>   2675 
ab78h: DOLBQ            - <   523>   2666 
ab95h: DOLBR            - <   535>    501    507    514    519    526    531 
         2665 
ab88h: DOLBZ            - <   530>   2667 
aba7h: DOLDA            - <   547>   2537   2538   2539   2540   2541   2542 
         2543   2544   2545   2546   2547   2548   2549   2550   2551   2552 
abb7h: DOLDI            - <   556>   2721 
abc5h: DOLDN            - <   564>   2474   2475   2476   2477   2478   2479 
         2480   2481   2482   2483   2484   2485   2486   2487   2488 
abd2h: DOLDX            - <   571>   2713 
abe0h: DOLDXA           - <   579>   2587 
abeeh: DOLSDF           - <   587>   2680 
abfch: DOLSIE           - <   593>   2677 
ac0ch: DOLSNF           - <   600>   2672 
ac1ah: DOLSNQ           - <   606>   2670 
ac2ah: DOLSNZ           - <   613>   2671 
ac37h: DOLSQ            - <   618>   2678 
ac47h: DOLSZ            - <   625>   2679 
ac54h: DOMARK           - <   633>   2594 
a9f3h: DONBR            - <   318>   2529 
ac7fh: DONLBR           - <   666>    502    508    515    520    527    532 
          589    596    602    609    614    621    626   2673 
ac92h: DONOP            - <   679>   2669 
ac9bh: DOOR             - <   682>   2714 
acach: DOORI            - <   693>   2722 
acbdh: DOOUT1           - <   704>   2570 
accch: DOOUT2           - <   713>   2571 
acdbh: DOOUT3           - <   722>   2572 
aceah: DOOUT4           - <   731>   2573 
acf9h: DOOUT5           - <   740>   2574 
ad08h: DOOUT6           - <   749>   2575 
ad17h: DOOUT7           - <   758>   2576 
ad26h: DOPHI            - <   767>   2649   2650   2651   2652   2653   2654 
         2655   2656   2657   2658   2659   2660   2661   2662   2663   2664 
ad32h: DOPLO            - <   773>   2633   2634   2635   2636   2637   2638 
         2639   2640   2641   2642   2643   2644   2645   2646   2647   2648 
ad5eh: DOREQ            - <   802>   2595 
ad3fh: DORET            - <   780>   2585 
ad6dh: DOSAV            - <   809>   2593 
ad7eh: DOSD             - <   819>   2718 
ad91h: DOSDB            - <   832>   2590 
ada6h: DOSDBI           - <   847>   2598 
adbbh: DOSDI            - <   862>   2726 
adceh: DOSEP            - <   875>   2681   2682   2683   2684   2685   2686 
         2687   2688   2689   2690   2691   2692   2693   2694   2695   2696 
add8h: DOSEQ            - <   879>   2596 
ade7h: DOSEX            - <   886>   2697   2698   2699   2700   2701   2702 
         2703   2704   2705   2706   2707   2708   2709   2710   2711   2712 
adf1h: DOSHL            - <   890>   2727 
adffh: DOSHLC           - <   898>   2599 
ae0fh: DOSHR            - <   908>   2719 
ae1dh: DOSHRC           - <   916>   2591 
ae2dh: DOSM             - <   926>   2720 
ae40h: DOSMB            - <   939>   2592 
ae55h: DOSMBI           - <   954>   2600 
ae6ah: DOSMI            - <   969>   2728 
ae7dh: DOSTR            - <   982>   2553   2554   2555   2556   2557   2558 
         2559   2560   2561   2562   2563   2564   2565   2566   2567   2568 
ae8ah: DOSTXD           - <   989>   2588 
ae99h: DOXOR            - <   998>   2716 
aeaah: DOXRI            - <  1009>   2724 
b007h: DRAWBIG          - <  1282>   1435   1438 
afc9h: DRAWBOX          - <  1250>   1374   1380   1386   1392   1398   1408 
         1414 
b0c8h: DRAWLP           - <  1351>   1364 
b093h: DRAWLP1          - <  1331>   1339 
af4fh: DRAWREGS         - <  1156>   1553 
b078h: DRAWSCN          - <  1320>   1470 
b422h: DUMP             - <  1939>   1605 
b441h: DUMPLPX          - <  1956>   1964 
b42fh: DUMPLPY          - <  1948>   1969 
b2f2h: EXIT             - <  1720>   1644 
f830h: F_ASTODT         - <   139> 
f833h: F_ASTOTM         - <   140> 
ff5dh: F_ATOI           - <   105> 
ff00h: F_BOOT           - <    74> 
ff42h: F_BOOTIDE        - <    96> 
f800h: F_BREAD          - <   123> 
ff6ch: F_BRKTEST        - <   110> 
f806h: F_BTEST          - <   125> 
f803h: F_BTYPE          - <   124> 
ff33h: F_DIV16          - <    91> 
ff2ah: F_DRIVE          - <    88> 
f827h: F_DTTOAS         - <   137> 
ff6fh: F_FINDTKN        - <   111> 
ff57h: F_FREEMEM        - <   103> 
ff81h: F_GETDEV         - <   117> 
f815h: F_GETTOD         - <   130> 
ff45h: F_HEXIN          - <    97> 
ff48h: F_HEXOUT2        - <    98> 
ff4bh: F_HEXOUT4        - <    99> 
f824h: F_IDEID          - <   135> 
ff3ch: F_IDEREAD        - <    94> 
ff36h: F_IDERESET       - <    92> 
f821h: F_IDESIZE        - <   134> 
ff39h: F_IDEWRITE       - <    93> 
ff7bh: F_IDNUM          - <   115> 
ff3fh: F_INITCALL       - <    95>    192 
ff66h: F_INMSG          - <   108>   1102   1107   1253   1259   1268   1274 
         1285   1313   1328   1334   1343   1419   1428   1869   2231   2364 
ff0fh: F_INPUT          - <    79>   1595 
ff69h: F_INPUTL         - <   109> 
ff63h: F_INTOUT         - <   107> 
ff78h: F_ISALNUM        - <   114> 
ff72h: F_ISALPHA        - <   112> 
ff75h: F_ISHEX          - <   113> 
ff5ah: F_ISNUM          - <   104> 
ff7eh: F_ISTERM         - <   116> 
ff15h: F_LTRIM          - <    81> 
ff1bh: F_MEMCPY         - <    83> 
ff54h: F_MINIMON        - <   102> 
ff51h: F_MOVER          - <   101> 
ff09h: F_MSG            - <    77>   1589   1835 
ff30h: F_MUL16          - <    90> 
f836h: F_NVRCCHK        - <   141> 
f81bh: F_RDNVR          - <   132> 
ff21h: F_RDSEC          - <    85> 
ff06h: F_READ           - <    76> 
f82dh: F_RTCTEST        - <   138> 
ff27h: F_SEEK           - <    87> 
ff24h: F_SEEK0          - <    86> 
ff2dh: F_SETBD          - <    89> 
f818h: F_SETTOD         - <   131> 
ff12h: F_STRCMP         - <    80> 
ff18h: F_STRCPY         - <    82> 
f82ah: F_TMTOAS         - <   136> 
ff4eh: F_TTY            - <   100> 
ff03h: F_TYPE           - <    75>   1071   1074   1080   1083   1086   1092 
         1095   1098   1119   1123   1263   1266   1294   1302   1355   1467 
         1562   1573   1722   1809   1838   1958 
ff0ch: F_TYPEX          - <    78> 
ff60h: F_UINTOUT        - <   106> 
f80ch: F_UREAD          - <   127> 
f812h: F_USETBD         - <   129> 
f80fh: F_UTEST          - <   128> 
f809h: F_UTYPE          - <   126> 
fff9h: F_VERSION        - <   119> 
f81eh: F_WRNVR          - <   133> 
ff1eh: F_WRTSEC         - <    84> 
b3cch: GETADDR          - <  1879>   1910   1941   1978   2008 
b3e7h: GETADDRGO        - <  1893>   1897   1903 
b3e6h: GETADDRP         - <  1892>   1881 
b3eeh: GETADDRR         - <  1898>   1887 
b3eah: GETADDRX         - <  1896>   1884 
b2e3h: GO               - <  1706>   1641 
aee7h: GOTOXY           - <  1069>   1165   1182   1190   1198   1208   1219 
         1231   1240   1251   1257   1272   1283   1291   1299   1311   1326 
         1332   1341   1352   1417   1426   1559   1570   1585   1919   1950 
         2214   2229   2350   2362 
7e22h: IE               - <  2760>    394    593    794   1220   2128   2149 
         2165   2761 
aec4h: INCP             - <  1032>    234    260    282    286    291    295 
          299    303    307    311    315    318    324    330    337    342 
          349    365    561    701    859    872    966    979   1017 
a916h: INCR             - <   195>    406    482   1034 
a917h: INCR2            - <   196>    552 
b70ch: INST             - <  2473>   1685   1690   1817   1820 
b191h: INSTDN           - <  1476>    219    247    271    360    377    402 
          407    417    427    437    447    457    467    477    483    489 
          496    544    553    568    576    590    597    603    610    615 
          622    627    663    676    679    690    770    777    806    816 
          829    844    876    883    887    895    905    913    923    936 
          951    986   1006   1035   1473   2019   2577 
b202h: INSTDN1          - <  1554>   1991 
af14h: INVERT           - <  1101> 
aecbh: ITOA             - <  1044>   1077   1089 
aedeh: ITOADN           - <  1056>   1049 
aed0h: ITOALP           - <  1048>   1055 
7e23h: LAST             - <  2761>   1574   1661   2762 
b226h: MAIN             - <  1580>   1932   1970   1985   2027   2041   2058 
         2071   2085   2110   2127   2131   2162   2183   2227   2237   2251 
         2258   2275   2303   2360   2370   2388   2413   2426 
7e26h: MCOUNT           - <  2763>   1486   2764 
b301h: MOVE             - <  1745>   1750   2292   2440 
7e25h: MULTI            - <  2762>   1457   1476   1651   1706   2763 
7e28h: NBP              - <  2764>   1449   1503   2196   2255   2293   2299 
         2322   2765 
af1ch: NORMAL           - <  1106> 
7e39h: NTRAPS           - <  2766>   1453   1531   2332   2375   2384   2410 
         2441   2767 
b90ch: PROMPT           - <  2729>   1587 
7e20h: Q                - <  2758>    333    345    511    523    606    618 
          802    879   1209   2088   2759 
7e00h: R0               - <  2742>    183   1160   1441   1445   2009   2743 
7e02h: R1               - <  2743>   2744 
7e04h: R2               - <  2744>   2745 
7e06h: R3               - <  2745>   2746 
7e08h: R4               - <  2746>   2747 
7e0ah: R5               - <  2747>   2748 
7e0ch: R6               - <  2748>   2749 
7e0eh: R7               - <  2749>   2750 
7e10h: R8               - <  2750>   2751 
7e12h: R9               - <  2751>   2752 
7e14h: RA               - <  2752>   2753 
7e16h: RB               - <  2753>   2754 
7e18h: RC               - <  2754>   2755 
7e1ah: RD               - <  2755>   2756 
7e1ch: RE               - <  2756>   2757 
af5bh: REGSLP           - <  1164>   1176 
fff1h: RET              - <    71> 
aebch: RETRR7           - <  1025>   1444 
aebbh: RETRR7RET        - <  1024>   1030 
7e1eh: RF               - <  2757>   2758 
b48eh: RUN              - <  2006>   1614 
0004h: SCALL            - <    67>    405    481    551   1033   1070   1073 
         1076   1079   1082   1085   1088   1091   1094   1097   1101   1106 
         1118   1122   1134   1138   1146   1149   1164   1170   1181   1184 
         1189   1192   1197   1202   1207   1213   1218   1224   1230   1234 
         1239   1242   1250   1252   1256   1258   1262   1265   1267   1271 
         1273   1282   1284   1290   1293   1298   1301   1310   1312   1325 
         1327   1331   1333   1340   1342   1351   1354   1357   1373   1379 
         1385   1391   1397   1407   1413   1416   1418   1425   1427   1434 
         1437   1466   1469   1480   1483   1552   1558   1561   1566   1569 
         1572   1577   1584   1588   1594   1597   1721   1805   1808   1834 
         1837   1854   1861   1866   1868   1888   1899   1909   1918   1923 
         1940   1949   1952   1957   1960   1977   1996   2007   2028   2042 
         2059   2072   2086   2111   2163   2176   2184   2213   2219   2228 
         2230   2253   2291   2314   2349   2352   2361   2363   2398   2408 
         2439 
b4c3h: SETD             - <  2052>   1623 
b4d8h: SETDF            - <  2068>   2055 
b552h: SETIE            - <  2159>   2126 
b4a1h: SETP             - <  2024>   1617 
b4e9h: SETQ             - <  2082>   1626 
b566h: SETR             - <  2175>   1635 
aeb6h: SETR7            - <  1020>   1443 
aeb5h: SETR7RET         - <  1019>   1022 
b4fdh: SETT             - <  2098>   1632 
b4b2h: SETX             - <  2038>   1620 
b57fh: SHOWBP           - <  2196>   2298   2321   2326 
b599h: SHOWBPLP1        - <  2213>   2209   2224 
b5aeh: SHOWBPLP2        - <  2228>   2212   2236 
b1ffh: SHOWREGS         - <  1552>   1479   1482   1485   1497   2033   2047 
         2063   2077   2093   2117   2153   2170   2191 
b643h: SHOWTP           - <  2332>   2379   2402   2446 
b65dh: SHOWTPLP1        - <  2349>   2345   2357 
b66fh: SHOWTPLP2        - <  2361>   2348   2369 
0005h: SRET             - <    68>    204   1062   1099   1104   1109   1120 
         1124   1140   1151   1245   1277   1315   1439   1546   1550   1701 
         1751   1798   1872   1891   1895   2465 
a900h: START            - <   181> 
a906h: START2           - <   183>    181 
b1fbh: STOP             - <  1548>   1519   1540 
b45ah: STORE            - <  1975>   1611 
b46bh: STORE1           - <  1984>   1989 
b485h: STORE2           - <  1996>   1993 
b478h: STORELP          - <  1990>   1987   1995   2001 
7e21h: T                - <  2759>    633    649    812   1199   2113   2132 
         2760 
b30ah: TOHEX            - <  1758>   1889   1900   1997   2029   2043   2060 
         2073   2087   2112   2164   2177   2185   2254   2315   2399   2409 
b341h: TOHEXAD          - <  1787>   1781   1784 
b345h: TOHEXAL          - <  1790>   1793 
b33eh: TOHEXD           - <  1785>   1766 
b356h: TOHEXDN          - <  1798>   1763   1769   1775   1778 
b332h: TOHEXLC          - <  1779> 
b30eh: TOHEXLP          - <  1761>   1797 
b338h: TOHEXUC          - <  1782>   1772 
b6e2h: TOUC             - <  2451>   1598   2464   2470 
b6feh: TOUC_DN          - <  2465>   2455   2468 
b6fah: TOUC_NXT         - <  2463>   2457   2459 
b700h: TOUC_QLP         - <  2467>   2471 
b6ffh: TOUC_QT          - <  2466>   2453 
b68ah: TRAPADD          - <  2384>   2104 
b681h: TRAPC            - <  2375>   2101 
7e3ah: TRAPS            - <  2767>   1536   2338   2394   2415   2768   2768 
b6a7h: TRAPSUB          - <  2407>   2107 
b6b7h: TRAPSUB1         - <  2418>   2424 
b6bch: TRAPSUB2         - <  2421> 
b6c6h: TRAPSUB3         - <  2427>   2420 
b6d8h: TRAPSUB4         - <  2441>   2436 

2769 Lines assembled
0 Errors
297 Labels
Object Code:4116 bytes

