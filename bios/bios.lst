1802 -> Native
2 Classes read.
186 Patterns read.
    1 0000:             ; *******************************************************************
    2 0000:             ; *** This software is copyright 2005 by Michael H Riley          ***
    3 0000:             ; *** You have permission to use, modify, copy, and distribute    ***
    4 0000:             ; *** this software so long as this copyright notice is retained. ***
    5 0000:             ; *** This software may not be used in commercial applications    ***
    6 0000:             ; *** without express written permission from the author.         ***
    7 0000:             ; *******************************************************************
    8 0000:             
    9 0000:             ; [RLA] Configuration for Mike Riley's PicoElf with Spare Time Gizmos' EPROM ...
            #endif
   26 0000:             
   27 0000:             ; [RLA] Spare Time Gizmos Elf 2000 configuration ...
            #ifdef ELF2K
   29 0000:             include config.inc
   30 0000:             ; DO NOT EDIT THIS FILE - EDIT CONFIG. INSTEAD!!
            #define BOOTS	 08000H
            #define WARMB	 (08000H+3)
            #define HELP	 09400H
            #define RAMPAGE	 07F00H
            #define BIOS	 0FF00H
            #define EBIOS	 0F800H
            #define FORTH	 0D700H
            #define EDTASM	 09C00H
            #define BASIC	 0BA00H
            #define VISUAL	 0A900H
            #define XMODEM	 0D400H
            #define STGROM                  ; Spare Time Gizmos' EPROM image
            #define SERHDX                  ; console serial is half duplex
            #define UART                    ; STG style UART interface
            #define  UART_SELECT    2       ;  ... UART register select I/O port
            #define  UART_DATA      3       ;  ... UART data I/O port
            #define NVR                     ; STG style NVR/RTC chip
            #define  NVR_SELECT     2       ;  ... NVR/RTC address I/O port
            #define  NVR_DATA       3       ;  ... NVR/RTC data I/O port
            #define EIDE                    ; to support an exteded IDE functions
            #define  IDE_SELECT     2       ;  ... IDE register select I/O port
            #define  IDE_DATA       3       ;  ... IDE data I/O port
            #define SERP            b3      ; bit banged serial input on EF3
            #define SERN            bn3     ;  ... and it is NOT inverted ...
            #define SERSEQ          seq     ;  ...
            #define SERREQ          req     ;  ...
            #define KBD_DATA        7       ; PS/2 keyboard ASCII data port
            #define BKBD            b2      ; branch on keyboard data ready
            #define BNKBD           bn2     ;  ... no keyboard data ready
            #define BASE            0f000h
            #endif
   62 0000:             
            #endif
   72 0000:             
            #endif
   82 0000:             
            #endif
   92 0000:             
   93 0000:             ; [RLA] Other definitions ...
   94 0000:             data:   equ     0
   95 0000:             scall:  equ     r4
   96 0000:             sret:   equ     r5
   97 0000:             
            #else
  101 0000:                     org     BASE+0300h      ; [RLA] extended BIOS starts here
            #endif
  103 f300:             
  104 f300:             ; A couple of words on the baud rate constant (RE.1) usage -
  105 f300:             ;
  106 f300:             ;   If (RE.1 & 0xFE) is not zero and is not 0xFE, then the bit banged "UART" is
  107 f300:             ; in use and (RE.1 & 0xFE) determines the baud rate (its the delay constant).
  108 f300:             ; In this case the LSB of RE.1 (i.e. RE.1 & 1) is the local echo flag - if this
  109 f300:             ; is 1 then all input is echoed back to the terminal.  If it is zero, then no
  110 f300:             ; echo is performed.
  111 f300:             ;
  112 f300:             ;   On the Elf2K and the PicoElf (and maybe other future hardware platforms) if
  113 f300:             ; (RE.1 & 0xFE) is zero (i.e. the bit banged serial delay is zero!) then the
  114 f300:             ; hardware UART is used for console I/O.  The UART still obeys the local echo
  115 f300:             ; flag, so if the LSB of RE.1 is one then character input will be echoed.
  116 f300:             ;
  117 f300:             ;   On the Elf2K, and currently only on the Elf2K, if (RE.1 & 0xFE) == 0xFE
  118 f300:             ; (i.e. the slowest possible bit banged baud ate) then the Elf 2000 80 column
  119 f300:             ; video card and PS/2 keyboard interface are used for console I/O.  The local
  120 f300:             ; echo flag still works in this case as well, so PS/2 keyboard input will be
  121 f300:             ; echoed to the video card only if the LSB of RE.1 is set.
  122 f300:             
            #ifdef UART
  124 f300:             ; ****************************************
  125 f300:             ; *** Test to see if uart is installed ***
  126 f300:             ; *** DF=1 uart is installed           ***
  127 f300:             ; *** DF=0 uart is not installed       ***
  128 f300:             ; ****************************************
  129 f300: e3          uart_test: sex     r3               ; [RLA] output immediate data
  130 f301: 62                     out     UART_SELECT      ; [RLA] select the UARTs MCR
  131 f302: 14                     db      14h              ; [RLA] ...
  132 f303: 63                     out     UART_DATA        ; [RLA] enable loopback mode, turn all
  133 f304: 10                     db      10h              ; [RLA]  ... modem control bits OFF
  134 f305: 62                     out     UART_SELECT      ; [RLA] now select the modem status register
  135 f306: 16                     db      16h              ; [RLA] ...
  136 f307: e2                     sex     r2               ; [RLA] point to the stack again
  137 f308: 6b                     inp     UART_DATA        ; [RLA] read the MSR
  138 f309: fa f0                  ani     0f0h             ; [RLA] check the current modem status
  139 f30b: ca f3 26               lbnz    no_uart          ; [RLA] all bits should be zero
  140 f30e: e3                     sex     r3               ; [RLA] back to X=P
  141 f30f: 62                     out     UART_SELECT      ; [RLA] select the MCR again
  142 f310: 14                     db      14h              ; [RLA] ...
  143 f311: 63                     out     UART_DATA        ; [RLA] enable loopback mode, turn all
  144 f312: 1f                     db      1fh              ; [RLA]  ... modem control bits ON
  145 f313: 62                     out     UART_SELECT      ; [RLA] select the MSR
  146 f314: 16                     db      16h              ; [RLA] ...
  147 f315: e2                     sex     r2               ; [RLA] ...
  148 f316: 6b                     inp     UART_DATA        ; [RLA] read the MSR
  149 f317: fa f0                  ani     0f0h             ; [RLA] check the current modem status
  150 f319: fb f0                  xri     0f0h             ; [RLA] all bits should be one this time
  151 f31b: ca f3 26               lbnz    no_uart          ; [RLA] no uart if they arent
  152 f31e: e3                     sex     r3               ; [RLA] X=P
  153 f31f: 62                     out     UART_SELECT      ; [RLA] select the MCR once more
  154 f320: 14                     db      14h              ; [RLA] ...
  155 f321: 63                     out     UART_DATA        ; [RLA] disable loopback mode, set DTR & RTS
  156 f322: 03                     db      03h              ; [RLA] ...
  157 f323: ff 00       yes_uart:  smi     0                ; signal uart is present
  158 f325: d5                     sep     sret             ; and return
  159 f326: fc 00       no_uart:   adi     0                ; signal no uart installed
  160 f328: d5                     sep     sret             ; and return
  161 f329:             
  162 f329:             
  163 f329:             ; ***************************************************
  164 f329:             ; *** Elf 2000 version of timalc, selects between ***
  165 f329:             ; *** bit-banged and uart serial modes            ***
  166 f329:             ; *** Returns RE.1 = 0 Uart was selected          ***
  167 f329:             ; ***         RF.0 = comm port parameters         ***
  168 f329:             ; ***         RE.1 <> 0 bit-banged baud constant  ***
  169 f329:             ; ***************************************************
  170 f329: d4          e2k_timalc: sep    scall               ; see if uart is present
  171 f32a: f3 00                   dw     uart_test
  172 f32c: cb fc 1d                lbnf   timalc_o            ; use standard timalc if no uart
  173 f32f: f8 34                   ldi    34h                 ; set 9600 N81
  174 f331: d4                      sep    scall               ; set deafult baud rate
  175 f332: f3 d9                   dw     e2k_stbd
  176 f334: e3          e2k_sblp2:  sex    r3                  ; [RLA] address the data register
  177 f335: 62                      out    UART_SELECT         ; [RLA] ...
  178 f336: 10                      db     10h                 ; [RLA] ...
  179 f337: e2                      sex    r2                  ; [RLA] ...
  180 f338: 6b                      inp    UART_DATA           ; [RLA] read RBR to clear DR bit
  181 f339: e3                      sex    r3                  ; need to set uart register to line stat
  182 f33a: 62                      out    UART_SELECT
  183 f33b: 15                      db     015h
  184 f33c: e2                      sex    r2                  ; point X back to stack
  185 f33d: 3e 80       e2k_sblp1:  SERN   e2k_setbd1          ; jump if character detectd on EF line
  186 f33f: 6b                      inp    UART_DATA           ; read modem status
  187 f340: f6                      shr                        ; shift DR bit into carry
  188 f341: cb f3 3d                lbnf   e2k_sblp1           ; loop if no character detected on uart
  189 f344: e3                      sex    r3                  ; setup for immediate out
  190 f345: 62                      out    UART_SELECT         ; select uart data register
  191 f346: 10                      db     010h
  192 f347: e2                      sex    r2                  ; point X back to stack
  193 f348: 6b                      inp    UART_DATA           ; read received char to stack
  194 f349:             
  195 f349:             ;   We have already initialized the UART to 9600bps and we know that the
  196 f349:             ; operator is typing a carriage return character on the terminal connected
  197 f349:             ; to the UART (at least he is supposed to be!).  Obviously, if his terminal
  198 f349:             ; is set to 9600bps we will actually receive a 0Dh character in the UART
  199 f349:             ; buffer.  But even if his terminal is set to a faster or slower baud
  200 f349:             ; rate, assuming that he is still typing carriage return, the bit pattern
  201 f349:             ; we receive is equally unique.  For example, if he transmits CR at 4800 bps
  202 f349:             ; and we receive at 9600bps, well actually see 0E6h in the buffer.  So
  203 f349:             ; by looking up whatever value we receive in a table, we can determine the
  204 f349:             ; correct abud rate.
  205 f349: f8 f3               ldi        high abdtab       ; [RLA] point to the auto baud table
  206 f34b: bf                  phi        rf                ; [RLA] ...
  207 f34c: f8 75               ldi        low abdtab        ; [RLA] ...
  208 f34e: af                  plo        rf                ; [RLA] ...
  209 f34f: 0f          abdlp1: ldn        rf                ; [RLA] get a byte from auto baud table
  210 f350: c2 f3 29            lbz        e2k_timalc        ; [RLA] start over if end of table
  211 f353: 1f                  inc        rf                ; [RLA] ...
  212 f354: f3                  xor                          ; [RLA] compare it to byte on the stack
  213 f355: c2 f3 5c            lbz        abd2              ; [RLA] branch if we found a match
  214 f358: 1f                  inc        rf                ; [RLA] skip the second byte
  215 f359: c0 f3 4f            lbr        abdlp1            ; [RLA] and keep looking
  216 f35c:             
  217 f35c:             ;   Here if we find a match in the auto baud table.  Remember that were
  218 f35c:             ; receiving at a fairly fast rate (9600bps) and if the operator was sending
  219 f35c:             ; at a slow rate (e.g. 2400bps) then his UART is _probably still sending_
  220 f35c:             ; right now!  To avoid having the last half of the CR show up as a garbage
  221 f35c:             ; character, we have to delay long enough for the transmitter to finish,
  222 f35c:             ; worst case.   BTW, at 4MHz, each clock is 500ns and each machine cycle
  223 f35c:             ; is 4us.  At 1200 baud, 10 bits takes about 8ms to transmit, so a delay
  224 f35c:             ; of about 8ms/4us = 2000 cycles is about enough.
  225 f35c: f8 00       abd2:   ldi        0                 ; [RLA] clear the delay counter
  226 f35e: c4          abd2a:  nop                          ; [RLA] 3 cycles
  227 f35f: c4                  nop                          ; [RLA] 3 cycles
  228 f360: ff 01               smi        1                 ; [RLA] 2 cycles
  229 f362: 3a 5e               bnz        abd2a             ; [RLA] 2 cycles
  230 f364:                                                  ; [RLA] 10 cycles * 256 = 2560 cycles...
  231 f364:             
  232 f364:             ;   The UART data register is still selected - read the RBR to remove any
  233 f364:             ; garbage character that might be there...
  234 f364: 6b                  inp        UART_DATA         ; [RLA] read the data register first
  235 f365: e3                  sex        r3                ; [RLA] ...
  236 f366: 62                  out        UART_SELECT       ; [RLA]  ... address the LSR
  237 f367: 15                  db         015h              ; [RLA]  ...
  238 f368: e2                  sex        r2                ; [RLA]         ...
  239 f369: 6b                  inp        UART_DATA         ; [RLA]        and clear the error flags too
  240 f36a:             
  241 f36a:             ; [RLA] All done - return re.1 ==1 and rf.0 == baud rate...
  242 f36a: f8 01               ldi        1                 ; [MHR] turn echoing on by default
  243 f36c: be                  phi        re                ; [RLA] ...
  244 f36d: 0f                  ldn        rf                ; [RLA] get the UART mode byte
  245 f36e: af                  plo        rf                ; [RLA] return it in rf
  246 f36f: d4                  sep        scall             ; [RLA] change the UART mode
  247 f370: f3 d9               dw         e2k_stbd          ; [RLA] ...
  248 f372: c0 fc 46            lbr        timalc_rt         ; [RLA] and return
  249 f375:             
  250 f375:             ; Table of autoboad results and baud rates...
  251 f375: 0d 34       abdtab: dw        00d34h             ; [RLA]  9,600bps
  252 f377: f2 35               dw        0f235h             ; [RLA] 19,200bps
  253 f379: f9 35               dw        0f935h             ; [RLA] 19,200bps
  254 f37b: e6 33               dw        0e633h             ; [RLA]  4,800bps
  255 f37d: 78 32               dw        07832h             ; [RLA]  2,400bps
  256 f37f:             ;       dw        08031h             ; [RLA]  1,200bps (unreliable!)
  257 f37f: 00                  db        0                  ; [RLA] end of table
  258 f380:             
  259 f380:             ; Here if we detect activity on the bit banged port...
  260 f380: c0 fc 1f    e2k_setbd1: lbr    end_sb            ; use standard bit-banged serial
  261 f383:             
  262 f383:             
  263 f383:             ; *******************************************
  264 f383:             ; *** Implement RE.1 for serial selection ***
  265 f383:             ; *******************************************
  266 f383: 9e          e2k_brk: ghi      re                 ; get baud constant
  267 f384: fa fe                ani      0feh               ; [RLA] mask out echo bit
  268 f386: c2 f8 0f             lbz      f_utest            ; [RLA] branch if the UART is in use
            #endif
  273 f389: c0 f8 06             lbr      f_btest            ; [RLA] otherwise use the bit banged serial
  274 f38c:             
  275 f38c:             
  276 f38c:             
  277 f38c:             ; [RLA] Generic transmit routine ...
  278 f38c:             ; [RLA]    This will send the character to the UART, video card or
  279 f38c:             ; [RLA] the plain old bit banged serial port, depending on which
  280 f38c:             ; [RLA] was detected ...
  281 f38c: ae          e2k_tx: plo     re              ; save character
  282 f38d: 9e                  ghi     re              ; get baud constant
  283 f38e: fa fe               ani     0feh            ; [RLA] mask out echo bit
  284 f390: c2 f3 97            lbz     e2k_tx1         ; [RLA] jump if UART
            #endif
  289 f393: 8e                  glo     re              ; recover character
  290 f394: c0 f8 03            lbr     f_btype         ; jump to bit-banged code
  291 f397: 8e          e2k_tx1:glo     re              ; recover character
  292 f398: c0 f8 09            lbr     f_utype         ; jump to UART routine
            #endif
  297 f39b:             
  298 f39b:             
  299 f39b:             ; [RLA] Generic receive routine ...
  300 f39b:             ; [RLA]    Receive a character from the UART, PS/2 keyboard or bit
  301 f39b:             ; [RLA] banged serial depending on which is installed...
  302 f39b: 9e          e2k_rx: ghi     re              ; get baud constant
  303 f39c: fa fe               ani     0feh            ; [RLA] mask out echo bit
  304 f39e: c2 f8 0c            lbz     f_uread         ; [RLA] use the UART if it is zero
            #endif
  309 f3a1: c0 f8 00            lbr     f_bread         ; jump to bit banged code
  310 f3a4:             
  311 f3a4:             
  312 f3a4:             ; *********************************************
  313 f3a4:             ; *** Read byte from Elf 2000 PS/2 Keyboard ***
  314 f3a4:             ; *** Returns: D - byte read                ***
  315 f3a4:             ; *********************************************
            #endif
  337 f3a4:             
  338 f3a4:             
  339 f3a4:             ; ****************************************************
  340 f3a4:             ; *** Test to see if character available from UART ***
  341 f3a4:             ; *** Returns: DF=1 - character available          ***
  342 f3a4:             ; ****************************************************
  343 f3a4: f8 15       e2k_utest: ldi     015h                ; need UART line status register
  344 f3a6: 52                     str     r2                  ; prepare for out
  345 f3a7: 62                     out     UART_SELECT         ; write to register select port
  346 f3a8: 22                     dec     r2                  ; back to a free spot
  347 f3a9: 6b                     inp     UART_DATA           ; read line status register
  348 f3aa: f6                     shr                         ; shift data ready bit into DF
  349 f3ab: d5                     sep     sret                ; and return
  350 f3ac:             
  351 f3ac:             ; ************************************
  352 f3ac:             ; *** Read byte from Elf 2000 UART ***
  353 f3ac:             ; *** Returns: D - byte read       ***
  354 f3ac:             ; ************************************
  355 f3ac:             e2k_uread:
  356 f3ac: f8 15               ldi     015h            ; need UART line status register
  357 f3ae: 52                  str     r2              ; prepare for out
  358 f3af: 62                  out     UART_SELECT     ; write to register select port
  359 f3b0: 22                  dec     r2              ; correct for inc on out
  360 f3b1:             uread_lp:
  361 f3b1: 6b                  inp     UART_DATA       ; read line status register
  362 f3b2: fa 01               ani     1               ; mask for data ready bit
  363 f3b4: c2 f3 b1            lbz     uread_lp        ; loop back if no bytes to read
  364 f3b7: f8 10               ldi     010h            ; select data register
  365 f3b9: 52                  str     r2              ; prepare for out
  366 f3ba: 62                  out     UART_SELECT     ; write to register select port
  367 f3bb: 22                  dec     r2              ; back to free spot
  368 f3bc: 6b                  inp     UART_DATA       ; read UART data register
  369 f3bd: ae                  plo     re              ; save for a moment
  370 f3be: 9e                  ghi     re              ; need to check for echo
  371 f3bf: f6                  shr                     ; shift echo flag into DF
  372 f3c0: 8e                  glo     re              ; recover read byte
  373 f3c1: c3 f3 c5            lbdf    e2k_utype       ; jump if need echo
  374 f3c4: d5                  sep     sret            ; otherwise return
  375 f3c5:             
  376 f3c5:             ;[MHR]     lbz     e2k_uread           ; [RLA] ignore nulls
  377 f3c5:             ;[RLA]     xri     $ff                 ; [RLA] and ignore $FF bytes
  378 f3c5:             ;[RLA]     lbz     e2k_uread           ; [RLA] ....
  379 f3c5:             ;[RLA]     xri     $ff                 ; [RLA] ...
  380 f3c5:             ;[RLA]     sep     sret                ; return byte to caller
  381 f3c5:             ;[RLA] Fall into utype to echo the character we just read...
  382 f3c5:             
  383 f3c5:             
  384 f3c5:             ; ***********************************
  385 f3c5:             ; *** Write byte to Elf 2000 UART ***
  386 f3c5:             ; *** D - byte to write           ***
  387 f3c5:             ; ***********************************
  388 f3c5: 73          e2k_utype: stxd                        ; save byte to send onto stack
  389 f3c6: f8 15                  ldi     015h                ; need line status register of UART
  390 f3c8: 52                     str     r2                  ; write to stack
  391 f3c9: 62                     out     UART_SELECT         ; select UART port
  392 f3ca: 22                     dec     r2                  ; keep stack at empty spot
  393 f3cb: 6b          utype_lp:  inp     UART_DATA           ; read status port
  394 f3cc: fa 20                  ani     020h                ; mask for holding register empty
  395 f3ce: c2 f3 cb               lbz     utype_lp            ; loop until allowd to send character
  396 f3d1: f8 10                  ldi     010h                ; select data register
  397 f3d3: 52                     str     r2                  ; prepare for out
  398 f3d4: 62                     out     UART_SELECT         ; select UART register
  399 f3d5: f0                     ldx                               ; [RLA] reload the original byte
  400 f3d6: 63                     out     UART_DATA           ; write byte to UART
  401 f3d7: 22                     dec     r2                  ; correct for inc on OUT
  402 f3d8: d5                     sep     sret                ; and return to caller
  403 f3d9:             
  404 f3d9:             ; *****************************************
  405 f3d9:             ; *** Setup UART parameters             ***
  406 f3d9:             ; *** D = Comm parameters               ***
  407 f3d9:             ; ***  Bits 0-2 = 0 0 0 - 300 baud      ***
  408 f3d9:             ; ***             0 0 1 - 1200 baud     ***
  409 f3d9:             ; ***             0 1 0 - 2400 baud     ***
  410 f3d9:             ; ***             0 1 1 - 4800 baud     ***
  411 f3d9:             ; ***             1 0 0 - 9600 baud     ***
  412 f3d9:             ; ***             1 0 1 - 19200 baud    ***
  413 f3d9:             ; ***             1 1 0 - 38400 baud    ***
  414 f3d9:             ; ***             1 1 1 - 76800 baud    ***
  415 f3d9:             ; ***  bit 3 - reserved for future baud ***
  416 f3d9:             ; ***          rates                    ***
  417 f3d9:             ; ***  Bits 4-5 = 0 0 - 5 bit words     ***
  418 f3d9:             ; ***             0 1 - 6 bit words     ***
  419 f3d9:             ; ***             1 0 - 7 bit words     ***
  420 f3d9:             ; ***             1 1 - 8 bit words     ***
  421 f3d9:             ; ***  Bit    6 =   0 - no parity       ***
  422 f3d9:             ; ***               1 - parity enabled  ***
  423 f3d9:             ; ***  Bit    7 -   0 - odd parity      ***
  424 f3d9:             ; ***               1 - even parity     ***
  425 f3d9:             ; *** Returns: DF=1 - No UART installed ***
  426 f3d9:             ; ***          DF=0 - success           ***
  427 f3d9:             ; *****************************************
  428 f3d9: ae          e2k_stbd:  plo     re                  ; save a coyp of parameters
  429 f3da: e3                     sex     r3                  ; setup line control register of UART
  430 f3db: 62                     out     UART_SELECT
  431 f3dc: 13                     db      013h
  432 f3dd: e2                     sex     r2                  ; set x back to stack
  433 f3de:             ;[RLA]     xri     0ffh                ; check for existance of UART
  434 f3de:             ;[RLA]     lbz     no_uart             ; jump if not installed
  435 f3de:             ;[RLA]     xri     0ffh                ; reset value
  436 f3de: f8 80                  ldi     080h                ; [RLA] set DLAB bit
  437 f3e0: 52                     str     r2                  ; store for write
  438 f3e1: 63                     out     UART_DATA           ; write line control register
  439 f3e2: 22                     dec     r2                  ; compensate for out
  440 f3e3:             ;[RLA]     dec     r2                  ; need some workspace
  441 f3e3: 8f                     glo     rf                  ; [RLA] save consumed register
  442 f3e4: 73                     stxd                        ; [RLA]
  443 f3e5: 9f                     ghi     rf                  ; [RLA]
  444 f3e6: 73                     stxd                        ; [RLA]
  445 f3e7: 8e                     glo     re                  ; get com parameters
  446 f3e8: fa 07                  ani     7                   ; strip all but baud rate bits
  447 f3ea: fe                     shl                         ; multiply by 2
  448 f3eb: 52                     str     r2                  ; and prepare for add
  449 f3ec: f8 1c                  ldi     low baudtab         ; point to diviser table
  450 f3ee: f4                     add                         ; add in offset
  451 f3ef: af                     plo     rf                  ; place into rf
  452 f3f0: f8 f4                  ldi     high baudtab        ; high portion of address
  453 f3f2: 7c 00                  adci    0                   ; [RLA] propagate carry
  454 f3f4: bf                     phi     rf
  455 f3f5: e3                     sex     r3                  ; setup for output
  456 f3f6: 62                     out     UART_SELECT         ; select msb of diviser latch
  457 f3f7: 11                     db      011h
  458 f3f8: ef                     sex     rf                  ; point to diviser value
  459 f3f9: 63                     out     UART_DATA           ; [RLA] and write to latch
  460 f3fa: e3                     sex     r3                  ; setup for next register select
  461 f3fb: 62                     out     UART_SELECT         ; select lsb of diviser latch
  462 f3fc: 10                     db      010h
  463 f3fd: ef                     sex     rf                  ; set x to diviser table
  464 f3fe: 63                     out     UART_DATA           ; and write to uart
  465 f3ff: e2                     sex     r2                  ; set x back to stack
  466 f400:             ;[RLA]     inc     r2                  ; point back to line control value
  467 f400: 60                     irx                         ; [RLA] restore rf
  468 f401: 72                     ldxa                        ; [RLA]
  469 f402: bf                     phi     rf                  ; [RLA] 
  470 f403: f0                     ldx                         ; [RLA]
  471 f404: af                     plo     rf                  ; [RLA]
  472 f405: 8e                     glo     re                  ; recover comm parameters
  473 f406: f6                     shr                         ; shift out baud value
  474 f407: f6                     shr
  475 f408: f6                     shr
  476 f409: f6                     shr
  477 f40a: fa 0f                  ani     0fh                 ; [RLA] clear unneded bits
  478 f40c: 52                     str     r2                  ; prepare for out
  479 f40d: e3                     sex     r3                  ; need to write register select
  480 f40e: 62                     out     UART_SELECT         ; select line control register
  481 f40f: 13                     db      013h
  482 f410: e2                     sex     r2                  ; X back to stack
  483 f411: 63                     out     UART_DATA           ; write new line control register
  484 f412: 22                     dec     r2                  ; compensate for out
  485 f413: e3                     sex     r3                  ; [RLA] X=P (again!)
  486 f414: 62                     out     UART_SELECT         ; [RLA] address modem control register
  487 f415: 14                     db      014h                ; [RLA] ...
  488 f416: 63                     out     UART_DATA           ; [RLA] clear loopback, set DTR & RTS
  489 f417: 03                     db      03h                 ; [RLA] ...
  490 f418: e2                     sex     r2                  ; [RLA] back to the stack again
  491 f419: fc 00                  adi     0                   ; signal success
  492 f41b: d5                     sep     sret                ; return to caller
  493 f41c: 02 00 00 80 
            00 40 00 20 
            00 10 00 08 
            00 04 00 02 baudtab:   dw      512,128,64,32,16,8,4,2 ; [RLA]
            #endif  ;; "#ifdef UART" ...
  495 f42c:             
            #ifdef NVR
  497 f42c:             ; *********************************
  498 f42c:             ;   Read a byte from an RTC/NVR register.  The address of the register
  499 f42c:             ; is passed inline, after the CALL RTCRDI, and the contents of the RTC/NVR
  500 f42c:             ; register is returned in D...
  501 f42c:             ; *********************************
  502 f42c: e6          rtcrdi: sex     r6              ; [RLA] point to the inline arguments
  503 f42d: 62                  out     NVR_SELECT      ; [RLA] select the disk/uart/rtc register
  504 f42e: e2                  sex     r2              ; [RLA] back to the regular stack
  505 f42f: 6b                  inp     NVR_DATA        ; [RLA] and read the RTC register 
  506 f430: d5                  sep     sret            ; [RLA] return the register value in D
  507 f431:             
  508 f431:             ; *********************************
  509 f431:             ;   Write a byte to an RTC/NVR register.  The address of the register is
  510 f431:             ; passed inline, after the CALL RTCWRI, and the byte to be written is passed
  511 f431:             ; in the D register...
  512 f431:             ; *********************************
  513 f431: e6          rtcwri: sex     r6              ; [RLA] address the inline arguments
  514 f432: 62                  out     NVR_SELECT      ; [RLA] output the register select and skip it
  515 f433: e2                  sex     r2              ; [RLA] back to the regular stack now
  516 f434: 52                  str     r2              ; [RLA] temporarily store the value to output
  517 f435: 63                  out     NVR_DATA        ; [RLA] and write it to the RTC/NVR 
  518 f436: 22                  dec     r2              ; [RLA] out increments R(X), so fix that
  519 f437: d5                  sep     sret            ; [RLA] and return
  520 f438:             
  521 f438:             ; *********************************
  522 f438:             ; *** Test if RTC is present    ***
  523 f438:             ; *** Returns: DF=1 present     ***
  524 f438:             ; ***          DF=0 not present ***
  525 f438:             ; ***          d = size         *** 
  526 f438:             ; [RLA]   Note that "size" does not include the bytes reserved for the
  527 f438:             ; [RLA] clock/calender!  i.e. a "128 byte chip" returns 114 and a "64 byte"
  528 f438:             ; [RLA] chip returns 50.  This way the size represents the number of bytes
  529 f438:             ; [RLA] actually usable by the caller, and also, it represents the maximum
  530 f438:             ; [RLA] length (less checksum) that can be passed to rdnvr/wrnvr...
  531 f438:             ; *********************************
  532 f438: d4          rtctest: sep     scall           ; [RLA] read RTC register 127 first
  533 f439: f4 2c                dw      rtcrdi          ; [RLA] ...
  534 f43b: ff                   db      80h+127         ; [RLA] ...
  535 f43c: 73                   stxd                    ; [RLA] save RTC loc 127 on the stack
  536 f43d: d4                   sep     scall           ; [RLA] now save RTC register 63
  537 f43e: f4 2c                dw      rtcrdi          ; [RLA] ... same as before
  538 f440: bf                   db      80h+63          ; [RLA] ...
  539 f441: 73                   stxd                    ; [RLA] push RTC loc 63 too
  540 f442:             
  541 f442:             ;   First test to see whether the RTC/NVR exists at all by trying to write
  542 f442:             ; (and successfully read back!) location 63...
  543 f442: fb ff               xri     0ffh            ; [RLA] complement previous data in loc 63
  544 f444: d4                  sep     scall           ; [RLA] write it back
  545 f445: f4 31               dw      rtcwri          ; [RLA] ...
  546 f447: bf                  db      80h+63          ; [RLA] ... to location 63
  547 f448: d4                  sep     scall           ; [RLA] now try to read RTC loc 63
  548 f449: f4 2c               dw      rtcrdi          ; [RLA] ...
  549 f44b: bf                  db      80h+63          ; [RLA] ...
  550 f44c: 12                  inc     r2              ; [RLA] previous contents are on the stack
  551 f44d: f4                  add                     ; [RLA] a number plus its complement
  552 f44e: 22                  dec     r2              ; [RLA] protect original contents of loc 63
  553 f44f: fb ff               xri     0ffh            ; [RLA] ... always equals 0FFH
  554 f451: ca f4 8c            lbnz    nortc           ; [RLA] branch if no RTC present
  555 f454:             
  556 f454:             ; Next, check the battery status bit in register 0dh...
  557 f454: d4                  sep     scall           ; [RLA] read register 0x0d
  558 f455: f4 2c               dw      rtcrdi          ; [RLA] ...
  559 f457: 8d                  db      80h+0dh         ; [RLA] ...
  560 f458: fa 80               ani     80h             ; [RLA] is the VRT bit set?
  561 f45a: c2 f4 8c            lbz     nortc           ; [RLA] branch if the battery is dead
  562 f45d:             
  563 f45d:             ;   There are two versions of the NVR - a 64 byte version and a 128 byte
  564 f45d:             ; version.  The 64 byte version simply doesn't decode the upper address bit,
  565 f45d:             ; so with this chip an attempt to access locations 64..127 simply accesses
  566 f45d:             ; locations 0..63 instead.  We can test for a 64 byte chip by writing location
  567 f45d:             ; 127 and checking to see if location 63 changes...
  568 f45d: f8 00               ldi     00              ; [RLA] write 0 to location 63
  569 f45f: d4                  sep     scall           ; [RLA] ...
  570 f460: f4 31               dw      rtcwri          ; [RLA] ...
  571 f462: bf                  db      80h+63          ; [RLA] ...
  572 f463: f8 ff               ldi     0ffh            ; [RLA] then write 0FFH to location 127
  573 f465: d4                  sep     scall           ; [RLA] ...
  574 f466: f4 31               dw      rtcwri          ; [RLA] ...
  575 f468: ff                  db      80h+127         ; [RLA] ...
  576 f469: d4                  sep     scall           ; [RLA] now read back location 63
  577 f46a: f4 2c               dw      rtcrdi          ; [RLA] ...
  578 f46c: bf                  db      80h+63          ; [RLA] ...
  579 f46d: ca f4 81            lbnz    rtc64           ; [RLA] branch if 64 byte chip
  580 f470:             
  581 f470:             ; Here for the 128 byte RTC/NVR with a good battery!
  582 f470: 60          rtc128: irx                     ; [RLA] pop the previous contents of loc 63
  583 f471: f0                  ldx                     ; [RLA] ...
  584 f472: d4                  sep     scall           ; [RLA] and write it back
  585 f473: f4 31               dw      rtcwri          ; [RLA] ...
  586 f475: bf                  db      80h+63          ; [RLA] ...
  587 f476: 60                  irx                     ; [RLA] now pop location 127
  588 f477: f0                  ldx                     ; [RLA] ...
  589 f478: d4                  sep     scall           ; [RLA] and write that back too
  590 f479: f4 31               dw      rtcwri          ; [RLA] ...
  591 f47b: ff                  db      80h+127         ; [RLA] ...
  592 f47c: f8 72               ldi     128-14          ; [RLA] return the size of the NVR
  593 f47e: ff 00               smi     0               ; [RLA] and DF=1 to indicate success
  594 f480: d5                  sep     sret            ; [RLA] ...
  595 f481:             
  596 f481:             
  597 f481:             ; Here for the 64 byte RTC/NVR....
  598 f481: 60          rtc64:  irx                     ; [RLA] pop the previous contents of loc 63
  599 f482: 72                  ldxa                    ; [RLA] ...
  600 f483: d4                  sep     scall           ; [RLA] and write it back
  601 f484: f4 31               dw      rtcwri          ; [RLA] ...
  602 f486: bf                  db      80h+63          ; [RLA] ...
  603 f487:                                             ; [RLA] no need to restore location 127
  604 f487: f8 32               ldi     64-14           ; [RLA] return the size of the NVR
  605 f489: ff 00               smi     0               ; [RLA] and DF=1 to indicate success
  606 f48b: d5                  sep     sret            ; [RLA] ...
  607 f48c:             
  608 f48c:             ; And here if the RTC doesnt exist or the battery is dead...
  609 f48c: 60          nortc:  irx                     ; [RLA] pop two bytes off the stack
  610 f48d: 60                  irx                     ; [RLA] ...
  611 f48e: f8 00               ldi     0               ; [RLA] return the size of the NVR
  612 f490: fc 00               adi     0               ; [RLA] and DF=0 to indicate failure
  613 f492: d5                  sep     sret            ; [RLA] ..
  614 f493:             
  615 f493:             
  616 f493:             ; ******************************** 
  617 f493:             ; *** Read RTC date            ***
  618 f493:             ; *** RF - buffer for time     ***
  619 f493:             ; *** Returns: DF=0 - success  ***
  620 f493:             ; ***          DF=1 - error    ***
  621 f493:             ; ***             D=0 no RTC   ***
  622 f493:             ; ***             D=1 bad time ***
  623 f493:             ; ********************************
  624 f493: d4          e2k_gtod:   sep     scall               ; see if RTC is present
  625 f494: f4 38                   dw      rtctest
  626 f496: c3 f4 a3                lbdf    rtc_go              ; jump if RTC was found
  627 f499:             ; Here if there is no RTC installed...
  628 f499: ff 00       rtc_err:    smi     0                   ; signal error
  629 f49b: f8 00                   ldi     0                   ; as no RTC
  630 f49d: d5                      sep     sret                ; return
  631 f49e:             ; And here if the RTC is not set...
  632 f49e: f8 01       rtc_notset: ldi     1                   ; [RLA] signal bad time/date
  633 f4a0: ff 00                   smi     0                   ; [RLA] signal error 
  634 f4a2: d5                      sep     sret                ; [RLA] return
  635 f4a3:             
  636 f4a3:             ;   There are two caveats in reading the clock - the first is that we check
  637 f4a3:             ; to ensure that 1) the clock is running and that 2) the 24 hour and binary
  638 f4a3:             ; mode bits are set.  If theres been a previous call to e2k_stod then these
  639 f4a3:             ; will all be true.  Note that you cant really change these bits while the
  640 f4a3:             ; clock is running (it can cause anomalies in the count if you do) - you have
  641 f4a3:             ; to first set the mode bits and then set the time, so thats why we leave it
  642 f4a3:             ; all up to e2k_stod().
  643 f4a3: d4          rtc_go: sep     scall           ; [RLA] first read register 0x0a
  644 f4a4: f4 2c               dw      rtcrdi          ; [RLA] ...
  645 f4a6: 8a                  db      80h+0ah         ; [RLA] ...
  646 f4a7: fa 70               ani     70h             ; [RLA] check the DV2/1/0 bits
  647 f4a9: fb 20               xri     20h             ; [RLA] make sure the clock is running
  648 f4ab: ca f4 9e            lbnz    rtc_notset      ; [RLA] not runing otherwise
  649 f4ae: d4                  sep     scall           ; [RLA] now read register 0x0b
  650 f4af: f4 2c               dw      rtcrdi          ; [RLA] ...
  651 f4b1: 8b                  db      80h+0bh         ; [RLA] ...
  652 f4b2: fa 06               ani     06h             ; [RLA] make sure the DM and 24 bits are set
  653 f4b4: fb 06               xri     06h             ; [RLA] (both bits must be set!)
  654 f4b6: ca f4 9e            lbnz    rtc_notset      ; [RLA] clock is not set otherwise
  655 f4b9:             
  656 f4b9:             ;   The second caveat is that we have to be careful _when_ we read the clock.
  657 f4b9:             ; Remember, the RTC hardware potentially changes the seconds, minutes, hours
  658 f4b9:             ; day, month and year registers any time the clock ticks (i.e. at 23:59:59 on
  659 f4b9:             ; the last day of the year, all these bytes will change on the next tick!).
  660 f4b9:             ; If the clock just happens to tick while were in the middle of reading it,
  661 f4b9:             ; then the date/time we assemble can be off by a minute, an hour, even a year
  662 f4b9:             ; if were unlucky!  (You might think this is unlikely to happen, and I admit
  663 f4b9:             ; that it is, but once upon a time I was personally inveolved in fixing a bug
  664 f4b9:             ; in an embedded system caused by just this situation!  It happens...)
  665 f4b9:             ; Fortunately for us, the DS1287 designers thought of this and they provide
  666 f4b9:             ; us with a bit, UIP, to signal that an update coming soon.  As long as UIP=0
  667 f4b9:             ; were guaranteed at least 244us before an update occurs.
  668 f4b9: d4          rtc_w1: sep     scall           ; [RLA] UIP is in register 0x0a
  669 f4ba: f4 2c               dw      rtcrdi          ; [RLA] ...
  670 f4bc: 8a                  db      80h+0ah         ; [RLA] ...
  671 f4bd: fa 80               ani     80h             ; [RLA] wait for UIP to be clear
  672 f4bf: ca f4 b9            lbnz    rtc_w1          ; [RLA] ...
  673 f4c2:             
  674 f4c2:             ; Ok, were safe...  Read the clock...
  675 f4c2: d4                  sep     scall           ; [RLA] first the month
  676 f4c3: f4 2c               dw      rtcrdi          ; [RLA] ...
  677 f4c5: 88                  db      80h+08h         ; [RLA] ...
  678 f4c6: 5f                  str     rf              ; [RLA] store that in the buffer
  679 f4c7: 1f                  inc     rf              ; [RLA] and on to the next byte
  680 f4c8: d4                  sep     scall           ; [RLA] next the day of the month
  681 f4c9: f4 2c               dw      rtcrdi          ; [RLA] ...
  682 f4cb: 87                  db      80h+07h         ; [RLA] ...
  683 f4cc: 5f                  str     rf              ; [RLA] ...
  684 f4cd: 1f                  inc     rf              ; [RLA] ...
  685 f4ce: d4                  sep     scall           ; [RLA] year (two digits only)
  686 f4cf: f4 2c               dw      rtcrdi          ; [RLA] ...
  687 f4d1: 89                  db      80h+09h         ; [RLA] ...
  688 f4d2: 5f                  str     rf              ; [RLA] ...
  689 f4d3: 1f                  inc     rf              ; [RLA] ...
  690 f4d4: d4                  sep     scall           ; [RLA] hour (24 hour mode)
  691 f4d5: f4 2c               dw      rtcrdi          ; [RLA] ...
  692 f4d7: 84                  db      80h+04h         ; [RLA] ...
  693 f4d8: 5f                  str     rf              ; [RLA] ...
  694 f4d9: 1f                  inc     rf              ; [RLA] ...
  695 f4da: d4                  sep     scall           ; [RLA] minute
  696 f4db: f4 2c               dw      rtcrdi          ; [RLA] ...
  697 f4dd: 82                  db      80h+02h         ; [RLA] ...
  698 f4de: 5f                  str     rf              ; [RLA] ...
  699 f4df: 1f                  inc     rf              ; [RLA] ...
  700 f4e0: d4                  sep     scall           ; [RLA] and seconds
  701 f4e1: f4 2c               dw      rtcrdi          ; [RLA] ...
  702 f4e3: 80                  db      80h+00h         ; [RLA] ...
  703 f4e4: 5f                  str     rf              ; [RLA] ...
  704 f4e5: 1f                  inc     rf              ; [RLA] ...
  705 f4e6:             
  706 f4e6:             ; All is well - return DF=0...
  707 f4e6: fc 00               adi     0               ; [RLA] indicate succes
  708 f4e8: d5                  sep     sret            ; [RLA] ...
  709 f4e9:             
  710 f4e9:             
  711 f4e9:             
  712 f4e9:             ; ********************************
  713 f4e9:             ; *** Set RTC date             ***
  714 f4e9:             ; *** RF - buffer holding data ***
  715 f4e9:             ; *** Returns: DF=0 - success  ***
  716 f4e9:             ; ***          DF=1 - no RTC   ***
  717 f4e9:             ; ********************************
  718 f4e9: d4          e2k_stod:  sep     scall               ; see if RTC is present
  719 f4ea: f4 38                  dw      rtctest
  720 f4ec: cb f4 99               lbnf    rtc_err             ; jump if no RTC is present
  721 f4ef:             
  722 f4ef:             ;   The RTC ships from the factory with the clock turned off - this saves
  723 f4ef:             ; the shelf life of the lithium cell.  Before setting the clock, lets turn
  724 f4ef:             ; on the oscillator so that it will actually keep time :-)  If the oscillator
  725 f4ef:             ; is already on, this will do no harm...
  726 f4ef: f8 20               ldi     20h             ; [RLA] turn ON the clock
  727 f4f1: d4                  sep     scall           ; [RLA] ... and OFF the SQW output
  728 f4f2: f4 31               dw      rtcwri          ; [RLA] ... which we dont use anyway
  729 f4f4: 8a                  db      80h+0ah         ; [RLA] ...
  730 f4f5:             
  731 f4f5:             ;   Now, set the SET bit, which inhibits the clock from counting.  This
  732 f4f5:             ; prevents it from accidentally rolling over while were in the middle of
  733 f4f5:             ; updating the registers!  At the same time, select 24 hour mode, binary
  734 f4f5:             ; (not BCD) mode, and enable daylight savings time.  The latter choice is
  735 f4f5:             ; debatable since the chip only knows the DST rules for the USA, and not
  736 f4f5:             ; even all parts of the US observe DST to start with.  Still, it works for
  737 f4f5:             ; most customers!
  738 f4f5: f8 86               ldi     86h             ; [RLA] SET, DM, and 24hr
  739 f4f7: d4                  sep     scall           ; [RLA] ...
  740 f4f8: f4 31               dw      rtcwri          ; [RLA] ...
  741 f4fa: 8b                  db      80h+0bh         ; [RLA] ...
  742 f4fb:             
  743 f4fb:             ;   Load the clock registers.  Note that there is no error checking on the
  744 f4fb:             ; values - if the caller gives bogus values then the count will be
  745 f4fb:             ; unpredictable!
  746 f4fb: 4f                  lda     rf              ; [RLA] fetch the month
  747 f4fc: d4                  sep     scall           ; [RLA] ... and update the RTC chip
  748 f4fd: f4 31               dw      rtcwri          ; [RLA] ...
  749 f4ff: 88                  db      80h+08h         ; [RLA] ...
  750 f500: 4f                  lda     rf              ; [RLA] next the day of the month
  751 f501: d4                  sep     scall           ; [RLA] ...
  752 f502: f4 31               dw      rtcwri          ; [RLA] ...
  753 f504: 87                  db      80h+07h         ; [RLA] ...
  754 f505: 4f                  lda     rf              ; [RLA] the year
  755 f506: d4                  sep     scall           ; [RLA] ...
  756 f507: f4 31               dw      rtcwri          ; [RLA] ...
  757 f509: 89                  db      80h+09h         ; [RLA] ...
  758 f50a: 4f                  lda     rf              ; [RLA] hour
  759 f50b: d4                  sep     scall           ; [RLA] ...
  760 f50c: f4 31               dw      rtcwri          ; [RLA] ...
  761 f50e: 84                  db      80h+04h         ; [RLA] ...
  762 f50f: 4f                  lda     rf              ; [RLA] minute
  763 f510: d4                  sep     scall           ; [RLA] ...
  764 f511: f4 31               dw      rtcwri          ; [RLA] ...
  765 f513: 82                  db      80h+02h         ; [RLA] ...
  766 f514: 4f                  lda     rf              ; [RLA] seconds
  767 f515: d4                  sep     scall           ; [RLA] ...
  768 f516: f4 31               dw      rtcwri          ; [RLA] ...
  769 f518: 80                  db      80h+00h         ; [RLA] ...
  770 f519:             
  771 f519:             ; Clear the SET bit to allow the clock to run, and were done!
  772 f519: f8 07               ldi     07h             ; [RLA] DM, 24hr and DSE
  773 f51b: d4                  sep     scall           ; [RLA] ...
  774 f51c: f4 31               dw      rtcwri          ; [RLA] ...
  775 f51e: 8b                  db      80h+0bh         ; [RLA] ...
  776 f51f: fc 00               adi     0               ; [RLA] return DF=0 for success
  777 f521: d5                  sep     sret            ; [RLA] ...
  778 f522:             
  779 f522:             
  780 f522:             ; ************************************************
  781 f522:             ; *** Read bytes from NVR                      ***
  782 f522:             ; *** RF.0 - relative address to start reading ***
  783 f522:             ; *** RD - Destination for bytes               ***
  784 f522:             ; *** RC.0 - count                             ***
  785 f522:             ; *** Returns: DF=0 - success                  ***
  786 f522:             ; ***          DF=1 - no NVR                   ***
  787 f522:             ; ************************************************
  788 f522: d4          e2k_rdnvr: sep     scall               ; check for presence of NVR
  789 f523: f4 38                  dw      rtctest
  790 f525: cb f4 99               lbnf    rtc_err             ; jump if not
  791 f528: 8f                     glo     rf                  ; save RF
  792 f529: 73                     stxd
  793 f52a: 9f                     ghi     rf
  794 f52b: 73                     stxd
  795 f52c: 8d                     glo     rd                  ; save RD
  796 f52d: 73                     stxd
  797 f52e: 9d                     ghi     rd
  798 f52f: 73                     stxd
  799 f530: d4                     sep     scall               ; compute checksum
  800 f531: f5 97                  dw      nvr_chk
  801 f533: d4                     sep     scall               ; get current checksum
  802 f534: f5 e3                  dw      get_chk
  803 f536: 8d                     glo     rd                  ; compare them
  804 f537: 52                     str     r2
  805 f538: 8f                     glo     rf
  806 f539: f7                     sm
  807 f53a: ca f5 65               lbnz    chk_err             ; jump on checksum error
  808 f53d: 9d                     ghi     rd                  ; check high byte as well
  809 f53e: 52                     str     r2
  810 f53f: 9f                     ghi     rf
  811 f540: f7                     sm
  812 f541: ca f5 65               lbnz    chk_err
  813 f544: 60                     irx                         ; recover RD and RF
  814 f545: 72                     ldxa
  815 f546: bd                     phi     rd
  816 f547: 72                     ldxa
  817 f548: ad                     plo     rd
  818 f549: 72                     ldxa
  819 f54a: bf                     phi     rf
  820 f54b: f0                     ldx
  821 f54c: af                     plo     rf
  822 f54d: fc 8e                  adi     08eh                ; offset to beginning of general regs.
  823 f54f: 52                     str     r2                  ; store into memory
  824 f550: 8c          rdnvr_lp:  glo     rc                  ; see if done
  825 f551: c2 f5 62               lbz     rdnvr_dn            ; jump if so
  826 f554: 62                     out     NVR_SELECT          ; write next register address
  827 f555: 22                     dec     r2                  ; compensate for inc on out
  828 f556: ed                     sex     rd                  ; set x to destination memory
  829 f557: 6b                     inp     NVR_DATA            ; read NVR
  830 f558: 1d                     inc     rd                  ; increment destination
  831 f559: 2c                     dec     rc                  ; decrement count
  832 f55a: e2                     sex     r2                  ; point x back to stack
  833 f55b: f8 01                  ldi     1                   ; [RLA] increment the register address
  834 f55d: f4                     add                         ; [RLA]
  835 f55e: 52                     str     r2                  ; [RLA]
  836 f55f: c0 f5 50               lbr     rdnvr_lp            ; loop back for more
  837 f562: fc 00       rdnvr_dn:  adi     0                   ; signal success
  838 f564: d5                     sep     sret                ; and return
  839 f565: 60          chk_err:   irx                         ; recover RD and RF
  840 f566: 72                     ldxa
  841 f567: bd                     phi     rd
  842 f568: 72                     ldxa
  843 f569: ad                     plo     rd
  844 f56a: 72                     ldxa
  845 f56b: bf                     phi     rf
  846 f56c: f0                     ldx
  847 f56d: af                     plo     rf
  848 f56e: ff 00                  smi     0                   ; signal an error
  849 f570: f8 01                  ldi     1                   ; signal bad checksum
  850 f572: d5                     sep     sret                ; return to caller
  851 f573:             
  852 f573:             ; ************************************************
  853 f573:             ; *** Write bytes to NVR                       ***
  854 f573:             ; *** RF.0 - relative address to start writing ***
  855 f573:             ; *** RD - source for bytes                    ***
  856 f573:             ; *** RC.0 - count                             ***
  857 f573:             ; *** Returns: DF=0 - success                  ***
  858 f573:             ; ***          DF=1 - no NVR                   ***
  859 f573:             ; ************************************************
  860 f573: d4          e2k_wrnvr: sep     scall               ; check for presence of NVR
  861 f574: f4 38                  dw      rtctest
  862 f576: cb f4 99               lbnf    rtc_err             ; jump if not
  863 f579: 8f                     glo     rf                  ; get starting register
  864 f57a: fc 8e                  adi     08eh                ; offset to beginning of general regs.
  865 f57c: 52                     str     r2                  ; store into memory
  866 f57d: 8c          wrnvr_lp:  glo     rc                  ; see if done
  867 f57e: c2 f5 8e               lbz     wrnvr_dn            ; jump if so
  868 f581: 62                     out     NVR_SELECT          ; write next register address
  869 f582: 22                     dec     r2                  ; compensate for inc on out
  870 f583: ed                     sex     rd                  ; set x to source memory
  871 f584: 63                     out     NVR_DATA            ; write NVR
  872 f585: 2c                     dec     rc                  ; decrement count
  873 f586: e2                     sex     r2                  ; point x back to stack
  874 f587: f8 01                  ldi     1                   ; [RLA] increment the register address
  875 f589: f4                     add                         ; [RLA]
  876 f58a: 52                     str     r2                  ; [RLA]
  877 f58b: c0 f5 7d               lbr     wrnvr_lp            ; loop back for more
  878 f58e: d4          wrnvr_dn:  sep     scall               ; compute new checksum
  879 f58f: f5 97                  dw      nvr_chk
  880 f591: d4                     sep     scall               ; and write to NVR
  881 f592: f5 c9                  dw      set_chk
  882 f594: fc 00                  adi     0                   ; signal success
  883 f596: d5                     sep     sret                ; and return
  884 f597:             
  885 f597:             ; ************************************
  886 f597:             ; *** Compute checksum for NVR ram ***
  887 f597:             ; *** Returns: RF - checksum       ***
  888 f597:             ; ************************************
  889 f597: f8 00       nvr_chk:   ldi     0                   ; set initial checksum
  890 f599: bf                     phi     rf
  891 f59a: af                     plo     rf
  892 f59b: 8c                     glo     rc                  ; [RLA] preserve rc.0
  893 f59c: 73                     stxd                        ; [RLA] ...
  894 f59d: f8 8e                  ldi     08eh                ; starting register
  895 f59f: 73                     stxd                        ; [RLA]
  896 f5a0: d4                     sep     scall               ; get size of nvram
  897 f5a1: f4 38                  dw      rtctest
  898 f5a3: fc 8c                  adi     08eh-2              ; [RLA] setup end
  899 f5a5: ac                     plo     rc
  900 f5a6: 12                     inc     r2                  ; [RLA] point to register address
  901 f5a7: f0          nvr_chklp: ldx                         ; [RLA] duplicate the byte on the TOS
  902 f5a8: 22                     dec     r2                  ; [RLA] ...
  903 f5a9: 52                     str     r2                  ; [RLA] ...
  904 f5aa: 62                     out     NVR_SELECT          ; select NVR address
  905 f5ab:             ;[RLA]     dec     r2                  ; [RLA] correct for out increment
  906 f5ab: 22                     dec     r2                  ; [RLA] and then point to a free byte
  907 f5ac: 6b                     inp     NVR_DATA            ; [RLA] read NVR byte
  908 f5ad: 8f                     glo     rf                  ; add into checksum
  909 f5ae: f4                     add
  910 f5af: af                     plo     rf
  911 f5b0: 9f                     ghi     rf                  ; propagate carry
  912 f5b1: fc 00                  adi     0
  913 f5b3: bf                     phi     rf
  914 f5b4: fe                     shl                         ; now ring shift left
  915 f5b5: 8f                     glo     rf
  916 f5b6: 7e                     shlc
  917 f5b7: af                     plo     rf
  918 f5b8: 9f                     ghi     rf
  919 f5b9: 7e                     shlc
  920 f5ba: bf                     phi     rf
  921 f5bb: 12                     inc     r2                  ; [RLA] point to NVR address
  922 f5bc: 02                     ldn     r2                  ; retrieve it
  923 f5bd: fc 01                  adi     1                   ; point to next byte
  924 f5bf: 52                     str     r2                  ; store again
  925 f5c0: 8c                     glo     rc                  ; get end
  926 f5c1: f7                     sm                          ; see if at end
  927 f5c2: ca f5 a7               lbnz    nvr_chklp           ; loop back if not
  928 f5c5: 60                     irx                         ; [RLA] restore rc.0
  929 f5c6: f0                     ldx                         ; [RLA] ...
  930 f5c7: ac                     plo     rc                  ; [RLA] ...
  931 f5c8: d5                     sep     sret                ; and return
  932 f5c9:             
  933 f5c9:             ; ************************
  934 f5c9:             ; *** Set NVR checksum ***
  935 f5c9:             ; *** RF - checkshum   ***
  936 f5c9:             ; ************************
  937 f5c9: 8c          set_chk:   glo     rc                  ; save consumed register
  938 f5ca: 73                     stxd
  939 f5cb: d4                     sep     scall               ; get size of nvram
  940 f5cc: f4 38                  dw      rtctest
  941 f5ce: fc 8c                  adi     8eh-2               ; [RLA]
  942 f5d0: ac                     plo     rc
  943 f5d1: 52                     str     r2                  ; store for out
  944 f5d2: 62                     out     NVR_SELECT          ; write register selection port
  945 f5d3: 22                     dec     r2                  ; compensate for increment
  946 f5d4: 9f                     ghi     rf                  ; get high of checksum
  947 f5d5: 52                     str     r2                  ; prepare for out
  948 f5d6: 63                     out     NVR_DATA            ; write to NVRAM
  949 f5d7: 22                     dec     r2                  ; [RLA] compensate for out
  950 f5d8: 1c                     inc     rc                  ; next position
  951 f5d9: 8c                     glo     rc                  ; setup address
  952 f5da: 52                     str     r2                  ; store for out
  953 f5db: 62                     out     NVR_SELECT          ; write register selection port
  954 f5dc: 22                     dec     r2                  ; compensate for increment
  955 f5dd: 8f                     glo     rf                  ; get low of checksum
  956 f5de: 52                     str     r2                  ; prepare for out
  957 f5df: 63                     out     NVR_DATA            ; write to NVRAM
  958 f5e0: f0                     ldx
  959 f5e1: ac                     plo     rc
  960 f5e2: d5                     sep     sret                ; and return
  961 f5e3:             
  962 f5e3:             ; ******************************
  963 f5e3:             ; *** Get NVR checksum       ***
  964 f5e3:             ; *** Returns: RD - checksum ***
  965 f5e3:             ; ******************************
  966 f5e3: 8c          get_chk:   glo     rc                  ; save consumed register
  967 f5e4: 73                     stxd    
  968 f5e5: d4                     sep     scall               ; get size of nvram
  969 f5e6: f4 38                  dw      rtctest
  970 f5e8: fc 8c                  adi     8eh-2                 ; [RLA] setup address
  971 f5ea: ac                     plo     rc    
  972 f5eb: 52                     str     r2                  ; store for out
  973 f5ec: 62                     out     NVR_SELECT          ; compensate for inc
  974 f5ed: 22                     dec     r2                  ; [RLA] correct for out instruction
  975 f5ee: 6b                     inp     NVR_DATA            ; read NVR 
  976 f5ef: bd                     phi     rd                  ; put into RD.1
  977 f5f0: 1c                     inc     rc                  ; move to next address
  978 f5f1: 8c                     glo     rc                  ; get checksum address
  979 f5f2: 52                     str     r2                  ; store for out
  980 f5f3: 62                     out     NVR_SELECT          ; compensate for inc
  981 f5f4: 22                     dec     r2                  ; [RLA] correct for out instruction
  982 f5f5: 6b                     inp     NVR_DATA            ; read NVR 
  983 f5f6: ad                     plo     rd                  ; put into RD.0
  984 f5f7: 60                     irx                         ; recover consumed register
  985 f5f8: f0                     ldx     
  986 f5f9: ac                     plo     rc
  987 f5fa: d5                     sep     sret                ; return to caller
  988 f5fb:             
  989 f5fb:             ; ****************************************************
  990 f5fb:             ; *** Output 2 digit decimal number with leading 0 ***
  991 f5fb:             ; *** D - value to output                          ***
  992 f5fb:             ; *** RF - buffer to write value to                ***
  993 f5fb:             ; ****************************************************
  994 f5fb:             intout2:
  995 f5fb: 52                  str     r2              ; save value for a moment
  996 f5fc: f8 00               ldi     0               ; setup count
  997 f5fe: ae                  plo     re
  998 f5ff: 02                  ldn     r2              ; retrieve it
  999 f600:             intout2lp:
 1000 f600: ff 0a               smi     10              ; subtract 10
 1001 f602: cb f6 09            lbnf    intout2go       ; jump if too small
 1002 f605: 1e                  inc     re              ; increment tens
 1003 f606: c0 f6 00            lbr     intout2lp       ; and keep looking
 1004 f609:             intout2go:
 1005 f609: fc 0a               adi     10              ; make positive again
 1006 f60b: 52                  str     r2              ; save units
 1007 f60c: 8e                  glo     re              ; get tens
 1008 f60d: fc 30               adi     '0'             ; convert to ascii
 1009 f60f: 5f                  str     rf              ; store into buffer
 1010 f610: 1f                  inc     rf
 1011 f611: 02                  ldn     r2              ; recover units
 1012 f612: fc 30               adi     '0'             ; convert to ascii
 1013 f614: 5f                  str     rf              ; and store into buffer
 1014 f615: 1f                  inc     rf
 1015 f616: d5                  sep     sret            ; return to caller
 1016 f617:             
 1017 f617:             ; ************************************
 1018 f617:             ; *** Convert packed date to ascii ***
 1019 f617:             ; *** RD - pointer to packed date  ***
 1020 f617:             ; *** RF - pointer to buffer       ***
 1021 f617:             ; ************************************
 1022 f617: 4d          dttoas: lda     rd              ; retrieve month
 1023 f618: d4                  sep     scall           ; output it
 1024 f619: f5 fb               dw      intout2
 1025 f61b: f8 2f               ldi     '/'             ; now a slash
 1026 f61d: 5f                  str     rf              ; store into buffer
 1027 f61e: 1f                  inc     rf
 1028 f61f: 4d                  lda     rd              ; retrieve day
 1029 f620: d4                  sep     scall           ; output it
 1030 f621: f5 fb               dw      intout2
 1031 f623: f8 2f               ldi     '/'             ; now a slash
 1032 f625: 5f                  str     rf              ; store into buffer
 1033 f626: 1f                  inc     rf
 1034 f627: 4d                  lda     rd              ; [RLA] get year
 1035 f628: 73                  stxd                    ; save contents of RD
 1036 f629: fc b4               adi     180             ; add base of 1972
 1037 f62b: ad                  plo     rd
 1038 f62c: 9d                  ghi     rd              ; save high byte
 1039 f62d: 73                  stxd
 1040 f62e: f8 07               ldi     7               ; high byte of 1972
 1041 f630: 7c 00               adci    0               ; propagate the carry
 1042 f632: bd                  phi     rd
 1043 f633: d4                  sep     scall           ; output the year
 1044 f634: ff 60               dw      f_uintout
 1045 f636: f8 00               ldi     0               ; write terminator
 1046 f638: 5f                  str     rf
 1047 f639: 60                  irx                     ; recover rd
 1048 f63a: 72                  ldxa
 1049 f63b: bd                  phi     rd
 1050 f63c: f0                  ldx
 1051 f63d: ad                  plo     rd
 1052 f63e: d5                  sep     sret            ; and return
 1053 f63f:             
 1054 f63f:             ; ************************************
 1055 f63f:             ; *** Convert packed time to ascii ***
 1056 f63f:             ; *** RD - pointer to packed time  ***
 1057 f63f:             ; *** RF - pointer to buffer       ***
 1058 f63f:             ; ************************************
 1059 f63f: f8 20       tmtoas: ldi     ' '             ; space after year
 1060 f641: 5f                  str     rf              ; store into buffer
 1061 f642: 1f                  inc     rf
 1062 f643: 4d                  lda     rd              ; get hour
 1063 f644: d4                  sep     scall           ; output it
 1064 f645: f5 fb               dw      intout2
 1065 f647: f8 3a               ldi     ':'             ; now a colon
 1066 f649: 5f                  str     rf              ; store into buffer
 1067 f64a: 1f                  inc     rf
 1068 f64b: 4d                  lda     rd              ; get minutes
 1069 f64c: d4                  sep     scall           ; output it
 1070 f64d: f5 fb               dw      intout2
 1071 f64f: f8 3a               ldi     ':'             ; now a colon
 1072 f651: 5f                  str     rf              ; store into buffer
 1073 f652: 1f                  inc     rf
 1074 f653: 4d                  lda     rd              ; get seconds
 1075 f654: d4                  sep     scall           ; output it
 1076 f655: f5 fb               dw      intout2
 1077 f657: f8 00               ldi     0
 1078 f659: 5f                  str     rf              ; write terminator
 1079 f65a: d5                  sep     sret            ; and return
 1080 f65b:             
 1081 f65b:             ; ************************************
 1082 f65b:             ; *** Convert ascii date to packed ***
 1083 f65b:             ; *** RF - pointer to ascii date   ***
 1084 f65b:             ; *** RA - destination address     ***
 1085 f65b:             ; ************************************
 1086 f65b: 8d          astodt: glo     rd              ; save consumed register
 1087 f65c: 73                  stxd
 1088 f65d: 9d                  ghi     rd
 1089 f65e: 73                  stxd
 1090 f65f: d4                  sep     scall           ; convert first number
 1091 f660: f8 39               dw      atoi
 1092 f662: 8d                  glo     rd              ; get value
 1093 f663: ff 0d               smi     13              ; see if valid month
 1094 f665: c3 f6 f0            lbdf    dterr           ; jump if invalid
 1095 f668: 8d                  glo     rd              ; recover number
 1096 f669: 5a                  str     ra              ; store into output
 1097 f66a: 1a                  inc     ra              ; and increment
 1098 f66b: 4f                  lda     rf              ; get next char
 1099 f66c: ff 2f               smi     '/'             ; must be a slash
 1100 f66e: ca f6 f0            lbnz    dterr
 1101 f671: d4                  sep     scall           ; get next number
 1102 f672: f8 39               dw      atoi
 1103 f674: 8d                  glo     rd              ; get value
 1104 f675: ff 20               smi     32              ; check next number
 1105 f677: c3 f6 f0            lbdf    dterr           ; jump if invalid
 1106 f67a: 8d                  glo     rd              ; recover value
 1107 f67b: 5a                  str     ra              ; and save in output
 1108 f67c: 1a                  inc     ra              ; and increment
 1109 f67d: 4f                  lda     rf              ; get next char
 1110 f67e: ff 2f               smi     '/'             ; must be a slash
 1111 f680: ca f6 f0            lbnz    dterr           ; jump if not
 1112 f683: d4                  sep     scall           ; now convert year
 1113 f684: f8 39               dw      atoi
 1114 f686: 9d                  ghi     rd              ; get high byte
 1115 f687: ca f6 97            lbnz    y4              ; jump if 4 digit year
 1116 f68a: 8d                  glo     rd              ; need to check y2k
 1117 f68b: ff 48               smi     72              ; need to check for y2k threshold
 1118 f68d: cb f6 9d            lbnf    y2k             ; jump if 2000+
 1119 f690:             asdtend:
 1120 f690: 5a                  str     ra              ; store into output
 1121 f691: 1a                  inc     ra              ; move to next position
 1122 f692: fc 00               adi     0               ; signal valid date
 1123 f694: c0 f6 dd            lbr     get_rd          ; recover RD and return
 1124 f697: 8d          y4:     glo     rd              ; subtract 1972
 1125 f698: ff b4               smi     180
 1126 f69a: c0 f6 90            lbr     asdtend         ; and store
 1127 f69d: 8d          y2k:    glo     rd              ; recover value
 1128 f69e: fc 1c               adi     28              ; add in offset
 1129 f6a0: c0 f6 90            lbr     asdtend         ; and continue processing
 1130 f6a3:             
 1131 f6a3:             ; ************************************
 1132 f6a3:             ; *** Convert ascii time to packed ***
 1133 f6a3:             ; *** RF - pointer to ascii time   ***
 1134 f6a3:             ; *** RA - destination address     ***
 1135 f6a3:             ; ************************************
 1136 f6a3: 8d          astotm: glo     rd              ; save consumed register
 1137 f6a4: 73                  stxd
 1138 f6a5: 9d                  ghi     rd
 1139 f6a6: 73                  stxd
 1140 f6a7: d4                  sep     scall           ; move past any spaces
 1141 f6a8: fd 2b               dw      ltrim
 1142 f6aa: d4                  sep     scall           ; convert hours
 1143 f6ab: f8 39               dw      atoi
 1144 f6ad: 8d                  glo     rd              ; check if valid
 1145 f6ae: ff 18               smi     24
 1146 f6b0: c3 f6 f0            lbdf    dterr           ; jump if not
 1147 f6b3: 8d                  glo     rd              ; store value into result
 1148 f6b4: 5a                  str     ra
 1149 f6b5: 1a                  inc     ra
 1150 f6b6: 4f                  lda     rf              ; get next char
 1151 f6b7: ff 3a               smi     ':'             ; must be a colon
 1152 f6b9: ca f6 f0            lbnz    dterr           ; jump if not
 1153 f6bc: d4                  sep     scall           ; convert minutes
 1154 f6bd: f8 39               dw      atoi
 1155 f6bf: 8d                  glo     rd              ; check for valid
 1156 f6c0: ff 3c               smi     60
 1157 f6c2: c3 f6 f0            lbdf    dterr           ; jump if not
 1158 f6c5: 8d                  glo     rd              ; store value into result
 1159 f6c6: 5a                  str     ra
 1160 f6c7: 1a                  inc     ra
 1161 f6c8: 4f                  lda     rf              ; get next char
 1162 f6c9: ae                  plo     re              ; keep a copy
 1163 f6ca: ff 3a               smi     ':'             ; check for colon
 1164 f6cc: c2 f6 e3            lbz     is_sec          ; jump if seconds are provided
 1165 f6cf: 8e                  glo     re              ; need to check for valid characters
 1166 f6d0: c2 f6 d8            lbz     no_sec          ; jump if terminator
 1167 f6d3: ff 20               smi     32              ; otherwise must be a space
 1168 f6d5: ca f6 f0            lbnz    dterr           ; jump on other chars to err
 1169 f6d8: f8 00       no_sec: ldi     0               ; set seconds to zero
 1170 f6da: 5a          tm_cont:str     ra
 1171 f6db: fc 00               adi     0               ; signal no error
 1172 f6dd: 60          get_rd: irx                     ; recover consumed register
 1173 f6de: 72                  ldxa
 1174 f6df: bd                  phi     rd
 1175 f6e0: f0                  ldx
 1176 f6e1: ad                  plo     rd
 1177 f6e2: d5                  sep     sret            ; and return
 1178 f6e3: d4          is_sec: sep     scall           ; convert seconds
 1179 f6e4: f8 39               dw      atoi
 1180 f6e6: 8d                  glo     rd              ; check for valid
 1181 f6e7: ff 3c               smi     60
 1182 f6e9: c3 f6 f0            lbdf    dterr           ; jump if not valid
 1183 f6ec: 8d                  glo     rd              ; store answer and return
 1184 f6ed: c0 f6 da            lbr     tm_cont
 1185 f6f0: ff 00       dterr:  smi     0               ; signal an error
 1186 f6f2: c0 f6 dd            lbr     get_rd          ; recover RD and return
            #endif  ;; "#ifdef NVR" ...
 1188 f6f5:             
            #ifdef EIDE
 1190 f6f5:             ; ********************************
 1191 f6f5:             ; *** Select master ide device ***
 1192 f6f5:             ; ********************************
 1193 f6f5: d4          master:    sep     scall               ; wait til drive ready
 1194 f6f6: fb 9a                  dw      waitrdy
 1195 f6f8: c3 f7 04               lbdf    sel_err             ; jump if timedout
 1196 f6fb: e3                     sex     r3                  ; setup for immediate outs
 1197 f6fc: 62                     out     IDE_SELECT          ; select device register
 1198 f6fd: 06                     db      6
 1199 f6fe: 63                     out     IDE_DATA            ; now output code for master
 1200 f6ff: 00                     db      0
 1201 f700: e2                     sex     r2                  ; restore x register
 1202 f701: fc 00                  adi     0                   ; signal no error
 1203 f703: d5                     sep     sret                ; and return
 1204 f704:             
 1205 f704: ff 00       sel_err:   smi     0                   ; signal an error
 1206 f706: d5                     sep     sret                ; and return
 1207 f707:             ; *******************************
 1208 f707:             ; *** Select slave ide device ***
 1209 f707:             ; *******************************
 1210 f707: d4          slave:     sep     scall               ; wait til drive ready
 1211 f708: fb 9a                  dw      waitrdy
 1212 f70a: c3 f7 04               lbdf    sel_err             ; jump if timedout
 1213 f70d: e3                     sex     r3                  ; setup for immediate outs
 1214 f70e: 62                     out     IDE_SELECT          ; select device register
 1215 f70f: 06                     db      6
 1216 f710: 63                     out     IDE_DATA            ; now output code for slave
 1217 f711: 10                     db      010h
 1218 f712: e2                     sex     r2                  ; restore x register
 1219 f713: fc 00                  adi     0                   ; signal no error
 1220 f715: d5                     sep     sret                ; and return
 1221 f716:             
 1222 f716:             ; ************************************
 1223 f716:             ; *** get ide identity information ***
 1224 f716:             ; *** RF - pointer to buffer       ***
 1225 f716:             ; *** RD.0 = 0 master              ***
 1226 f716:             ; ***      = 1 slave               ***
 1227 f716:             ; *** Returns: DF=1 drive error    ***
 1228 f716:             ; ************************************
 1229 f716: 8f          ide_ident: glo     rf                  ; save buffer position
 1230 f717: 73                     stxd
 1231 f718: 9f                     ghi     rf
 1232 f719: 73                     stxd
 1233 f71a: d4                     sep     scall               ; read drive data
 1234 f71b: f7 28                  dw      ide_id
 1235 f71d: 60                     irx                         ; recover buffer
 1236 f71e: 72                     ldxa
 1237 f71f: bf                     phi     rf
 1238 f720: f0                     ldx
 1239 f721: af                     plo     rf
 1240 f722: c3 f7 04               lbdf    sel_err             ; jump if drive error
 1241 f725: c0 f7 51               lbr     swap                ; perform byte swaps
 1242 f728:                       
 1243 f728: 8d          ide_id:    glo     rd
 1244 f729: c2 f7 35               lbz     id_master
 1245 f72c: d4                     sep     scall               ; select slave drive
 1246 f72d: f7 07                  dw      slave
 1247 f72f: c3 f7 04               lbdf    sel_err             ; jump on error
 1248 f732: c0 f7 3b               lbr     ident_go
 1249 f735: d4          id_master: sep     scall               ; select master
 1250 f736: f6 f5                  dw      master
 1251 f738: c3 f7 04               lbdf    sel_err             ; jump on error
 1252 f73b: 8c          ident_go:  glo     rc                  ; save consumed registers
 1253 f73c: 73                     stxd
 1254 f73d: 9c                     ghi     rc
 1255 f73e: 73                     stxd
 1256 f73f: d4                     sep     scall               ; wait for drive to be ready
 1257 f740: fb 9a                  dw      waitrdy
 1258 f742: c3 f7 04               lbdf    sel_err             ; jump on timeout
 1259 f745: e3                     sex     r3                  ; setup for outs
 1260 f746: 62                     out     IDE_SELECT          ; select command port
 1261 f747: 07                     db      7
 1262 f748: 63                     out     IDE_DATA            ; issue get identity command
 1263 f749: ec                     db      0ech
 1264 f74a: e2                     sex     r2                  ; reset stack
 1265 f74b: d4                     sep     scall               ; wait for DRQ
 1266 f74c: fb ed                  dw      drqloop
 1267 f74e: c0 fb 82               lbr     ide_read            ; read drive data
 1268 f751:             
 1269 f751: f8 00       swap:      ldi     0                   ; setup counter
 1270 f753: ac                     plo     rc
 1271 f754: 4f          swap_lp:   lda     rf                  ; get first byte
 1272 f755: ae                     plo     re                  ; keep a copy
 1273 f756: 0f                     ldn     rf                  ; get second byte
 1274 f757: bc                     phi     rc                  ; keep a copy
 1275 f758: 8e                     glo     re                  ; get first byte
 1276 f759: 5f                     str     rf                  ; write into 2nd position
 1277 f75a: 2f                     dec     rf                  ; point back to first byte
 1278 f75b: 9c                     ghi     rc                  ; get 2nd byte
 1279 f75c: 5f                     str     rf                  ; write into first position
 1280 f75d: 1f                     inc     rf                  ; point to next word
 1281 f75e: 1f                     inc     rf
 1282 f75f: 2c                     dec     rc                  ; decrement count
 1283 f760: 8c                     glo     rc                  ; see if done
 1284 f761: ca f7 54               lbnz    swap_lp             ; loop back if not
 1285 f764: d5                     sep     sret                ; otherwise return to caller
 1286 f765:             
 1287 f765:             ; *****************************************
 1288 f765:             ; *** Determine size of hard drive      ***
 1289 f765:             ; *** RD.0 = 0 - master drive           ***
 1290 f765:             ; *** RD.0 = 1 - slave drive            ***
 1291 f765:             ; *** Returns: RF - size of drive in MB ***
 1292 f765:             ; ***               0=no drive          ***
 1293 f765:             ; *****************************************
 1294 f765: 8d          ide_size:  glo     rd                  ; get selected drive
 1295 f766: c2 f7 6f               lbz     sz_master           ; jump if master is selected
 1296 f769: d4                     sep     scall               ; select slave drive
 1297 f76a: f7 07                  dw      slave
 1298 f76c: c0 f7 72               lbr     size_go             ; then continue
 1299 f76f: d4          sz_master: sep     scall               ; select master drive
 1300 f770: f6 f5                  dw      master
 1301 f772: e3          size_go:   sex     r3                  ; setup for immediate out
 1302 f773: 62                     out     IDE_SELECT          ; select status register
 1303 f774: 07                     db      07h
 1304 f775: e2                     sex     r2                  ; reset stack
 1305 f776: f8 00                  ldi     0                   ; setup for failure count
 1306 f778: ac                     plo     rc
 1307 f779: bc                     phi     rc
 1308 f77a: 6b          rdyloopz:  inp     IDE_DATA            ; read status port
 1309 f77b: fa c0                  ani     0c0h                ; mask for BSY and RDY
 1310 f77d: ff 40                  smi     040h                ; want only RDY bit
 1311 f77f: c2 f7 90               lbz     sz_ready            ; jump if drive is ready
 1312 f782: 2c                     dec     rc                  ; decrement timetout
 1313 f783: 8c                     glo     rc                  ; check if timeout occurred
 1314 f784: ca f7 7a               lbnz    rdyloopz            ; jump if not
 1315 f787: 9c                     ghi     rc
 1316 f788: ca f7 7a               lbnz    rdyloopz
 1317 f78b: f8 00                  ldi     0                   ; signify no drive
 1318 f78d: bf                     phi     rf
 1319 f78e: af                     plo     rf
 1320 f78f: d5                     sep     sret                ; and return
 1321 f790: e3          sz_ready:  sex     r3                  ; issued commands to perform an ident
 1322 f791: 62                     out     IDE_SELECT          ; select command register
 1323 f792: 07                     db      07h
 1324 f793: 63                     out     IDE_DATA            ; issue identify command
 1325 f794: ec                     db      0ech
 1326 f795: e2                     sex     r2                  ; pont x back to stack
 1327 f796: d4                     sep     scall               ; wait for DRQ
 1328 f797: fb ed                  dw      drqloop
 1329 f799: e3                     sex     r3                  ; now setup data register
 1330 f79a: 62                     out     IDE_SELECT
 1331 f79b: 00                     db      0
 1332 f79c: e2                     sex     r2                  ; x back to stack
 1333 f79d: f8 78                  ldi     120                 ; need to throw away 120 bytes
 1334 f79f: ac                     plo     rc
 1335 f7a0: 6b          size_lp1:  inp     IDE_DATA            ; read byte from drive
 1336 f7a1: 2c                     dec     rc                  ; decrement count
 1337 f7a2: 8c                     glo     rc                  ; see if done
 1338 f7a3: ca f7 a0               lbnz    size_lp1            ; loop back if not
 1339 f7a6: 6b                     inp     IDE_DATA            ; read 4 bytes into r8:r7
 1340 f7a7: a7                     plo     r7
 1341 f7a8: 6b                     inp     IDE_DATA
 1342 f7a9: b7                     phi     r7
 1343 f7aa: 6b                     inp     IDE_DATA
 1344 f7ab: a8                     plo     r8
 1345 f7ac: 6b                     inp     IDE_DATA
 1346 f7ad: b8                     phi     r8
 1347 f7ae: f8 01                  ldi     1                   ; need to read 388 more bytes
 1348 f7b0: bc                     phi     rc
 1349 f7b1: f8 84                  ldi     132
 1350 f7b3: ac                     plo     rc
 1351 f7b4: 6b          size_lp2:  inp     IDE_DATA            ; read byte
 1352 f7b5: 2c                     dec     rc                  ; decrement count
 1353 f7b6: 8c                     glo     rc                  ; see if done
 1354 f7b7: ca f7 b4               lbnz    size_lp2
 1355 f7ba: 9c                     ghi     rc                  ; check high byte
 1356 f7bb: ca f7 b4               lbnz    size_lp2
 1357 f7be: 97                     ghi     r7                  ; need 11 shift to convert to MB
 1358 f7bf: a7                     plo     r7
 1359 f7c0: 88                     glo     r8
 1360 f7c1: b7                     phi     r7
 1361 f7c2: 98                     ghi     r8
 1362 f7c3: a8                     plo     r8                  ; 8 shift are now done
 1363 f7c4: f8 03                  ldi     3                   ; need 3 more
 1364 f7c6: ac                     plo     rc
 1365 f7c7: 88          size_lp3:  glo     r8                  ; shift whole number right by 1
 1366 f7c8: f6                     shr
 1367 f7c9: a8                     plo     r8
 1368 f7ca: 97                     ghi     r7
 1369 f7cb: 76                     shrc
 1370 f7cc: b7                     phi     r7
 1371 f7cd: 87                     glo     r7
 1372 f7ce: 76                     shrc
 1373 f7cf: a7                     plo     r7
 1374 f7d0: 2c                     dec     rc                  ; decrement count
 1375 f7d1: 8c                     glo     rc                  ; see if done
 1376 f7d2: ca f7 c7               lbnz    size_lp3            ; jump if not
 1377 f7d5: 97                     ghi     r7                  ; transfer result
 1378 f7d6: bf                     phi     rf
 1379 f7d7: 87                     glo     r7
 1380 f7d8: af                     plo     rf
 1381 f7d9: d5                     sep     sret                ; and return
 1382 f7da:             
 1383 f7da:             ; ***********************************
 1384 f7da:             ; *** Check for valid boot loader ***
 1385 f7da:             ; ***********************************
 1386 f7da: f8 01       btcheck:   ldi     1                   ; point to boot code
 1387 f7dc: bf                     phi     rf
 1388 f7dd: f8 00                  ldi     0
 1389 f7df: af                     plo     rf
 1390 f7e0: f8 41                  ldi     041h                ; number of bytes to check
 1391 f7e2: ac                     plo     rc
 1392 f7e3: f8 00                  ldi     0                   ; setup initial value
 1393 f7e5: ad                     plo     rd
 1394 f7e6: ef                     sex     rf                  ; point X to boot code
 1395 f7e7:             btchk_lp:
 1396 f7e7: 8d                     glo     rd                  ; get value
 1397 f7e8: f4                     add                         ; add in next byte
 1398 f7e9: 60                     irx                         ; move pointer
 1399 f7ea: fe                     shl                         ; shift high byte into DF
 1400 f7eb: f6                     shr                         ; move bits back
 1401 f7ec: 7e                     shlc                        ; ring shift now done
 1402 f7ed: ad                     plo     rd                  ; save value
 1403 f7ee: 2c                     dec     rc                  ; decrement byte count
 1404 f7ef: 8c                     glo     rc                  ; see if done
 1405 f7f0: ca f7 e7               lbnz    btchk_lp            ; loop back if not
 1406 f7f3: e2                     sex     r2                  ; point X back to stack
 1407 f7f4: 8d                     glo     rd                  ; get number
 1408 f7f5: ff 60                  smi     060h                ; check against check value
 1409 f7f7: ca f9 e4               lbnz    err                 ; jump on mismatch to error
 1410 f7fa: fc 00                  adi     0                   ; signal good
 1411 f7fc: d5                     sep     sret                ; and return
            #endif  ;; "#ifdef EIDE" ...
 1413 f7fd:             
 1414 f7fd:             
 1415 f7fd:             ; ****************************************************************
 1416 f7fd:             ; * [RLA] Extended BIOS vectors ...                              *
 1417 f7fd:             ; * [RLA]   This is probably obvious, but DON'T CHANGE THE ORDER *
 1418 f7fd:             ; * [RLA] OF THESE VECTORS!!!                                    *
 1419 f7fd:             ; ****************************************************************
 1420 f7fd:                        org     BASE+0800h
 1421 f800: c0 fc 87    f_bread:   lbr     read
 1422 f803: c0 fc 50    f_btype:   lbr     type
 1423 f806: c0 fc cd    f_btest:   lbr     brktest
            #ifdef UART
 1425 f809: c0 f3 c5    f_utype:   lbr     e2k_utype    ; [RLA] type console character via UART
 1426 f80c: c0 f3 ac    f_uread:   lbr     e2k_uread    ; [RLA] read console character via UART
 1427 f80f: c0 f3 a4    f_utest:   lbr     e2k_utest    ; [RLA] test UART for character available
 1428 f812: c0 f3 d9    f_usetbd:  lbr     e2k_stbd     ; [RLA] set UART baud rate and character format
            #endif
            #ifdef NVR
 1436 f815: c0 f4 93    f_gettod:  lbr     e2k_gtod     ; [RLA] get RTC time and date
 1437 f818: c0 f4 e9    f_settod:  lbr     e2k_stod     ; [RLA] set RTC time and date
 1438 f81b: c0 f5 22    f_rdnvr:   lbr     e2k_rdnvr    ; [RLA] read NVR data
 1439 f81e: c0 f5 73    f_wrnvr:   lbr     e2k_wrnvr    ; [RLA] write NVR data
            #endif
            #ifdef EIDE
 1447 f821: c0 f7 65    f_idesize: lbr     ide_size     ; [RLA] return the size of attached IDE drive
 1448 f824: c0 f7 16    f_ideid:   lbr     ide_ident    ; [RLA] return the manufacturer of IDE drive
            #endif
            #ifdef NVR
 1454 f827: c0 f6 17    f_dttoas:  lbr     dttoas       ; [RLA] convert date to ASCII
 1455 f82a: c0 f6 3f    f_tmtoas:  lbr     tmtoas       ; [RLA] convert time to ASCII
 1456 f82d: c0 f4 38    f_rtctest: lbr     rtctest      ; [RLA] test if NVR/RTC present
 1457 f830: c0 f6 5b    f_astodt:  lbr     astodt       ; [RLA] parse ASCII date
 1458 f833: c0 f6 a3    f_astotm:  lbr     astotm       ; [RLA] parse ASCII time
 1459 f836: c0 f5 97    f_nvrcchk: lbr     nvr_chk      ; [RLA] compute NVR checksum
            #endif
 1468 f839:             
 1469 f839:             ; *** rf - pointer to ascii string
 1470 f839:             ; *** returns: rf - first non-numeric character
 1471 f839:             ; ***          RD - number
 1472 f839:             ; ***          DF = 1 if first character non-numeric 
 1473 f839: f8 00       atoi:      ldi     0                   ; clear answer
 1474 f83b: bd                     phi     rd
 1475 f83c: ad                     plo     rd
 1476 f83d: ae                     plo     re                  ; signify positive number
 1477 f83e: 0f                     ldn     rf                  ; get first value
 1478 f83f: d4                     sep     scall               ; check if numeric
 1479 f840: f9 d4                  dw      isnum
 1480 f842: 33 4b                  bdf     atoicnt             ; jump if so
 1481 f844: fb 2d                  xri     '-'                 ; check for minus
 1482 f846: 32 4b                  bz      atoicnt             ; jump if so
 1483 f848: ff 00                  smi     0                   ; signal number error
 1484 f84a: d5                     sep     sret                ; return to caller
 1485 f84b: 0f          atoicnt:   ldn     rf                  ; get first bytr
 1486 f84c: fb 2d                  xri     '-'                 ; check for negative
 1487 f84e: 3a 54                  bnz     atoilp              ; jump if not negative
 1488 f850: f8 01                  ldi     1                   ; signify negative number
 1489 f852: ae                     plo     re
 1490 f853: 1f                     inc     rf                  ; move past - sign
 1491 f854: 0f          atoilp:    ldn     rf                  ; get byte from input
 1492 f855: d4                     sep     scall               ; check for number
 1493 f856: f9 d4                  dw      isnum
 1494 f858: cb f8 7d               lbnf    atoidn              ; jump if not
 1495 f85b: 9d                     ghi     rd                  ; make a copy for add
 1496 f85c: 73                     stxd
 1497 f85d: 8d                     glo     rd                  ; multiply by 2
 1498 f85e: 73                     stxd                        ; TOS now has copy of number
 1499 f85f: d4                     sep     scall               ; multiply by 2
 1500 f860: f8 80                  dw      mul2
 1501 f862: d4                     sep     scall               ; multiply by 4
 1502 f863: f8 80                  dw      mul2
 1503 f865: 60                     irx                         ; point to adds
 1504 f866: 8d                     glo     rd                  ; multiply by 5 (add TOS)
 1505 f867: f4                     add
 1506 f868: ad                     plo     rd
 1507 f869: 60                     irx                         ; point to msb
 1508 f86a: 9d                     ghi     rd
 1509 f86b: 74                     adc
 1510 f86c: bd                     phi     rd
 1511 f86d: d4                     sep     scall               ; multiply by 10
 1512 f86e: f8 80                  dw      mul2
 1513 f870: 4f                     lda     rf                  ; get byte from buffer
 1514 f871: ff 30                  smi     '0'                 ; convert to binary
 1515 f873: 52                     str     r2                  ; prepare for addition
 1516 f874: 8d                     glo     rd                  ; add in new digit
 1517 f875: f4                     add
 1518 f876: ad                     plo     rd
 1519 f877: 9d                     ghi     rd
 1520 f878: 7c 00                  adci    0
 1521 f87a: bd                     phi     rd
 1522 f87b: 30 54                  br      atoilp              ; loop back for next character
 1523 f87d: fc 00       atoidn:    adi     0                   ; signal valid number
 1524 f87f: d5                     sep     sret                ; return to caller
 1525 f880: 8d          mul2:      glo     rd                  ; multiply number by 2
 1526 f881: fe                     shl
 1527 f882: ad                     plo     rd
 1528 f883: 9d                     ghi     rd
 1529 f884: 7e                     shlc
 1530 f885: bd                     phi     rd
 1531 f886: d5                     sep     sret                ; and return
 1532 f887:             
 1533 f887:             ; **** convert binary number to ascii
 1534 f887:             ; **** RD - number to convert
 1535 f887:             ; **** RF - buffer to store
 1536 f887:             ; **** Returns: RF - last postion+1
 1537 f887: 30 9f       uintout:   br      positive
 1538 f889: e2          intout:    sex     r2                  ; point X to stack
 1539 f88a: 9d                     ghi     rd                  ; get high of number
 1540 f88b: fa 80                  ani     128                 ; mask all bit sign bit
 1541 f88d: 32 9f                  bz      positive            ; jump if number is positive
 1542 f88f: f8 2d                  ldi     '-'                 ; need a minus sign
 1543 f891: 5f                     str     rf                  ; store into output
 1544 f892: 1f                     inc     rf
 1545 f893: 8d                     glo     rd                  ; get low byte
 1546 f894: 52                     str     r2                  ; store it
 1547 f895: f8 00                  ldi     0                   ; need to subtract from 0
 1548 f897: f7                     sm
 1549 f898: ad                     plo     rd                  ; put back
 1550 f899: 9d                     ghi     rd                  ; get high byte
 1551 f89a: 52                     str     r2                  ; place into memory
 1552 f89b: f8 00                  ldi     0                   ; still subtracting from zero
 1553 f89d: 77                     smb     
 1554 f89e: bd                     phi     rd                  ; and put back 
 1555 f89f: 87          positive:  glo     r7                  ; save consumed registers
 1556 f8a0: 73                     stxd
 1557 f8a1: 97                     ghi     r7
 1558 f8a2: 73                     stxd
 1559 f8a3: 88                     glo     r8                  ; save consumed registers
 1560 f8a4: 73                     stxd
 1561 f8a5: 98                     ghi     r8
 1562 f8a6: 73                     stxd
 1563 f8a7: 89                     glo     r9                  ; save consumed registers
 1564 f8a8: 73                     stxd
 1565 f8a9: 99                     ghi     r9
 1566 f8aa: 73                     stxd
 1567 f8ab: f8 fe                  ldi     high numbers        ; point to numbers
 1568 f8ad: b9                     phi     r9
 1569 f8ae: f8 e7                  ldi     low numbers
 1570 f8b0: a9                     plo     r9
 1571 f8b1: 49                     lda     r9                  ; get first division
 1572 f8b2: b7                     phi     r7
 1573 f8b3: 49                     lda     r9
 1574 f8b4: a7                     plo     r7
 1575 f8b5: f8 00                  ldi     0                   ; leading zero flag
 1576 f8b7: 73                     stxd                        ; store onto stack
 1577 f8b8: f8 00       nxtiter:   ldi     0                   ; star count at zero
 1578 f8ba: a8                     plo     r8                  ; place into low of r8
 1579 f8bb: 87          divlp:     glo     r7                  ; get low of number to subtrace
 1580 f8bc: 52                     str     r2                  ; place into memory
 1581 f8bd: 8d                     glo     rd                  ; get low of number
 1582 f8be: f7                     sm                          ; subtract
 1583 f8bf: b8                     phi     r8                  ; place into temp space
 1584 f8c0: 97                     ghi     r7                  ; get high of subtraction
 1585 f8c1: 52                     str     r2                  ; place into memory
 1586 f8c2: 9d                     ghi     rd                  ; get high of number
 1587 f8c3: 77                     smb                         ; perform subtract
 1588 f8c4: 3b cc                  bnf     nomore              ; jump if subtraction was too large
 1589 f8c6: bd                     phi     rd                  ; store result
 1590 f8c7: 98                     ghi     r8
 1591 f8c8: ad                     plo     rd
 1592 f8c9: 18                     inc     r8                  ; increment count
 1593 f8ca: 30 bb                  br      divlp               ; and loop back
 1594 f8cc: 60          nomore:    irx                         ; point back to leading zero flag
 1595 f8cd: 88                     glo     r8
 1596 f8ce: 3a d8                  bnz     nonzero             ; jump if not zero
 1597 f8d0: 02                     ldn     r2                  ; get flag
 1598 f8d1: 3a d6                  bnz     allow0              ; jump if no longer zero
 1599 f8d3: 22                     dec     r2                  ; keep leading zero flag
 1600 f8d4: 30 df                  br      findnxt             ; skip output
 1601 f8d6: f8 00       allow0:    ldi     0                   ; recover the zero
 1602 f8d8: fc 30       nonzero:   adi     30h                 ; convert to ascii
 1603 f8da: 5f                     str     rf                  ; store into buffer
 1604 f8db: 1f                     inc     rf
 1605 f8dc: f8 01                  ldi     1                   ; need to set leading flag
 1606 f8de: 73                     stxd                        ; store it
 1607 f8df: 27          findnxt:   dec     r7                  ; subtract 1 for zero check
 1608 f8e0: 87                     glo     r7                  ; check for end
 1609 f8e1: 32 f1                  bz      intdone             ; jump if done
 1610 f8e3: 49                     lda     r9                  ; get next number
 1611 f8e4: b7                     phi     r7
 1612 f8e5: 49                     lda     r9
 1613 f8e6: a7                     plo     r7
 1614 f8e7: ff 01                  smi     1                   ; see if at last number
 1615 f8e9: 3a b8                  bnz     nxtiter             ; jump if not 
 1616 f8eb: 60                     irx                         ; set leading flag
 1617 f8ec: f8 01                  ldi     1
 1618 f8ee: 73                     stxd
 1619 f8ef: 30 b8                  br      nxtiter
 1620 f8f1: 60          intdone:   irx                         ; put x back where it belongs
 1621 f8f2: 60                     irx                         ; recover consumed registers
 1622 f8f3: 72                     ldxa
 1623 f8f4: b9                     phi     r9
 1624 f8f5: 72                     ldxa
 1625 f8f6: a9                     plo     r9
 1626 f8f7: 72                     ldxa
 1627 f8f8: b8                     phi     r8
 1628 f8f9: 72                     ldxa
 1629 f8fa: a8                     plo     r8
 1630 f8fb: 72                     ldxa
 1631 f8fc: b7                     phi     r7
 1632 f8fd: f0                     ldx
 1633 f8fe: a7                     plo     r7
 1634 f8ff: d5                     sep     sret                ; return to caller
 1635 f900:             
 1636 f900:             
 1637 f900:             
 1638 f900:                        org     BASE+0900h
            #else
 1642 f900:             buffer:    equ     03
            #endif
 1644 f900: f8 f9       minimon:   ldi     high start          ; setup main pc
 1645 f902: b6                     phi     r6
 1646 f903: f8 10                  ldi     low start
 1647 f905: a6                     plo     r6
            #else
 1654 f906: f8 00                  ldi     0                   ; setup stack
 1655 f908: b2                     phi     r2
 1656 f909: f8 ff                  ldi     0ffh
 1657 f90b: a2                     plo     r2
            #endif
 1659 f90c: e2                     sex     r2
 1660 f90d: c0 ff 3f               lbr     f_initcall
 1661 f910: d4          start:     sep     scall               ; initialize baud setting
 1662 f911: ff 2d                  dw      f_setbd
 1663 f913:             
 1664 f913: f8 f9       mainlp:    ldi     high prompt         ; get address of prompt
 1665 f915: bf                     phi     rf
 1666 f916: f8 c6                  ldi     low prompt
 1667 f918: af                     plo     rf
 1668 f919: d4                     sep     scall               ; display prompt
 1669 f91a: ff 09                  dw      f_msg
 1670 f91c: d4                     sep     scall
 1671 f91d: f9 b5                  dw      loadbuf
 1672 f91f: d4                     sep     scall               ; get input from user
 1673 f920: ff 0f                  dw      f_input
 1674 f922: d4                     sep     scall
 1675 f923: f9 bc                  dw      docrlf
 1676 f925: d4                     sep     scall
 1677 f926: f9 b5                  dw      loadbuf
 1678 f928: 4f                     lda     rf                  ; get first byte
 1679 f929: bc                     phi     rc                  ; save it
 1680 f92a: d4                     sep     scall               ; obtain address
 1681 f92b: ff 45                  dw      f_hexin
 1682 f92d: 9d                     ghi     rd                  ; move to address var
 1683 f92e: ba                     phi     ra
 1684 f92f: 8d                     glo     rd
 1685 f930: aa                     plo     ra
 1686 f931:             
 1687 f931: 9c                     ghi     rc                  ; retrieve command
 1688 f932: ff 21                  smi     33
 1689 f934: 32 7b                  bz      storesp
 1690 f936: ff 1c                  smi     28                  ; look for copy command
 1691 f938: 32 8d                  bz      copy                ; jump if found
 1692 f93a: ff 02                  smi     2
 1693 f93c: 32 48                  bz      examine
 1694 f93e: ff 01                  smi     1
 1695 f940: 3a 13                  bnz     mainlp
 1696 f942: 9a          run:       ghi     ra                  ; move to address var
 1697 f943: b0                     phi     r0
 1698 f944: 8a                     glo     ra
 1699 f945: a0                     plo     r0
 1700 f946: e0                     sex     r0
 1701 f947: d0                     sep     r0
 1702 f948:                        
 1703 f948: f8 08       examine:   ldi     8                   ; set count to 128 bytes
 1704 f94a: ac                     plo     rc
 1705 f94b: 9a          exloop1:   ghi     ra                  ; get address
 1706 f94c: bd                     phi     rd                  ; transfer for output
 1707 f94d: 8a                     glo     ra
 1708 f94e: ad                     plo     rd
 1709 f94f: d4                     sep     scall
 1710 f950: f9 b5                  dw      loadbuf
 1711 f952: d4                     sep     scall               ; put address into output
 1712 f953: ff 4b                  dw      f_hexout4
 1713 f955: f8 3a                  ldi     ':'                 ; want a colon
 1714 f957: 5f                     str     rf
 1715 f958: 1f                     inc     rf
 1716 f959: f8 10                  ldi     16                  ; 16 bytes per line
 1717 f95b: ab                     plo     rb                  ; put into secondary counter
 1718 f95c: f8 20       exloop2:   ldi     ' '                 ; output a space
 1719 f95e: 5f                     str     rf
 1720 f95f: 1f                     inc     rf
 1721 f960: 4a                     lda     ra                  ; get next byte from memory
 1722 f961: ad                     plo     rd                  ; prepare for output
 1723 f962: d4                     sep     scall               ; convert for output
 1724 f963: ff 48                  dw      f_hexout2
 1725 f965: 2b                     dec     rb                  ; decrment line count
 1726 f966: 8b                     glo     rb                  ; get count
 1727 f967: 3a 5c                  bnz     exloop2             ; loop back if not done
 1728 f969: f8 00                  ldi     0                   ; need terminator
 1729 f96b: 5f                     str     rf
 1730 f96c: d4                     sep     scall
 1731 f96d: f9 b5                  dw      loadbuf
 1732 f96f: d4                     sep     scall               ; output the line
 1733 f970: ff 09                  dw      f_msg
 1734 f972: d4                     sep     scall
 1735 f973: f9 bc                  dw      docrlf
 1736 f975: 2c                     dec     rc                  ; decrement line count
 1737 f976: 8c                     glo     rc                  ; get count
 1738 f977: 3a 4b                  bnz     exloop1             ; loop back if not all lines printed
 1739 f979: 30 13                  br      mainlp              ; return to main loop
 1740 f97b:             
 1741 f97b: 0f          storesp:   ldn     rf                  ; get byte from input
 1742 f97c: 32 13                  bz      mainlp              ; jump if found
 1743 f97e: ff 21                  smi     33                  ; check for less than space
 1744 f980: 33 85                  bdf     storec              ; jump if not space
 1745 f982: 1f                     inc     rf                  ; point to next character
 1746 f983: 30 7b                  br      storesp             ; and keep moving past spaces
 1747 f985: d4          storec:    sep     scall               ; convert next number
 1748 f986: ff 45                  dw      f_hexin
 1749 f988: 8d                     glo     rd                  ; get converted byt
 1750 f989: 5a                     str     ra                  ; store into memory
 1751 f98a: 1a                     inc     ra                  ; point to next position
 1752 f98b: 30 7b                  br      storesp             ; and do next character
 1753 f98d:             
 1754 f98d: 9a          copy:      ghi     ra                  ; move source
 1755 f98e: b8                     phi     r8
 1756 f98f: 8a                     glo     ra
 1757 f990: a8                     plo     r8
 1758 f991: d4                     sep     scall               ; move past spaces
 1759 f992: ff 15                  dw      f_ltrim
 1760 f994: d4                     sep     scall               ; get destination address
 1761 f995: ff 45                  dw      f_hexin
 1762 f997: 9d                     ghi     rd                  ; transfer to r9
 1763 f998: b9                     phi     r9
 1764 f999: 8d                     glo     rd
 1765 f99a: a9                     plo     r9
 1766 f99b: d4                     sep     scall               ; move past spaces
 1767 f99c: ff 15                  dw      f_ltrim
 1768 f99e: d4                     sep     scall               ; get source address
 1769 f99f: ff 45                  dw      f_hexin
 1770 f9a1: 9d                     ghi     rd                  ; transfer to rc
 1771 f9a2: bc                     phi     rc
 1772 f9a3: 8d                     glo     rd
 1773 f9a4: ac                     plo     rc
 1774 f9a5: 9c          movelp:    ghi     rc                  ; check for zero
 1775 f9a6: 3a ad                  bnz     domove
 1776 f9a8: 8c                     glo     rc
 1777 f9a9: 3a ad                  bnz     domove
 1778 f9ab: 30 b3                  br      done
 1779 f9ad: 48          domove:    lda     r8
 1780 f9ae: 59                     str     r9
 1781 f9af: 19                     inc     r9
 1782 f9b0: 2c                     dec     rc
 1783 f9b1: 30 a5                  br      movelp
 1784 f9b3: 30 13       done:      br      mainlp
 1785 f9b5:             
 1786 f9b5: f8 00       loadbuf:   ldi     high buffer
 1787 f9b7: bf                     phi     rf
 1788 f9b8: f8 03                  ldi     low buffer
 1789 f9ba: af                     plo     rf
 1790 f9bb: d5                     sep     sret
 1791 f9bc:             
 1792 f9bc: f8 f9       docrlf:    ldi     high crlf
 1793 f9be: bf                     phi     rf
 1794 f9bf: f8 c8                  ldi     low crlf
 1795 f9c1: af                     plo     rf
 1796 f9c2: d4                     sep     scall
 1797 f9c3: ff 09                  dw      f_msg
 1798 f9c5: d5                     sep     sret
 1799 f9c6:             
 1800 f9c6: 3e 00       prompt:    db      '>',0
 1801 f9c8: 0a 0d 00    crlf:      db      10,13,0
 1802 f9cb:             
 1803 f9cb:             ; ***************************************
 1804 f9cb:             ; *** Type inline message             ***
 1805 f9cb:             ; ***************************************
 1806 f9cb: 46          typeinmsg: lda     r6                  ; load byte from message
 1807 f9cc: c2 fe 4d               lbz     return              ; return if last byte
 1808 f9cf: d4                     sep     scall               ; call type routine
 1809 f9d0: ff 4e                  dw      f_tty
 1810 f9d2: 30 cb                  br      typeinmsg           ; loop until a zero found
 1811 f9d4:             
 1812 f9d4:             ; *************************************
 1813 f9d4:             ; *** Check if character is numeric ***
 1814 f9d4:             ; *** D - char to check             ***
 1815 f9d4:             ; *** Returns DF=1 if numeric       ***
 1816 f9d4:             ; ***         DF=0 if not           ***
 1817 f9d4:             ; *************************************
 1818 f9d4: ae          isnum:     plo     re                  ; save a copy
 1819 f9d5: ff 30                  smi     '0'                 ; check for below zero
 1820 f9d7: 3b e0                  bnf     fails               ; jump if below
 1821 f9d9: ff 0a                  smi     10                  ; see if above
 1822 f9db: 33 e0                  bdf     fails               ; fails if so
 1823 f9dd: ff 00       passes:    smi     0                   ; signal success
 1824 f9df: c8                     lskp
 1825 f9e0: fc 00       fails:     adi     0                   ; signal failure
 1826 f9e2: 8e                     glo     re                  ; recover character
 1827 f9e3: d5                     sep     sret                ; and return
 1828 f9e4:             
 1829 f9e4: ff 00       err:       smi     0                   ; signal an error
 1830 f9e6: d5                     sep     sret                ; and return
 1831 f9e7:             
 1832 f9e7:                        org     BASE+0a00h
 1833 fa00:             ; ***************************************************************
 1834 fa00:             ; *** Function to convert hex input characters to binary      ***
 1835 fa00:             ; *** RF - Pointer to characters                              ***
 1836 fa00:             ; *** Returns - RF - First character that is not alphanumeric ***
 1837 fa00:             ; ***           RD - Converted number                         ***
 1838 fa00:             ; ***************************************************************
 1839 fa00: f8 00       hexin:     ldi     0                   ; set initial total
 1840 fa02: bd                     phi     rd
 1841 fa03: ad                     plo     rd
 1842 fa04: 4f          tobinlp:   lda     rf                  ; get input character
 1843 fa05: ff 30                  smi     '0'                 ; convert to binary
 1844 fa07: 3b 45                  bnf     tobindn             ; jump if termination
 1845 fa09: 73                     stxd
 1846 fa0a: fa f0                  ani     0f0h                ; check for alpha
 1847 fa0c: 60                     irx                         ; point back
 1848 fa0d: 32 1e                  bz      isnumeric
 1849 fa0f: f0                     ldx                         ; recover byte
 1850 fa10: ff 31                  smi     49                  ; see if lowercase
 1851 fa12: 3b 19                  bnf     hexgo
 1852 fa14: f0                     ldx                         ; get byte
 1853 fa15: ff 20                  smi     32                  ; convert to uppercase
 1854 fa17: 30 1a                  br      hexgo2              ; and continue
 1855 fa19: f0          hexgo:     ldx                         ; recover byte
 1856 fa1a: ff 07       hexgo2:    smi     7                   ; offset
 1857 fa1c: 30 24                  br      tobingo             ; and continue
 1858 fa1e: f0          isnumeric: ldx                         ; recover byte
 1859 fa1f: ff 0a                  smi     10                  ; check for end of numbers
 1860 fa21: 33 45                  bdf     tobindn             ; jump if end
 1861 fa23: f0                     ldx                         ; recover byte
 1862 fa24: 73          tobingo:   stxd                        ; save number
 1863 fa25: ff 10                  smi     16                  ; check for valid range
 1864 fa27: 3b 2c                  bnf     tobingd             ; jump if good
 1865 fa29: 60                     irx                         ; remove number from stack
 1866 fa2a: 30 45                  br      tobindn
 1867 fa2c: f8 04       tobingd:   ldi     4                   ; need to multiply by 16
 1868 fa2e: 73          tobinglp:  stxd
 1869 fa2f: 8d                     glo     rd                  ; multiply by 2
 1870 fa30: fe                     shl
 1871 fa31: ad                     plo     rd
 1872 fa32: 9d                     ghi     rd
 1873 fa33: 7e                     shlc
 1874 fa34: bd                     phi     rd
 1875 fa35: 60                     irx
 1876 fa36: f8 01                  ldi     1
 1877 fa38: f5                     sd
 1878 fa39: 3a 2e                  bnz     tobinglp
 1879 fa3b: 60                     irx                         ; point to new number
 1880 fa3c: 8d                     glo     rd                  ; and add to total
 1881 fa3d: f4                     add
 1882 fa3e: ad                     plo     rd
 1883 fa3f: 9d                     ghi     rd
 1884 fa40: 7c 00                  adci    0
 1885 fa42: bd                     phi     rd
 1886 fa43: 30 04                  br      tobinlp             ; loop back for next character
 1887 fa45: 2f          tobindn:   dec     rf                  ; move back to terminating character
 1888 fa46: d5                     sep     sret                ; return to caller
 1889 fa47:             
 1890 fa47:             ; *********************************************
 1891 fa47:             ; *** Convert a binary number to hex output ***
 1892 fa47:             ; *** RD - Number to convert                ***
 1893 fa47:             ; *** RF - Buffer for output                ***
 1894 fa47:             ; *** Returns: RF - next buffer position    ***
 1895 fa47:             ; ***          RD - consumed                ***
 1896 fa47:             ; *********************************************
 1897 fa47: 8d          hexout2:   glo     rd                  ; move low byte to high
 1898 fa48: bd                     phi     rd
 1899 fa49: f8 02                  ldi     2                   ; 2 nybbles to display
 1900 fa4b: c8                     lskp                        ; skip over the 4
 1901 fa4c: f8 04       hexout4:   ldi     4                   ; 4 nybbles to display
 1902 fa4e: 73          hexoutlp:  stxd                        ; save the count
 1903 fa4f: f8 00                  ldi     0                   ; zero the temp var
 1904 fa51: ae                     plo     re
 1905 fa52: f8 04                  ldi     4                   ; perform 4 shift
 1906 fa54: 73          hexoutl2:  stxd                        ; save count
 1907 fa55: 8d                     glo     rd                  ; perform shift
 1908 fa56: fe                     shl
 1909 fa57: ad                     plo     rd
 1910 fa58: 9d                     ghi     rd
 1911 fa59: 7e                     shlc
 1912 fa5a: bd                     phi     rd
 1913 fa5b: 8e                     glo     re
 1914 fa5c: 7e                     shlc
 1915 fa5d: ae                     plo     re
 1916 fa5e: 60                     irx                         ; point back to count
 1917 fa5f: f8 01                  ldi     1                   ; need to decrement it
 1918 fa61: f5                     sd
 1919 fa62: 3a 54                  bnz     hexoutl2            ; jump if more shifts needed
 1920 fa64: 8e                     glo     re                  ; get nybble
 1921 fa65: ff 0a                  smi     10                  ; compare to 10
 1922 fa67: 33 75                  bdf     hexoutal            ; jump if alpha
 1923 fa69: 8e                     glo     re                  ; get value
 1924 fa6a: fc 30                  adi     30h                 ; convert to ascii
 1925 fa6c: 5f          hexoutl3:  str     rf                  ; store value into buffer
 1926 fa6d: 1f                     inc     rf
 1927 fa6e: 60                     irx                         ; point to count
 1928 fa6f: f8 01                  ldi     1                   ; need to subtract 1 from it
 1929 fa71: f5                     sd
 1930 fa72: 3a 4e                  bnz     hexoutlp            ; loop if not done
 1931 fa74: d5                     sep     sret                ; return to caller
 1932 fa75: 8e          hexoutal:  glo     re                  ; get value
 1933 fa76: fc 37                  adi     55                  ; convert to ascii
 1934 fa78: 30 6c                  br      hexoutl3            ; and continue
 1935 fa7a:             
 1936 fa7a:             
 1937 fa7a: d3                   sep     r3                    ; jump to called routine
 1938 fa7b: ae          call:    plo     re                    ; Save D
 1939 fa7c: 96                   ghi     r6                    ; save last R[6] to stack
 1940 fa7d: e2                   sex     r2
 1941 fa7e: 73                   stxd
 1942 fa7f: 86                   glo     r6
 1943 fa80: 73                   stxd
 1944 fa81: 93                   ghi     r3                    ; copy R[3] to R[6]
 1945 fa82: b6                   phi     r6
 1946 fa83: 83                   glo     r3
 1947 fa84: a6                   plo     r6
 1948 fa85: 46                   lda     r6                    ; get subroutine address
 1949 fa86: b3                   phi     r3                    ; and put into r3
 1950 fa87: 46                   lda     r6
 1951 fa88: a3                   plo     r3
 1952 fa89: 8e                   glo     re                    ; recover D
 1953 fa8a: 30 7a                br      call-1                ; transfer control to subroutine
 1954 fa8c:             
 1955 fa8c: d3                   sep     r3                    ; transfer control back to coller
 1956 fa8d: ae          ret:     plo     re                    ; Save D
 1957 fa8e: 96                   ghi     r6                    ; copy R[6] to R[3]
 1958 fa8f: b3                   phi     r3
 1959 fa90: 86                   glo     r6
 1960 fa91: a3                   plo     r3
 1961 fa92: e2                   sex     r2
 1962 fa93: 60                   irx                           ; point to old R[6]
 1963 fa94: 72                   ldxa
 1964 fa95: a6                   plo     r6
 1965 fa96: f0                   ldx
 1966 fa97: b6                   phi     r6
 1967 fa98: 8e                   glo     re
 1968 fa99: 30 8c                br      ret-1                 ; and perform return to caller
 1969 fa9b:             
 1970 fa9b:             ; ********************************
 1971 fa9b:             ; *** See if D is alphabetic   ***
 1972 fa9b:             ; *** Returns DF=0 - not alpha ***
 1973 fa9b:             ; ***         DF=1 - is alpha  ***
 1974 fa9b:             ; ********************************
 1975 fa9b: ae          isalpha:   plo     re                  ; save copy of do
 1976 fa9c: ff 41                  smi     'A'                 ; check uc letters
 1977 fa9e: cb f9 e0               lbnf    fails               ; jump if below A
 1978 faa1: ff 1b                  smi     27                  ; check upper range
 1979 faa3: cb f9 dd               lbnf    passes              ; jump if valid
 1980 faa6: 8e                     glo     re                  ; recover character
 1981 faa7: ff 61                  smi     'a'                 ; check lc letters
 1982 faa9: cb f9 e0               lbnf    fails               ; jump if below A
 1983 faac: ff 1b                  smi     27                  ; check upper range
 1984 faae: cb f9 dd               lbnf    passes              ; jump if valid
 1985 fab1: c0 f9 e0               lbr     fails
 1986 fab4:             
 1987 fab4:             ; **********************************
 1988 fab4:             ; *** check D if hex             ***
 1989 fab4:             ; *** Returns DF=1 - hex         ***
 1990 fab4:             ; ***         DF=0 - non-hex     ***
 1991 fab4:             ; **********************************
 1992 fab4: d4          ishex:     sep     scall               ; see if it is numeric
 1993 fab5: f9 d4                  dw      isnum
 1994 fab7: ae                     plo     re                  ; keep a copy
 1995 fab8: c3 f9 dd               lbdf    passes              ; jump if it is numeric
 1996 fabb: ff 41                  smi     'A'                 ; check for below uppercase a
 1997 fabd: cb f9 e0               lbnf    fails               ; value is not hex
 1998 fac0: ff 06                  smi     6                   ; check for less then 'G'
 1999 fac2: cb f9 dd               lbnf    passes              ; jump if so
 2000 fac5: 8e                     glo     re                  ; recover value
 2001 fac6: ff 61                  smi     'a'                 ; check for lowercase a
 2002 fac8: cb f9 e0               lbnf    fails               ; jump if not
 2003 facb: ff 06                  smi     6                   ; check for less than 'g'
 2004 facd: cb f9 dd               lbnf    passes              ; jump if so
 2005 fad0: c0 f9 e0               lbr     fails
 2006 fad3:             
 2007 fad3:             ;
 2008 fad3:             ; MOVER.ASM - Function Move Programs Into Low memory
 2009 fad3:             ; For Execution.
 2010 fad3:             ;
 2011 fad3:             ; Normal Entry PC = 3, RF = Program Header
 2012 fad3:             ;
 2013 fad3:             ; Exit: Starts Program at specified address
 2014 fad3:             ; With P=0,X=0,IE=1
 2015 fad3:             ;
 2016 fad3:             ; This module written by Richard Peters
 2017 fad3:             ;*********************************************************
 2018 fad3:             ; HEADER DEFINITION ANY ADDRESS
 2019 fad3:             ; OFFSET
 2020 fad3:             ;  00   = Program RAM Start Address
 2021 fad3:             ; +02   = Program RAM End Address
 2022 fad3:             ; +04   = Program Execution Address
 2023 fad3:             ; +06   = Accual PROGRAM Bytes
 2024 fad3:             ;*********************************************************
 2025 fad3:                        org     BASE+0adah
 2026 fada: e0          mover:     sex     r0
 2027 fadb: 4f                     lda     rf
 2028 fadc: b0                     phi     r0
 2029 fadd: 4f                     lda     rf
 2030 fade: a0                     plo     r0
 2031 fadf: 4f                     lda     rf
 2032 fae0: b1                     phi     r1
 2033 fae1: 4f                     lda     rf
 2034 fae2: a1                     plo     r1
 2035 fae3: 11                     inc     r1
 2036 fae4: 4f                     lda     rf
 2037 fae5: ba                     phi     ra
 2038 fae6: 4f                     lda     rf
 2039 fae7: aa                     plo     ra
 2040 fae8: 4f          moverlp:   lda     rf
 2041 fae9: 50                     str     r0
 2042 faea: 10                     inc     r0
 2043 faeb: 81                     glo     r1
 2044 faec: 50                     str     r0
 2045 faed: 80                     glo     r0
 2046 faee: f5                     sd
 2047 faef: 3a e8                  bnz     moverlp
 2048 faf1: 91                     ghi     r1
 2049 faf2: 50                     str     r0
 2050 faf3: 90                     ghi     r0
 2051 faf4: f5                     sd
 2052 faf5: 3a e8                  bnz     moverlp
 2053 faf7: f8 03                  ldi     3
 2054 faf9: 50                     str     r0
 2055 fafa: 70                     ret
 2056 fafb: 9a                     ghi     ra
 2057 fafc: b0                     phi     r0
 2058 fafd: 8a                     glo     ra
 2059 fafe: a0                     plo     r0
 2060 faff: d0                     sep     r0
 2061 fb00:             
 2062 fb00:                        org     BASE+0b00h
 2063 fb00: d4          resetide:  sep     scall               ; wait til drive ready
 2064 fb01: fb 9a                  dw      waitrdy
 2065 fb03: 33 30                  bdf     ide_err             ; jump if timout
 2066 fb05: 8d                     glo     rd                  ; get selected drive
 2067 fb06: f6                     shr                         ; shift over 4 bits
 2068 fb07: f6                     shr
 2069 fb08: f6                     shr
 2070 fb09: f6                     shr
 2071 fb0a: 73                     stxd                        ; write drive select to stack
 2072 fb0b: f8 06                  ldi     6                   ; select device register
 2073 fb0d: 52                     str     r2                  ; write to stack
 2074 fb0e: 62                     out     IDE_SELECT          ; write select port
 2075 fb0f: 63                     out     IDE_DATA            ; write device code
 2076 fb10: 22                     dec     r2                  ; point back
 2077 fb11: e3                     sex     r3                  ; setup for immediate outs
 2078 fb12:             
 2079 fb12: 62                     out     IDE_SELECT          ; select interrupt port
 2080 fb13: 0e                     db      00eh
 2081 fb14: 63                     out     IDE_DATA            ; function to perform soft reset
 2082 fb15: 04                     db      4
 2083 fb16: 63                     out     IDE_DATA            ; and clear it
 2084 fb17: 00                     db      0
 2085 fb18: e2                     sex     r2                  ; reset x to stack
 2086 fb19: d4                     sep     scall               ; wait til drive ready
 2087 fb1a: fb 9a                  dw      waitrdy
 2088 fb1c: 33 30                  bdf     ide_err             ; jump if timout
 2089 fb1e: e3                     sex     r3                  ; setup for immediate outs
 2090 fb1f: 62                     out     IDE_SELECT          ; select feature register
 2091 fb20: 01                     db      1
 2092 fb21: 63                     out     IDE_DATA            ; enable 8 bit mode
 2093 fb22: 01                     db      1
 2094 fb23: 62                     out     IDE_SELECT          ; select command register
 2095 fb24: 07                     db      7
 2096 fb25: 63                     out     IDE_DATA            ; command to set features
 2097 fb26: ef                     db      0efh
 2098 fb27:             
 2099 fb27:             
 2100 fb27: e2                     sex     r2                  ; point X back to stack
 2101 fb28: d4                     sep     scall               ; wait til drive ready
 2102 fb29: fb 9a                  dw      waitrdy
 2103 fb2b: 33 30                  bdf     ide_err             ; jump if timout
 2104 fb2d: fc 00       ide_good:  adi     0                   ; signal no error
 2105 fb2f: d5                     sep     sret                ; return to caller
 2106 fb30: ff 00       ide_err:   smi     0                   ; signal error occurred
 2107 fb32: d5                     sep     sret
 2108 fb33:                        
 2109 fb33: 8c          wrtide:    glo     rc                  ; save consumed registers
 2110 fb34: 73                     stxd
 2111 fb35: 9c                     ghi     rc
 2112 fb36: 73                     stxd
 2113 fb37: d4                     sep     scall               ; call wait til ready
 2114 fb38: fb 9a                  dw      waitrdy
 2115 fb3a: 33 69                  bdf     ide_fail            ; jump on timeout error
 2116 fb3c: f8 30                  ldi     030h                ; command for sector write
 2117 fb3e: d4                     sep     scall               ; now setup command
 2118 fb3f: fb c1                  dw      wrtcmd
 2119 fb41: 33 69                  bdf     ide_fail            ; jump if error occurred
 2120 fb43: f8 02                  ldi     2                   ; high byte of 512
 2121 fb45: bc                     phi     rc                  ; place into count
 2122 fb46: f8 00                  ldi     0                   ; low byte of 512
 2123 fb48: ac                     plo     rc                  ; place into low of count
 2124 fb49: f8 00                  ldi     0                   ; need data register
 2125 fb4b: 52                     str     r2                  ; place on stack
 2126 fb4c: 62                     out     IDE_SELECT          ; select data register
 2127 fb4d: 22                     dec     r2                  ; move pointer
 2128 fb4e: ef                     sex     rf                  ; set data pointer
 2129 fb4f: 63          wrtloop:   out     IDE_DATA            ; write to ide controller
 2130 fb50: 2c                     dec     rc                  ; decrement byte count
 2131 fb51: 8c                     glo     rc                  ; check for completion
 2132 fb52: 3a 4f                  bnz     wrtloop             ; jump if not
 2133 fb54: 9c                     ghi     rc                  ; need to check high byte
 2134 fb55: 3a 4f                  bnz     wrtloop             ; jump if more to go
 2135 fb57: e2                     sex     r2                  ; point x to stack
 2136 fb58: d4                     sep     scall               ; call wait til ready
 2137 fb59: fb 9a                  dw      waitrdy
 2138 fb5b: 33 69                  bdf     ide_fail            ; jump if error occurred
 2139 fb5d: fc 00                  adi     0                   ; signal no error
 2140 fb5f: f8 00                  ldi     0                   ; no errors in D
 2141 fb61: ae          ideret:    plo     re
 2142 fb62: 60                     irx                         ; recover consumed registers
 2143 fb63: 72                     ldxa
 2144 fb64: bc                     phi     rc
 2145 fb65: f0                     ldx
 2146 fb66: ac                     plo     rc
 2147 fb67: 8e                     glo     re
 2148 fb68: d5                     sep     sret                ; and return to caller
 2149 fb69: e3          ide_fail:  sex     r3                  ; setup for immediate out
 2150 fb6a: 62                     out     IDE_SELECT          ; select error register
 2151 fb6b: 01                     db      1
 2152 fb6c: e2                     sex     r2                  ; point X back to stack
 2153 fb6d: 6b                     inp     IDE_DATA            ; read error register
 2154 fb6e: ff 00                  smi     0                   ; signal an error
 2155 fb70: 30 61                  br      ideret              ; and return
 2156 fb72:             
 2157 fb72: 8c          rdide:     glo     rc                  ; save consumed registers
 2158 fb73: 73                     stxd
 2159 fb74: 9c                     ghi     rc
 2160 fb75: 73                     stxd
 2161 fb76: d4                     sep     scall               ; call wait til ready 
 2162 fb77: fb 9a                  dw      waitrdy
 2163 fb79: 33 69                  bdf     ide_fail            ; jump on timeout error
 2164 fb7b: f8 20                  ldi     020h                ; command for sector read
 2165 fb7d: d4                     sep     scall               ; now setup command
 2166 fb7e: fb c1                  dw      wrtcmd
 2167 fb80: 33 69                  bdf     ide_fail            ; jump if error occurred
 2168 fb82: f8 02       ide_read:  ldi     2                   ; high byte of 512
 2169 fb84: bc                     phi     rc                  ; place into count
 2170 fb85: f8 00                  ldi     0                   ; lo byte of 512
 2171 fb87: ac                     plo     rc                  ; place into low of count
 2172 fb88: 52                     str     r2                  ; place on stack
 2173 fb89: 62                     out     IDE_SELECT          ; select data register
 2174 fb8a: 22                     dec     r2                  ; move pointer
 2175 fb8b: ef                     sex     rf                  ; set data pointer
 2176 fb8c: 6b          rdloop:    inp     IDE_DATA            ; read from ide controller
 2177 fb8d: 1f                     inc     rf                  ; point to next position
 2178 fb8e: 2c                     dec     rc                  ; decrement byte count
 2179 fb8f: 8c                     glo     rc                  ; check for completion
 2180 fb90: 3a 8c                  bnz     rdloop              ; jump if not
 2181 fb92: 9c                     ghi     rc                  ; need to check high byte
 2182 fb93: 3a 8c                  bnz     rdloop              ; jump if more to go
 2183 fb95: f8 00                  ldi     0                   ; signify read complete
 2184 fb97: e2                     sex     r2
 2185 fb98: 30 61                  br      ideret              ; return to caller
 2186 fb9a:                       
 2187 fb9a: f8 07       waitrdy:   ldi     07h                 ; need status register
 2188 fb9c: 52                     str     r2                  ; store onto stack
 2189 fb9d: 62                     out     IDE_SELECT          ; write ide selection port
 2190 fb9e: 22                     dec     r2                  ; point x back to free spot
 2191 fb9f:             ;[RLA]   Note that the whole rdyloop thing takes about 24 machine cycles or 192
 2192 fb9f:             ;[RLA] clocks. The timeout here is 65,536 iterations which, at 2MHz, is about
 2193 fb9f:             ;[RLA] 6 seconds...
 2194 fb9f: f8 00                  ldi     0                   ; setup timeout
 2195 fba1: ac                     plo     rc
 2196 fba2: bc                     phi     rc
 2197 fba3: 2c          rdyloop:   dec     rc                  ; decrement timeout
 2198 fba4: 8c                     glo     rc                  ; check for end
 2199 fba5: 3a b2                  bnz     rdy_go
 2200 fba7: 9c                     ghi     rc
 2201 fba8: 3a b2                  bnz     rdy_go
 2202 fbaa: e3          ideerror:  sex     r3                  ; setup for immediate out
 2203 fbab: 62                     out     IDE_SELECT          ; seelct error register
 2204 fbac: 01                     db      1
 2205 fbad: e2                     sex     r2                  ; set X back to stack
 2206 fbae: 6b                     inp     IDE_DATA            ; read error register into D
 2207 fbaf: ff 00                  smi     0                   ; signal error occurred
 2208 fbb1: d5                     sep     sret                ; return to caller
 2209 fbb2: 6b          rdy_go:    inp     IDE_DATA            ; read status port
 2210 fbb3: f6                     shr                         ; shift error bit
 2211 fbb4: 33 aa                  bdf     ideerror            ; jump if error occurred
 2212 fbb6: 7e                     shlc                        ; shift it back
 2213 fbb7: fa c0                  ani     0c0h                ; mask for BSY and RDY
 2214 fbb9: ff 40                  smi     040h                ; want only RDY bit
 2215 fbbb: 3a a3                  bnz     rdyloop             ; loop back until drive is ready
 2216 fbbd: 02                     ldn     r2                  ; get status byte
 2217 fbbe: fc 00                  adi     0                   ; signal good
 2218 fbc0: d5                     sep     sret                ; return to caller
 2219 fbc1:             ; RF will point to wrtcmd, which is next needed after first waitrdy
 2220 fbc1: 73          wrtcmd:    stxd                        ; write passed command to stack
 2221 fbc2: f8 07                  ldi     7                   ; command register
 2222 fbc4: 73                     stxd                        ; write to stack
 2223 fbc5: 98                     ghi     r8                  ; get device
 2224 fbc6: 73                     stxd                        ; write to stack
 2225 fbc7: f8 06                  ldi     6                   ; head/device register
 2226 fbc9: 73                     stxd                        ; write to stack
 2227 fbca: 88                     glo     r8                  ; get high of lba
 2228 fbcb: 73                     stxd                        ; write to stack
 2229 fbcc: f8 05                  ldi     5                   ; cylinder high register
 2230 fbce: 73                     stxd                        ; write to stack
 2231 fbcf: 97                     ghi     r7                  ; get mid of lba
 2232 fbd0: 73                     stxd                        ; write to stack
 2233 fbd1: f8 04                  ldi     4                   ; cylinder lo register
 2234 fbd3: 73                     stxd                        ; write to stack
 2235 fbd4: 87                     glo     r7                  ; get lo of lba
 2236 fbd5: 73                     stxd                        ; write to stack
 2237 fbd6: f8 03                  ldi     3                   ; sector start register
 2238 fbd8: 73                     stxd                        ; write to stack
 2239 fbd9: f8 01                  ldi     1                   ; read one sector
 2240 fbdb: 73                     stxd                        ; write to stack
 2241 fbdc: f8 02                  ldi     2                   ; sector count register register
 2242 fbde: 73                     stxd                        ; write to stack
 2243 fbdf: 98                     ghi     r8                  ; get device
 2244 fbe0: 73                     stxd                        ; write to stack
 2245 fbe1: f8 06                  ldi     6                   ; head/device register
 2246 fbe3: 52                     str     r2                  ; write to stack
 2247 fbe4: f8 07                  ldi     7                   ; 7 sets to output
 2248 fbe6: 62          wrtcmd2:   out     IDE_SELECT
 2249 fbe7: 63                     out     IDE_DATA
 2250 fbe8: ff 01                  smi     1                   ; subtract 1
 2251 fbea: 3a e6                  bnz     wrtcmd2             ; loop back if not done
 2252 fbec: 22                     dec     r2                  ; point back to free register
 2253 fbed: 6b          drqloop:   inp     IDE_DATA            ; read status register
 2254 fbee: f6                     shr                         ; get error bit
 2255 fbef: 33 aa                  bdf     ideerror            ; jump if error
 2256 fbf1: 7e                     shlc                        ; restore value
 2257 fbf2: fe                     shl                         ; check BSY bit
 2258 fbf3: 33 ed                  bdf     drqloop             ; jump if set
 2259 fbf5: 76                     shrc                        ; restore value
 2260 fbf6: fa 08                  ani     8                   ; mask for DRQ bit
 2261 fbf8: 32 ed                  bz      drqloop             ; loop until found
 2262 fbfa: d5                     sep     sret                ; return to caller
 2263 fbfb:             ; the branch to beforerdy, allows us to use waitrdy again
 2264 fbfb:             
 2265 fbfb:                        org     BASE+0c00h
 2266 fc00: d3                     sep     r3
 2267 fc01: 9e          delay:     ghi     re                  ; get baud constant
 2268 fc02: f6                     shr                         ; remove echo flag
 2269 fc03: ae                     plo     re                  ; put into counter
 2270 fc04: e2                     sex     r2                  ; waste a cycle
 2271 fc05: 2e          delay1:    dec     re                  ; decrement counter
 2272 fc06: 8e                     glo     re                  ; get count
 2273 fc07: 32 00                  bz      delay-1             ; return if zero
 2274 fc09: 30 05                  br      delay1              ; otherwise keep going
 2275 fc0b:             
 2276 fc0b:             timalc:
 2277 fc0b:             ;[RLA]   If the Elf2K 80 column video card and PS/2 keyboard are in use, then
 2278 fc0b:             ;[RLA] this is completely a no-op.  
            #endif
 2287 fc0b: 7a                     SERREQ
 2288 fc0c: 8b                     glo     rb                  ; save consumed registesr
 2289 fc0d: 73                     stxd
 2290 fc0e: 9b                     ghi     rb
 2291 fc0f: 73                     stxd
 2292 fc10: 8c                     glo     rc
 2293 fc11: 73                     stxd
 2294 fc12: 9c                     ghi     rc
 2295 fc13: 73                     stxd
 2296 fc14: f8 00                  ldi     0                   ; zero counter 1
 2297 fc16: bc                     phi     rc
 2298 fc17: ac                     plo     rc
 2299 fc18: bb                     phi     rb                  ; and counter 2
 2300 fc19: ab                     plo     rb
            #ifdef UART
 2302 fc1a: c0 f3 29               lbr     e2k_timalc          ; use elf2000 specific timalc
            #endif
 2304 fc1d: 36 1d       timalc_o:  SERP    $                   ; wait until start bit found
 2305 fc1f: 3e 1f       end_sb:    SERN    $                   ; wait until start bit found
 2306 fc21: 36 21                  SERP    $
 2307 fc23: 1c          setbd1:    inc     rc
 2308 fc24: e2                     sex     r2
 2309 fc25: e2                     sex     r2
 2310 fc26: 3e 23                  SERN    setbd1              ; wait until another high
 2311 fc28: 1b          setbd2:    inc     rb
 2312 fc29: e2                     sex     r2
 2313 fc2a: e2                     sex     r2
 2314 fc2b: 36 28                  SERP    setbd2              ; wait til the next low
 2315 fc2d: 8b          setbd4:    glo     rb                  ; compare values
 2316 fc2e: f6                     shr                         ; quantize over small differences
 2317 fc2f: f6                     shr     
 2318 fc30: 52                     str     r2
 2319 fc31: 8c                     glo     rc
 2320 fc32: f6                     shr
 2321 fc33: f6                     shr
 2322 fc34: f7                     sm      
 2323 fc35: 32 3a                  bz      setbd3             ; jump if CR was entered
 2324 fc37:             ;           glo     rb
 2325 fc37:             ;           plo     rc
 2326 fc37: f8 01                  ldi     1
 2327 fc39: c8                     lskp    
 2328 fc3a: f8 00       setbd3:    ldi     0
 2329 fc3c: bb                     phi     rb
 2330 fc3d: 8c                     glo     rc
 2331 fc3e: ff 04                  smi     4
 2332 fc40: be                     phi     re
 2333 fc41: 9b                     ghi     rb
 2334 fc42: f6                     shr     
 2335 fc43: 9e                     ghi     re
 2336 fc44: 7e                     shlc    
 2337 fc45: be                     phi     re
 2338 fc46: 60          timalc_rt: irx                         ; recover consumed registesr
 2339 fc47: 72                     ldxa
 2340 fc48: bc                     phi     rc
 2341 fc49: 72                     ldxa
 2342 fc4a: ac                     plo     rc
 2343 fc4b: 72                     ldxa
 2344 fc4c: bb                     phi     rb
 2345 fc4d: f0                     ldx
 2346 fc4e: ab                     plo     rb
 2347 fc4f: d5                     sep     sret
 2348 fc50:             
 2349 fc50: ae          type:      plo     re
 2350 fc51: 8f 73 9f 73            push    rf                  ; save consumed registers
 2351 fc55: 8d 73 9d 73            push    rd
 2352 fc59: 8e                     glo     re
 2353 fc5a: bf                     phi     rf
 2354 fc5b: f8 09                  ldi     9                   ; 9 bits to send
 2355 fc5d: af                     plo     rf
 2356 fc5e: f8 01 ad f8 
            fc bd                  mov     rd,delay            ; point RD to delay routine
 2357 fc64: f8 00                  ldi     0
 2358 fc66: f6                     shr
 2359 fc67: 33 6c       sendlp:    bdf     sendnb              ; jump if no bit
 2360 fc69: 7b                     SERSEQ                      ; set output
 2361 fc6a: 30 6f                  br      sendct
 2362 fc6c: 7a          sendnb:    SERREQ                      ; reset output
 2363 fc6d: 30 6f                  br      sendct
 2364 fc6f: dd          sendct:    sep     rd                  ; perform bit delay
 2365 fc70: e2                     sex r2
 2366 fc71: e2                     sex r2
 2367 fc72: 9f                     ghi     rf
 2368 fc73: 76                     shrc
 2369 fc74: bf                     phi     rf
 2370 fc75: 2f                     dec     rf
 2371 fc76: 8f                     glo     rf
 2372 fc77: 3a 67                  bnz     sendlp
 2373 fc79: 7a                     SERREQ                      ; set stop bits
 2374 fc7a: dd                     sep     rd
 2375 fc7b: dd                     sep     rd
 2376 fc7c: 60 72 bd f0 
            ad                     pop     rd                  ; recover consumed registers
 2377 fc81: 60 72 bf f0 
            af                     pop     rf
 2378 fc86: d5                     sep     sret
 2379 fc87:             
            #ifdef SERHDX
 2381 fc87:             ; [RLA]   If the console bit banged serial is half duplex (as is, for example,
 2382 fc87:             ; [RLA] the DS275 used in the ELF2K) then we can't echo input on a bit for bit
 2383 fc87:             ; [RLA] basis.  Istead, we have to read the entire character, wait for the stop
 2384 fc87:             ; [RLA] bit, and then transmit the whole character back to the terminal.  This
 2385 fc87:             ; [RLA] version of read: does precisely that ...
 2386 fc87: 8f          read:      glo     rf
 2387 fc88: 73                     stxd
 2388 fc89: 9f                     ghi     rf
 2389 fc8a: 73                     stxd
 2390 fc8b: 8d                     glo     rd
 2391 fc8c: 73                     stxd
 2392 fc8d: 9d                     ghi     rd
 2393 fc8e: 73                     stxd
 2394 fc8f: f8 09                  ldi     9                   ; receive 9 bits (counting the START bit)
 2395 fc91: af                     plo     rf
 2396 fc92: f8 fc                  ldi     high delay
 2397 fc94: bd                     phi     rd
 2398 fc95: f8 01                  ldi     low delay
 2399 fc97: ad                     plo     rd
 2400 fc98: 9e                     ghi     re                  ; first delay is half bit size
 2401 fc99: bf                     phi     rf
 2402 fc9a: f6                     shr
 2403 fc9b: ff 01                  smi     01
 2404 fc9d: be                     phi     re
 2405 fc9e: 36 9e                  SERP    $                   ; wait for transmission
 2406 fca0: dd                     sep     rd                  ; wait half the pulse width
 2407 fca1: 9f                     ghi     rf                  ; recover baud constant
 2408 fca2: be                     phi     re
 2409 fca3: 9f          recvlp:    ghi     rf
 2410 fca4: f6                     shr                         ; shift right
 2411 fca5: 3e cb                  SERN    recvlp0             ; jump if zero bi
 2412 fca7: f9 80                  ori     128                 ; set bit
 2413 fca9: bf          recvlp1:   phi     rf
 2414 fcaa: dd                     sep     rd                  ; perform bit delay
 2415 fcab: 2f                     dec     rf                  ; decrement bit count
 2416 fcac: c4                     nop
 2417 fcad: c4                     nop
 2418 fcae: 8f                     glo     rf                  ; check for zero
 2419 fcaf: 3a a3                  bnz     recvlp              ; loop if not
 2420 fcb1: 7a          recvdone:  SERREQ
 2421 fcb2: dd                     sep     rd                  ; get past stop bit
 2422 fcb3: dd                     sep     rd
 2423 fcb4: 9f                     ghi     rf                  ; get character
 2424 fcb5: ae                     plo     re
 2425 fcb6: 60                     irx
 2426 fcb7: 72                     ldxa
 2427 fcb8: bd                     phi     rd
 2428 fcb9: 72                     ldxa
 2429 fcba: ad                     plo     rd
 2430 fcbb: 72                     ldxa
 2431 fcbc: bf                     phi     rf
 2432 fcbd: f0                     ldx
 2433 fcbe: af                     plo     rf
 2434 fcbf:             ;;[RLA]    glo     re
 2435 fcbf:             ;;[RLA]    shr
 2436 fcbf:             ;;[RLA]    plo     re                  ; save char
 2437 fcbf: 9e                     ghi     re                  ; get echo flag
 2438 fcc0: f6                     shr                         ; see if need echo
 2439 fcc1: 8e                     glo     re                  ; get character
 2440 fcc2: 3b ca                  bnf     noecho              ; jump if no echo needed
 2441 fcc4: 73                     stxd                        ; save on stack
 2442 fcc5: d4                     sep     scall               ; type the character out
 2443 fcc6: ff 03                  dw      f_type
 2444 fcc8: 60                     irx                         ; recover character
 2445 fcc9: f0                     ldx
 2446 fcca: d5          noecho:    sep     sret                ; and return to caller
 2447 fccb: 30 a9       recvlp0:   br      recvlp1             ; equalize between 0 and 1
 2448 fccd:             
            #endif
 2505 fccd:             
 2506 fccd:             
 2507 fccd: fc 00       brktest:   adi     0                   ; clear DF flag
 2508 fccf: 36 d5                  SERP    nobreak
 2509 fcd1: 3e d1                  SERN    $
 2510 fcd3: ff 00                  smi     0                   ; signal break condition on serial
 2511 fcd5: d5          nobreak:   sep     sret                ; and return
 2512 fcd6:             
 2513 fcd6:             ; *****************************************************
 2514 fcd6:             ; *** Serial output with 0C translation to <ESC>[2J ***
 2515 fcd6:             ; *****************************************************
 2516 fcd6: ae          tty:       plo     re                  ; save character
 2517 fcd7: ff 0c                  smi     0ch                 ; compare against formfeed
 2518 fcd9: 32 df                  bz      ttyff               ; jump if formfeed
 2519 fcdb: 8e                     glo     re                  ; recover byte
 2520 fcdc: c0 ff 4e    ttyend:    lbr     f_tty               ; and display character
 2521 fcdf: d4          ttyff:     sep     scall               ; display vt100 sequence to clear screen
 2522 fce0: f9 cb                  dw      typeinmsg
 2523 fce2: 1b 5b 32 4a 
            00                     db      01bh,'[2J',0
 2524 fce7: d5                     sep     sret                ; and return to caller
 2525 fce8:             
 2526 fce8:             
 2527 fce8:                        org     BASE+0d00h
 2528 fd00: f8 fa       initcall:  ldi     high ret
 2529 fd02: 22                     dec     r2
 2530 fd03: 22                     dec     r2
 2531 fd04: b5                     phi     r5
 2532 fd05: f8 8d                  ldi     low ret
 2533 fd07: a5                     plo     r5
 2534 fd08: f8 fa                  ldi     high call
 2535 fd0a: b4                     phi     r4
 2536 fd0b: f8 7b                  ldi     low call
 2537 fd0d: a4                     plo     r4
 2538 fd0e: d5                     sep     r5
 2539 fd0f:             
 2540 fd0f:             ; **** Strcmp compares the strings pointing to by R(D) and R(F)
 2541 fd0f:             ; **** Returns:
 2542 fd0f:             ; ****    R(F) = R(D)     0
 2543 fd0f:             ; ****    R(F) < R(D)     -1 (255)
 2544 fd0f:             ; ****    R(F) > R(D)     1
 2545 fd0f: 4d          strcmp:  lda     rd          ; get next byte in string
 2546 fd10: fa ff                ani     0ffh        ; check for zero
 2547 fd12: 32 22                bz      strcmpe     ; found end of first string
 2548 fd14: 73                   stxd                ; store into memory
 2549 fd15: 60                   irx
 2550 fd16: 4f                   lda     rf          ; get byte from first string
 2551 fd17: f7                   sm                  ; subtract 2nd byte from it
 2552 fd18: 32 0f                bz      strcmp      ; so far a match, keep looking
 2553 fd1a: 3b 1f                bnf     strcmp1     ; jump if first string is smaller
 2554 fd1c: f8 01                ldi     1           ; indicate first string is larger
 2555 fd1e: c8                   lskp                ; and return to caller
 2556 fd1f: f8 ff       strcmp1: ldi     255         ; return -1, first string is smaller
 2557 fd21: d5                   sep     sret        ; return to calelr
 2558 fd22: 4f          strcmpe: lda     rf          ; get byte from second string
 2559 fd23: 32 28                bz      strcmpm     ; jump if also zero
 2560 fd25: f8 01                ldi     1           ; first string is smaller (returns -1)
 2561 fd27: d5                   sep     sret        ; return to caller
 2562 fd28: f8 00       strcmpm: ldi     0           ; strings are a match
 2563 fd2a: d5                   sep     sret        ; return to caller
 2564 fd2b:             
 2565 fd2b:             ; **** ltrim trims leading white space from string pointed to by R[F]
 2566 fd2b:             ; **** Returns:
 2567 fd2b:             ; ****    R(F) pointing to non-whitespace portion of string
 2568 fd2b: 0f          ltrim:   ldn     rf          ; get next byte from string
 2569 fd2c: c2 fe 4d             lbz     return      ; return if at end of string
 2570 fd2f: ff 21                smi     ' '+1       ; looking for anthing <= space
 2571 fd31: c3 fe 4d             lbdf    return      ; found first non white-space
 2572 fd34: 1f                   inc     rf          ; point to next character
 2573 fd35: 30 2b                br      ltrim       ; keep looking
 2574 fd37:             
 2575 fd37:             ; **** strcpy copies string pointed to by R[F] to R[D]
 2576 fd37: 4f          strcpy:  lda    rf           ; get byte from source string
 2577 fd38: 5d                   str    rd           ; store into destination
 2578 fd39: c2 fe 4d             lbz    return       ; return if copied terminator
 2579 fd3c: 1d                   inc    rd           ; increment destination pointer
 2580 fd3d: 30 37                br     strcpy       ; continue looping
 2581 fd3f:             
 2582 fd3f:             ; **** memcpy copies R[C] bytes from R[F] to R[D]
 2583 fd3f: 8c          memcpy:  glo    rc           ; get low count byte
 2584 fd40: 3a 46                bnz    memcpy1      ; jump if not zero
 2585 fd42: 9c                   ghi    rc           ; get high count byte
 2586 fd43: c2 fe 4d             lbz    return       ; return if zero
 2587 fd46: 4f          memcpy1: lda    rf           ; get byte from source
 2588 fd47: 5d                   str    rd           ; store into destination
 2589 fd48: 1d                   inc    rd           ; point to next destination position
 2590 fd49: 2c                   dec    rc           ; decrement count
 2591 fd4a: 30 3f                br     memcpy       ; and continue copy
 2592 fd4c:             
 2593 fd4c:             ; *** RC:RB = RF * RD (RB is low word)
 2594 fd4c:             ; *** R(X) must point to suitable stack
 2595 fd4c: f8 00       mul16:     ldi     0                   ; zero out total
 2596 fd4e: bb                     phi     rb
 2597 fd4f: ab                     plo     rb
 2598 fd50: bc                     phi     rc
 2599 fd51: ac                     plo     rc
 2600 fd52: e2                     sex     r2                  ; make sure X points to stack
 2601 fd53: 8d          mulloop:   glo     rd                  ; get low of multiplier
 2602 fd54: 3a 5a                  bnz     mulcont             ; continue multiplying if nonzero
 2603 fd56: 9d                     ghi     rd                  ; check hi byte as well
 2604 fd57: 3a 5a                  bnz     mulcont
 2605 fd59: d5                     sep     sret                ; return to caller
 2606 fd5a: 9d          mulcont:   ghi     rd                  ; shift multiplier
 2607 fd5b: f6                     shr     
 2608 fd5c: bd                     phi     rd
 2609 fd5d: 8d                     glo     rd
 2610 fd5e: 76                     shrc    
 2611 fd5f: ad                     plo     rd
 2612 fd60: 3b 74                  bnf     mulcont2            ; loop if no addition needed
 2613 fd62: 8f                     glo     rf                  ; add F to C:B
 2614 fd63: 52                     str     r2
 2615 fd64: 8b                     glo     rb
 2616 fd65: f4                     add     
 2617 fd66: ab                     plo     rb
 2618 fd67: 9f                     ghi     rf
 2619 fd68: 52                     str     r2
 2620 fd69: 9b                     ghi     rb
 2621 fd6a: 74                     adc
 2622 fd6b: bb                     phi     rb
 2623 fd6c: 8c                     glo     rc                  ; carry into high word
 2624 fd6d: 7c 00                  adci    0
 2625 fd6f: ac                     plo     rc
 2626 fd70: 9c                     ghi     rc
 2627 fd71: 7c 00                  adci    0
 2628 fd73: bc                     phi     rc
 2629 fd74: 8f          mulcont2:  glo     rf                  ; shift first number
 2630 fd75: fe                     shl
 2631 fd76: af                     plo     rf
 2632 fd77: 9f                     ghi     rf
 2633 fd78: 7e                     shlc
 2634 fd79: bf                     phi     rf
 2635 fd7a: 30 53                  br      mulloop             ; loop until done
 2636 fd7c:             
 2637 fd7c:             ; *** RB = RF/RD
 2638 fd7c:             ; *** RF = Remainder
 2639 fd7c:             ; *** uses R8 and R9
 2640 fd7c: f8 00       div16:     ldi     0                   ; clear answer
 2641 fd7e: bb                     phi     rb
 2642 fd7f: ab                     plo     rb
 2643 fd80: b8                     phi     r8                  ; set additive
 2644 fd81: a8                     plo     r8
 2645 fd82: 18                     inc     r8
 2646 fd83: 8d                     glo     rd                  ; check for divide by 0
 2647 fd84: 3a 8e                  bnz     d16lp1
 2648 fd86: 9d                     ghi     rd
 2649 fd87: 3a 8e                  bnz     d16lp1
 2650 fd89: f8 ff                  ldi     0ffh                ; return 0ffffh as div/0 error
 2651 fd8b: bb                     phi     rb
 2652 fd8c: ab                     plo     rb
 2653 fd8d: d5                     sep     sret     
 2654 fd8e: 9d          d16lp1:    ghi     rd                  ; get high byte from r7
 2655 fd8f: fa 80                  ani     128                 ; check high bit
 2656 fd91: 3a a1                  bnz     divst               ; jump if set
 2657 fd93: 8d                     glo     rd                  ; lo byte of divisor
 2658 fd94: fe                     shl                         ; multiply by 2
 2659 fd95: ad                     plo     rd                  ; and put back
 2660 fd96: 9d                     ghi     rd                  ; get high byte of divisor
 2661 fd97: 7e                     shlc                        ; continue multiply by 2
 2662 fd98: bd                     phi     rd                  ; and put back
 2663 fd99: 88                     glo     r8                  ; multiply additive by 2
 2664 fd9a: fe                     shl
 2665 fd9b: a8                     plo     r8
 2666 fd9c: 98                     ghi     r8
 2667 fd9d: 7e                     shlc
 2668 fd9e: b8                     phi     r8
 2669 fd9f: 30 8e                  br      d16lp1              ; loop until high bit set in divisor
 2670 fda1: 88          divst:     glo     r8                  ; get low of divisor
 2671 fda2: 3a a8                  bnz     divgo               ; jump if still nonzero
 2672 fda4: 98                     ghi     r8                  ; check hi byte too
 2673 fda5: c2 fe 4d               lbz     return              ; jump if done
 2674 fda8: 9f          divgo:     ghi     rf                  ; copy dividend
 2675 fda9: b9                     phi     r9
 2676 fdaa: 8f                     glo     rf
 2677 fdab: a9                     plo     r9
 2678 fdac: 8d                     glo     rd                  ; get lo of divisor
 2679 fdad: 73                     stxd                        ; place into memory
 2680 fdae: 60                     irx                         ; point to memory
 2681 fdaf: 8f                     glo     rf                  ; get low byte of dividend
 2682 fdb0: f7                     sm                          ; subtract
 2683 fdb1: af                     plo     rf                  ; put back into r6
 2684 fdb2: 9d                     ghi     rd                  ; get hi of divisor
 2685 fdb3: 73                     stxd                        ; place into memory
 2686 fdb4: 60                     irx                         ; point to byte
 2687 fdb5: 9f                     ghi     rf                  ; get hi of dividend
 2688 fdb6: 77                     smb                         ; subtract
 2689 fdb7: bf                     phi     rf                  ; and put back
 2690 fdb8: 33 c0                  bdf     divyes              ; branch if no borrow happened
 2691 fdba: 99                     ghi     r9                  ; recover copy
 2692 fdbb: bf                     phi     rf                  ; put back into dividend
 2693 fdbc: 89                     glo     r9
 2694 fdbd: af                     plo     rf
 2695 fdbe: 30 cc                  br      divno               ; jump to next iteration
 2696 fdc0: 88          divyes:    glo     r8                  ; get lo of additive
 2697 fdc1: 73                     stxd                        ; place in memory
 2698 fdc2: 60                     irx                         ; point to byte
 2699 fdc3: 8b                     glo     rb                  ; get lo of answer
 2700 fdc4: f4                     add                         ; and add
 2701 fdc5: ab                     plo     rb                  ; put back
 2702 fdc6: 98                     ghi     r8                  ; get hi of additive
 2703 fdc7: 73                     stxd                        ; place into memory
 2704 fdc8: 60                     irx                         ; point to byte
 2705 fdc9: 9b                     ghi     rb                  ; get hi byte of answer
 2706 fdca: 74                     adc                         ; and continue addition
 2707 fdcb: bb                     phi     rb                  ; put back
 2708 fdcc: 9d          divno:     ghi     rd                  ; get hi of divisor
 2709 fdcd: f6                     shr                         ; divide by 2
 2710 fdce: bd                     phi     rd                  ; put back
 2711 fdcf: 8d                     glo     rd                  ; get lo of divisor
 2712 fdd0: 76                     shrc                        ; continue divide by 2
 2713 fdd1: ad                     plo     rd
 2714 fdd2: 98                     ghi     r8                  ; get hi of divisor
 2715 fdd3: f6                     shr                         ; divide by 2
 2716 fdd4: b8                     phi     r8                  ; put back
 2717 fdd5: 88                     glo     r8                  ; get lo of divisor
 2718 fdd6: 76                     shrc                        ; continue divide by 2
 2719 fdd7: a8                     plo     r8
 2720 fdd8: 30 a1                  br      divst               ; next iteration
 2721 fdda:             
 2722 fdda: c0 fc d6    ttyold:    lbr     tty
 2723 fddd:             
 2724 fddd:             ; *****************************************
 2725 fddd:             ; *** See if D is alphanumeric          ***
 2726 fddd:             ; *** Returns: DF=0 - not valid         ***
 2727 fddd:             ; ***          DF=1 - is valid          ***
 2728 fddd:             ; *****************************************
 2729 fddd: ae          isalnum:   plo     re                  ; keep copy of D
 2730 fdde: d4                     sep     scall               ; check if numeric
 2731 fddf: f9 d4                  dw      isnum
 2732 fde1: c3 f9 dd               lbdf    passes              ; jump if numeric
 2733 fde4: d4                     sep     scall               ; check for alpha
 2734 fde5: fa 9b                  dw      isalpha
 2735 fde7: c3 f9 dd               lbdf    passes              ; jump if alpha
 2736 fdea: c0 f9 e0               lbr     fails               ; otherwise fails
 2737 fded:             
 2738 fded:             ; ***********************************
 2739 fded:             ; *** Check for symbol terminator ***
 2740 fded:             ; *** Returns: DF=1 - terminator  ***
 2741 fded:             ; ***********************************
 2742 fded: d4          isterm:    sep     scall               ; see if alphanumeric
 2743 fdee: fd dd                  dw      isalnum
 2744 fdf0: c3 f9 e0               lbdf    fails               ; fails if so
 2745 fdf3: c0 f9 dd               lbr     passes
 2746 fdf6:             
 2747 fdf6:             ;;[RLA]   The BIOS assembles OK even if this next part isn't aligned, and we
 2748 fdf6:             ;;[RLA] we desperately need those extra couple of bytes at $FF00!
            #endif
 2752 fdf6:             ; ******************************************
 2753 fdf6:             ; *** Check if symbol is in symbol table ***
 2754 fdf6:             ; *** RF - pointer to ascii symbol       ***
 2755 fdf6:             ; *** R7 - pointer to token table        ***
 2756 fdf6:             ; *** Returns: RD - function number      ***
 2757 fdf6:             ; ***          DF=1 - is function        ***
 2758 fdf6:             ; ***          DF=0 - is not a function  ***
 2759 fdf6:             ; ******************************************
 2760 fdf6: 87          tokenfunc: glo     r7                  ; save position of R7
 2761 fdf7: 73                     stxd
 2762 fdf8: 97                     ghi     r7
 2763 fdf9: 73                     stxd
 2764 fdfa: 8b                     glo     rb                  ; save other consumed register
 2765 fdfb: 73                     stxd
 2766 fdfc: 9b                     ghi     rb
 2767 fdfd: 73                     stxd
 2768 fdfe: f8 00                  ldi     0                   ; setup function number
 2769 fe00: ad                     plo     rd
 2770 fe01: 9f                     ghi     rf                  ; save buffer position
 2771 fe02: bb                     phi     rb
 2772 fe03: 8f                     glo     rf
 2773 fe04: ab                     plo     rb
 2774 fe05: 07          tfloop:    ldn     r7                  ; see if at last token
 2775 fe06: 3a 14                  bnz     tfgo                ; jump if not
 2776 fe08: fc 00                  adi     0                   ; signal symbol not found
 2777 fe0a: 60          tfreturn:  irx                         ; recover consumed registers
 2778 fe0b: 72                     ldxa
 2779 fe0c: bb                     phi     rb
 2780 fe0d: 72                     ldxa
 2781 fe0e: ab                     plo     rb
 2782 fe0f: 72                     ldxa
 2783 fe10: b7                     phi     r7
 2784 fe11: f0                     ldx
 2785 fe12: a7                     plo     r7
 2786 fe13: d5                     sep     sret                ; and return
 2787 fe14: 07          tfgo:      ldn     r7                  ; get token byte
 2788 fe15: fa 80                  ani     080h                ; see if last one
 2789 fe17: 3a 2b                  bnz     tflast              ; jump if it was
 2790 fe19: 47                     lda     r7                  ; get byte from function table
 2791 fe1a: 52                     str     r2                  ; setup compare
 2792 fe1b: 4f                     lda     rf                  ; get byte from input
 2793 fe1c: f7                     sm                          ; and compare
 2794 fe1d: 32 14                  bz      tfgo                ; loop back if match
 2795 fe1f: 47          tfnolp:    lda     r7                  ; need to find end of token
 2796 fe20: fa 80                  ani     080h
 2797 fe22: 32 1f                  bz      tfnolp              ; loop until found
 2798 fe24: 1d          tfno:      inc     rd                  ; increment function number
 2799 fe25: 9b                     ghi     rb                  ; restore buffer position
 2800 fe26: bf                     phi     rf
 2801 fe27: 8b                     glo     rb
 2802 fe28: af                     plo     rf
 2803 fe29: 30 05                  br      tfloop              ; loop to check next token
 2804 fe2b: 47          tflast:    lda     r7                  ; get byte from token
 2805 fe2c: fa 7f                  ani     07fh                ; strip high bit
 2806 fe2e: 52                     str     r2                  ; store for compare
 2807 fe2f: 4f                     lda     rf                  ; get byte from buffer
 2808 fe30: f7                     sm                          ; and see if a match
 2809 fe31: 3a 24                  bnz     tfno                ; jump if not
 2810 fe33: ff 00                  smi     0                   ; signal match found
 2811 fe35: 30 0a                  br      tfreturn            ; and return
 2812 fe37:             
 2813 fe37:             ; ***********************************************
 2814 fe37:             ; *** identify symbol as decimal, hex, or non ***
 2815 fe37:             ; *** RF - pointer to symbol                  ***
 2816 fe37:             ; *** Returns: D=0 - decimal number           ***
 2817 fe37:             ; ***          D=1 - hex number               ***
 2818 fe37:             ; ***          DF=1 - non numeric             ***
 2819 fe37:             ; ***          DF=0 - is numeric              ***
 2820 fe37:             ; ***********************************************
 2821 fe37: 8f          idnum:     glo     rf                  ; save position
 2822 fe38: 73                     stxd
 2823 fe39: 9f                     ghi     rf
 2824 fe3a: 73                     stxd
 2825 fe3b: 0f                     ldn     rf                  ; get first byte
 2826 fe3c: d4                     sep     scall               ; must be numeric
 2827 fe3d: f9 d4                  dw      isnum
 2828 fe3f: 33 4e                  bdf     idlp1               ; jump if it was
 2829 fe41: ff 00       idnumno:   smi     0                   ; signal non-numeric
 2830 fe43: c8                     lskp
 2831 fe44: fc 00       idnumyes:  adi     0                   ; signal numeric
 2832 fe46: ae                     plo     re                  ; save number
 2833 fe47: 60                     irx                         ; recover RF
 2834 fe48: 72                     ldxa
 2835 fe49: bf                     phi     rf
 2836 fe4a: f0                     ldx
 2837 fe4b: af                     plo     rf
 2838 fe4c: 8e                     glo     re                  ; recover number
 2839 fe4d: d5          return:    sep     sret                ; and return to caller
 2840 fe4e: 4f          idlp1:     lda     rf                  ; get next byte
 2841 fe4f: d4                     sep     scall               ; check for symbol terminator
 2842 fe50: fd ed                  dw      isterm
 2843 fe52: 33 6f                  bdf     iddec               ; signal decimal number
 2844 fe54: d4                     sep     scall               ; see if char is numeric
 2845 fe55: f9 d4                  dw      isnum
 2846 fe57: 33 4e                  bdf     idlp1               ; jump if so
 2847 fe59: 2f                     dec     rf                  ; move back to char
 2848 fe5a: 4f          idlp2:     lda     rf                  ; get next byte
 2849 fe5b: d4                     sep     scall               ; see if terminator
 2850 fe5c: fd ed                  dw      isterm
 2851 fe5e: 33 41                  bdf     idnumno             ; jump if term found before h
 2852 fe60: d4                     sep     scall               ; check for hex character
 2853 fe61: fa b4                  dw      ishex
 2854 fe63: 33 5a                  bdf     idlp2               ; loop back if so
 2855 fe65: ff 48                  smi     'H'                 ; check for final H
 2856 fe67: 32 73                  bz      idhex               ; jump if hex
 2857 fe69: ff 20                  smi     32                  ; check for h
 2858 fe6b: 32 73                  bz      idhex
 2859 fe6d: 30 41                  br      idnumno             ; was not proper number
 2860 fe6f: f8 00       iddec:     ldi     0                   ; signal decimal number
 2861 fe71: 30 44                  br      idnumyes            ; and return
 2862 fe73: f8 01       idhex:     ldi     1                   ; signal hex number
 2863 fe75: 30 44                  br      idnumyes            ; and return
 2864 fe77:             
 2865 fe77:             
 2866 fe77:             
 2867 fe77:             ; **** Find last available memory address
 2868 fe77:             ; **** Returns: RF - last writable address
            #else
 2872 fe77: f8 00       freemem:   ldi     000h      ; start from beginning of memory
            #endif
 2874 fe79: bf                     phi     rf        ; place into register
 2875 fe7a: f8 ff                  ldi     0ffh
 2876 fe7c: af                     plo     rf
 2877 fe7d: e2                     sex     r2        ; be sure x points to stack
 2878 fe7e: 0f          fmemlp:    ldn     rf        ; get byte
 2879 fe7f: ae                     plo     re        ; save a copy
 2880 fe80: fb ff                  xri     255       ; flip the bits
 2881 fe82: 5f                     str     rf        ; place into memory
 2882 fe83: 0f                     ldn     rf        ; retrieve from memory
 2883 fe84: 73                     stxd              ; place into memory
 2884 fe85: 60                     irx               ; point to previous value
 2885 fe86: 8e                     glo     re
 2886 fe87: f7                     sm                ; and compare
 2887 fe88: 32 95                  bz      fmemdn    ; jump if not different
 2888 fe8a: 8e                     glo     re        ; recover byte
 2889 fe8b: 5f                     str     rf        ; write back into memory
 2890 fe8c: 9f                     ghi     rf
 2891 fe8d: fc 01                  adi     1
 2892 fe8f: bf                     phi     rf
 2893 fe90:             ;;[RLA]    bnz     fmemlp    ; jump if not
            #ifdef STGROM
 2895 fe90:             ;[RLA]   For the Elf 2000, we never want to use page 07FxxH - that belongs to
 2896 fe90:             ;[RLA] the Elf 2000 monitor program.  Likewise, if the 80 column video card
 2897 fe90:             ;[RLA] is installed then we need to reserve another 2K off the top of SRAM
 2898 fe90:             ;[RLA] for the frame buffer.  Sadly, theres no easy way for the BIOS to know
 2899 fe90:             ;[RLA] if the video card is installed, but we can make a pretty good guess
 2900 fe90:             ;[RLA] by checking RE.1 (the baud rate constant) - if this is zero, then the
 2901 fe90:             ;[RLA] video card is being used as the console!
            #endif
 2911 fe90:             ;[RLA] No video card - test memory up to 07EFFH ...
 2912 fe90: 9f          fmeml1:    ghi     rf        ; [RLA] get the current page
 2913 fe91: ff 7f                  smi     07fh      ; [RLA] and stop at page 7FH
 2914 fe93:             fmeml2:
            #endif
 2918 fe93: 3a 7e                  bnz     fmemlp
 2919 fe95: 9f          fmemdn:    ghi     rf        ; point back to last writable memory
 2920 fe96: ff 01                  smi     1
 2921 fe98: bf                     phi     rf
 2922 fe99: d5                     sep     sret      ; and return to caller
 2923 fe9a:             
 2924 fe9a:             ;[RLA]   This is a "cold" boot - it will set up SCRT and a temporary stack
 2925 fe9a:             ;[RLA] before calling the "warm" boot at bootret: ...
 2926 fe9a: f8 fe       bootide:   ldi     high bootret        ; prepare for seetin call
 2927 fe9c: b6                     phi     r6
 2928 fe9d: f8 aa                  ldi     low bootret
 2929 fe9f: a6                     plo     r6
 2930 fea0: f8 00                  ldi     0                   ; setup temp stack
 2931 fea2: b2                     phi     r2
 2932 fea3: f8 f0                  ldi     0f0h
 2933 fea5: a2                     plo     r2
 2934 fea6: e2                     sex     r2
 2935 fea7: c0 ff 3f               lbr     f_initcall
 2936 feaa:             
 2937 feaa:             ;[RLA]   This routine will attempt to boot ElfOS from the primary (i.e. master)
 2938 feaa:             ;[RLA] IDE drive.  It returns with DF=1 if there's a hardware error (e.g. no
 2939 feaa:             ;[RLA] drive, read error, etc) and with DF=0 if the hardware is OK but the drive
 2940 feaa:             ;[RLA] does not contain a bootable ElfOS system.  Of course, if it works then
 2941 feaa:             ;[RLA] this routine never returns ...
 2942 feaa: f8 00       bootret:   ldi     0                   ; select master drive
 2943 feac: ad                     plo     rd
 2944 fead: d4                     sep     scall               ; reset ide drive
 2945 feae: ff 36                  dw      f_iderst
            #ifdef EIDE
 2947 feb0: c3 f9 e4               lbdf    err                 ; [RLA] quit now if error!
            #endif
 2949 feb3: f8 00                  ldi     0                   ; prepare to read sector 0
 2950 feb5: a7                     plo     r7
 2951 feb6: b7                     phi     r7
 2952 feb7: a8                     plo     r8
 2953 feb8: af                     plo     rf
 2954 feb9: f8 e0                  ldi     0e0h
 2955 febb: b8                     phi     r8
 2956 febc: f8 01                  ldi     1
 2957 febe: bf                     phi     rf
 2958 febf: d4                     sep     scall
 2959 fec0: ff 3c                  dw      f_ideread
            #ifdef EIDE
 2961 fec2: c3 f9 e4               lbdf    err                 ; return to monitor if disk error
 2962 fec5: d4                     sep     scall               ; check boot code
 2963 fec6: f7 da                  dw      btcheck
 2964 fec8: c3 f9 e4               lbdf    err                 ; error out on mismatch
            #endif
 2966 fecb: c0 01 06               lbr     0106h
 2967 fece:             
 2968 fece: f8 01       input256:  ldi     1                   ; allow 256 input bytes
 2969 fed0: bc                     phi     rc
 2970 fed1: f8 00                  ldi     0
 2971 fed3: ac                     plo     rc
 2972 fed4: c0 ff 84               lbr     input
 2973 fed7:             
 2974 fed7:             ; ***************************************
 2975 fed7:             ; *** Type message pointed to by R[F] ***
 2976 fed7:             ; ***************************************
 2977 fed7: 4f          typemsg:   lda     rf                  ; load byte from message
 2978 fed8: c2 fe 4d               lbz     return              ; return if last byte
 2979 fedb: d4                     sep     scall               ; call type routine
 2980 fedc: ff 4e                  dw      f_tty
 2981 fede: 30 d7                  br      typemsg             ; loop until a zero found
 2982 fee0:             
 2983 fee0:             ; *******************************************************
 2984 fee0:             ; *** Get supported devices list                      ***
 2985 fee0:             ; *** Returns: RF - device list                       ***
 2986 fee0:             ; ***          Bit 0 - IDE                            ***
 2987 fee0:             ; ***          Bit 1 - Floppy                         ***
 2988 fee0:             ; ***          Bit 2 - Bit-banged serial              ***
 2989 fee0:             ; ***          Bit 3 - UART                           ***
 2990 fee0:             ; ***          Bit 4 - RTC                            ***
 2991 fee0:             ; ***          Bit 5 - NVR                            ***
 2992 fee0:             ; ***          Bit 6 - 1861 video ?                   ***
 2993 fee0:             ; ***          Bit 7 - 9118 video ?                   ***
 2994 fee0:             ; ***          Bit 8 - extended BIOS vectors at $F800 ***
 2995 fee0:             ; ***          Bit 9 - extended BIOS vectors at $F000 ***
 2996 fee0:             ; *******************************************************
 2997 fee0:             
 2998 fee0:             ; Device bits returned in RF.0
 2999 fee0:             DEVICES:equ     05h     ; all versions support IDE and bit banged serial
            #ifdef UART
 3001 fee0:             UARTDEV:equ     08h     ; UART is supported too
            #endif
            #ifdef NVR
 3006 fee0:             NVRDEV: equ     30h     ; RTC and NVR supported
            #endif
 3010 fee0:             
 3011 fee0:             ; BIOS options bits returned in RF.1
 3012 fee0:             BIOSOPTS:  equ  01h     ; extended vectors at $F800
 3013 fee0:             
 3014 fee0: f8 3d       getdev:    ldi     DEVICES+UARTDEV+NVRDEV  ; load map of supported devices
 3015 fee2: af                     plo     rf                  ; ...
 3016 fee3: f8 01                  ldi     BIOSOPTS            ; high byte is BIOS options
 3017 fee5: bf                     phi     rf                  ; ...
 3018 fee6: d5                     sep     sret                ; return
            #endif
 3020 fee7:             
 3021 fee7: 27 10 03 e8 
            00 64 00 0a 
            00 01       numbers:   db      027h,010h,3,0e8h,0,100,0,10,0,1
 3022 fef1:             
 3023 fef1:                        org     BASE+0f00h
 3024 ff00: c0 fe 9a    f_boot:    lbr     bootide
            #ifdef UART
 3026 ff03: c0 f3 8c    f_type:    lbr     e2k_tx
            #endif
            #ifdef UART
 3031 ff06: c0 f3 9b    f_read:    lbr     e2k_rx
            #endif
 3035 ff09: c0 fe d7    f_msg:     lbr     typemsg
 3036 ff0c: c0 fe 4d    f_typex:   lbr     return
 3037 ff0f: c0 fe ce    f_input:   lbr     input256
 3038 ff12: c0 fd 0f    f_strcmp:  lbr     strcmp
 3039 ff15: c0 fd 2b    f_ltrim:   lbr     ltrim
 3040 ff18: c0 fd 37    f_strcpy:  lbr     strcpy
 3041 ff1b: c0 fd 3f    f_memcpy:  lbr     memcpy
 3042 ff1e: c0 00 00    f_wrtsec:  lbr     0
 3043 ff21: c0 00 00    f_rdsec:   lbr     0
 3044 ff24: c0 00 00    f_seek0:   lbr     0
 3045 ff27: c0 00 00    f_seek:    lbr     0
 3046 ff2a: c0 00 00    f_drive:   lbr     0
 3047 ff2d: c0 fc 0b    f_setbd:   lbr     timalc
 3048 ff30: c0 fd 4c    f_mul16:   lbr     mul16
 3049 ff33: c0 fd 7c    f_div16:   lbr     div16
 3050 ff36: c0 fb 00    f_iderst:  lbr     resetide
 3051 ff39: c0 fb 33    f_idewrt:  lbr     wrtide
 3052 ff3c: c0 fb 72    f_ideread: lbr     rdide
 3053 ff3f: c0 fd 00    f_initcall: lbr    initcall
 3054 ff42: c0 fe aa    f_ideboot: lbr     bootret
 3055 ff45: c0 fa 00    f_hexin:   lbr     hexin
 3056 ff48: c0 fa 47    f_hexout2: lbr     hexout2
 3057 ff4b: c0 fa 4c    f_hexout4: lbr     hexout4
            #ifdef UART
 3059 ff4e: c0 f3 8c    f_tty:     lbr     e2k_tx
            #endif
 3063 ff51: c0 fa da    f_mover:   lbr     mover
 3064 ff54: c0 f9 00    f_minimon: lbr     minimon
 3065 ff57: c0 fe 77    f_freemem: lbr     freemem
 3066 ff5a: c0 f9 d4    f_isnum:   lbr     isnum
 3067 ff5d: c0 f8 39    f_atoi:    lbr     atoi
 3068 ff60: c0 f8 87    f_uintout: lbr     uintout
 3069 ff63: c0 f8 89    f_intout:  lbr     intout
 3070 ff66: c0 f9 cb    f_inmsg:   lbr     typeinmsg
 3071 ff69: c0 ff 84    f_inputl:  lbr     input
            #ifdef UART
 3073 ff6c: c0 f3 83    f_brktest: lbr     e2k_brk
            #endif
 3077 ff6f: c0 fd f6    f_findtkn: lbr     tokenfunc
 3078 ff72: c0 fa 9b    f_isalpha: lbr     isalpha
 3079 ff75: c0 fa b4    f_ishex:   lbr     ishex
 3080 ff78: c0 fd dd    f_isalnum: lbr     isalnum
 3081 ff7b: c0 fe 37    f_idnum:   lbr     idnum
 3082 ff7e: c0 fd ed    f_isterm:  lbr     isterm
 3083 ff81: c0 fe e0    f_getdev:  lbr     getdev
 3084 ff84:             
 3085 ff84: 8a          input:     glo     ra                  ; save RA
 3086 ff85: 73                     stxd
 3087 ff86: 9a                     ghi     ra
 3088 ff87: 73                     stxd
 3089 ff88: f8 00                  ldi     0                   ; byte count
 3090 ff8a: aa                     plo     ra                  ; store into counter
 3091 ff8b: d4          inplp:     sep     scall               ; call input function
 3092 ff8c: ff 06                  dw      f_read
 3093 ff8e: ae                     plo     re                  ; save char
 3094 ff8f: ff 03                  smi     3                   ; check for <CTRL><C>
 3095 ff91: 32 cf                  bz      inpterm             ; terminate input
 3096 ff93: ff 05                  smi     5                   ; check for <BS>
 3097 ff95: 32 af                  bz      isbs                ; jump if so
 3098 ff97: ff 05                  smi     5                   ; check for <CR>
 3099 ff99: 32 c5                  bz      inpdone             ; jump if so
 3100 ff9b: 8c                     glo     rc                  ; check count
 3101 ff9c: 3a a8                  bnz     inpcnt              ; jump if can continue
 3102 ff9e: 9c                     ghi     rc                  ; check high of count
 3103 ff9f: 3a a8                  bnz     inpcnt
 3104 ffa1: f8 08                  ldi     8                   ; performa backspace
 3105 ffa3: d4                     sep     scall
 3106 ffa4: ff 4e                  dw      f_tty
 3107 ffa6: 30 b5                  br      bs2                 ; remove char from screen
 3108 ffa8: 8e          inpcnt:    glo     re
 3109 ffa9: 5f                     str     rf                  ; store into output
 3110 ffaa: 1f                     inc     rf                  ; point to next position
 3111 ffab: ff 08                  smi     08                  ; look for backspace
 3112 ffad: 3a c1                  bnz     nobs                ; jump if not a backspace
 3113 ffaf: 8a          isbs:      glo     ra                  ; get input count
 3114 ffb0: 32 8b                  bz      inplp               ; disregard if string is empty
 3115 ffb2: 2a                     dec     ra                  ; decrement the count
 3116 ffb3: 2f                     dec     rf                  ; decrement buffer position
 3117 ffb4: 1c                     inc     rc                  ; increment allowed characters
 3118 ffb5: f8 20       bs2:       ldi     32                  ; display a space
 3119 ffb7: d4                     sep     scall
 3120 ffb8: ff 4e                  dw      f_tty
 3121 ffba: f8 08                  ldi     8                   ; then backspace again
 3122 ffbc: d4                     sep     scall
 3123 ffbd: ff 4e                  dw      f_tty
 3124 ffbf: 30 8b                  br      inplp               ; and loop back for more
 3125 ffc1: 1a          nobs:      inc     ra                  ; increment input count
 3126 ffc2: 2c                     dec     rc                  ; decrement character count
 3127 ffc3: 30 8b                  br      inplp               ; and then loop back
 3128 ffc5: f8 00       inpdone:   ldi     0                   ; need a zero terminator
 3129 ffc7: f6                     shr                         ; reset DF flag, to show valid input
 3130 ffc8: 5f          inpdone2:  str     rf                  ; store into buffer
 3131 ffc9: 60                     irx                         ; recover RA
 3132 ffca: 72                     ldxa
 3133 ffcb: ba                     phi     ra
 3134 ffcc: f0                     ldx
 3135 ffcd: aa                     plo     ra
 3136 ffce: d5                     sep     sret                ; return to caller
 3137 ffcf: ff 00       inpterm:   smi     0                   ; signal <CTRL><C> exit
 3138 ffd1: f8 00                  ldi     0                   ; finish
 3139 ffd3: 30 c8                  br      inpdone2
 3140 ffd5:                       
 3141 ffd5:             
 3142 ffd5:             ; *****************************************************
 3143 ffd5:             ; *** Function to implement a stack based call      ***
 3144 ffd5:             ; ***    RX is assumed to be the stack pointer      ***
 3145 ffd5:             ; ***    R3 is assumed to be the main PC            ***
 3146 ffd5:             ; ***    R6 will hold return address                ***
 3147 ffd5:             ; ***    usage is:    sep R4                        ***
 3148 ffd5:             ; ***                 dw  call_addr                 ***
 3149 ffd5:             ; *****************************************************
 3150 ffd5:                      org     BASE+0fe0h
 3151 ffe0: c0 fa 7b             lbr     call
 3152 ffe3:                      org     BASE+0ff1h
 3153 fff1: c0 fa 8d             lbr     ret
 3154 fff4:             
 3155 fff4:                      org     BASE+0ff9h
 3156 fff9: 01 00 0a    version: db      1,0,10
 3157 fffc: 00 00 00 00 chsum:   db      0,0,0,0

f35ch: ABD2             - <   225>    213 
f35eh: ABD2A            - <   226>    229 
f34fh: ABDLP1           - <   209>    215 
f375h: ABDTAB           - <   251>    205    207 
f8d6h: ALLOW0           - <  1601>   1598 
f690h: ASDTEND          - <  1119>   1126   1129 
f65bh: ASTODT           - <  1086>   1457 
f6a3h: ASTOTM           - <  1136>   1458 
f839h: ATOI             - <  1473>   1091   1102   1113   1143   1154   1179 
         3067 
f84bh: ATOICNT          - <  1485>   1480   1482 
f87dh: ATOIDN           - <  1523>   1494 
f854h: ATOILP           - <  1491>   1487   1522 
f41ch: BAUDTAB          - <   493>    449    452 
0001h: BIOSOPTS         - <  3012>   3016 
fe9ah: BOOTIDE          - <  2926>   3024 
feaah: BOOTRET          - <  2942>   2926   2928   3054 
fccdh: BRKTEST          - <  2507>   1423 
ffb5h: BS2              - <  3118>   3107 
f7dah: BTCHECK          - <  1386>   2963 
f7e7h: BTCHK_LP         - <  1395>   1405 
0003h: BUFFER           - <  1642>   1786   1788 
fa7bh: CALL             - <  1938>   1953   2534   2536   3151 
f565h: CHK_ERR          - <   839>    807    812 
fffch: CHSUM            - <  3157> 
f98dh: COPY             - <  1754>   1691 
f9c8h: CRLF             - <  1801>   1792   1794 
fd8eh: D16LP1           - <  2654>   2647   2649   2669 
0000h: DATA             - <    94> 
fc01h: DELAY            - <  2267>   2273   2356   2396   2398 
fc05h: DELAY1           - <  2271>   2274 
0005h: DEVICES          - <  2999>   3014 
fd7ch: DIV16            - <  2640>   3049 
fda8h: DIVGO            - <  2674>   2671 
f8bbh: DIVLP            - <  1579>   1593 
fdcch: DIVNO            - <  2708>   2695 
fda1h: DIVST            - <  2670>   2656   2720 
fdc0h: DIVYES           - <  2696>   2690 
f9bch: DOCRLF           - <  1792>   1675   1735 
f9adh: DOMOVE           - <  1779>   1775   1777 
f9b3h: DONE             - <  1784>   1778 
fbedh: DRQLOOP          - <  2253>   1266   1328   2258   2261 
f6f0h: DTERR            - <  1185>   1094   1100   1105   1111   1146   1152 
         1157   1168   1182 
f617h: DTTOAS           - <  1022>   1454 
f383h: E2K_BRK          - <   266>   3073 
f493h: E2K_GTOD         - <   624>   1436 
f522h: E2K_RDNVR        - <   788>   1438 
f39bh: E2K_RX           - <   302>   3031 
f33dh: E2K_SBLP1        - <   185>    188 
f334h: E2K_SBLP2        - <   176> 
f380h: E2K_SETBD1       - <   260>    185 
f3d9h: E2K_STBD         - <   428>    175    247   1428 
f4e9h: E2K_STOD         - <   718>   1437 
f329h: E2K_TIMALC       - <   170>    210   2302 
f38ch: E2K_TX           - <   281>   3026   3059 
f397h: E2K_TX1          - <   291>    284 
f3ach: E2K_UREAD        - <   355>   1426 
f3a4h: E2K_UTEST        - <   343>   1427 
f3c5h: E2K_UTYPE        - <   388>    373   1425 
f573h: E2K_WRNVR        - <   860>   1439 
fc1fh: END_SB           - <  2305>    260 
f9e4h: ERR              - <  1829>   1409   2947   2961   2964 
f948h: EXAMINE          - <  1703>   1693 
f94bh: EXLOOP1          - <  1705>   1738 
f95ch: EXLOOP2          - <  1718>   1727 
f9e0h: FAILS            - <  1825>   1820   1822   1977   1982   1985   1997 
         2002   2005   2736   2744 
f8dfh: FINDNXT          - <  1607>   1600 
fe95h: FMEMDN           - <  2919>   2887 
fe90h: FMEML1           - <  2912> 
fe93h: FMEML2           - <  2914> 
fe7eh: FMEMLP           - <  2878>   2918 
fe77h: FREEMEM          - <  2872>   3065 
f830h: F_ASTODT         - <  1457> 
f833h: F_ASTOTM         - <  1458> 
ff5dh: F_ATOI           - <  3067> 
ff00h: F_BOOT           - <  3024> 
f800h: F_BREAD          - <  1421>    309 
ff6ch: F_BRKTEST        - <  3073> 
f806h: F_BTEST          - <  1423>    273 
f803h: F_BTYPE          - <  1422>    290 
ff33h: F_DIV16          - <  3049> 
ff2ah: F_DRIVE          - <  3046> 
f827h: F_DTTOAS         - <  1454> 
ff6fh: F_FINDTKN        - <  3077> 
ff57h: F_FREEMEM        - <  3065> 
ff81h: F_GETDEV         - <  3083> 
f815h: F_GETTOD         - <  1436> 
ff45h: F_HEXIN          - <  3055>   1681   1748   1761   1769 
ff48h: F_HEXOUT2        - <  3056>   1724 
ff4bh: F_HEXOUT4        - <  3057>   1712 
ff42h: F_IDEBOOT        - <  3054> 
f824h: F_IDEID          - <  1448> 
ff3ch: F_IDEREAD        - <  3052>   2959 
ff36h: F_IDERST         - <  3050>   2945 
f821h: F_IDESIZE        - <  1447> 
ff39h: F_IDEWRT         - <  3051> 
ff7bh: F_IDNUM          - <  3081> 
ff3fh: F_INITCALL       - <  3053>   1660   2935 
ff66h: F_INMSG          - <  3070> 
ff0fh: F_INPUT          - <  3037>   1673 
ff69h: F_INPUTL         - <  3071> 
ff63h: F_INTOUT         - <  3069> 
ff78h: F_ISALNUM        - <  3080> 
ff72h: F_ISALPHA        - <  3078> 
ff75h: F_ISHEX          - <  3079> 
ff5ah: F_ISNUM          - <  3066> 
ff7eh: F_ISTERM         - <  3082> 
ff15h: F_LTRIM          - <  3039>   1759   1767 
ff1bh: F_MEMCPY         - <  3041> 
ff54h: F_MINIMON        - <  3064> 
ff51h: F_MOVER          - <  3063> 
ff09h: F_MSG            - <  3035>   1669   1733   1797 
ff30h: F_MUL16          - <  3048> 
f836h: F_NVRCCHK        - <  1459> 
f81bh: F_RDNVR          - <  1438> 
ff21h: F_RDSEC          - <  3043> 
ff06h: F_READ           - <  3031>   3092 
f82dh: F_RTCTEST        - <  1456> 
ff27h: F_SEEK           - <  3045> 
ff24h: F_SEEK0          - <  3044> 
ff2dh: F_SETBD          - <  3047>   1662 
f818h: F_SETTOD         - <  1437> 
ff12h: F_STRCMP         - <  3038> 
ff18h: F_STRCPY         - <  3040> 
f82ah: F_TMTOAS         - <  1455> 
ff4eh: F_TTY            - <  3059>   1809   2520   2980   3106   3120   3123 
ff03h: F_TYPE           - <  3026>   2443 
ff0ch: F_TYPEX          - <  3036> 
ff60h: F_UINTOUT        - <  3068>   1044 
f80ch: F_UREAD          - <  1426>    304 
f812h: F_USETBD         - <  1428> 
f80fh: F_UTEST          - <  1427>    268 
f809h: F_UTYPE          - <  1425>    292 
f81eh: F_WRNVR          - <  1439> 
ff1eh: F_WRTSEC         - <  3042> 
fee0h: GETDEV           - <  3014>   3083 
f5e3h: GET_CHK          - <   966>    802 
f6ddh: GET_RD           - <  1172>   1123   1186 
fa19h: HEXGO            - <  1855>   1851 
fa1ah: HEXGO2           - <  1856>   1854 
fa00h: HEXIN            - <  1839>   3055 
fa47h: HEXOUT2          - <  1897>   3056 
fa4ch: HEXOUT4          - <  1901>   3057 
fa75h: HEXOUTAL         - <  1932>   1922 
fa54h: HEXOUTL2         - <  1906>   1919 
fa6ch: HEXOUTL3         - <  1925>   1934 
fa4eh: HEXOUTLP         - <  1902>   1930 
fe6fh: IDDEC            - <  2860>   2843 
fbaah: IDEERROR         - <  2202>   2211   2255 
f73bh: IDENT_GO         - <  1252>   1248 
fb61h: IDERET           - <  2141>   2155   2185 
fb30h: IDE_ERR          - <  2106>   2065   2088   2103 
fb69h: IDE_FAIL         - <  2149>   2115   2119   2138   2163   2167 
fb2dh: IDE_GOOD         - <  2104> 
f728h: IDE_ID           - <  1243>   1234 
f716h: IDE_IDENT        - <  1229>   1448 
fb82h: IDE_READ         - <  2168>   1267 
f765h: IDE_SIZE         - <  1294>   1447 
fe73h: IDHEX            - <  2862>   2856   2858 
fe4eh: IDLP1            - <  2840>   2828   2846 
fe5ah: IDLP2            - <  2848>   2854 
fe37h: IDNUM            - <  2821>   3081 
fe41h: IDNUMNO          - <  2829>   2851   2859 
fe44h: IDNUMYES         - <  2831>   2861   2863 
f735h: ID_MASTER        - <  1249>   1244 
fd00h: INITCALL         - <  2528>   3053 
ffa8h: INPCNT           - <  3108>   3101   3103 
ffc5h: INPDONE          - <  3128>   3099 
ffc8h: INPDONE2         - <  3130>   3139 
ff8bh: INPLP            - <  3091>   3114   3124   3127 
ffcfh: INPTERM          - <  3137>   3095 
ff84h: INPUT            - <  3085>   2972   3071 
feceh: INPUT256         - <  2968>   3037 
f8f1h: INTDONE          - <  1620>   1609 
f889h: INTOUT           - <  1538>   3069 
f5fbh: INTOUT2          - <   994>   1024   1030   1064   1070   1076 
f609h: INTOUT2GO        - <  1004>   1001 
f600h: INTOUT2LP        - <   999>   1003 
fdddh: ISALNUM          - <  2729>   2743   3080 
fa9bh: ISALPHA          - <  1975>   2734   3078 
ffafh: ISBS             - <  3113>   3097 
fab4h: ISHEX            - <  1992>   2853   3079 
f9d4h: ISNUM            - <  1818>   1479   1493   1993   2731   2827   2845 
         3066 
fa1eh: ISNUMERIC        - <  1858>   1848 
fdedh: ISTERM           - <  2742>   2842   2850   3082 
f6e3h: IS_SEC           - <  1178>   1164 
f9b5h: LOADBUF          - <  1786>   1671   1677   1710   1731 
fd2bh: LTRIM            - <  2568>   1141   2573   3039 
f913h: MAINLP           - <  1664>   1695   1739   1742   1784 
f6f5h: MASTER           - <  1193>   1250   1300 
fd3fh: MEMCPY           - <  2583>   2591   3041 
fd46h: MEMCPY1          - <  2587>   2584 
f900h: MINIMON          - <  1644>   3064 
f9a5h: MOVELP           - <  1774>   1783 
fadah: MOVER            - <  2026>   3063 
fae8h: MOVERLP          - <  2040>   2047   2052 
fd4ch: MUL16            - <  2595>   3048 
f880h: MUL2             - <  1525>   1500   1502   1512 
fd5ah: MULCONT          - <  2606>   2602   2604 
fd74h: MULCONT2         - <  2629>   2612 
fd53h: MULLOOP          - <  2601>   2635 
fcd5h: NOBREAK          - <  2511>   2508 
ffc1h: NOBS             - <  3125>   3112 
fccah: NOECHO           - <  2446>   2440 
f8cch: NOMORE           - <  1594>   1588 
f8d8h: NONZERO          - <  1602>   1596 
f48ch: NORTC            - <   609>    554    561 
f6d8h: NO_SEC           - <  1169>   1166 
f326h: NO_UART          - <   159>    139    151 
fee7h: NUMBERS          - <  3021>   1567   1569 
0030h: NVRDEV           - <  3006>   3014 
f597h: NVR_CHK          - <   889>    800    879   1459 
f5a7h: NVR_CHKLP        - <   901>    927 
f8b8h: NXTITER          - <  1577>   1615   1619 
f9ddh: PASSES           - <  1823>   1979   1984   1995   1999   2004   2732 
         2735   2745 
f89fh: POSITIVE         - <  1555>   1537   1541 
f9c6h: PROMPT           - <  1800>   1664   1666 
fb72h: RDIDE            - <  2157>   3052 
fb8ch: RDLOOP           - <  2176>   2180   2182 
f562h: RDNVR_DN         - <   837>    825 
f550h: RDNVR_LP         - <   824>    836 
fba3h: RDYLOOP          - <  2197>   2215 
f77ah: RDYLOOPZ         - <  1308>   1314   1316 
fbb2h: RDY_GO           - <  2209>   2199   2201 
fc87h: READ             - <  2386>   1421 
fcb1h: RECVDONE         - <  2420> 
fca3h: RECVLP           - <  2409>   2419 
fccbh: RECVLP0          - <  2447>   2411 
fca9h: RECVLP1          - <  2413>   2447 
fb00h: RESETIDE         - <  2063>   3050 
fa8dh: RET              - <  1956>   1968   2528   2532   3153   3153 
fe4dh: RETURN           - <  2839>   1807   2569   2571   2578   2586   2673 
         2978   3036 
f470h: RTC128           - <   582> 
f481h: RTC64            - <   598>    579 
f42ch: RTCRDI           - <   502>    533    537    548    558    577    644 
          650    669    676    681    686    691    696    701 
f438h: RTCTEST          - <   532>    625    719    789    861    897    940 
          969   1456 
f431h: RTCWRI           - <   513>    545    570    574    585    590    601 
          728    740    748    752    756    760    764    768    774 
f499h: RTC_ERR          - <   628>    720    790    862 
f4a3h: RTC_GO           - <   643>    626 
f49eh: RTC_NOTSET       - <   632>    648    654 
f4b9h: RTC_W1           - <   668>    672 
f942h: RUN              - <  1696> 
0004h: SCALL            - <    95>    170    174    246    532    536    544 
          547    557    569    573    576    584    589    600    624    643 
          649    668    675    680    685    690    695    700    718    727 
          739    747    751    755    759    763    767    773    788    799 
          801    860    878    880    896    939    968   1023   1029   1043 
         1063   1069   1075   1090   1101   1112   1140   1142   1153   1178 
         1193   1210   1233   1245   1249   1256   1265   1296   1299   1327 
         1478   1492   1499   1501   1511   1661   1668   1670   1672   1674 
         1676   1680   1709   1711   1723   1730   1732   1734   1747   1758 
         1760   1766   1768   1796   1808   1992   2063   2086   2101   2113 
         2117   2136   2161   2165   2442   2521   2730   2733   2742   2826 
         2841   2844   2849   2852   2944   2958   2962   2979   3091   3105 
         3119   3122 
f704h: SEL_ERR          - <  1205>   1195   1212   1240   1247   1251   1258 
fc6fh: SENDCT           - <  2364>   2361   2363 
fc67h: SENDLP           - <  2359>   2372 
fc6ch: SENDNB           - <  2362>   2359 
fc23h: SETBD1           - <  2307>   2310 
fc28h: SETBD2           - <  2311>   2314 
fc3ah: SETBD3           - <  2328>   2323 
fc2dh: SETBD4           - <  2315> 
f5c9h: SET_CHK          - <   937>    881 
f772h: SIZE_GO          - <  1301>   1298 
f7a0h: SIZE_LP1         - <  1335>   1338 
f7b4h: SIZE_LP2         - <  1351>   1354   1356 
f7c7h: SIZE_LP3         - <  1365>   1376 
f707h: SLAVE            - <  1210>   1246   1297 
0005h: SRET             - <    96>    158    160    349    374    402    492 
          506    519    594    606    613    630    634    708    777    838 
          850    883    931    960    987   1015   1052   1079   1177   1203 
         1206   1220   1285   1320   1381   1411   1484   1524   1531   1634 
         1790   1798   1827   1830   1888   1931   2105   2107   2148   2208 
         2218   2262   2347   2378   2446   2511   2524   2557   2561   2563 
         2605   2653   2786   2839   2922   3018   3136 
f910h: START            - <  1661>   1644   1646 
f985h: STOREC           - <  1747>   1744 
f97bh: STORESP          - <  1741>   1689   1746   1752 
fd0fh: STRCMP           - <  2545>   2552   3038 
fd1fh: STRCMP1          - <  2556>   2553 
fd22h: STRCMPE          - <  2558>   2547 
fd28h: STRCMPM          - <  2562>   2559 
fd37h: STRCPY           - <  2576>   2580   3040 
f751h: SWAP             - <  1269>   1241 
f754h: SWAP_LP          - <  1271>   1284 
f76fh: SZ_MASTER        - <  1299>   1295 
f790h: SZ_READY         - <  1321>   1311 
fe14h: TFGO             - <  2787>   2775   2794 
fe2bh: TFLAST           - <  2804>   2789 
fe05h: TFLOOP           - <  2774>   2803 
fe24h: TFNO             - <  2798>   2809 
fe1fh: TFNOLP           - <  2795>   2797 
fe0ah: TFRETURN         - <  2777>   2811 
fc0bh: TIMALC           - <  2276>   3047 
fc1dh: TIMALC_O         - <  2304>    172 
fc46h: TIMALC_RT        - <  2338>    248 
f63fh: TMTOAS           - <  1059>   1455 
f6dah: TM_CONT          - <  1170>   1184 
fa45h: TOBINDN          - <  1887>   1844   1860   1866 
fa2ch: TOBINGD          - <  1867>   1864 
fa2eh: TOBINGLP         - <  1868>   1878 
fa24h: TOBINGO          - <  1862>   1857 
fa04h: TOBINLP          - <  1842>   1886 
fdf6h: TOKENFUNC        - <  2760>   3077 
fcd6h: TTY              - <  2516>   2722 
fcdch: TTYEND           - <  2520> 
fcdfh: TTYFF            - <  2521>   2518 
fddah: TTYOLD           - <  2722> 
fc50h: TYPE             - <  2349>   1422 
f9cbh: TYPEINMSG        - <  1806>   1810   2522   3070 
fed7h: TYPEMSG          - <  2977>   2981   3035 
0008h: UARTDEV          - <  3001>   3014 
f300h: UART_TEST        - <   129>    171 
f887h: UINTOUT          - <  1537>   3068 
f3b1h: UREAD_LP         - <   360>    363 
f3cbh: UTYPE_LP         - <   393>    395 
fff9h: VERSION          - <  3156> 
fb9ah: WAITRDY          - <  2187>   1194   1211   1257   2064   2087   2102 
         2114   2137   2162 
f58eh: WRNVR_DN         - <   878>    867 
f57dh: WRNVR_LP         - <   866>    877 
fbc1h: WRTCMD           - <  2220>   2118   2166 
fbe6h: WRTCMD2          - <  2248>   2251 
fb33h: WRTIDE           - <  2109>   3051 
fb4fh: WRTLOOP          - <  2129>   2132   2134 
f69dh: Y2K              - <  1127>   1118 
f697h: Y4               - <  1124>   1115 
f323h: YES_UART         - <   157> 

3157 Lines assembled
0 Errors
309 Labels
Object Code:3219 bytes

