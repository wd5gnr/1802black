[00001]                   ; *******************************************************************
[00002]                   ; *** This software is copyright 2006 by Michael H Riley          ***
[00003]                   ; *** You have permission to use, modify, copy, and distribute    ***
[00004]                   ; *** this software so long as this copyright notice is retained. ***
[00005]                   ; *** This software may not be used in commercial applications    ***
[00006]                   ; *** without express written permission from the author.         ***
[00007]                   ; *******************************************************************
[00008]                   
<00000>                   #include opcodes.inc
<00001>                   .op "PUSH","R","9$1 73 8$1 73"
<00002>                   .op "POP","R","60 72 A$1 F0 B$1"
<00003>                   .op "MOV","NR","9$2 B$1 8$2 A$1"
<00004>                   .op "MOV","NW","F8 H2 B$1 F8 L2 A$1"
<00005>                   .op "BRNZ","RW","8$1 3A T2 9$1 3A T2"
<00006>                   .op "LBRNZ","RW","8$1 CA H2 L2 9$1 CA H2 L2"
<00007>                   .op "CALL","W","D4 H1 L1"
<00008>                   .op "RTN","","D5"
<00009>                   .op "SUB16","NR","8$2 52 8$1 F7 A$1 9$2 52 9$1 77 B$1"
<00010>                   .op "SHL16","N","8$1 FE A$1 9$1 7E B$1"
<00011>                   .op "SHR16","N","9$1 F6 B$1 8$1 76 A$1"
<00012>                   .op "ADD16","NR","8$2 73 60 8$1 F4 A$1 9$2 73 60 9$1 74 B$1"
<00013>                   .op "ADD16","NW","8$1 FC L2 A$1 9$1 7C H2 B$1"
<00014>                   .op "SUB16","NW","8$1 FF L2 A$1 9$1 7F H2 B$1"
<00015>                   .op "CLC","","FC 00"
<00016>                   .op "STC","","FF 00"
[00010]                   
[00011]                   ; #define ELFOS
[00012]                   ;#define PICOROM
[00013]                   #define LEVEL 2
[00014]                   ; #define ELF2K
[00015]                   
[00016]                   ; Define as 0 for default order of operations
[00017]                   ; 1 means that AND/OR is lower than = <> etc.
[00018]                   #define ANDOR_LOW_PREC 1
[00019]                   ; Set to 1 if you want the original behavior of IF blah blah GOTO being OK
[00020]                   ; Note that this turns OFF IF blah blah THEN 100
[00021]                   #define IF_OPT 0
[00022]                   ; R7 - Group 7 subroutines
[00023]                   ; R8 - GOSUB stack
[00024]                   ; R9 - Expression stack
[00025]                   ; RA - Current token
[00026]                   ; RC - Current line pointer
[00027]                   
[00044]                   #endif
[00045]                   
[00062]                   #endif
[00063]                   
[00064]                   #ifdef ELF2K
[00065]                   #define    INROM
<00000>                   #include config.inc    	; From ELF2K Rom build
<00001>                   ; DO NOT EDIT THIS FILE - EDIT CONFIG. INSTEAD!!
<00002>                   #define BOOTS	 08000H
<00003>                   #define WARMB	 (08000H+3)
<00004>                   #define HELP	 09400H
<00005>                   #define RAMPAGE	 07F00H
<00006>                   #define BIOS	 0FF00H
<00007>                   #define EBIOS	 0F800H
<00008>                   #define FORTH	 0D700H
<00009>                   #define EDTASM	 09C00H
<00010>                   #define BASIC	 0BA00H
<00011>                   #define VISUAL	 0A900H
<00012>                   #define XMODEM	 0D400H
[00067]                   #define     DATA   0100h
[00068]                   #define     BASE   BASIC
[00069]                   #define     BASE2  (BASIC+0100h)
[00070]                   #define     MSG    f_msg
[00071]                   #define     TYPE   f_type
[00072]                   #define     INPUT  f_input
[00073]                   #define     INMSG  f_inmsg
[00074] 0000:             xopenw:    equ     XMODEM
[00075] 0000:             xopenr:    equ     XMODEM+3
[00076] 0000:             xread:     equ     XMODEM+6
[00077] 0000:             xwrite:    equ     XMODEM+9
[00078] 0000:             xclosew:   equ     XMODEM+0ch
[00079] 0000:             xcloser:   equ     XMODEM+0fh
[00080] 0000:             exitaddr:  equ     WARMB
[00081]                   #endif
[00082]                   
[00098]                   #endif
[00099]                   
[00109]                   #endif
[00110]                   
<00000>                   #include    bios.inc
<00001>                   ; *******************************************************************
<00002>                   ; *** This software is copyright 2006 by Michael H Riley          ***
<00003>                   ; *** You have permission to use, modify, copy, and distribute    ***
<00004>                   ; *** this software so long as this copyright notice is retained. ***
<00005>                   ; *** This software may not be used in commercial applications    ***
<00006>                   ; *** without express written permission from the author.         ***
<00007>                   ; *******************************************************************
<00008>                   
<00011>                   #endif
<00012>                   
<00013>                   ; Define address for standard BIOS vectors
<00016>                   #endif
<00017>                   
<00018>                   ; Define address for extended BIOS vectors
<00021>                   #endif
<00022>                   
<00023>                   #ifndef TASM
<00024> 0000:             scall:      equ  r4                    ; register for SCALL
<00025> 0000:             sret:       equ  r5                    ; register for SRET
<00026>                   
<00027> 0000:             call:       equ  0ffe0h                ; depricated
<00028> 0000:             ret:        equ  0fff1h                ; depricated
<00029>                   #endif
<00030>                   
<00031> 0000:             f_boot:     equ  (BIOS+00h)            ; boot from ide device
<00032> 0000:             f_type:     equ  (BIOS+03h)            ; type 1 character to console
<00033> 0000:             f_read:     equ  (BIOS+06h)            ; read 1 character from console
<00034> 0000:             f_msg:      equ  (BIOS+09h)            ; type asciiz string to console
<00035> 0000:             f_typex:    equ  (BIOS+0ch)            ; depricated, just returns now
<00036> 0000:             f_input:    equ  (BIOS+0fh)            ; read asciiz from console
<00037> 0000:             f_strcmp:   equ  (BIOS+12h)            ; compare 2 strings
<00038> 0000:             f_ltrim:    equ  (BIOS+15h)            ; trim leading spaces
<00039> 0000:             f_strcpy:   equ  (BIOS+18h)            ; copy an asciiz string
<00040> 0000:             f_memcpy:   equ  (BIOS+1bh)            ; copy memory
<00041> 0000:             f_wrtsec:   equ  (BIOS+1eh)            ; write floppy sector (depricated)
<00042> 0000:             f_rdsec:    equ  (BIOS+21h)            ; read floppy sector (depricated)
<00043> 0000:             f_seek0:    equ  (BIOS+24h)            ; floppy seek to track 0 (depricated)
<00044> 0000:             f_seek:     equ  (BIOS+27h)            ; floopy track seek (depricated)
<00045> 0000:             f_drive:    equ  (BIOS+2ah)            ; select floppy drive (depricated)
<00046> 0000:             f_setbd:    equ  (BIOS+2dh)            ; set console baud rate
<00047> 0000:             f_mul16:    equ  (BIOS+30h)            ; 16-bit multiply
<00048> 0000:             f_div16:    equ  (BIOS+33h)            ; 16-bit division
<00049> 0000:             f_idereset: equ  (BIOS+36h)            ; reset ide device
<00050> 0000:             f_idewrite: equ  (BIOS+39h)            ; write ide sector
<00051> 0000:             f_ideread:  equ  (BIOS+3ch)            ; read ide sector
<00052> 0000:             f_initcall: equ  (BIOS+3fh)            ; initialize R4 and R5
<00053> 0000:             f_bootide:  equ  (BIOS+42h)            ; boot from ide device
<00054> 0000:             f_hexin:    equ  (BIOS+45h)            ; convert ascii number to hex
<00055> 0000:             f_hexout2:  equ  (BIOS+48h)            ; convert hex to 2-digit ascii
<00056> 0000:             f_hexout4:  equ  (BIOS+4bh)            ; convert hex to 4-digit ascii
<00057> 0000:             f_tty:      equ  (BIOS+4eh)            ; type character to console
<00058> 0000:             f_mover:    equ  (BIOS+51h)            ; program relocator
<00059> 0000:             f_minimon:  equ  (BIOS+54h)            ; mini monitor
<00060> 0000:             f_freemem:  equ  (BIOS+57h)            ; determine memory size
<00061> 0000:             F_isnum:    equ  (BIOS+5ah)            ; determine if D is numeric
<00062> 0000:             f_atoi:     equ  (BIOS+5dh)            ; convert ascii to integer
<00063> 0000:             f_uintout:  equ  (BIOS+60h)            ; convert unsigned integer to ascii
<00064> 0000:             f_intout:   equ  (BIOS+63h)            ; convert signed integer to ascii
<00065> 0000:             f_inmsg:    equ  (BIOS+66h)            ; type in-line message
<00066> 0000:             f_inputl:   equ  (BIOS+69h)            ; read limited line from console
<00067> 0000:             f_brktest:  equ  (BIOS+6ch)            ; check for serial break
<00068> 0000:             f_findtkn:  equ  (BIOS+6fh)            ; find token in a token table
<00069> 0000:             f_isalpha:  equ  (BIOS+72h)            ; determine if D is alphabetic
<00070> 0000:             f_ishex:    equ  (BIOS+75h)            ; determine if D is hexadecimal
<00071> 0000:             f_isalnum:  equ  (BIOS+78h)            ; determine if D is alpha or numeric
<00072> 0000:             f_idnum:    equ  (BIOS+7bh)            ; determine type of ascii number
<00073> 0000:             f_isterm:   equ  (BIOS+7eh)            ; determine if D is a termination char
<00074> 0000:             f_getdev:   equ  (BIOS+81h)            ; get supported devices
<00075>                   
<00076> 0000:             f_version:  equ  (BIOS+0f9h)           ; 3 bytes holding bios version number
<00077>                   
<00078>                   ; "Extended" BIOS vectors
<00079>                   
<00080> 0000:             f_bread:     equ  (EBIOS+00h)        ; read from onboard serial port
<00081> 0000:             f_btype:     equ  (EBIOS+03h)        ; write to onboard serial port
<00082> 0000:             f_btest:     equ  (EBIOS+06h)        ; test onboard serial port
<00083> 0000:             f_utype:     equ  (EBIOS+09h)        ; write to disk board UART
<00084> 0000:             f_uread:     equ  (EBIOS+0ch)        ; read from disk board UART
<00085> 0000:             f_utest:     equ  (EBIOS+0fh)        ; test disk board UART
<00086> 0000:             f_usetbd:    equ  (EBIOS+12h)        ; set disk board UART baud rate and format
<00087> 0000:             f_gettod:    equ  (EBIOS+15h)        ; read time of day clock
<00088> 0000:             f_settod:    equ  (EBIOS+18h)        ; set time of day clock
<00089> 0000:             f_rdnvr:     equ  (EBIOS+1bh)        ; read non volatile RAM
<00090> 0000:             f_wrnvr:     equ  (EBIOS+1eh)        ; write non volatile RAM
<00091> 0000:             f_idesize:   equ  (EBIOS+21h)        ; return size of attached IDE drive(s)
<00092> 0000:             f_ideid:     equ  (EBIOS+24h)        ; return device data for IDE drive(s)
<00093> 0000:             f_tmtoas:    equ  (EBIOS+2ah)        ; time to ASCII string
<00094> 0000:             f_dttoas:    equ  (EBIOS+27h)        ; date to ASCII string
<00095> 0000:             f_rtctest:   equ  (EBIOS+2dh)        ; test size and presence of RTC/NVR
<00096> 0000:             f_astodt:    equ  (EBIOS+30h)        ; convert ASCII string to date
<00097> 0000:             f_astotm:    equ  (EBIOS+33h)        ; convert ASCII string to time
<00098> 0000:             f_nvrcchk:   equ  (EBIOS+36h)	    ; [RLA] compute NVR checksum
<00099>                   
<00100>                   
[00112]                   
[00113] 0000:             TKN_USTR:  equ     0fch
[00114] 0000:             TKN_QSTR:  equ     0fdh
[00115] 0000:             TKN_NUM:   equ     0feh
[00116] 0000:             TKN_TERM:  equ     0ffh
[00117]                   
[00118] 0000:             ERR_BREAK:  equ    0
[00119] 0000:             ERR_DIRECT: equ    1
[00120] 0000:             ERR_SYN:    equ    2
[00121] 0000:             ERR_NOLIN:  equ    3
[00122] 0000:             ERR_INVRET: equ    4
[00123] 0000:             ERR_VAL:    equ    5
[00124] 0000:             ERR_FILE:   equ    6
[00125] 0000:             ERR_INVLP:  equ    7
[00126] 0000:             ERR_NOFOR:  equ    8
[00127] 0000:             ERR_NODATA: equ    9
[00128] 0000:             ERR_NOMEM:  equ     10
[00129] 0000:             ERR_BADDIM: equ     11
[00130] 0000:             ERR_UNSUP:  equ     12
[00131]                   
[00132] 0000:             CMD_START:  equ    26
[00133]                   
[00134]                   
[00153]                   #endif
[00154]                   
[00155] 0000:                        org     BASE
[00156]                   
[00162]                   #else
[00163] ba00: c0 d3 c2               lbr     begin               ; jump to program start
[00164] ba03: c0 d3 b2               lbr     begin2
[00165]                   #endif
[00166]                   
[00167] ba06: d3                     sep     r3                  ; return to caller
[00168] ba07: 43          group_7:   lda     r3                  ; retrieve get subcode
[00169] ba08: a7                     plo     r7                  ; and jump to it
[00170] ba09: f8 01       set_buf:   ldi     high buffer         ; point to input buffer
[00171] ba0b: bf                     phi     rf
[00172] ba0c: f8 b3                  ldi     low buffer
[00173] ba0e: af                     plo     rf
[00174] ba0f: 30 06                  br      group_7-1           ; and return
[00175] ba11: f8 03       set_tkn:   ldi     high tokens         ; point to input buffer
[00176] ba13: ba                     phi     ra
[00177] ba14: f8 b5                  ldi     low tokens
[00178] ba16: aa                     plo     ra
[00179] ba17: 30 06                  br      group_7-1           ; and return
[00180]                   
[00181]                   ; ***************************************
[00182]                   ; *** Find a line                     ***
[00183]                   ; *** RD - line number to find        ***
[00184]                   ; *** Returns - RC - address of line  ***
[00185]                   ; ***           DF=1 - exact match    ***
[00186]                   ; ***           DF=0 - line is higher ***
[00187]                   ; ***************************************
[00188] ba19: f8 05       find_ln:   ldi     high basic          ; point to beginning of basic storage
[00189] ba1b: bc                     phi     rc
[00190] ba1c: f8 b7                  ldi     low basic
[00191] ba1e: ac                     plo     rc
[00192] ba1f: 4c          find_lp:   lda     rc                  ; get line size
[00193] ba20: 32 43                  bz      find_eof            ; jump if no more lines
[00194] ba22: 1c                     inc     rc                  ; point to lsb
[00195] ba23: ec                     sex     rc                  ; point data to line number
[00196] ba24: 8d                     glo     rd                  ; get requested line
[00197] ba25: f7                     sm                          ; and subtract
[00198] ba26: ae                     plo     re                  ; save result
[00199] ba27: 2c                     dec     rc                  ; point to msb
[00200] ba28: 9d                     ghi     rd                  ; get msb of search line
[00201] ba29: 77                     smb                         ; complete comparison
[00202] ba2a: e2                     sex     r2                  ; point X back to stack
[00203] ba2b: 52                     str     r2                  ; place into memory
[00204] ba2c: 8e                     glo     re                  ; get previous result
[00205] ba2d: f1                     or                          ; and or them together
[00206] ba2e: 32 3e                  bz      find_ex             ; found an exact match
[00207] ba30: 3b 43                  bnf     find_eof            ; jump if line was high
[00208] ba32: 2c                     dec     rc                  ; point to line size
[00209] ba33: ec                     sex     rc                  ; point to size
[00210] ba34: 8c                     glo     rc                  ; and add into line position
[00211] ba35: f4                     add
[00212] ba36: ac                     plo     rc
[00213] ba37: 9c                     ghi     rc                  ; propogate carry
[00214] ba38: 7c 00                  adci    0
[00215] ba3a: bc                     phi     rc
[00216] ba3b: e2                     sex     r2                  ; point X back to stack
[00217] ba3c: 30 1f                  br      find_lp             ; and keep searching
[00218] ba3e: 2c          find_ex:   dec     rc                  ; point back to line size
[00219] ba3f: ff 00                  smi     0                   ; signal exact match
[00220] ba41: 30 06                  br      group_7-1           ; and return
[00221] ba43: 2c          find_eof:  dec     rc                  ; last position is pointer
[00222] ba44: fc 00                  adi     0                   ; signal line is higher/non existant
[00223] ba46: 30 06                  br      group_7-1           ; return to caller
[00224]                   ; ******************************************
[00225]                   ; *** Find next basic line               ***
[00226]                   ; *** RC - pointer to basic line         ***
[00227]                   ; *** Returns: RF - pointer to next line ***
[00228]                   ; ******************************************
[00229] ba48: ec          next_ln:   sex     rc                  ; use rc as data pointer
[00230] ba49: 8c                     glo     rc                  ; get current low pointer
[00231] ba4a: f4                     add                         ; and add in offset
[00232] ba4b: af                     plo     rf                  ; place into rf
[00233] ba4c: 9c                     ghi     rc                  ; get msb of address
[00234] ba4d: 7c 00                  adci    0                   ; propagate carry
[00235] ba4f: bf                     phi     rf                  ; rf now points to next line
[00236] ba50: e2                     sex     r2                  ; point x back to stack
[00237] ba51: 30 06                  br      group_7-1           ; return to caller
[00238]                   
[00239]                   ; **************************************
[00240]                   ; *** Add inline character to buffer ***
[00241]                   ; *** RF - buffer                    ***
[00242]                   ; **************************************
[00243] ba53: 43          add_char:  lda     r3                  ; get byte to add to buffer
[00244] ba54: 5f                     str     rf                  ; store into buffer
[00245] ba55: 1f                     inc     rf                  ; increment it
[00246] ba56: 30 06                  br      group_7-1           ; and return to caller
[00247]                   
[00248] ba58: e9          ex_pop:    sex     r9                  ; point X to expression stack
[00249] ba59: 60                     irx                         ; recover value
[00250] ba5a: 72                     ldxa
[00251] ba5b: bf                     phi     rf
[00252] ba5c: f0                     ldx
[00253] ba5d: af                     plo     rf
[00254] ba5e: e2                     sex     r2                  ; point x back to proper stack
[00255] ba5f: 30 06                  br      group_7-1
[00256]                   
[00257] ba61: e9          ex_pop_rd: sex     r9                  ; point X to expression stack
[00258] ba62: 60                     irx                         ; recover value
[00259] ba63: 72                     ldxa
[00260] ba64: bd                     phi     rd
[00261] ba65: f0                     ldx
[00262] ba66: ad                     plo     rd
[00263] ba67: e2                     sex     r2                  ; point x back to proper stack
[00264] ba68: 30 06                  br      group_7-1
[00265]                   
[00266] ba6a: e9          ex_push:   sex     r9                  ; point X to expression stack
[00267] ba6b: 8f                     glo     rf                  ; place RF onto it
[00268] ba6c: 73                     stxd
[00269] ba6d: 9f                     ghi     rf
[00270] ba6e: 73                     stxd
[00271] ba6f: e2                     sex     r2                  ; reset x back to main stack
[00272] ba70: 30 06                  br      group_7-1
[00273]                   
[00274] ba72: 9f          rf_rd:     ghi     rf                  ; copy rf to rd
[00275] ba73: bd                     phi     rd
[00276] ba74: 8f                     glo     rf
[00277] ba75: ad                     plo     rd
[00278] ba76: 30 06                  br      group_7-1
[00279]                   
[00280] ba78: f8 00       get_flags: ldi     0                   ; start with zero
[00281] ba7a: 3c 7e                  bn1     no_ef1              ; jump if ef1 not asserted
[00282] ba7c: f9 01                  ori     1                   ; indicate set
[00283] ba7e: 3d 82       no_ef1:    bn2     no_ef2              ; jump if ef2 not asserted
[00284] ba80: f9 02                  ori     2                   ; indicate set
[00285] ba82: 3e 86       no_ef2:    bn3     no_ef3              ; jump if ef2 not asserted
[00286] ba84: f9 04                  ori     4                   ; indicate set
[00287] ba86: 3f 06       no_ef3:    bn4     group_7-1           ; jump if ef2 not asserted
[00288] ba88: f9 08                  ori     8                   ; indicate set
[00289] ba8a: 30 06                  br      group_7-1
[00290]                   
[00291]                   ; ************************************
[00292]                   ; *** process statement jump table ***
[00293]                   ; ************************************
[00294] ba8c: 8f          do_cmd:    glo     rf                  ; get command
[00295] ba8d: fe                     shl                         ; multiply command by 2
[00296] ba8e: 52                     str     r2                  ; prepare for add
[00297] ba8f: f8 00                  ldi     low cmd_table       ; lsb of command table address
[00298] ba91: f4                     add                         ; add in command offset
[00299] ba92: a3                     plo     r3                  ; place into R3
[00300] ba93: f8 bb                  ldi     high cmd_table      ; msb of command table
[00301] ba95: b3                     phi     r3                  ; r3 now has command
[00302] ba96: 43                     lda     r3                  ; read command address
[00303] ba97: ae                     plo     re
[00304] ba98: 03                     ldn     r3
[00305] ba99: a3                     plo     r3
[00306] ba9a: 8e                     glo     re
[00307] ba9b: b3                     phi     r3
[00308] ba9c: 30 06                  br      group_7-1
[00309]                   
[00310] ba9e: 8f          push_rf:   glo     rf
[00311] ba9f: 73                     stxd
[00312] baa0: 9f                     ghi     rf
[00313] baa1: 73                     stxd
[00314] baa2: 30 06                  br      group_7-1
[00315]                   
[00316] baa4: 60          pop_rf:    irx
[00317] baa5: 72                     ldxa
[00318] baa6: bf                     phi     rf
[00319] baa7: f0                     ldx
[00320] baa8: af                     plo     rf
[00321] baa9: 30 06                  br      group_7-1
[00322]                   
[00323] baab: 8b          push_rb:   glo     rb
[00324] baac: 73                     stxd
[00325] baad: 9b                     ghi     rb
[00326] baae: 73                     stxd
[00327] baaf: 30 06                  br      group_7-1
[00328]                   
[00329] bab1: 60          pop_rb:    irx
[00330] bab2: 72                     ldxa
[00331] bab3: bb                     phi     rb
[00332] bab4: f0                     ldx
[00333] bab5: ab                     plo     rb
[00334] bab6: 30 06                  br      group_7-1
[00335]                   
[00336] bab8: 8d          push_rd:   glo     rd
[00337] bab9: 73                     stxd
[00338] baba: 9d                     ghi     rd
[00339] babb: 73                     stxd
[00340] babc: 30 06                  br      group_7-1
[00341]                   
[00342] babe: 60          pop_rd:    irx
[00343] babf: 72                     ldxa
[00344] bac0: bd                     phi     rd
[00345] bac1: f0                     ldx
[00346] bac2: ad                     plo     rd
[00347] bac3: 30 06                  br      group_7-1
[00348]                   
[00349] bac5: 43          set_byte:  lda     r3                  ; get msb of address
[00350] bac6: bf                     phi     rf                  ; place into RF
[00351] bac7: 43                     lda     r3
[00352] bac8: af                     plo     rf
[00353] bac9: 43          byte_go:   lda     r3                  ; get value
[00354] baca: 5f                     str     rf                  ; and store
[00355] bacb: 30 06                  br      group_7-1
[00356]                   
[00357] bacd: 43          set_word:  lda     r3                  ; get msb of address
[00358] bace: bf                     phi     rf                  ; place into RF
[00359] bacf: 43                     lda     r3
[00360] bad0: af                     plo     rf
[00361] bad1: 43                     lda     r3                  ; get value
[00362] bad2: 5f                     str     rf                  ; and store
[00363] bad3: 1f                     inc     rf
[00364] bad4: 30 c9                  br      byte_go
[00365]                   
[00366] bad6: 43          set_rf:    lda     r3                  ; get msb
[00367] bad7: bf                     phi     rf                  ; place into rf
[00368] bad8: 43                     lda     r3
[00369] bad9: af                     plo     rf
[00370] bada: 30 06                  br      group_7-1
[00371]                   
[00372] badc: 43          get_rb:    lda     r3                  ; get msb of address
[00373] badd: bb                     phi     rb
[00374] bade: 43                     lda     r3
[00375] badf: ab                     plo     rb
[00376] bae0: 4b                     lda     rb                  ; retrieve it
[00377] bae1: ae                     plo     re
[00378] bae2: 0b                     ldn     rb
[00379] bae3: ab                     plo     rb
[00380] bae4: 8e                     glo     re
[00381] bae5: bb                     phi     rb                  ; rb is not pointing to for stack
[00382] bae6: 30 06                  br      group_7-1
[00383]                   
[00384] bae8: 96          func_call: ghi     r6                  ; save last value to stack
[00385] bae9: 73                     stxd
[00386] baea: 86                     glo     r6
[00387] baeb: 73                     stxd
[00388] baec: 93                     ghi     r3                  ; copy R3 to R6
[00389] baed: b6                     phi     r6
[00390] baee: 83                     glo     r3
[00391] baef: a6                     plo     r6
[00392] baf0: 48                     lda     r8                  ; get function address
[00393] baf1: b3                     phi     r3                  ; and put into r3
[00394] baf2: 48                     lda     r8
[00395] baf3: a3                     plo     r3
[00396] baf4: 30 06                  br      group_7-1           ; now execute it
[00397]                   
[00398]                   ; ***************************************************************************
[00399]                   ; ***                    End of group 7 subroutines                       ***
[00400]                   ; ***************************************************************************
[00401]                   
[00402]                   	;; This is the command table
[00403]                   	;; tokens vector here and anything that is not
[00404]                   	;; really a command (like MID$) should define syn_err here
[00405]                   	;; We need to know about the string functions so the count
[00406]                   	;; is computed here
[00407]                   	;; in functable (below) everything before PRINT is a real function
[00408]                   	;; Everything from PRINT on down is a command
[00409]                   
[00410] baf6:                        org     BASE2
[00411] bb00: cc 5d       cmd_table: dw      ex_print            ; 0
[00412] bb02: cc 5d                  dw      ex_print            ; 1
[00413] bb04: ca af                  dw      ex_let              ; 2
[00414] bb06: ca 03                  dw      ex_goto             ; 3
[00415] bb08: ca 2d                  dw      ex_if               ; 4
[00416] bb0a: d3 84                  dw      syn_err             ; 5 (THEN)
[00417] bb0c: c9 d8                  dw      ex_end              ; 6
[00418] bb0e: c9 df                  dw      ex_gosub            ; 7
[00419] bb10: cc c4                  dw      ex_return           ; 8
[00420] bb12: d3 68                  dw      exec_dn             ; 9 (REM)
[00421] bb14: ca 4c                  dw      ex_input            ; 10
[00422] bb16: cc 39                  dw      ex_poke             ; 11
[00423] bb18: cb c2                  dw      ex_out              ; 12
[00424] bb1a: cb f0                  dw      ex_plot             ; 13
[00425] bb1c: cc e8                  dw      ex_run              ; 14
[00426] bb1e: ca ec                  dw      ex_list             ; 15
[00427] bb20: cb b3                  dw      ex_new              ; 16
[00428]                   #if LEVEL>=2
[00429] bb22: cd ac                  dw      ex_for              ; 17
[00430] bb24: d3 84                  dw      syn_err             ; 18 (TO)
[00431] bb26: ce 98                  dw      ex_next             ; 19
[00432] bb28: d3 84                  dw      syn_err             ; 20 (NEXT)
[00433] bb2a: cf 59                  dw      ex_on               ; 21
[00434] bb2c: d3 68                  dw      exec_dn             ; 22 (DATA)
[00435] bb2e: cf b4                  dw      ex_read             ; 23
[00436] bb30: cf ec                  dw      ex_restore          ; 24
[00437] bb32: d2 42                  dw      ex_dim              ; 25
[00438] bb34: cf 98                  dw      ex_random           ; 26
[00439] bb36: d3 84                  dw      syn_err             ; 27 (VARPTR)
[00440] bb38: cd a6                  dw      ex_clear            ; 28
[00441] bb3a: d3 84                  dw      syn_err             ; 29 (LEN)
[00442] bb3c: d3 84                  dw      syn_err             ; 30 (ASC)
[00443] bb3e: d3 84                  dw      syn_err             ; 31 (VAL)
[00444]                   startstrfunc:
[00445] bb40: d3 84                  dw      syn_err             ; 32 (STR)
[00446] bb42: d3 84                  dw      syn_err             ; 33 (CHR)
[00447] bb44: d3 84                  dw      syn_err             ; 34 (LEFT)
[00448] bb46: d3 84                  dw      syn_err             ; 35 (RIGHT)
[00449] bb48: d3 84                  dw      syn_err             ; 36 (MID)
[00450] bb4a: d3 84       	   dw      syn_err             ; 37 (HEX)
[00451]                   endstrfunc:
[00452]                   #endif
[00453] bb4c: cd 34                  dw      ex_bye              ; 21
[00457]                   #endif
[00458]                   #ifdef INROM
[00459] bb4e: cd 37                  dw      ex_save             ; 22
[00460] bb50: cd 74                  dw      ex_load             ; 23
[00461]                   #endif
[00462]                   
[00463] bb52:             strfuncct:	equ (endstrfunc-startstrfunc)/2
[00464]                   
[00465]                   
[00466] bb52: f8 0c       restart:   ldi     0ch                 ; form feed
[00467] bb54: d4                     sep     scall               ; clear the screen
[00470]                   #else
[00471] bb55: ff 03                  dw      f_type
[00472]                   #endif
[00473] bb57: d4                     sep     scall               ; display welcome message
[00476]                   #else
[00477] bb58: ff 66                  dw      f_inmsg
[00478]                   #endif
[00481]                   #endif
[00482]                   #if LEVEL==2
[00483] bb5a: 52 43 2f 42            db      'RC/Basic L2',10,13
              61 73 69 63 
              20 4c 32 0a 
              0d 
[00484]                   #endif
[00485] bb67: 28 63 29 20            db      '(c) Copyright 2006 by Michael H. Riley',10,13,10,13,0
              43 6f 70 79 
              72 69 67 68 
              74 20 32 30 
              30 36 20 62 
              79 20 4d 69 
              63 68 61 65 
              6c 20 48 2e 
              20 52 69 6c 
              65 79 0a 0d 
              0a 0d 00 
[00488]                   #endif
[00489] bb92: f8 ba                  ldi     high group_7        ; setup group 7 subroutines
[00490] bb94: b7                     phi     r7
[00491] bb95: f8 07                  ldi     low group_7
[00492] bb97: a7                     plo     r7
[00499]                   #else
[00500] bb98: d4                     sep     scall               ; call bios to get end of memory
[00501] bb99: ff 57                  dw      f_freemem
[00502]                   #endif
[00503] bb9b: f8 00                  ldi     0                   ; zero terminator in heap memory
[00504] bb9d: 5f                     str     rf
[00505] bb9e: f8 01                  ldi     high memory         ; point to high memory storage
[00506] bba0: bd                     phi     rd
[00507] bba1: f8 00                  ldi     low memory
[00508] bba3: ad                     plo     rd
[00509] bba4: 9f                     ghi     rf                  ; store heap address
[00510] bba5: 5d                     str     rd
[00511] bba6: 1d                     inc     rd
[00512] bba7: 8f                     glo     rf
[00513] bba8: 5d                     str     rd
[00514] bba9: d4                     sep     scall               ; setup variable table
[00515] bbaa: bf 36                  dw      rst_vars
[00516] bbac: c0 bc 13               lbr     mainlp
[00517]                   
[00518] bbaf: d4          start:     sep     scall               ; display welcome message
[00519]                   #ifndef ELFOS
[00520]                   ;           dw      f_setbd
[00521]                   ;           sep     scall               ; display welcome message
[00522]                   #endif
[00523] bbb0: ff 66                  dw      INMSG
[00526]                   #endif
[00527]                   #if LEVEL==2
[00528] bbb2: 52 43 2f 42            db      'RC/Basic L2',10,13
              61 73 69 63 
              20 4c 32 0a 
              0d 
[00529]                   #endif
[00530] bbbf: 28 63 29 20            db      '(c) Copyright 2006 by Michael H. Riley',10,13,10,13,0
              43 6f 70 79 
              72 69 67 68 
              74 20 32 30 
              30 36 20 62 
              79 20 4d 69 
              63 68 61 65 
              6c 20 48 2e 
              20 52 69 6c 
              65 79 0a 0d 
              0a 0d 00 
[00537]                   #else
[00538] bbea: d4          picostrt:  sep     scall               ; call bios to get end of memory
[00539] bbeb: ff 57                  dw      f_freemem
[00540]                   #endif
[00541] bbed: f8 01                  ldi     high memory         ; point to high memory storage
[00542] bbef: bd                     phi     rd
[00543] bbf0: f8 00                  ldi     low memory
[00544] bbf2: ad                     plo     rd
[00545] bbf3: 9f                     ghi     rf                  ; store heap address
[00546] bbf4: 5d                     str     rd
[00547] bbf5: 1d                     inc     rd
[00548] bbf6: 8f                     glo     rf
[00549] bbf7: 5d                     str     rd
[00550] bbf8: f8 ba                  ldi     high group_7        ; setup group 7 subroutines
[00551] bbfa: b7                     phi     r7
[00552] bbfb: f8 07                  ldi     low group_7
[00553] bbfd: a7                     plo     r7
[00554] bbfe: d7                     sep     r7                  ; mark no program loaded
[00555] bbff: cd                     db      set_word.0
[00556] bc00: 05 b7                  dw      basic
[00557] bc02: 00 00                  dw      0
[00558] bc04: d7                     sep     r7                  ; set initial value in lfsr
[00559] bc05: cd                     db      set_word.0
[00560] bc06: 01 5d                  dw      lfsr
[00561] bc08: 00 00                  dw      0
[00562] bc0a: d7                     sep     r7                  ; set initial value in lfsr
[00563] bc0b: cd                     db      set_word.0
[00564] bc0c: 01 5f                  dw      (lfsr+2)
[00565] bc0e: 00 01                  dw      1
[00566] bc10: d4                     sep     scall               ; setup variable table
[00567] bc11: bf 36                  dw      rst_vars
[00568]                   
[00569] bc13: d4          mainlp:    sep     scall               ; display prompt
[00570] bc14: ff 66                  dw      INMSG
[00571] bc16: 3e 00                  db      '>',0
[00572] bc18: d7                     sep     r7                  ; setup input buffer
[00573] bc19: 09                     db      set_buf.0
[00574] bc1a: d4                     sep     scall               ; get input from user
[00575] bc1b: ff 0f                  dw      INPUT
[00576] bc1d: d4                     sep     scall               ; setup CR/LF
[00577] bc1e: bd 71                  dw      do_crlf
[00578] bc20: d7                     sep     r7                  ; setup input buffer
[00579] bc21: 09                     db      set_buf.0
[00580] bc22: d4                     sep     scall               ; convert to uppercase
[00581] bc23: d3 d2                  dw      touc
[00582] bc25: d7                     sep     r7                  ; setup input buffer
[00583] bc26: 09                     db      set_buf.0
[00584] bc27: d7                     sep     r7                  ; setup token buffer
[00585] bc28: 11                     db      set_tkn.0
[00586] bc29: d4                     sep     scall               ; tokenize input
[00587] bc2a: bf 67                  dw      tokenize
[00588] bc2c: 9a                     ghi     ra                  ; save ending of tokens
[00589] bc2d: bb                     phi     rb
[00590] bc2e: 8a                     glo     ra
[00591] bc2f: ab                     plo     rb
[00592] bc30: d7                     sep     r7                  ; setup token buffer
[00593] bc31: 11                     db      set_tkn.0
[00594] bc32: 0a                     ldn     ra                  ; get first token
[00595] bc33: ff fe                  smi     TKN_NUM             ; is it numeric
[00596] bc35: c2 be 7f               lbz     insert_ln           ; need to insert new line
[00597] bc38: f8 00                  ldi     0                   ; no current line
[00598] bc3a: ac                     plo     rc
[00599] bc3b: bc                     phi     rc
[00600] bc3c: d7                     sep     r7                  ; set token address into RA
[00601] bc3d: 11                     db      set_tkn.0
[00602] bc3e: d4                     sep     scall               ; execute commands
[00603] bc3f: d3 39                  dw      execute
[00604] bc41: c3 bc 4d               lbdf    error               ; jump if error occurred
[00605] bc44: d4                     sep     scall               ; display error message
[00606] bc45: ff 66                  dw      INMSG
[00607] bc47: 0a 0d 00               db      10,13,0
[00608] bc4a: c0 bc 13               lbr     mainlp              ; back to main loop
[00609] bc4d: ad          error:     plo     rd                  ; put error code into RD
[00610] bc4e: f8 00                  ldi     0                   ; high byte is zero
[00611] bc50: bd                     phi     rd
[00612] bc51: d4                     sep     scall               ; display error message
[00613] bc52: ff 66                  dw      INMSG
[00614] bc54: 0a 0d 45 52            db      10,13,'ERROR:',0
              52 4f 52 3a 
              00 
[00615] bc5d: d7                     sep     r7                  ; setup buffer
[00616] bc5e: 09                     db      set_buf.0
[00617] bc5f: d4                     sep     scall               ; convert error code
[00618] bc60: ff 60                  dw      f_uintout
[00619] bc62: f8 00                  ldi     0                   ; terminate error code
[00620] bc64: 5f                     str     rf
[00621] bc65: d7                     sep     r7                  ; setup buffer
[00622] bc66: 09                     db      set_buf.0
[00623] bc67: d4                     sep     scall               ; display error code
[00624] bc68: ff 09                  dw      MSG
[00625] bc6a: 8c                     glo     rc                  ; see if program was running
[00626] bc6b: ca bc 7b               lbnz    was_run
[00627] bc6e: 9c                     ghi     rc
[00628] bc6f: ca bc 7b               lbnz    was_run
[00629] bc72: d4          error_cnt: sep     scall               ; display error message
[00630] bc73: ff 66                  dw      INMSG
[00631] bc75: 0a 0d 00               db      10,13,0
[00632] bc78: c0 bc 13               lbr     mainlp
[00633] bc7b: d4          was_run:   sep     scall               ; add to error message
[00634] bc7c: ff 66                  dw      INMSG
[00635] bc7e: 20 69 6e 20            db      ' in line ',0
              6c 69 6e 65 
              20 00 
[00636] bc88: 1c                     inc     rc                  ; move past line size
[00637] bc89: 4c                     lda     rc                  ; get line number
[00638] bc8a: bd                     phi     rd
[00639] bc8b: 0c                     ldn     rc
[00640] bc8c: ad                     plo     rd
[00641] bc8d: d7                     sep     r7                  ; setup buffer
[00642] bc8e: 09                     db      set_buf.0
[00643] bc8f: d4                     sep     scall               ; convert error code
[00644] bc90: ff 60                  dw      f_uintout
[00645] bc92: f8 00                  ldi     0                   ; terminate error code
[00646] bc94: 5f                     str     rf
[00647] bc95: d7                     sep     r7                  ; setup buffer
[00648] bc96: 09                     db      set_buf.0
[00649] bc97: d4                     sep     scall               ; display error code
[00650] bc98: ff 09                  dw      MSG
[00651] bc9a: c0 bc 72               lbr     error_cnt           ; then continue
[00652]                   
[00653]                   
[00654]                   
[00655]                   ; ******************************************************************************
[00656]                   ; ***                    Start of utility functions                          ***
[00657]                   ; ******************************************************************************
[00658]                   
[00659]                   ; **************************************************
[00660]                   ; *** Find end of basic program area             ***
[00661]                   ; *** Returns: RF - pointing to terminating null ***
[00662]                   ; **************************************************
[00663] bc9d: d7          bas_end:   sep     r7                  ; point to basic program area
[00664] bc9e: d6                     db      set_rf.0
[00665] bc9f: 05 b7                  dw      basic
[00666] bca1: 0f          bas_endlp: ldn     rf                  ; see if at end
[00667] bca2: ca bc a6               lbnz    bas_end2            ; jump if not
[00668] bca5: d5                     sep     sret                ; return to caller
[00669] bca6: ef          bas_end2:  sex     rf                  ; need to add in offset
[00670] bca7: 8f                     glo     rf
[00671] bca8: f4                     add
[00672] bca9: af                     plo     rf
[00673] bcaa: 9f                     ghi     rf                  ; propagate carry
[00674] bcab: 7c 00                  adci    0
[00675] bcad: bf                     phi     rf
[00676] bcae: e2                     sex     r2                  ; point X back to stack
[00677] bcaf: c0 bc a1               lbr     bas_endlp           ; loop until end is found
[00678]                   
[00679]                   ; *********************************************
[00680]                   ; *** copy tokenized line into basic memory ***
[00681]                   ; *** RA - tokenized line pointer           ***
[00682]                   ; *** RC - basic memory pointer             ***
[00683]                   ; *** RF.0 - count of bytes                 ***
[00684]                   ; *********************************************
[00685] bcb2: 8f          copy_ln:   glo     rf                  ; get count
[00686] bcb3: fc 01                  adi     1                   ; 1 higher
[00687] bcb5: 5c                     str     rc                  ; store into buffer
[00688] bcb6: 1c                     inc     rc
[00689] bcb7: 4a          copy_lp:   lda     ra                  ; get byte from tokenized line
[00690] bcb8: 5c                     str     rc                  ; store into basic buffer
[00691] bcb9: 1c                     inc     rc
[00692] bcba: 2f                     dec     rf                  ; decrement count
[00693] bcbb: 8f                     glo     rf                  ; need to see if done
[00694] bcbc: ca bc b7               lbnz    copy_lp             ; jump if not
[00695] bcbf: d5          return:    sep     sret
[00696]                   
[00697]                   ; *******************************************
[00698]                   ; *** Delete line from BASIC program area ***
[00699]                   ; *******************************************
[00700] bcc0: 2a          delete_ln: dec     ra                  ; move back to line number
[00701] bcc1: 2a                     dec     ra
[00702] bcc2: 4a                     lda     ra                  ; get line
[00703] bcc3: bd                     phi     rd                  ; and setup for search
[00704] bcc4: 0a                     ldn     ra
[00705] bcc5: ad                     plo     rd
[00706] bcc6: 2a                     dec     ra                  ; ra back msb of line number
[00707] bcc7: d7                     sep     r7                  ; find line
[00708] bcc8: 19                     db      find_ln.0
[00709] bcc9: c3 bc d2               lbdf    do_delete           ; jump if line was found
[00710] bccc: d4                     sep     scall               ; setup variable table
[00711] bccd: bf 36                  dw      rst_vars
[00712] bccf: c0 bc 13               lbr     mainlp              ; nothing to delete
[00713] bcd2: 9c          do_delete: ghi     rc                  ; current line is copy destination
[00714] bcd3: bd                     phi     rd
[00715] bcd4: 8c                     glo     rc
[00716] bcd5: ad                     plo     rd
[00717] bcd6: d7                     sep     r7                  ; next line is source
[00718] bcd7: 48                     db      next_ln.0
[00719] bcd8: d4                     sep     scall               ; get size of basic block
[00720] bcd9: d3 8c                  dw      size_end
[00721] bcdb: d4                     sep     scall               ; perform the copy
[00722] bcdc: be eb                  dw      memcpy
[00723] bcde: d4                     sep     scall               ; setup variable table
[00724] bcdf: bf 36                  dw      rst_vars
[00725] bce1: c0 bc 13               lbr     mainlp              ; and back to main loop
[00726]                   
[00727]                   ; ****************************
[00728]                   ; *** Detokenize a string  ***
[00729]                   ; *** RA - pointer to line ***
[00730]                   ; *** RF - where to put    ***
[00731]                   ; ****************************
[00732] bce4: 1a          detoken:   inc     ra                  ; move past line size
[00733] bce5: 4a                     lda     ra                  ; get line number
[00734] bce6: bd                     phi     rd
[00735] bce7: 4a                     lda     ra
[00736] bce8: ad                     plo     rd
[00737] bce9: d4                     sep     scall               ; convert it to ascii
[00738] bcea: ff 60                  dw      f_uintout
[00739] bcec: d7                     sep     r7                  ; add a space
[00740] bced: 53                     db      add_char.0
[00741] bcee: 20                     db      32
[00742] bcef: 0a          detkn_lp:  ldn     ra                  ; get next byte from token stream
[00743] bcf0: c2 bd 6d               lbz     detkn_dn            ; jump if end of line
[00744] bcf3: fa 80                  ani     80h                 ; see if it is a token
[00745] bcf5: ca bc fe               lbnz    detkn_tk            ; it is
[00746] bcf8: 4a                     lda     ra                  ; if not get get it
[00747] bcf9: 5f                     str     rf                  ; and place into output
[00748] bcfa: 1f                     inc     rf
[00749] bcfb: c0 bc ef               lbr     detkn_lp            ; loop back for next
[00750] bcfe: 4a          detkn_tk:  lda     ra                  ; retrieve token
[00751] bcff: ae                     plo     re                  ; keep a copy
[00752] bd00: ff fd                  smi     TKN_QSTR            ; check for quoted string
[00753] bd02: c2 bd 57               lbz     detkn_qs            ; jump if so
[00754] bd05: ff 01                  smi     1                   ; check for number
[00755] bd07: c2 bd 4d               lbz     detkn_nm            ; jump if so
[00756] bd0a: 8e                     glo     re                  ; recover token
[00757] bd0b: fa 7f                  ani     07fh                ; strip off token bit
[00758] bd0d: ae                     plo     re                  ; re will be the counter
[00759] bd0e: f8 d3                  ldi     high functable      ; point to function table
[00760] bd10: bd                     phi     rd
[00761] bd11: f8 fc                  ldi     low functable
[00762] bd13: ad                     plo     rd
[00763] bd14: 8e          tkn_lp_1:  glo     re                  ; see if pointing at correct token
[00764] bd15: c2 bd 22               lbz     tkn_yes             ; jump if so
[00765] bd18: 2e                     dec     re                  ; decrement count
[00766] bd19: 4d          tkn_lp_2:  lda     rd                  ; get byte from token table
[00767] bd1a: fa 80                  ani     080h                ; see if last char
[00768] bd1c: c2 bd 19               lbz     tkn_lp_2            ; keep looking if not
[00769] bd1f: c0 bd 14               lbr     tkn_lp_1            ; see if at correct token
[00770] bd22: 2f          tkn_yes:   dec     rf                  ; point to previous character
[00771] bd23: 4f                     lda     rf                  ; retrieve it
[00772] bd24: d4                     sep     scall               ; see if alphanumeric
[00773] bd25: ff 78                  dw      f_isalnum
[00774] bd27: cb bd 36               lbnf    tkn_yes_l           ; jump if not
[00775] bd2a: 0d                     ldn     rd                  ; see what first char of token is
[00776] bd2b: fa 7f                  ani     07fh
[00777] bd2d: d4                     sep     scall               ; need to know if it is alpha
[00778] bd2e: ff 72                  dw      f_isalpha
[00779] bd30: cb bd 36               lbnf    tkn_yes_l           ; jump if not
[00780] bd33: d7                     sep     r7                  ; otherwise add  space
[00781] bd34: 53                     db      add_char.0
[00782] bd35: 20                     db      ' '
[00783] bd36: 0d          tkn_yes_l: ldn     rd                  ; get byte from token
[00784] bd37: fa 7f                  ani     07fh                ; strip token bit
[00785] bd39: 5f                     str     rf                  ; place character into buffer
[00786] bd3a: 1f                     inc     rf
[00787] bd3b: 4d                     lda     rd                  ; get byte back
[00788] bd3c: fe                     shl                         ; shift high bit into DF
[00789] bd3d: cb bd 36               lbnf    tkn_yes_l           ; jump if not at end
[00790] bd40: f6                     shr
[00791] bd41: d4                     sep     scall               ; see if alphs
[00792] bd42: ff 72                  dw      f_isalpha
[00793] bd44: cb bc ef               lbnf    detkn_lp            ; jump if not
[00794] bd47: d7                     sep     r7                  ; otherwise add trailing space
[00795] bd48: 53                     db      add_char.0
[00796] bd49: 20                     db      ' '
[00797] bd4a: c0 bc ef               lbr     detkn_lp            ; and continue processing
[00798] bd4d: 4a          detkn_nm:  lda     ra                  ; get msb of number
[00799] bd4e: bd                     phi     rd                  ; and prepare for output
[00800] bd4f: 4a                     lda     ra
[00801] bd50: ad                     plo     rd
[00802] bd51: d4                     sep     scall               ; convert number
[00803] bd52: ff 63                  dw      f_intout
[00804] bd54: c0 bc ef               lbr     detkn_lp            ; and look for more tokens
[00805] bd57: d7          detkn_qs:  sep     r7                  ; need to add a quote
[00806] bd58: 53                     db      add_char.0
[00807] bd59: 22                     db      '"'
[00808] bd5a: 4a          qs_lp:     lda     ra                  ; get next byte
[00809] bd5b: fb ff                  xri     0ffh                ; see if at end
[00810] bd5d: c2 bd 67               lbz     qs_done             ; jump if so
[00811] bd60: fb ff                  xri     0ffh                ; restore character
[00812] bd62: 5f                     str     rf                  ; place into output buffer
[00813] bd63: 1f                     inc     rf
[00814] bd64: c0 bd 5a               lbr     qs_lp               ; and keep looking
[00815] bd67: d7          qs_done:   sep     r7                  ; need terminating quote
[00816] bd68: 53                     db      add_char.0
[00817] bd69: 22                     db      '"'
[00818] bd6a: c0 bc ef               lbr     detkn_lp            ; and loop back for more tokens
[00819] bd6d: f8 00       detkn_dn:  ldi     0                   ; need a terminator
[00820] bd6f: 5f                     str     rf                  ; place into buffer
[00821] bd70: d5                     sep     sret                ; and return
[00822]                   
[00823] bd71: f8 d4       do_crlf:   ldi     high crlf           ; point to input buffer
[00824] bd73: bf                     phi     rf
[00825] bd74: f8 da                  ldi     low crlf
[00826] bd76: af                     plo     rf
[00827] bd77: d4                     sep     scall               ; display it
[00828] bd78: ff 09                  dw      MSG
[00829] bd7a: d5                     sep     sret                ; and return
[00830]                   
[00831]                   ; ********************************
[00832]                   ; *** Get random bit from LFSR ***
[00833]                   ; ********************************
[00834] bd7b: f8 01       fn_lfsr:   ldi     high lfsr           ; point to lfsr
[00835] bd7d: bd                     phi     rd
[00836] bd7e: f8 5d                  ldi     low lfsr
[00837] bd80: ad                     plo     rd
[00838] bd81: 1d                     inc     rd                  ; point to lsb
[00839] bd82: 1d                     inc     rd
[00840] bd83: 1d                     inc     rd
[00841] bd84: 0d                     ldn     rd                  ; retrieve it
[00842] bd85: ae                     plo     re                  ; put into re  ( have bit 0)
[00843] bd86: f6                     shr                         ; shift bit 1 into first position
[00844] bd87: 52                     str     r2                  ; xor with previous value
[00845] bd88: 8e                     glo     re
[00846] bd89: f3                     xor
[00847] bd8a: ae                     plo     re                  ; keep copy
[00848] bd8b: 02                     ldn     r2                  ; get value
[00849] bd8c: f6                     shr                         ; shift bit 2 into first position
[00850] bd8d: 52                     str     r2                  ; and combine
[00851] bd8e: 8e                     glo     re
[00852] bd8f: f3                     xor
[00853] bd90: ae                     plo     re
[00854] bd91: 02                     ldn     r2                  ; now shift to bit 4
[00855] bd92: f6                     shr
[00856] bd93: f6                     shr
[00857] bd94: 52                     str     r2                  ; and combine
[00858] bd95: 8e                     glo     re
[00859] bd96: f3                     xor
[00860] bd97: ae                     plo     re
[00861] bd98: 02                     ldn     r2                  ; now shift to bit 6
[00862] bd99: f6                     shr
[00863] bd9a: f6                     shr
[00864] bd9b: 52                     str     r2                  ; and combine
[00865] bd9c: 8e                     glo     re
[00866] bd9d: f3                     xor
[00867] bd9e: ae                     plo     re
[00868] bd9f: 2d                     dec     rd                  ; point to lfsr msb
[00869] bda0: 2d                     dec     rd
[00870] bda1: 2d                     dec     rd
[00871] bda2: 0d                     ldn     rd                  ; retrieve it
[00872] bda3: fe                     shl                         ; shift high bit to low
[00873] bda4: 7e                     shlc
[00874] bda5: 52                     str     r2                  ; combine with previous value
[00875] bda6: 8e                     glo     re
[00876] bda7: f3                     xor
[00877] bda8: f6                     shr                         ; shift new bit into DF
[00878] bda9: 0d                     ldn     rd                  ; now shift the register
[00879] bdaa: 76                     shrc
[00880] bdab: 5d                     str     rd
[00881] bdac: 1d                     inc     rd                  ; now byte 1
[00882] bdad: 0d                     ldn     rd                  ; now shift the register
[00883] bdae: 76                     shrc
[00884] bdaf: 5d                     str     rd
[00885] bdb0: 1d                     inc     rd                  ; now byte 2
[00886] bdb1: 0d                     ldn     rd                  ; now shift the register
[00887] bdb2: 76                     shrc
[00888] bdb3: 5d                     str     rd
[00889] bdb4: 1d                     inc     rd                  ; now byte 3
[00890] bdb5: 0d                     ldn     rd                  ; now shift the register
[00891] bdb6: 76                     shrc
[00892] bdb7: 5d                     str     rd
[00893] bdb8: f6                     shr                         ; shift result bit into DF
[00894] bdb9: d5                     sep     sret                ; and return
[00895]                   
[00896]                   #if LEVEL>=2
[00897] bdba: 8f          get_sinput: glo    rf                  ; save consumed registers
[00898] bdbb: 73                     stxd
[00899] bdbc: 9f                     ghi     rf
[00900] bdbd: 73                     stxd
[00901] bdbe: 8c                     glo     rc                  ; save consumed registers
[00902] bdbf: 73                     stxd
[00903] bdc0: 9c                     ghi     rc
[00904] bdc1: 73                     stxd
[00905] bdc2: d4                     sep     scall               ; display ?
[00906] bdc3: ff 66                  dw      INMSG
[00907] bdc5: 3f 20 00               db      '? ',0
[00908] bdc8: d7                     sep     r7                  ; setup input buffer
[00909] bdc9: 09                     db      set_buf.0
[00910] bdca: d4                     sep     scall               ; get input from user
[00911] bdcb: ff 0f                  dw      INPUT
[00912] bdcd: f8 ff       sinput_go: ldi     0ffh                ; need different kind of terminator
[00913] bdcf: 5f                     str     rf
[00914] bdd0: d4                     sep     scall               ; setup CR/LF
[00915] bdd1: bd 71                  dw      do_crlf
[00916] bdd3: d7                     sep     r7                  ; setup input buffer
[00917] bdd4: 09                     db      set_buf.0
[00918] bdd5: d4                     sep     scall               ; copy string into heap
[00919] bdd6: c7 0c                  dw      str2heap
[00920] bdd8: d7                     sep     r7                  ; retrieve address
[00921] bdd9: 58                     db      ex_pop.0
[00922] bdda: d7                     sep     r7                  ; transfer to rd
[00923] bddb: 72                     db      rf_rd.0
[00924] bddc: 60                     irx                         ; recover consumed register
[00925] bddd: 72                     ldxa
[00926] bdde: bc                     phi     rc
[00927] bddf: 72                     ldxa
[00928] bde0: ac                     plo     rc
[00929] bde1: 72                     ldxa
[00930] bde2: bf                     phi     rf
[00931] bde3: f0                     ldx
[00932] bde4: af                     plo     rf
[00933] bde5: c3 d3 89               lbdf    err_ret             ; jump if error occurred
[00934]                   
[00935] bde8: fc 00                  adi     0                   ; signal success
[00936] bdea: d5                     sep     sret                ; and return
[00937]                   #endif
[00938]                   
[00939]                   ; ********************************
[00940]                   ; *** Get input from user      ***
[00941]                   ; *** returns: RD - next value ***
[00942]                   ; ********************************
[00943] bdeb: 8f          get_input: glo     rf                  ; save consumed registers
[00944] bdec: 73                     stxd
[00945] bded: 9f                     ghi     rf
[00946] bdee: 73                     stxd
[00947] bdef: 8a                     glo     ra
[00948] bdf0: 73                     stxd
[00949] bdf1: 9a                     ghi     ra
[00950] bdf2: 73                     stxd
[00951] bdf3: f8 01                  ldi     high inp_pos        ; need to get position
[00952] bdf5: bf                     phi     rf
[00953] bdf6: f8 61                  ldi     low inp_pos
[00954] bdf8: af                     plo     rf
[00955] bdf9: 4f                     lda     rf                  ; get buffer position
[00956] bdfa: ba                     phi     ra
[00957] bdfb: 0f                     ldn     rf
[00958] bdfc: aa                     plo     ra
[00959] bdfd: 0a          input_go:  ldn     ra                  ; is there stil input in the buffer
[00960] bdfe: ca be 07               lbnz    input_gd            ; jump if not
[00961] be01: d4                     sep     scall               ; get input from user
[00962] be02: be 32                  dw      need_inp
[00963] be04: c0 bd fd               lbr     input_go
[00964] be07: d4          input_gd:  sep     scall               ; evaluate input
[00965] be08: c2 8a                  dw      new_expr
[00966] be0a: c3 d3 84               lbdf    syn_err             ; jump if error occurred
[00967] be0d: 0a                     ldn     ra                  ; get next token
[00968] be0e: c2 be 17               lbz     input_go2           ; terminator is acceptable
[00969] be11: ff 8d                  smi     08dh                ; otherwise must be a comma
[00970] be13: ca be 71               lbnz    inp_err             ; else syntax error
[00971] be16: 1a                     inc     ra                  ; move past the comma
[00972] be17: f8 01       input_go2: ldi     high inp_pos        ; need to get position
[00973] be19: bf                     phi     rf
[00974] be1a: f8 61                  ldi     low inp_pos
[00975] be1c: af                     plo     rf
[00976] be1d: 9a                     ghi     ra                  ; save new pointer
[00977] be1e: 5f                     str     rf
[00978] be1f: 1f                     inc     rf
[00979] be20: 8a                     glo     ra
[00980] be21: 5f                     str     rf
[00981] be22: d7                     sep     r7                  ; get expression value
[00982] be23: 58                     db      ex_pop.0
[00983] be24: d7                     sep     r7                  ; move it to RD
[00984] be25: 72                     db      rf_rd.0
[00985] be26: 60                     irx                         ; recover consumed registers
[00986] be27: 72                     ldxa
[00987] be28: ba                     phi     ra
[00988] be29: 72                     ldxa
[00989] be2a: aa                     plo     ra
[00990] be2b: 72                     ldxa
[00991] be2c: bf                     phi     rf
[00992] be2d: f0                     ldx
[00993] be2e: af                     plo     rf
[00994] be2f: fc 00                  adi     0                   ; signal no errors
[00995] be31: d5                     sep     sret                ; and return
[00996]                   
[00997] be32: 8c          need_inp:  glo     rc
[00998] be33: 73                     stxd
[00999] be34: 9c                     ghi     rc
[01000] be35: 73                     stxd
[01001] be36: 87                     glo     r7
[01002] be37: 73                     stxd
[01003] be38: 97                     ghi     r7
[01004] be39: 73                     stxd
[01005] be3a: d4                     sep     scall               ; display ?
[01006] be3b: ff 66                  dw      INMSG
[01007] be3d: 3f 20 00               db      '? ',0
[01008] be40: d7                     sep     r7                  ; setup input buffer
[01009] be41: 09                     db      set_buf.0
[01010] be42: d4                     sep     scall               ; get input from user
[01011] be43: ff 0f                  dw      INPUT
[01012]                   ;           lbnf    need_go
[01013]                   ;           ldi     0
[01014]                   ;           lbr     inp_err
[01015] be45: d4          need_go:   sep     scall               ; need a cr/lf
[01016] be46: ff 66                  dw      INMSG
[01017] be48: 0a 0d 00               db      10,13,0
[01018] be4b: d7                     sep     r7                  ; point to input buffer
[01019] be4c: 09                     db      set_buf.0
[01020] be4d: f8 01                  ldi     high ibuffer        ; buffer for tokenized input
[01021] be4f: ba                     phi     ra
[01022] be50: f8 63                  ldi     low ibuffer
[01023] be52: aa                     plo     ra
[01024] be53: d4                     sep     scall               ; tokenize input
[01025] be54: bf 67                  dw      tokenize
[01026] be56: 60                     irx                         ; recover consumed registers
[01027] be57: 72                     ldxa
[01028] be58: b7                     phi     r7
[01029] be59: 72                     ldxa
[01030] be5a: a7                     plo     r7
[01031] be5b: 72                     ldxa
[01032] be5c: bc                     phi     rc
[01033] be5d: f0                     ldx
[01034] be5e: ac                     plo     rc
[01035] be5f: f8 01                  ldi     high inp_pos        ; need to setup input pointer
[01036] be61: bf                     phi     rf
[01037] be62: f8 61                  ldi     low inp_pos
[01038] be64: af                     plo     rf
[01039] be65: f8 01                  ldi     high ibuffer        ; set to beginning of buffer
[01040] be67: ba                     phi     ra
[01041] be68: 5f                     str     rf
[01042] be69: 1f                     inc     rf
[01043] be6a: f8 63                  ldi     low ibuffer
[01044] be6c: aa                     plo     ra
[01045] be6d: 5f                     str     rf
[01046] be6e: fc 00                  adi     0                   ; signal no error
[01047] be70: d5                     sep     sret                ; return to calelr
[01048] be71: ae          inp_err:   plo     re
[01049] be72: 60                     irx                         ; recover consumed registers
[01050] be73: 72                     ldxa
[01051] be74: ba                     phi     ra
[01052] be75: 72                     ldxa
[01053] be76: aa                     plo     ra
[01054] be77: 72                     ldxa
[01055] be78: bf                     phi     rf
[01056] be79: f0                     ldx
[01057] be7a: af                     plo     rf
[01058] be7b: 8e                     glo     re
[01059] be7c: c0 d3 84               lbr     syn_err
[01060]                   
[01061]                   ; *****************************************************
[01062]                   ; *** Insert tokenized line into basic program area ***
[01063]                   ; *** RA - pointer to tokens                        ***
[01064]                   ; *** RB - pointer to end of tokens                 ***
[01065]                   ; *****************************************************
[01066] be7f: d4          insert_ln: sep     scall               ; setup variable table
[01067] be80: bf 36                  dw      rst_vars
[01068] be82: 1a                     inc     ra                  ; move to next token
[01069] be83: 1a                     inc     ra
[01070] be84: 1a                     inc     ra
[01071] be85: 0a                     ldn     ra                  ; retrieve it
[01072] be86: c2 bc c0               lbz     delete_ln           ; need to delete instead of insert
[01073] be89: 2a                     dec     ra                  ; move back to line number
[01074] be8a: 2a                     dec     ra
[01075] be8b: 4a                     lda     ra                  ; get line
[01076] be8c: bd                     phi     rd                  ; and setup for search
[01077] be8d: 0a                     ldn     ra
[01078] be8e: ad                     plo     rd
[01079] be8f: 2a                     dec     ra                  ; ra back msb of line number
[01080] be90: 8a                     glo     ra                  ; need to get size of tokens
[01081] be91: 52                     str     r2
[01082] be92: 8b                     glo     rb
[01083] be93: f7                     sm
[01084] be94: fc 01                  adi     1                   ; account for terminator
[01085] be96: 73                     stxd                        ; keep it stored on stack
[01086] be97: d7                     sep     r7                  ; find line
[01087] be98: 19                     db      find_ln.0
[01088] be99: cb be b2               lbnf    notexact            ; jump if not an exact match
[01089] be9c: d7                     sep     r7                  ; get address of next line
[01090] be9d: 48                     db      next_ln.0           ; rf now has source
[01091] be9e: 60                     irx                         ; point to line size
[01092] be9f: 8c                     glo     rc                  ; need to compute dest
[01093] bea0: f4                     add                         ; add token size
[01094] bea1: ad                     plo     rd                  ; and place into rd
[01095] bea2: 9c                     ghi     rc                  ; high of address
[01096] bea3: 7c 00                  adci    0                   ; propagate carry
[01097] bea5: bd                     phi     rd                  ; rd now has dest
[01098] bea6: 1d                     inc     rd
[01099] bea7: 22                     dec     r2                  ; protect size
[01100] bea8: 8c                     glo     rc                  ; need to save RC
[01101] bea9: 73                     stxd
[01102] beaa: 9c                     ghi     rc
[01103] beab: 73                     stxd
[01104] beac: d4                     sep     scall               ; find size of block
[01105] bead: d3 8c                  dw      size_end
[01106] beaf: c0 be c9               lbr     insert_1            ; process the copy
[01107] beb2: 0c          notexact:  ldn     rc                  ; get line size
[01108] beb3: c2 be dc               lbz     end_line            ; jump if at end of program
[01109] beb6: 60                     irx                         ; point to token size
[01110] beb7: 8c                     glo     rc                  ; get source address
[01111] beb8: f4                     add
[01112] beb9: ad                     plo     rd
[01113] beba: 9c                     ghi     rc
[01114] bebb: 7c 00                  adci    0                   ; propagate carry
[01115] bebd: bd                     phi     rd                  ; RD is copy destination
[01116] bebe: 1d                     inc     rd
[01117] bebf: 22                     dec     r2                  ; keep token count safe
[01118] bec0: 8c                     glo     rc                  ; need to save RC
[01119] bec1: 73                     stxd
[01120] bec2: af                     plo     rf                  ; which is also source
[01121] bec3: 9c                     ghi     rc
[01122] bec4: 73                     stxd
[01123] bec5: bf                     phi     rf                  ; RF now has source
[01124] bec6: d4                     sep     scall               ; compute block size
[01125] bec7: d3 8c                  dw      size_end
[01126] bec9: d4          insert_1:  sep     scall               ; move memory
[01127] beca: be eb                  dw      memcpy
[01128] becc: 60                     irx                         ; recover basic pointer
[01129] becd: 72                     ldxa
[01130] bece: bc                     phi     rc
[01131] becf: 72                     ldxa
[01132] bed0: ac                     plo     rc
[01133] bed1: f0                     ldx                         ; and token count
[01134] bed2: af                     plo     rf
[01135] bed3: d4                     sep     scall               ; copy tokenized line into memory
[01136] bed4: bc b2                  dw      copy_ln
[01137] bed6: d4                     sep     scall               ; setup variable table
[01138] bed7: bf 36                  dw      rst_vars
[01139] bed9: c0 bc 13               lbr     mainlp              ; and then back to main loop
[01140] bedc: 60          end_line:  irx                         ; recover count
[01141] bedd: f0                     ldx
[01142] bede: af                     plo     rf                  ; and setup for copy
[01143] bedf: d4                     sep     scall               ; copy the line to basic mmeory
[01144] bee0: bc b2                  dw      copy_ln
[01145] bee2: f8 00                  ldi     0                   ; zero next line start
[01146] bee4: 5c                     str     rc
[01147] bee5: d4                     sep     scall               ; setup variable table
[01148] bee6: bf 36                  dw      rst_vars
[01149] bee8: c0 bc 13               lbr     mainlp
[01150]                   
[01151]                   ; ************************************************
[01152]                   ; *** copy memory, detects overlaps and copies ***
[01153]                   ; *** in corrrect direction                    ***
[01154]                   ; *** RF - Source memory                       ***
[01155]                   ; *** RD - Destination memory                  ***
[01156]                   ; *** RC - count                               ***
[01157]                   ; ************************************************
[01158] beeb: 8d          memcpy:    glo     rd                  ; perform RF-RD
[01159] beec: 52                     str     r2
[01160] beed: 8f                     glo     rf
[01161] beee: f7                     sm
[01162] beef: 9d                     ghi     rd
[01163] bef0: 52                     str     r2
[01164] bef1: 9f                     ghi     rf
[01165] bef2: 77                     smb
[01166] bef3: cb bf 03               lbnf    cpy_rev             ; if RF is lower, need to copy in reverse
[01167] bef6: 4f          cpy_1:     lda     rf                  ; get source byte
[01168] bef7: 5d                     str     rd                  ; store into destination
[01169] bef8: 1d                     inc     rd
[01170] bef9: 2c                     dec     rc                  ; decrement count
[01171] befa: 8c                     glo     rc                  ; see if done
[01172] befb: ca be f6               lbnz    cpy_1               ; jump if not done
[01173] befe: 9c                     ghi     rc                  ; check high byte as well
[01174] beff: ca be f6               lbnz    cpy_1
[01175] bf02: d5                     sep     sret                ; return to caller
[01176] bf03: 2c          cpy_rev:   dec     rc                  ; need to add count-1 to both pointers
[01177] bf04: 8c                     glo     rc                  ; start with low byte
[01178] bf05: 52                     str     r2
[01179] bf06: 8f                     glo     rf                  ; add to source
[01180] bf07: f4                     add
[01181] bf08: af                     plo     rf
[01182] bf09: 7e                     shlc                        ; get carry
[01183] bf0a: ae                     plo     re                  ; and save it
[01184] bf0b: 8d                     glo     rd                  ; now add count to destination
[01185] bf0c: f4                     add
[01186] bf0d: ad                     plo     rd
[01187] bf0e: 9c                     ghi     rc                  ; now high byte
[01188] bf0f: 52                     str     r2
[01189] bf10: 9d                     ghi     rd                  ; do RD first since we have its carry
[01190] bf11: 74                     adc
[01191] bf12: bd                     phi     rd                  ; rd is now correct
[01192] bf13: 8e                     glo     re                  ; get carry from rf
[01193] bf14: f6                     shr                         ; and put back into carry
[01194] bf15: 9f                     ghi     rf                  ; now finish add on source
[01195] bf16: 74                     adc
[01196] bf17: bf                     phi     rf
[01197] bf18: 1c                     inc     rc                  ; put count back
[01198] bf19: 0f          cpy_2:     ldn     rf                  ; get byte from source
[01199] bf1a: 5d                     str     rd                  ; store into destination
[01200] bf1b: 2f                     dec     rf                  ; decrement pointers
[01201] bf1c: 2d                     dec     rd
[01202] bf1d: 2c                     dec     rc                  ; decrement count
[01203] bf1e: 8c                     glo     rc                  ; see if done
[01204] bf1f: ca bf 19               lbnz    cpy_2               ; jump if not
[01205] bf22: 9c                     ghi     rc                  ; check high byte as well
[01206] bf23: ca bf 19               lbnz    cpy_2
[01207] bf26: d5                     sep     sret                ; done with copy
[01208]                   
[01209]                   ; *****************************************************
[01210]                   ; *** Shift top 2 expression stack entries upwards  ***
[01211]                   ; *** 0000-7FFF -> 8000-FFFF                        ***
[01212]                   ; *** 8000-FFFF -> 0000-7FFF                        ***
[01213]                   ; *****************************************************
[01214] bf27: 19          roll_up:   inc     r9                  ; point to msb of first number
[01215] bf28: 09                     ldn     r9                  ; retrieive
[01216] bf29: fb 80                  xri     080h                ; shift upwards
[01217] bf2b: 59                     str     r9                  ; and put back
[01218] bf2c: 19                     inc     r9                  ; move to msb of next arg
[01219] bf2d: 19                     inc     r9
[01220] bf2e: 09                     ldn     r9                  ; retrieive
[01221] bf2f: fb 80                  xri     080h                ; shift upwards
[01222] bf31: 59                     str     r9                  ; and put back
[01223] bf32: 29                     dec     r9                  ; move r9 back to where it belongs
[01224] bf33: 29                     dec     r9
[01225] bf34: 29                     dec     r9
[01226] bf35: d5                     sep     sret                ; return to caller
[01227]                   
[01228]                   ; ***********************
[01229]                   ; *** Reset Variables ***
[01230]                   ; ***********************
[01233]                   #else
[01234] bf36: d4          rst_vars:  sep     scall               ; find end of basic
[01235] bf37: bc 9d                  dw      bas_end
[01236] bf39: 1f                     inc     rf                  ; 1 past
[01237] bf3a: f8 00                  ldi     0                   ; make variable table empty
[01238] bf3c: 5f                     str     rf
[01239] bf3d: f8 01                  ldi     high var_pos        ; pointer for variable table
[01240] bf3f: bd                     phi     rd
[01241] bf40: f8 06                  ldi     low var_pos
[01242] bf42: ad                     plo     rd
[01243] bf43: 9f                     ghi     rf                  ; store address of variable table
[01244] bf44: 5d                     str     rd
[01245] bf45: 1d                     inc     rd
[01246] bf46: 8f                     glo     rf
[01247] bf47: 5d                     str     rd
[01248] bf48: f8 01                  ldi     high memory         ; need end of memory pointer
[01249] bf4a: bd                     phi     rd
[01250] bf4b: f8 00                  ldi     low memory
[01251] bf4d: ad                     plo     rd
[01252] bf4e: 4d                     lda     rd
[01253] bf4f: bf                     phi     rf
[01254] bf50: 0d                     ldn     rd
[01255] bf51: af                     plo     rf
[01256] bf52: f8 ff                  ldi     0ffh                ; zero terminator in heap memory
[01257] bf54: 5f                     str     rf
[01258] bf55: f8 01                  ldi     high heap           ; point to heap storage
[01259] bf57: bd                     phi     rd
[01260] bf58: f8 08                  ldi     low heap
[01261] bf5a: ad                     plo     rd
[01262] bf5b: 9f                     ghi     rf                  ; store heap address
[01263] bf5c: 5d                     str     rd
[01264] bf5d: 1d                     inc     rd
[01265] bf5e: 8f                     glo     rf
[01266] bf5f: 5d                     str     rd
[01267] bf60: 2f           dec rf
[01268] bf61: f8 00        ldi 0
[01269] bf63: 5f           str rf
[01270] bf64: 2f           dec rf
[01271] bf65: 5f           str rf
[01272] bf66: d5                     sep     sret                ; return to caller
[01273]                   #endif
[01274]                   
[01275]                   
[01276]                   ; *************************************
[01277]                   ; *** Tokenize a string             ***
[01278]                   ; *** RA - Buffer for tokens        ***
[01279]                   ; *** RF - Ascii string to tokenize ***
[01280]                   ; *** Returns: RC - token count     ***
[01281]                   ; ***          DF=1 - error         ***
[01282]                   ; *************************************
[01283] bf67: f8 00       tokenize:  ldi     0                   ; set initial token count to zero
[01284] bf69: bc                     phi     rc
[01285] bf6a: ac                     plo     rc
[01286] bf6b: 87                     glo     r7                  ; save consumed register
[01287] bf6c: 73                     stxd
[01288] bf6d: 97                     ghi     r7
[01289] bf6e: 73                     stxd
[01290] bf6f: d4          tokenlp:   sep     scall               ; move past any whitespace
[01291] bf70: ff 15                  dw      f_ltrim
[01292] bf72: 0f                     ldn     rf                  ; get pointed at character
[01293] bf73: c2 bf f1               lbz     tokendn             ; jump if terminator
[01294] bf76: ff 22                  smi     34                  ; check for string
[01295] bf78: c2 bf a8               lbz     charstr             ; jump if so
[01296] bf7b: d4                     sep     scall               ; see if numeric
[01297] bf7c: ff 7b                  dw      f_idnum
[01298] bf7e: cb bf c2               lbnf    tokennum            ; jump if numeric
[01299] bf81: f8 d3                  ldi     high functable      ; point to function table
[01300] bf83: b7                     phi     r7
[01301] bf84: f8 fc                  ldi     low functable
[01302] bf86: a7                     plo     r7
[01303] bf87: d4                     sep     scall               ; check for token
[01304] bf88: ff 6f                  dw      f_findtkn
[01305] bf8a: c3 bf dc               lbdf    tokenfunc           ; jump if function
[01306]                   
[01307] bf8d: 0f                     ldn     rf                  ; get next character
[01308] bf8e: d4                     sep     scall               ; see if alnum
[01309] bf8f: ff 78                  dw      f_isalnum
[01310] bf91: c3 bf 9a               lbdf    ustrlpa             ; jump if it is
[01311] bf94: 4f                     lda     rf                  ; otherwise it is a single character
[01312] bf95: 5a                     str     ra
[01313] bf96: 1a                     inc     ra
[01314] bf97: c0 bf 6f               lbr     tokenlp             ; and keep looking for tokens
[01315]                   
[01316] bf9a: 4f          ustrlpa:   lda     rf                  ; get first byte
[01317] bf9b: 5a          ustrlp:    str     ra                  ; store into token stream
[01318] bf9c: 1a                     inc     ra
[01319] bf9d: 4f                     lda     rf                  ; get next byte
[01320] bf9e: d4                     sep     scall               ; see if alphanumeric
[01321] bf9f: ff 78                  dw      f_isalnum
[01322] bfa1: c3 bf 9b               lbdf    ustrlp              ; loop back if so, store, and keep going
[01323] bfa4: 2f                     dec     rf                  ; move back to non-string char
[01324] bfa5: c0 bf 6f               lbr     tokenlp             ; loop back for more tokens
[01325] bfa8: 1f          charstr:   inc     rf                  ; move past opening quote
[01326] bfa9: f8 fd                  ldi     TKN_QSTR            ; token for quoted string
[01327] bfab: 5a          charstrlp: str     ra                  ; store it
[01328] bfac: 1a                     inc     ra
[01329] bfad: 4f                     lda     rf                  ; get next byte of string
[01330] bfae: ae                     plo     re                  ; save a copy
[01331] bfaf: c2 bf bb               lbz     tokenterm           ; jump if end
[01332] bfb2: ff 22                  smi     34                  ; check for ending quote
[01333] bfb4: c2 bf bb               lbz     tokenterm           ; also done
[01334] bfb7: 8e                     glo     re                  ; recover byte
[01335] bfb8: c0 bf ab               lbr     charstrlp           ; and loop back til done
[01336] bfbb: f8 ff       tokenterm: ldi     0ffh                ; quoted string termination
[01337] bfbd: 5a                     str     ra
[01338] bfbe: 1a                     inc     ra
[01339] bfbf: c0 bf 6f               lbr     tokenlp
[01340] bfc2: c2 bf cc    tokennum:  lbz     numisdec            ; jump if decimal number
[01341] bfc5: d4                     sep     scall               ; convert hex number
[01342] bfc6: ff 45                  dw      f_hexin
[01343]                   	;; need to skip terminating H here
[01344] bfc8: 1f          	   inc     rf
[01345] bfc9: c0 bf cf               lbr     numcont             ; continue processing number
[01346] bfcc: d4          numisdec:  sep     scall               ; convert number
[01347] bfcd: ff 5d                  dw      f_atoi
[01348] bfcf: f8 fe       numcont:   ldi     TKN_NUM             ; get token for number
[01349] bfd1: 5a                     str     ra                  ; place into token stream
[01350] bfd2: 1a                     inc     ra
[01351] bfd3: 9d                     ghi     rd                  ; now write number
[01352] bfd4: 5a                     str     ra
[01353] bfd5: 1a                     inc     ra
[01354] bfd6: 8d                     glo     rd                  ; and low byte
[01355] bfd7: 5a                     str     ra
[01356] bfd8: 1a                     inc     ra
[01357] bfd9: c0 bf 6f               lbr     tokenlp             ; loop back for more tokens
[01358] bfdc: 8d          tokenfunc: glo     rd                  ; get token number
[01359] bfdd: f9 80                  ori     080h                ; set high bit
[01360] bfdf: 5a                     str     ra                  ; store into token stream
[01361] bfe0: 1a                     inc     ra                  ; point to next free space
[01362] bfe1: ff 1a                  smi     CMD_START           ; remove command bias
[01363] bfe3: ff 89                  smi     89h                 ; check for REM
[01364] bfe5: ca bf 6f               lbnz    tokenlp             ; jump if not
[01365] bfe8: 4f          rem_lp:    lda     rf                  ; read from input
[01366] bfe9: c2 bf f1               lbz     tokendn             ; jump if end of line found
[01367] bfec: 5a                     str     ra                  ; store into token stream
[01368] bfed: 1a                     inc     ra
[01369] bfee: c0 bf e8               lbr     rem_lp              ; loop back until full line is copied
[01370] bff1: f8 00       tokendn:   ldi     0                   ; need to terminate token sequence
[01371] bff3: 5a                     str     ra
[01372] bff4: fc 00                  adi     0                   ; signal no error
[01373] bff6: 60                     irx                         ; recover R7
[01374] bff7: 72                     ldxa
[01375] bff8: b7                     phi     r7
[01376] bff9: f0                     ldx
[01377] bffa: a7                     plo     r7
[01378] bffb: d5                     sep     sret                ; and return to caller
[01379]                   
[01380]                   ; ******************************************************************************
[01381]                   ; ***                      end of utility functions                          ***
[01382]                   ; ******************************************************************************
[01383]                   
[01384]                   #if LEVEL>=2
[01385]                   ; ******************************************************************************
[01386]                   ; ***                    Start of L2 utility functions                       ***
[01387]                   ; ******************************************************************************
[01388]                   ; ***********************************************
[01389]                   ; *** Find end of heap                        ***
[01390]                   ; *** Returns: RF - last address used by heap ***
[01391]                   ; ***********************************************
[01392] bffc: f8 01       end_heap:  ldi     high heap           ; point to heap pointer
[01393] bffe: bf                     phi     rf
[01394] bfff: f8 08                  ldi     low heap
[01395] c001: af                     plo     rf
[01396] c002: 4f                     lda     rf                  ; retrieve it
[01397] c003: ae                     plo     re
[01398] c004: 0f                     ldn     rf
[01399] c005: af                     plo     rf
[01400] c006: 8e                     glo     re
[01401] c007: bf                     phi     rf
[01402] c008: d5                     sep     sret                ; and return
[01403]                   
[01404]                   ; **********************************
[01405]                   ; *** Find end of variable table ***
[01406]                   ; *** Returns: RF - end of table ***
[01407]                   ; **********************************
[01408] c009: f8 01       end_vars:  ldi     high var_pos        ; point to variable table
[01409] c00b: bf                     phi     rf
[01410] c00c: f8 06                  ldi     low var_pos
[01411] c00e: af                     plo     rf
[01412] c00f: 4f                     lda     rf                  ; retrieve it
[01413] c010: ae                     plo     re
[01414] c011: 0f                     ldn     rf
[01415] c012: af                     plo     rf
[01416] c013: 8e                     glo     re
[01417] c014: bf                     phi     rf
[01418] c015: 0f          endvarslp: ldn     rf                  ; get size
[01419] c016: c2 c0 25               lbz     endvarsdn           ; jump if found ind
[01420] c019: ef                     sex     rf                  ; set x to size address
[01421] c01a: 8f                     glo     rf                  ; and add into rf
[01422] c01b: f4                     add
[01423] c01c: af                     plo     rf
[01424] c01d: e2                     sex     r2                  ; ponit x back to stack
[01425] c01e: 9f                     ghi     rf                  ; propagate carry
[01426] c01f: 7c 00                  adci    0
[01427] c021: bf                     phi     rf
[01428] c022: c0 c0 15               lbr     endvarslp           ; loop until end is found
[01429] c025: d5          endvarsdn: sep     sret                ; return to caller
[01430]                   
[01431]                   ; ************************************************
[01432]                   ; *** Get next data item from a DATA statement ***
[01433]                   ; ************************************************
[01434] c026: 8a          get_data:  glo     ra                  ; need to save RA
[01435] c027: 73                     stxd
[01436] c028: 9a                     ghi     ra
[01437] c029: 73                     stxd
[01438] c02a: f8 01                  ldi     high data_pos       ; need current data position
[01439] c02c: bd                     phi     rd
[01440] c02d: f8 04                  ldi     low data_pos
[01441] c02f: ad                     plo     rd
[01442] c030: 4d                     lda     rd                  ; get pointer
[01443] c031: ba                     phi     ra
[01444] c032: 0d                     ldn     rd
[01445] c033: aa                     plo     ra
[01446] c034: 0a                     ldn     ra                  ; see if valid data
[01447] c035: c2 c0 5c               lbz     data_err            ; jump if not
[01448] c038: d4                     sep     scall               ; otherwise evaluate it
[01449] c039: c2 8a                  dw      new_expr
[01450] c03b: c3 c0 5f               lbdf    bad_data            ; jump if error in data
[01451] c03e: 0a                     ldn     ra                  ; see if at terminator
[01452] c03f: c2 c0 6b               lbz     data_ne             ; jump if end of data
[01453] c042: ff 8d                  smi     8dh                 ; otherwise must be a comma
[01454] c044: ca c0 5f               lbnz    bad_data            ; jump if not
[01455] c047: 1a                     inc     ra                  ; move to next item
[01456] c048: f8 01                  ldi     high data_pos       ; need current data position
[01457] c04a: bd                     phi     rd
[01458] c04b: f8 04                  ldi     low data_pos
[01459] c04d: ad                     plo     rd
[01460] c04e: 9a                     ghi     ra                  ; save new data pointer
[01461] c04f: 5d                     str     rd
[01462] c050: 1d                     inc     rd
[01463] c051: 8a                     glo     ra
[01464] c052: 5d                     str     rd
[01465] c053: d7          data_cnt:  sep     r7                  ; retrieve data value
[01466] c054: 58                     db      ex_pop.0
[01467] c055: d7                     sep     r7                  ; transfer it to RD
[01468] c056: 72                     db      rf_rd.0
[01469] c057: fc 00                  adi     0                   ; signal no error
[01470] c059: c0 c0 63               lbr     data_dn             ; and clean up
[01471] c05c: f8 09       data_err:  ldi     ERR_NODATA          ; no more data, so error
[01472] c05e: c8                     lskp
[01473] c05f: f8 02       bad_data:  ldi     ERR_SYN             ; signal syntax error
[01474] c061: ff 00                  smi     0                   ; signal an error
[01475] c063: ae          data_dn:   plo     re                  ; save possible error code
[01476] c064: 60                     irx                         ; recover ra
[01477] c065: 72                     ldxa
[01478] c066: ba                     phi     ra
[01479] c067: f0                     ldx
[01480] c068: aa                     plo     ra
[01481] c069: 8e                     glo     re
[01482] c06a: d5                     sep     sret                ; and return
[01483] c06b: d4          data_ne:   sep     scall               ; find next data line
[01484] c06c: c0 73                  dw      find_data
[01485] c06e: fc 00                  adi     0                   ; signal no error
[01486] c070: c0 c0 53               lbr     data_cnt            ; finish up
[01487]                   
[01488]                   ; *******************************************
[01489]                   ; *** Find next DATA statement in program ***
[01490]                   ; *******************************************
[01491] c073: 8c          find_data: glo     rc                  ; save current line pointer
[01492] c074: 73                     stxd
[01493] c075: 9c                     ghi     rc
[01494] c076: 73                     stxd
[01495] c077: f8 01                  ldi     high data_lin       ; need to get current data line
[01496] c079: bf                     phi     rf
[01497] c07a: f8 02                  ldi     low data_lin
[01498] c07c: af                     plo     rf
[01499] c07d: 4f                     lda     rf                  ; get it
[01500] c07e: bc                     phi     rc
[01501] c07f: 0f                     ldn     rf
[01502] c080: ac                     plo     rc
[01503] c081: d7          fnd_datlp: sep     r7                  ; get next line
[01504] c082: 48                     db      next_ln.0
[01505] c083: 0f                     ldn     rf                  ; are we at end of program
[01506] c084: c2 c0 af               lbz     fnd_daten           ; jump if so
[01507] c087: 1f                     inc     rf                  ; need to get first token
[01508] c088: 1f                     inc     rf
[01509] c089: 1f                     inc     rf
[01510] c08a: 0f                     ldn     rf                  ; get the token
[01511] c08b: ff 1a                  smi     CMD_START           ; shift into command range
[01512] c08d: ff 96                  smi     96h                 ; check for DATA
[01513] c08f: c2 c0 9c               lbz     fnd_datys           ; jump if it is
[01514] c092: 2f                     dec     rf                  ; back to line start
[01515] c093: 2f                     dec     rf
[01516] c094: 2f                     dec     rf
[01517] c095: 9f                     ghi     rf                  ; transfer line number
[01518] c096: bc                     phi     rc
[01519] c097: 8f                     glo     rf
[01520] c098: ac                     plo     rc
[01521] c099: c0 c0 81               lbr     fnd_datlp           ; keep looking
[01522] c09c: 1f          fnd_datys: inc     rf                  ; move past data token
[01523] c09d: f8 01                  ldi     high data_pos       ; need to set data position
[01524] c09f: bc                     phi     rc
[01525] c0a0: f8 04                  ldi     low data_pos
[01526] c0a2: ac                     plo     rc
[01527] c0a3: 9f                     ghi     rf                  ; write new pointer
[01528] c0a4: 5c                     str     rc
[01529] c0a5: 1c                     inc     rc
[01530] c0a6: 8f                     glo     rf
[01531] c0a7: 5c                     str     rc
[01532] c0a8: 2f                     dec     rf                  ; move back to beginning
[01533] c0a9: 2f                     dec     rf
[01534] c0aa: 2f                     dec     rf
[01535] c0ab: 2f                     dec     rf
[01536] c0ac: c0 c0 ba               lbr     fnd_datdn           ; and finish
[01537] c0af: f8 01       fnd_daten: ldi     high data_pos       ; need to set data position
[01538] c0b1: bc                     phi     rc
[01539] c0b2: f8 04                  ldi     low data_pos
[01540] c0b4: ac                     plo     rc
[01541] c0b5: 9f                     ghi     rf                  ; write new pointer
[01542] c0b6: 5c                     str     rc
[01543] c0b7: 1c                     inc     rc
[01544] c0b8: 8f                     glo     rf
[01545] c0b9: 5c                     str     rc
[01546] c0ba: f8 01       fnd_datdn: ldi     high data_lin       ; need to write new opinter
[01547] c0bc: bc                     phi     rc
[01548] c0bd: f8 02                  ldi     low data_lin
[01549] c0bf: ac                     plo     rc
[01550] c0c0: 9f                     ghi     rf                  ; write new pointer
[01551] c0c1: 5c                     str     rc
[01552] c0c2: 1c                     inc     rc
[01553] c0c3: 8f                     glo     rf
[01554] c0c4: 5c                     str     rc
[01555] c0c5: 60                     irx                         ; recover consumed registers
[01556] c0c6: 72                     ldxa
[01557] c0c7: bc                     phi     rc
[01558] c0c8: f0                     ldx
[01559] c0c9: ac                     plo     rc
[01560] c0ca: d5                     sep     sret                ; and return
[01561]                   
[01562]                   ; ******************************************************************************
[01563]                   ; ***                      End of L2 utility functions                       ***
[01564]                   ; ******************************************************************************
[01565]                   #endif
[01566]                   
[01567]                   
[01568]                   ; ******************************************************************************
[01569]                   ; ***                    Integer expression functions                        ***
[01570]                   ; ******************************************************************************
[01571]                   ; ******************************
[01572]                   ; *** Add top 2 stack values ***
[01573]                   ; ******************************
[01574] c0cb: d7          ex_add:    sep     r7                  ; get top of expression stack
[01575] c0cc: 58                     db      ex_pop.0
[01576] c0cd: d7                     sep     r7                  ; copy rf to rd
[01577] c0ce: 72                     db      rf_rd.0
[01578] c0cf: d7                     sep     r7                  ; get next stack value
[01579] c0d0: 58                     db      ex_pop.0
[01580] c0d1: 8f                     glo     rf                  ; add them together
[01581] c0d2: 52                     str     r2
[01582] c0d3: 8d                     glo     rd
[01583] c0d4: f4                     add
[01584] c0d5: af                     plo     rf
[01585] c0d6: 9f                     ghi     rf
[01586] c0d7: 52                     str     r2
[01587] c0d8: 9d                     ghi     rd
[01588] c0d9: 74                     adc
[01589] c0da: bf                     phi     rf
[01590] c0db: d7                     sep     r7                  ; place back onto stack
[01591] c0dc: 6a                     db      ex_push.0
[01592] c0dd: d5                     sep     sret                ; and return
[01593]                   
[01594]                   ; ******************************
[01595]                   ; *** And top 2 stack values ***
[01596]                   ; ******************************
[01597] c0de: d7          ex_and:    sep     r7                  ; get top of expression stack
[01598] c0df: 58                     db      ex_pop.0
[01599] c0e0: d7                     sep     r7                  ; copy rf to rd
[01600] c0e1: 72                     db      rf_rd.0
[01601] c0e2: d7                     sep     r7                  ; get next stack value
[01602] c0e3: 58                     db      ex_pop.0
[01603] c0e4: 8f                     glo     rf                  ; and them together
[01604] c0e5: 52                     str     r2
[01605] c0e6: 8d                     glo     rd
[01606] c0e7: f2                     and
[01607] c0e8: af                     plo     rf
[01608] c0e9: 9f                     ghi     rf
[01609] c0ea: 52                     str     r2
[01610] c0eb: 9d                     ghi     rd
[01611] c0ec: f2                     and
[01612] c0ed: bf                     phi     rf
[01613] c0ee: d7                     sep     r7                  ; place back onto stack
[01614] c0ef: 6a                     db      ex_push.0
[01615] c0f0: d5                     sep     sret                ; and return
[01616]                   
[01617]                   
[01618]                   ; ************************************
[01619]                   ; *** make both arguments positive ***
[01620]                   ; *** Arg1 RF                      ***
[01621]                   ; *** Arg2 RD                      ***
[01622]                   ; *** Returns D=0 - signs same     ***
[01623]                   ; ***         D=1 - signs difer    ***
[01624]                   ; ************************************
[01625] c0f1: 9f          mdnorm:    ghi     rf                  ; get high byte if divisor
[01626] c0f2: 52                     str     r2                  ; store for sign check
[01627] c0f3: 9d                     ghi     rd                  ; get high byte of dividend
[01628] c0f4: f3                     xor                         ; compare
[01629] c0f5: fe                     shl                         ; shift into df
[01630] c0f6: f8 00                  ldi     0                   ; convert to 0 or 1
[01631] c0f8: 7e                     shlc                        ; shift into D
[01632] c0f9: ae                     plo     re                  ; store into sign flag
[01633] c0fa: 9f                     ghi     rf                  ; need to see if RF is negative
[01634] c0fb: fe                     shl                         ; shift high byte to df
[01635] c0fc: cb c1 08               lbnf    mdnorm2             ; jump if not
[01636] c0ff: 9f                     ghi     rf                  ; 2s compliment on RF
[01637] c100: fb ff                  xri     0ffh
[01638] c102: bf                     phi     rf
[01639] c103: 8f                     glo     rf
[01640] c104: fb ff                  xri     0ffh
[01641] c106: af                     plo     rf
[01642] c107: 1f                     inc     rf
[01643] c108: 9d          mdnorm2:   ghi     rd                  ; now check rD for negative
[01644] c109: fe                     shl                         ; shift sign bit into df
[01645] c10a: cb c1 16               lbnf    mdnorm3             ; jump if not
[01646] c10d: 9d                     ghi     rd                  ; 2 compliment on RD
[01647] c10e: fb ff                  xri     0ffh
[01648] c110: bd                     phi     rd
[01649] c111: 8d                     glo     rd
[01650] c112: fb ff                  xri     0ffh
[01651] c114: ad                     plo     rd
[01652] c115: 1d                     inc     rd
[01653] c116: 8e          mdnorm3:   glo     re                  ; recover sign flag
[01654] c117: d5                     sep     sret                ; and return to caller
[01655]                   
[01656]                   ; *** RC = RB/R7
[01657]                   ; *** RB = remainder
[01658]                   ; *** uses R8 and R9
[01659]                   
[01660]                   ; *** RB = RF/RD
[01661]                   ; ****RF = remainder
[01662]                   ; *** uses R8 and R9
[01663] c118: d4          div16:     sep     scall               ; normalize numbers
[01664] c119: c0 f1                  dw      mdnorm
[01665] c11b: ae                     plo     re                  ; save sign comparison
[01666] c11c: f8 00                  ldi     0                   ; clear answer
[01667] c11e: bb                     phi     rb
[01668] c11f: ab                     plo     rb
[01669] c120: b8                     phi     r8                  ; set additive
[01670] c121: a8                     plo     r8
[01671] c122: 18                     inc     r8
[01672] c123: 8d                     glo     rd                  ; check for divide by 0
[01673] c124: ca c1 30               lbnz    d16lp1
[01674] c127: 9d                     ghi     rd
[01675] c128: ca c1 30               lbnz    d16lp1
[01676] c12b: f8 ff                  ldi     0ffh                ; return 0ffffh as div/0 error
[01677] c12d: bb                     phi     rb
[01678] c12e: ab                     plo     rb
[01679] c12f: d5                     sep     sret                ; return to caller
[01680] c130: 9d          d16lp1:    ghi     rd                  ; get high byte from r7
[01681] c131: fa 80                  ani     128                 ; check high bit
[01682] c133: ca c1 45               lbnz    divst               ; jump if set
[01683] c136: 8d                     glo     rd                  ; lo byte of divisor
[01684] c137: fe                     shl                         ; multiply by 2
[01685] c138: ad                     plo     rd                  ; and put back
[01686] c139: 9d                     ghi     rd                  ; get high byte of divisor
[01687] c13a: 7e                     shlc                        ; continue multiply by 2
[01688] c13b: bd                     phi     rd                  ; and put back
[01689] c13c: 88                     glo     r8                  ; multiply additive by 2
[01690] c13d: fe                     shl
[01691] c13e: a8                     plo     r8
[01692] c13f: 98                     ghi     r8
[01693] c140: 7e                     shlc
[01694] c141: b8                     phi     r8
[01695] c142: c0 c1 30               lbr     d16lp1              ; loop until high bit set in divisor
[01696] c145: 8d          divst:     glo     rd                  ; get low of divisor
[01697] c146: ca c1 5c               lbnz    divgo               ; jump if still nonzero
[01698] c149: 9d                     ghi     rd                  ; check hi byte too
[01699] c14a: ca c1 5c               lbnz    divgo
[01700] c14d: 8e                     glo     re                  ; get sign flag
[01701] c14e: f6                     shr                         ; move to df
[01702] c14f: cb c1 5b               lbnf    divret              ; jump if signs were the same
[01703] c152: 9b                     ghi     rb                  ; perform 2s compliment on answer
[01704] c153: fb ff                  xri     0ffh
[01705] c155: bb                     phi     rb
[01706] c156: 8b                     glo     rb
[01707] c157: fb ff                  xri     0ffh
[01708] c159: ab                     plo     rb
[01709] c15a: 1b                     inc     rb
[01710] c15b: d5          divret:    sep     sret                ; jump if done
[01711] c15c: 9f          divgo:     ghi     rf                  ; copy dividend
[01712] c15d: b9                     phi     r9
[01713] c15e: 8f                     glo     rf
[01714] c15f: a9                     plo     r9
[01715] c160: 8d                     glo     rd                  ; get lo of divisor
[01716] c161: 73                     stxd                        ; place into memory
[01717] c162: 60                     irx                         ; point to memory
[01718] c163: 8f                     glo     rf                  ; get low byte of dividend
[01719] c164: f7                     sm                          ; subtract
[01720] c165: af                     plo     rf                  ; put back into r6
[01721] c166: 9d                     ghi     rd                  ; get hi of divisor
[01722] c167: 73                     stxd                        ; place into memory
[01723] c168: 60                     irx                         ; point to byte
[01724] c169: 9f                     ghi     rf                  ; get hi of dividend
[01725] c16a: 77                     smb                         ; subtract
[01726] c16b: bf                     phi     rf                  ; and put back
[01727] c16c: c3 c1 76               lbdf    divyes              ; branch if no borrow happened
[01728] c16f: 99                     ghi     r9                  ; recover copy
[01729] c170: bf                     phi     rf                  ; put back into dividend
[01730] c171: 89                     glo     r9
[01731] c172: af                     plo     rf
[01732] c173: c0 c1 82               lbr     divno               ; jump to next iteration
[01733] c176: 88          divyes:    glo     r8                  ; get lo of additive
[01734] c177: 73                     stxd                        ; place in memory
[01735] c178: 60                     irx                         ; point to byte
[01736] c179: 8b                     glo     rb                  ; get lo of answer
[01737] c17a: f4                     add                         ; and add
[01738] c17b: ab                     plo     rb                  ; put back
[01739] c17c: 98                     ghi     r8                  ; get hi of additive
[01740] c17d: 73                     stxd                        ; place into memory
[01741] c17e: 60                     irx                         ; point to byte
[01742] c17f: 9b                     ghi     rb                  ; get hi byte of answer
[01743] c180: 74                     adc                         ; and continue addition
[01744] c181: bb                     phi     rb                  ; put back
[01745] c182: 9d          divno:     ghi     rd                  ; get hi of divisor
[01746] c183: f6                     shr                         ; divide by 2
[01747] c184: bd                     phi     rd                  ; put back
[01748] c185: 8d                     glo     rd                  ; get lo of divisor
[01749] c186: 76                     shrc                        ; continue divide by 2
[01750] c187: ad                     plo     rd
[01751] c188: 98                     ghi     r8                  ; get hi of divisor
[01752] c189: f6                     shr                         ; divide by 2
[01753] c18a: b8                     phi     r8                  ; put back
[01754] c18b: 88                     glo     r8                  ; get lo of divisor
[01755] c18c: 76                     shrc                        ; continue divide by 2
[01756] c18d: a8                     plo     r8
[01757] c18e: c0 c1 45               lbr     divst               ; next iteration
[01758]                   
[01759]                   
[01760]                   
[01761]                   
[01762]                   ; *********************************
[01763]                   ; *** Divide top 2 stack values ***
[01764]                   ; *********************************
[01765] c191: d7          ex_div:    sep     r7                  ; get top of expression stack
[01766] c192: 58                     db      ex_pop.0
[01767] c193: d7                     sep     r7                  ; copy to rD
[01768] c194: 72                     db      rf_rd.0
[01769] c195: d7                     sep     r7                  ; get next value
[01770] c196: 58                     db      ex_pop.0
[01771] c197: 89                     glo     r9                  ; save consumed register
[01772] c198: 73                     stxd
[01773] c199: 99                     ghi     r9
[01774] c19a: 73                     stxd
[01775] c19b: 88                     glo     r8                  ; save consumed register
[01776] c19c: 73                     stxd
[01777] c19d: 98                     ghi     r8
[01778] c19e: 73                     stxd
[01779] c19f: d4                     sep     scall               ; call bios to divide
[01780] c1a0: c1 18                  dw      div16
[01781] c1a2: 8b                     glo     rb                  ; transfer answer
[01782] c1a3: af                     plo     rf
[01783] c1a4: 9b                     ghi     rb
[01784] c1a5: bf                     phi     rf
[01785] c1a6: 60                     irx                         ; recover consumed register
[01786] c1a7: 72                     ldxa
[01787] c1a8: b8                     phi     r8
[01788] c1a9: 72                     ldxa
[01789] c1aa: a8                     plo     r8
[01790] c1ab: 72                     ldxa
[01791] c1ac: b9                     phi     r9
[01792] c1ad: f0                     ldx
[01793] c1ae: a9                     plo     r9
[01794] c1af: d7                     sep     r7                  ; write back to stack
[01795] c1b0: 6a                     db      ex_push.0
[01796] c1b1: d5                     sep     sret                ; and return
[01797]                   
[01798]                   ; *************************************
[01799]                   ; *** see if top 2 values are equal ***
[01800]                   ; *************************************
[01801] c1b2: d4          ex_eq:     sep     scall               ; subtract top 2 values
[01802] c1b3: c2 77                  dw      ex_sub
[01803] c1b5: d7                     sep     r7                  ; get result
[01804] c1b6: 58                     db      ex_pop.0
[01805] c1b7: 8f                     glo     rf                  ; check for equality
[01806] c1b8: ca c1 bf               lbnz    false               ; jump if not equal
[01807] c1bb: 9f                     ghi     rf                  ; check high byte
[01808] c1bc: c2 c1 c2               lbz     true                ; jump if true
[01809] c1bf: f8 00       false:     ldi     0                   ; need zero on stack
[01810] c1c1: c8                     lskp
[01811] c1c2: f8 ff       true:      ldi     0ffh                ; place -1 on stack
[01812] c1c4: bf                     phi     rf
[01813] c1c5: af                     plo     rf
[01814] c1c6: d7                     sep     r7
[01815] c1c7: 6a                     db      ex_push.0
[01816] c1c8: d5                     sep     sret                ; and return to caller
[01817]                   
[01818]                   ; **************************
[01819]                   ; *** see if tos-1 > tos ***
[01820]                   ; **************************
[01821] c1c9: d4          ex_gt:     sep     scall               ; bias numbers upwards
[01822] c1ca: bf 27                  dw      roll_up
[01823] c1cc: d4                     sep     scall               ; subtract top 2 values
[01824] c1cd: c2 77                  dw      ex_sub
[01825] c1cf: d7                     sep     r7                  ; get result
[01826] c1d0: 58                     db      ex_pop.0
[01827] c1d1: 8f                     glo     rf                  ; check for equal
[01828] c1d2: ca c1 d9               lbnz    ex_gt_go            ; jump if not
[01829] c1d5: 9f                     ghi     rf                  ; check high byte
[01830] c1d6: c2 c1 bf               lbz     false               ; they are equal, so fasle
[01831] c1d9: c3 c1 c2    ex_gt_go:  lbdf    true                ; true if subtraction was positive
[01832] c1dc: c0 c1 bf               lbr     false               ; otherwise false
[01833]                   
[01834]                   ; ***************************
[01835]                   ; *** see if tos-1 >= tos ***
[01836]                   ; ***************************
[01837] c1df: d4          ex_gte:    sep     scall               ; bias numbers upwards
[01838] c1e0: bf 27                  dw      roll_up
[01839] c1e2: d4                     sep     scall               ; subtract top 2 values
[01840] c1e3: c2 77                  dw      ex_sub
[01841] c1e5: d7                     sep     r7                  ; get result
[01842] c1e6: 58                     db      ex_pop.0
[01843] c1e7: c3 c1 c2               lbdf    true                ; true if subtraction was positive
[01844] c1ea: c0 c1 bf               lbr     false               ; otherwise false
[01845]                   
[01846]                   ; **************************
[01847]                   ; *** see if tos-1 < tos ***
[01848]                   ; **************************
[01849] c1ed: d4          ex_lt:     sep     scall               ; bias numbers upwards
[01850] c1ee: bf 27                  dw      roll_up
[01851] c1f0: d4                     sep     scall               ; subtract top 2 values
[01852] c1f1: c2 77                  dw      ex_sub
[01853] c1f3: d7                     sep     r7                  ; get result
[01854] c1f4: 58                     db      ex_pop.0
[01855] c1f5: cb c1 c2               lbnf    true                ; true if subtraction was negative
[01856] c1f8: c0 c1 bf               lbr     false               ; otherwise false
[01857]                   
[01858]                   ; ***************************
[01859]                   ; *** see if tos-1 <= tos ***
[01860]                   ; ***************************
[01861] c1fb: d4          ex_lte:    sep     scall               ; bias numbers upwards
[01862] c1fc: bf 27                  dw      roll_up
[01863] c1fe: d4                     sep     scall               ; subtract top 2 values
[01864] c1ff: c2 77                  dw      ex_sub
[01865] c201: d7                     sep     r7                  ; get result
[01866] c202: 58                     db      ex_pop.0
[01867] c203: 8f                     glo     rf                  ; check for equal
[01868] c204: ca c2 0b               lbnz    ex_lte_go           ; jump if not
[01869] c207: 9f                     ghi     rf                  ; check high byte
[01870] c208: c2 c1 c2               lbz     true                ; they are equal, so true
[01871] c20b: cb c1 c2    ex_lte_go: lbnf    true                ; true if subtraction was negative
[01872] c20e: c0 c1 bf               lbr     false               ; otherwise false
[01873]                   
[01874]                   ; *********************************
[01875]                   ; *** Modulo top 2 stack values ***
[01876]                   ; *********************************
[01877] c211: d7          ex_mod:    sep     r7                  ; get top of expression stack
[01878] c212: 58                     db      ex_pop.0
[01879] c213: d7                     sep     r7                  ; copy to rD
[01880] c214: 72                     db      rf_rd.0
[01881] c215: d7                     sep     r7                  ; get next value
[01882] c216: 58                     db      ex_pop.0
[01883] c217: 89                     glo     r9                  ; save consumed register
[01884] c218: 73                     stxd
[01885] c219: 99                     ghi     r9
[01886] c21a: 73                     stxd
[01887] c21b: 88                     glo     r8                  ; save consumed register
[01888] c21c: 73                     stxd
[01889] c21d: 98                     ghi     r8
[01890] c21e: 73                     stxd
[01891] c21f: d4                     sep     scall               ; call bios to divide
[01892] c220: ff 33                  dw      f_div16
[01893] c222: 60                     irx                         ; recover consumed register
[01894] c223: 72                     ldxa
[01895] c224: b8                     phi     r8
[01896] c225: 72                     ldxa
[01897] c226: a8                     plo     r8
[01898] c227: 72                     ldxa
[01899] c228: b9                     phi     r9
[01900] c229: f0                     ldx
[01901] c22a: a9                     plo     r9
[01902] c22b: d7                     sep     r7                  ; write back to stack
[01903] c22c: 6a                     db      ex_push.0
[01904] c22d: d5                     sep     sret                ; and return
[01905]                   
[01906]                   ; ***********************************
[01907]                   ; *** Multiply top 2 stack values ***
[01908]                   ; ***********************************
[01909] c22e: d7          ex_mul:    sep     r7                  ; get top of expression stack
[01910] c22f: 58                     db      ex_pop.0
[01911] c230: d7                     sep     r7                  ; copy rf to rd
[01912] c231: 72                     db      rf_rd.0
[01913] c232: d7                     sep     r7                  ; get next stack value
[01914] c233: 58                     db      ex_pop.0
[01915] c234: 8c                     glo     rc                  ; preserver consumed register
[01916] c235: 73                     stxd
[01917] c236: 9c                     ghi     rc
[01918] c237: 73                     stxd
[01919] c238: d4                     sep     scall               ; call bios to multiply numbers
[01920] c239: ff 30                  dw      f_mul16
[01921] c23b: 9b                     ghi     rb                  ; move answer to rf
[01922] c23c: bf                     phi     rf
[01923] c23d: 8b                     glo     rb
[01924] c23e: af                     plo     rf
[01925] c23f: 60                     irx                         ; and recover RC
[01926] c240: 72                     ldxa
[01927] c241: bc                     phi     rc
[01928] c242: f0                     ldx
[01929] c243: ac                     plo     rc
[01930] c244: d7                     sep     r7                  ; place back onto stack
[01931] c245: 6a                     db      ex_push.0
[01932] c246: d5                     sep     sret                ; and return
[01933]                   
[01934]                   ; **************************************
[01935]                   ; *** Negate top of expression stack ***
[01936]                   ; **************************************
[01937] c247: d7          ex_neg:    sep     r7                  ; get top of expression stack
[01938] c248: 58                     db      ex_pop.0
[01939] c249: 8f                     glo     rf                  ; subtract it from 0
[01940] c24a: fd 00                  sdi     0
[01941] c24c: af                     plo     rf
[01942] c24d: 9f                     ghi     rf                  ; carry through upper byte
[01943] c24e: 7d 00                  sdbi    0
[01944] c250: bf                     phi     rf
[01945] c251: d7                     sep     r7                  ; put back onto stack
[01946] c252: 6a                     db      ex_push.0
[01947] c253: d5                     sep     sret                ; and return
[01948]                   
[01949]                   ; ***************************************
[01950]                   ; *** see if top 2 values are unequal ***
[01951]                   ; ***************************************
[01952] c254: d4          ex_neq:    sep     scall               ; subtract top 2 values
[01953] c255: c2 77                  dw      ex_sub
[01954] c257: d7                     sep     r7                  ; get result
[01955] c258: 58                     db      ex_pop.0
[01956] c259: 8f                     glo     rf                  ; check for equality
[01957] c25a: ca c1 c2               lbnz    true                ; jump if not equal
[01958] c25d: 9f                     ghi     rf                  ; check high byte
[01959] c25e: c2 c1 bf               lbz     false               ; jump if true
[01960] c261: c0 c1 c2               lbr     true
[01961]                   
[01962]                   ; *****************************
[01963]                   ; *** Or top 2 stack values ***
[01964]                   ; *****************************
[01965] c264: d7          ex_or:     sep     r7                  ; get top of expression stack
[01966] c265: 58                     db      ex_pop.0
[01967] c266: d7                     sep     r7                  ; copy rf to rd
[01968] c267: 72                     db      rf_rd.0
[01969] c268: d7                     sep     r7                  ; get next stack value
[01970] c269: 58                     db      ex_pop.0
[01971] c26a: 8f                     glo     rf                  ; and them together
[01972] c26b: 52                     str     r2
[01973] c26c: 8d                     glo     rd
[01974] c26d: f1                     or
[01975] c26e: af                     plo     rf
[01976] c26f: 9f                     ghi     rf
[01977] c270: 52                     str     r2
[01978] c271: 9d                     ghi     rd
[01979] c272: f1                     or
[01980] c273: bf                     phi     rf
[01981] c274: d7                     sep     r7                  ; place back onto stack
[01982] c275: 6a                     db      ex_push.0
[01983] c276: d5                     sep     sret                ; and return
[01984]                   
[01985]                   ; ***********************************
[01986]                   ; *** Subtract top 2 stack values ***
[01987]                   ; ***********************************
[01988] c277: d7          ex_sub:    sep     r7                  ; get top of expression stack
[01989] c278: 58                     db      ex_pop.0
[01990] c279: d7                     sep     r7                  ; copy rf to rd
[01991] c27a: 72                     db      rf_rd.0
[01992] c27b: d7                     sep     r7                  ; get next stack value
[01993] c27c: 58                     db      ex_pop.0
[01994] c27d: 8f                     glo     rf                  ; subtract them
[01995] c27e: 52                     str     r2
[01996] c27f: 8d                     glo     rd
[01997] c280: f5                     sd
[01998] c281: af                     plo     rf
[01999] c282: 9f                     ghi     rf
[02000] c283: 52                     str     r2
[02001] c284: 9d                     ghi     rd
[02002] c285: 75                     sdb
[02003] c286: bf                     phi     rf
[02004] c287: d7                     sep     r7                  ; place back onto stack
[02005] c288: 6a                     db      ex_push.0
[02006] c289: d5                     sep     sret                ; and return
[02007]                   
[02008]                   ; ******************************************************************************
[02009]                   ; ***                  End of Integer expression functions                   ***
[02010]                   ; ******************************************************************************
[02011]                   
[02012]                   
[02013]                   
[02014]                   ; ******************************************************************************
[02015]                   ; ***                     Start of expression evaluator                      ***
[02016]                   ; ******************************************************************************
[02017]                   ; ****************************
[02018]                   ; *** Expression Evaluator ***
[02019]                   ; *** RA points to tokens  ***
[02020]                   ; ****************************
[02021] c28a: f8 05       new_expr:  ldi     high expstack       ; setup expression stack
[02022] c28c: b9                     phi     r9
[02023] c28d: f8 b6                  ldi     low expstack
[02024] c28f: a9                     plo     r9
[02025]                   expr:
[02041]                   #endif
[02042]                   #if ANDOR_LOW_PREC
[02043]                   ; ***********************************
[02044]                   ; *** Level 1, find AND, OR, &, | ***
[02045]                   ; ***********************************
[02046] c290: d4          expr_0:    sep     scall               ; call level 2 to get value
[02047] c291: c2 c8                  dw      level_1
[02048] c293: c3 d3 89               lbdf    err_ret             ; jump on syntax error
[02049] c296: 0a          level_1c:  ldn     ra                  ; get next byte
[02050] c297: ff 8e                  smi     08eh                ; see if AND
[02051] c299: ca c2 a9               lbnz    level_1a            ; jump if not
[02052] c29c: 1a          level_and: inc     ra                  ; move past plus
[02053] c29d: d4                     sep     scall               ; call level 2 to get value
[02054]                              ;dw      level_1
[02055] c29e: c6 90                  dw       mexpr
[02056] c2a0: c3 d3 89               lbdf    err_ret             ; jump on syntax error
[02057] c2a3: d4                     sep     scall               ; and top 2 stack values
[02058] c2a4: c0 de                  dw      ex_and
[02059] c2a6: c0 c2 96               lbr     level_1c            ; keep looking
[02060] c2a9: ff 01       level_1a:  smi     1                   ; check for &
[02061] c2ab: c2 c2 9c               lbz     level_and           ; compute and
[02062] c2ae: ff 01                  smi     1                   ; check for OR
[02063] c2b0: ca c2 c0               lbnz    level_1b            ; jump if not
[02064] c2b3: 1a          level_or:  inc     ra                  ; move past minus sign
[02065] c2b4: d4                     sep     scall               ; call level 2 to get value
[02066]                             ; dw      level_1
[02067] c2b5: c6 90                  dw       mexpr
[02068] c2b7: c3 d3 89               lbdf    err_ret             ; jump on syntax error
[02069] c2ba: d4                     sep     scall               ; or top 2 stack values
[02070] c2bb: c2 64                  dw      ex_or
[02071] c2bd: c0 c2 96               lbr     level_1c            ; keep looking
[02072] c2c0: ff 01       level_1b:  smi     1                   ; check for |
[02073] c2c2: c2 c2 b3               lbz     level_or            ; jump if so
[02074] c2c5: fc 00       level_1n:  adi     0                   ; signal no error in level
[02075] c2c7: d5                     sep     sret                ; return from level 2
[02076]                   
[02077] c2c8: d4          level_1:    sep     scall               ; call level 2 to get value
[02078] c2c9: c3 40                  dw      level_2
[02079] c2cb: c3 d3 89               lbdf    err_ret             ; jump on syntax error
[02080] c2ce: 0a          expr_1:    ldn     ra                  ; get token
[02081] c2cf: ff 86                  smi     086h                ; check for =
[02082] c2d1: ca c2 e1               lbnz    expr_1a             ; jump if not
[02083] c2d4: 1a                     inc     ra                  ; move past =
[02084] c2d5: d4                     sep     scall               ; call level 1 to get value
[02085] c2d6: c3 40                  dw      level_2
[02086] c2d8: c3 d3 89               lbdf    err_ret             ; jump on syntax error
[02087] c2db: d4                     sep     scall               ; now check for equality
[02088] c2dc: c1 b2                  dw      ex_eq
[02089] c2de: c0 c2 ce               lbr     expr_1              ; look for more
[02090] c2e1: ff 01       expr_1a:   smi     1                   ; check for <=
[02091] c2e3: ca c2 f3               lbnz    expr_1b             ; jump if not
[02092] c2e6: 1a                     inc     ra                  ; move past symbol
[02093] c2e7: d4                     sep     scall               ; call level 1 to get value
[02094] c2e8: c3 40                  dw      level_2
[02095] c2ea: c3 d3 89               lbdf    err_ret             ; jump on syntax error
[02096] c2ed: d4                     sep     scall               ; now check
[02097] c2ee: c1 fb                  dw      ex_lte
[02098] c2f0: c0 c2 ce               lbr     expr_1              ; look for more
[02099] c2f3: ff 01       expr_1b:   smi     1                   ; check for >=
[02100] c2f5: ca c3 05               lbnz    expr_1c             ; jump if not
[02101] c2f8: 1a                     inc     ra                  ; move past symbol
[02102] c2f9: d4                     sep     scall               ; call level 1 to get value
[02103] c2fa: c3 40                  dw      level_2
[02104] c2fc: c3 d3 89               lbdf    err_ret             ; jump on syntax error
[02105] c2ff: d4                     sep     scall               ; now check
[02106] c300: c1 df                  dw      ex_gte
[02107] c302: c0 c2 ce               lbr     expr_1              ; look for more
[02108] c305: ff 01       expr_1c:   smi     1                   ; check for <>
[02109] c307: ca c3 17               lbnz    expr_1d             ; jump if not
[02110] c30a: 1a                     inc     ra                  ; move past symbol
[02111] c30b: d4                     sep     scall               ; call level 1 to get value
[02112] c30c: c3 40                  dw      level_2
[02113] c30e: c3 d3 89               lbdf    err_ret             ; jump on syntax error
[02114] c311: d4                     sep     scall               ; now check
[02115] c312: c2 54                  dw      ex_neq
[02116] c314: c0 c2 ce               lbr     expr_1              ; look for more
[02117] c317: ff 01       expr_1d:   smi     1                   ; check for <
[02118] c319: ca c3 29               lbnz    expr_1e             ; jump if not
[02119] c31c: 1a                     inc     ra                  ; move past symbol
[02120] c31d: d4                     sep     scall               ; call level 1 to get value
[02121] c31e: c3 40                  dw      level_2
[02122] c320: c3 d3 89               lbdf    err_ret             ; jump on syntax error
[02123] c323: d4                     sep     scall               ; now check
[02124] c324: c1 ed                  dw      ex_lt
[02125] c326: c0 c2 ce               lbr     expr_1              ; look for more
[02126] c329: ff 01       expr_1e:   smi     1                   ; check for >
[02127] c32b: ca c3 3b               lbnz    expr_1f             ; jump if not
[02128] c32e: 1a                     inc     ra                  ; move past symbol
[02129] c32f: d4                     sep     scall               ; call level 1 to get value
[02130] c330: c3 40                  dw      level_2
[02131] c332: c3 d3 89               lbdf    err_ret             ; jump on syntax error
[02132] c335: d4                     sep     scall               ; now check
[02133] c336: c1 c9                  dw      ex_gt
[02134] c338: c0 c2 ce               lbr     expr_1              ; look for more
[02135] c33b: fc 00       expr_1f:   adi     0                   ; signal no errors
[02136] c33d: f8 02                  ldi     2                   ; signal integer result
[02137] c33f: d5                     sep     sret                ; and return to caller
[02232]                   #endif
[02233]                   ; **************************
[02234]                   ; *** Level 2, find +, - ***
[02235]                   ; **************************
[02236] c340: d4          level_2:   sep     scall               ; call level 3 to get value
[02237] c341: c3 6e                  dw      level_3
[02238] c343: c3 d3 89               lbdf    err_ret             ; jump on syntax error
[02239] c346: 0a          level_2c:  ldn     ra                  ; get next byte
[02240] c347: ff 80                  smi     080h                ; see if plus
[02241] c349: ca c3 59               lbnz    level_2a            ; jump if not
[02242] c34c: 1a                     inc     ra                  ; move past plus
[02243] c34d: d4                     sep     scall               ; call level 3 to get value
[02244] c34e: c3 6e                  dw      level_3
[02245] c350: c3 d3 89               lbdf    err_ret             ; jump on syntax error
[02246] c353: d4                     sep     scall               ; add top 2 stack values
[02247] c354: c0 cb                  dw      ex_add
[02248] c356: c0 c3 46               lbr     level_2c            ; keep looking
[02249] c359: ff 01       level_2a:  smi     1                   ; check for minus
[02250] c35b: ca c3 6b               lbnz    level_2n            ; jump if not
[02251] c35e: 1a                     inc     ra                  ; move past minus sign
[02252] c35f: d4                     sep     scall               ; call level 3 to get value
[02253] c360: c3 6e                  dw      level_3
[02254] c362: c3 d3 89               lbdf    err_ret             ; jump on syntax error
[02255] c365: d4                     sep     scall               ; subtract top 2 stack values
[02256] c366: c2 77                  dw      ex_sub
[02257] c368: c0 c3 46               lbr     level_2c            ; keep looking
[02258] c36b: fc 00       level_2n:  adi     0                   ; signal no error in level
[02259] c36d: d5                     sep     sret                ; return from level 2
[02260]                   
[02261]                   ; **************************
[02262]                   ; *** Level 2, find *, / ***
[02263]                   ; **************************
[02264] c36e: d4          level_3:   sep     scall               ; call level 4 to get value
[02265] c36f: c3 9c                  dw      level_4
[02266] c371: c3 d3 89               lbdf    err_ret             ; jump on syntax error
[02267] c374: 0a          level_3c:  ldn     ra                  ; get next token
[02268] c375: ff 82                  smi     082h                ; check for *
[02269] c377: ca c3 87               lbnz    level_3a            ; jump if not
[02270] c37a: 1a                     inc     ra                  ; move past multiply symbol
[02271] c37b: d4                     sep     scall               ; call level 4 to get value
[02272] c37c: c3 9c                  dw      level_4
[02273] c37e: c3 d3 89               lbdf    err_ret             ; jump on syntax error
[02274] c381: d4                     sep     scall               ; multiply values
[02275] c382: c2 2e                  dw      ex_mul
[02276] c384: c0 c3 74               lbr     level_3c            ; then continue
[02277] c387: ff 01       level_3a:  smi     1                   ; check for division
[02278] c389: ca c3 99               lbnz    level_3n            ; jump if not
[02279] c38c: 1a                     inc     ra                  ; move past /
[02280] c38d: d4                     sep     scall               ; call level 4 to get value
[02281] c38e: c3 9c                  dw      level_4
[02282] c390: c3 d3 89               lbdf    err_ret             ; jump on syntax error
[02283] c393: d4                     sep     scall               ; perform division
[02284] c394: c1 91                  dw      ex_div
[02285] c396: c0 c3 74               lbr     level_3c            ; then keep processing
[02286] c399: fc 00       level_3n:  adi     0                   ; signal no error
[02287] c39b: d5                     sep     sret                ; and return
[02288]                   
[02289]                   ; ***********************************************
[02290]                   ; *** Check for numbers, variables, functions ***
[02291]                   ; ***********************************************
[02292] c39c: 0a          level_4:   ldn     ra                  ; get token
[02293]                   #if 1
[02294] c39d: ff 80                  smi     80h                  ; PLUS
[02295] c39f: 3a a4                  bnz     l4negck
[02296] c3a1: 1a                     inc     ra
[02297] c3a2: 30 b4                  br      l4num
[02298] c3a4: ff 01       l4negck:   smi     1
[02299] c3a6: 3a b4                  bnz     l4num
[02300] c3a8: 1a                     inc     ra
[02301] c3a9: d4                     sep     scall
[02302] c3aa: c3 9c                  dw      level_4
[02303] c3ac: c3 d3 89               lbdf    err_ret
[02304] c3af: d4                     sep     scall
[02305] c3b0: c2 47                  dw      ex_neg
[02306] c3b2: 30 bf                  br      push_it
[02307] c3b4: 0a          l4num:     ldn     ra
[02308]                   #endif
[02309] c3b5: ff fe                  smi     TKN_NUM             ; check for number
[02310] c3b7: ca c3 c4               lbnz    level_4a            ; jump if not
[02311] c3ba: 1a                     inc     ra                  ; move past token
[02312] c3bb: 4a                     lda     ra                  ; retrieve actual number
[02313] c3bc: bf                     phi     rf
[02314] c3bd: 4a                     lda     ra
[02315] c3be: af                     plo     rf
[02316] c3bf: d7          push_it:   sep     r7                  ; place onto stack
[02317] c3c0: 6a                     db      ex_push.0
[02318] c3c1: fc 00                  adi     0                   ; signal no error
[02319] c3c3: d5                     sep     sret                ; and return
[02320] c3c4: 0a          level_4a:  ldn     ra                  ; get token
[02321] c3c5: ff 84                  smi     84h                 ; check for open parens
[02322] c3c7: ca c3 da               lbnz    level_4b            ; jump if not
[02323] c3ca: 1a                     inc     ra                  ; move past parens
[02324] c3cb: d4                     sep     scall               ; evaluate inside parens
[02325] c3cc: c2 90                  dw      expr
[02326] c3ce: c3 d3 89               lbdf    err_ret
[02327] c3d1: 4a          closed:    lda     ra                  ; check for closing parens
[02328] c3d2: ff 85                  smi     085h
[02329] c3d4: ca d3 84               lbnz    syn_err             ; no closing parens is a syntax error
[02330] c3d7: fc 00                  adi     0                   ; otherwise good value computed
[02331] c3d9: d5                     sep     sret                ; return
[02332] c3da: 0a          level_4b:  ldn     ra                  ; get token
[02333] c3db: d4                     sep     scall               ; see if variable name
[02334] c3dc: ff 78                  dw      f_isalnum
[02335] c3de: cb c3 f0               lbnf    level_4c            ; jump if not
[02336] c3e1: d4                     sep     scall               ; get variable address
[02337] c3e2: c8 7b                  dw      get_var
[02338] c3e4: c3 d3 89               lbdf    err_ret
[02339] c3e7: 4f                     lda     rf                  ; retrieve value from variable
[02340] c3e8: ae                     plo     re
[02341] c3e9: 4f                     lda     rf
[02342] c3ea: af                     plo     rf
[02343] c3eb: 8e                     glo     re
[02344] c3ec: bf                     phi     rf
[02345] c3ed: c0 c3 bf               lbr     push_it             ; put onto stack and return
[02346] c3f0: 4a          level_4c:  lda     ra                  ; last try, functions
[02347] c3f1: fe                     shl                         ; is high bit set
[02348] c3f2: cb d3 84               lbnf    syn_err             ; syntax error if not
[02349] c3f5: f6                     shr
[02350] c3f6: ff 14                  smi     020                 ; check for PEEK
[02351] c3f8: c2 c4 aa               lbz     fn_peek             ; jump if so
[02352] c3fb: ff 01                  smi     1                   ; check for FRE
[02353] c3fd: c2 c4 6d               lbz     fn_fre              ; jump if so
[02354] c400: ff 01                  smi     1                   ; check for RND
[02355] c402: c2 c4 bc               lbz     fn_rnd              ; jump if so
[02356] c405: ff 01                  smi     1                   ; check for INP
[02357] c407: c2 c4 84               lbz     fn_inp              ; jump if so
[02358] c40a: ff 01                  smi     1                   ; check for FLG
[02359] c40c: c2 c4 62               lbz     fn_flg              ; jump if so
[02360] c40f: ff 01                  smi     1                   ; check for USR
[02361] c411: c2 c4 2b               lbz     fn_usr              ; jump if so
[02362]                   #if LEVEL>=2
[02363] c414: ff 1c                  smi     28                  ; check for VARPTR
[02364] c416: c2 c4 da               lbz     fn_varptr           ; jump if so
[02365] c419: ff 02                  smi     2                   ; check for LEN
[02366] c41b: c2 c5 44               lbz     fn_len              ; jump if so
[02367] c41e: ff 01                  smi     1                   ; check for ASC
[02368] c420: c2 c4 ec               lbz     fn_asc              ; jump if so
[02369] c423: ff 01                  smi     1                   ; check for VAL
[02370] c425: c2 c6 4f               lbz     fn_val              ; jump if so
[02371]                   #endif
[02372] c428: ff 00                  smi     0                   ; signal an error
[02373] c42a: d5                     sep     sret                ; and return
[02374]                   
[02375]                   ; ******************************************************************************
[02376]                   ; ***                       End of expression evaluator                      ***
[02377]                   ; ******************************************************************************
[02378]                   
[02379]                   
[02380]                   ; ******************************************************************************
[02381]                   ; ***                         Start of L1 functions                          ***
[02382]                   ; ******************************************************************************
[02383]                   ; *****************************************************
[02384]                   ; *** Process USR                                   ***
[02385]                   ; *** User routine is called with R3 active         ***
[02386]                   ; *** RF will hold passed value from 2nd arg of USR ***
[02387]                   ; *** routine must return with a SEP RD             ***
[02388]                   ; *** it is up to the USR to preserve any registers ***
[02389]                   ; *** that it uses                                  ***
[02390]                   ; *****************************************************
[02391] c42b: d4          fn_usr:    sep     scall               ; get argument
[02392] c42c: c2 90                  dw      expr
[02393] c42e: c3 d3 89               lbdf    err_ret
[02394] c431: 4a                     lda     ra                  ; get next token
[02395] c432: ff 85                  smi     085h                ; check for single argument version
[02396] c434: c2 c4 47               lbz     fn_usr_1            ; jump if single argument version
[02397] c437: ff 08                  smi     8                   ; check for comma
[02398] c439: ca d3 84               lbnz    syn_err             ; else syntax error
[02399] c43c: d4                     sep     scall               ; get first 2nd argument
[02400] c43d: c2 90                  dw      expr
[02401] c43f: 4a                     lda     ra                  ; get next token
[02402] c440: ff 85                  smi     085h                ; need to be closing parens
[02403] c442: ca d3 84               lbnz    syn_err             ; jump if not
[02404] c445: d7                     sep     r7                  ; retrieve argument to pass
[02405] c446: 58                     db      ex_pop.0
[02406] c447: f8 c4       fn_usr_1:  ldi     high fn_usr_go      ; setup jump
[02407] c449: bd                     phi     rd
[02408] c44a: f8 4e                  ldi     low fn_usr_go
[02409] c44c: ad                     plo     rd
[02410] c44d: dd                     sep     rd                  ; transfer to usr call routine
[02411] c44e: e9          fn_usr_go: sex     r9                  ; retrieve call address
[02412] c44f: 60                     irx                         ; from expression stack
[02413] c450: 72                     ldxa
[02414] c451: b3                     phi     r3
[02415] c452: f0                     ldx
[02416] c453: a3                     plo     r3
[02417] c454: e2                     sex     r2                  ; x back to stack
[02418] c455: d3                     sep     r3                  ; transfer to usr routine
[02419] c456: f8 c4                  ldi     high fn_usr_dn      ; need to get back on R3
[02420] c458: b3                     phi     r3
[02421] c459: f8 5d                  ldi     low fn_usr_dn
[02422] c45b: a3                     plo     r3
[02423] c45c: d3                     sep     r3
[02424] c45d: d7          fn_usr_dn: sep     r7                  ; place return value onto stack
[02425] c45e: 6a                     db      ex_push.0
[02426] c45f: fc 00                  adi     0                   ; signal no error
[02427] c461: d5                     sep     sret                ; and return
[02428]                   
[02429]                   ; *******************
[02430]                   ; *** Process FLG ***
[02431]                   ; *******************
[02432] c462: d7          fn_flg:    sep     r7                  ; get flags
[02433] c463: 78                     db      get_flags.0
[02434] c464: af                     plo     rf                  ; place into rf
[02435] c465: f8 00                  ldi     0                   ; high byte is zero
[02436] c467: bf                     phi     rf
[02437] c468: d7                     sep     r7                  ; place onto stack
[02438] c469: 6a                     db      ex_push.0
[02439] c46a: c0 c3 d1               lbr     closed              ; be sure function is closed
[02440]                   
[02441]                   ; *******************
[02442]                   ; *** Process FRE ***
[02443]                   ; *******************
[02453]                   #else
[02454] c46d: d4          fn_fre:    sep     scall               ; get end of basic
[02455] c46e: c0 09                  dw      end_vars
[02456] c470: d7                     sep     r7                  ; move to rd
[02457] c471: 72                     db      rf_rd.0
[02458] c472: d4                     sep     scall               ; get end of heap
[02459] c473: bf fc                  dw      end_heap
[02460]                   #endif
[02461] c475: 8d                     glo     rd                  ; subtract end of variables
[02462] c476: 52                     str     r2
[02463] c477: 8f                     glo     rf
[02464] c478: f7                     sm
[02465] c479: af                     plo     rf
[02466] c47a: 9d                     ghi     rd
[02467] c47b: 52                     str     r2
[02468] c47c: 9f                     ghi     rf
[02469] c47d: 77                     smb
[02470] c47e: bf                     phi     rf
[02471] c47f: d7                     sep     r7                  ; put value onto stack
[02472] c480: 6a                     db      ex_push.0
[02473] c481: c0 c3 d1               lbr     closed              ; check to be sure function is closed
[02474]                   
[02475]                   ; *******************
[02476]                   ; *** Process INP ***
[02477]                   ; *******************
[02478] c484: d4          fn_inp:    sep     scall               ; get argument
[02479] c485: c2 90                  dw      expr
[02480] c487: c3 d3 89               lbdf    err_ret
[02481] c48a: d7                     sep     r7                  ; retrieve port
[02482] c48b: 58                     db      ex_pop.0
[02483] c48c: f8 01                  ldi     high buffer         ; need somewhere for command
[02484] c48e: bd                     phi     rd
[02485] c48f: f8 b3                  ldi     low buffer
[02486] c491: ad                     plo     rd
[02487] c492: 8f                     glo     rf
[02488] c493: fa 07                  ani     7                   ; mask for range
[02489] c495: c2 d3 87               lbz     val_err             ; jump if error
[02490] c498: fc 68                  adi     68h                 ; convert to INP instructino
[02491] c49a: 5d                     str     rd                  ; store into memory
[02492] c49b: 1d                     inc     rd
[02493] c49c: f8 d3                  ldi     0d3h                ; function to reset P=3
[02494] c49e: 5d                     str     rd
[02495] c49f: 2d                     dec     rd                  ; point rd back to inp instruction
[02496] c4a0: dd                     sep     rd                  ; and execute it
[02497] c4a1: af                     plo     rf                  ; put read value into rf
[02498] c4a2: f8 00                  ldi     0                   ; zero high byte
[02499] c4a4: bf                     phi     rf
[02500] c4a5: d7                     sep     r7                  ; put read value on expr stack
[02501] c4a6: 6a                     db      ex_push.0
[02502] c4a7: c0 c3 d1               lbr     closed              ; and be sure function is closed
[02503]                   
[02504]                   ; ********************
[02505]                   ; *** Process PEEK ***
[02506]                   ; ********************
[02507] c4aa: d4          fn_peek:   sep     scall               ; get argument
[02508] c4ab: c2 90                  dw      expr
[02509] c4ad: c3 d3 89               lbdf    err_ret             ; jump if error occured
[02510] c4b0: d7                     sep     r7                  ; get address
[02511] c4b1: 58                     db      ex_pop.0
[02512] c4b2: 0f                     ldn     rf                  ; read value from memory
[02513] c4b3: af                     plo     rf                  ; put back into rf
[02514] c4b4: f8 00                  ldi     0                   ; zero high byte
[02515] c4b6: bf                     phi     rf
[02516] c4b7: d7                     sep     r7                  ; put value onto stack
[02517] c4b8: 6a                     db      ex_push.0
[02518] c4b9: c0 c3 d1               lbr     closed              ; check to be sure function is closed
[02519]                   
[02520]                   ; *******************
[02521]                   ; *** Process RND ***
[02522]                   ; *******************
[02523] c4bc: f8 10       fn_rnd:    ldi     16                  ; need to get 16 bits
[02524] c4be: 73          rnd_lp:    stxd                        ; save count
[02525] c4bf: d4                     sep     scall               ; get random bit
[02526] c4c0: bd 7b                  dw      fn_lfsr
[02527] c4c2: 8f                     glo     rf                  ; shift into result
[02528] c4c3: 7e                     shlc
[02529] c4c4: af                     plo     rf
[02530] c4c5: 9f                     ghi     rf
[02531] c4c6: 7e                     shlc
[02532] c4c7: bf                     phi     rf
[02533] c4c8: 60                     irx                         ; recover count
[02534] c4c9: f0                     ldx
[02535] c4ca: ff 01                  smi     1                   ; minus 1
[02536] c4cc: ca c4 be               lbnz    rnd_lp              ; keep looping until all bits read
[02537] c4cf: d7                     sep     r7                  ; put result onto stack
[02538] c4d0: 6a                     db      ex_push.0
[02539] c4d1: d4                     sep     scall               ; evaluate argument
[02540] c4d2: c2 90                  dw      expr
[02541] c4d4: d4                     sep     scall               ; get modulo
[02542] c4d5: c2 11                  dw      ex_mod
[02543] c4d7: c0 c3 d1               lbr     closed              ; then be sure function is closed
[02544]                   
[02545]                   ; ******************************************************************************
[02546]                   ; ***                           End of L1 functions                          ***
[02547]                   ; ******************************************************************************
[02548]                   
[02549]                   
[02550]                   
[02551]                   #if LEVEL>=2
[02552]                   ; ******************************************************************************
[02553]                   ; ***                         Start of L2 functions                          ***
[02554]                   ; ******************************************************************************
[02555]                   ; **********************
[02556]                   ; *** Process VARPTR ***
[02557]                   ; **********************
[02558] c4da: 0a          fn_varptr: ldn     ra                 ; get next token
[02559] c4db: d4                     sep     scall              ; must be alpha, indicating a variable
[02560] c4dc: ff 72                  dw      f_isalpha
[02561] c4de: cb d3 84               lbnf    syn_err            ; otherwise syntax error
[02562] c4e1: d4                     sep     scall              ; get variables location
[02563] c4e2: c8 7b                  dw      get_var
[02564] c4e4: c3 d3 89               lbdf    err_ret            ; jump if error occurred
[02565] c4e7: d7                     sep     r7                 ; place onto expression stack
[02566] c4e8: 6a                     db      ex_push.0
[02567] c4e9: c0 c3 d1               lbr     closed              ; check to be sure function is closed
[02568]                   
[02569]                   ; ******************************************************************************
[02570]                   ; ***                       Start of String functions                        ***
[02571]                   ; ******************************************************************************
[02572]                   
[02573]                   ; *******************
[02574]                   ; *** Process ASC ***
[02575]                   ; *******************
[02576] c4ec: d4          fn_asc:    sep     scall              ; get argument
[02577] c4ed: c7 46                  dw      sexpr
[02578] c4ef: c3 d3 89               lbdf    err_ret            ; jump if error occurred
[02579] c4f2: d7                     sep     r7                 ; retrieve string address
[02580] c4f3: 58                     db      ex_pop.0
[02581] c4f4: d4                     sep     scall              ; deallocate temporary storage
[02582] c4f5: d1 1c                  dw      dealloc
[02583] c4f7: 0f                     ldn     rf                 ; get first byte for string
[02584] c4f8: af                     plo     rf                 ; set RF to value
[02585] c4f9: f8 00                  ldi     0
[02586] c4fb: bf                     phi     rf
[02587] c4fc: c0 c5 5f               lbr     len_dn             ; put answer on stack and finish
[02588]                   
[02589]                   ; *******************
[02590]                   ; *** Process CHR ***
[02591]                   ; *******************
[02592] c4ff: d4          fn_chr:    sep     scall              ; evaluate argument
[02593] c500: c2 90                  dw      expr
[02594] c502: c3 d3 89               lbdf    err_ret            ; jump if error occurred
[02595] c505: d7                     sep     r7                 ; get buffer
[02596] c506: 09                     db      set_buf.0
[02597] c507: d7                     sep     r7                 ; put into rd
[02598] c508: 72                     db      rf_rd.0
[02599] c509: d7                     sep     r7                 ; get argument
[02600] c50a: 58                     db      ex_pop.0
[02601] c50b: 8f                     glo     rf                 ; put answer into buffer
[02602] c50c: 5d                     str     rd
[02603] c50d: 1d                     inc     rd
[02604] c50e: f8 ff       str_term:  ldi     0ffh               ; terminate it
[02605] c510: 5d                     str     rd
[02606] c511: 1d                     inc     rd
[02607] c512: c0 c6 3f               lbr     copy_str           ; copy string into heap
[02608]                   
[02609]                   ; *********************
[02610]                   ; *** Process LEFT$ ***
[02611]                   ; *********************
[02612] c515: d4          fn_left:   sep     scall              ; get first argument
[02613] c516: c7 46                  dw      sexpr
[02614] c518: c3 d3 89               lbdf    err_ret            ; jump if error occurred
[02615] c51b: 4a                     lda     ra                 ; get next token
[02616] c51c: ff 8d                  smi     08dh               ; must be a comma
[02617] c51e: ca d3 84               lbnz    syn_err            ; else syntax error
[02618] c521: d4                     sep     scall              ; get length argument
[02619] c522: c2 90                  dw      expr
[02620] c524: c3 d3 89               lbdf    err_ret            ; jump if error occurred
[02621] c527: d7          left_go2:  sep     r7                 ; get number of characters
[02622] c528: 58                     db      ex_pop.0
[02623] c529: 8f                     glo     rf                 ; save number of characters
[02624] c52a: 73                     stxd
[02625] c52b: d7                     sep     r7                 ; get source address
[02626] c52c: 58                     db      ex_pop.0
[02627] c52d: d4                     sep     scall              ; deallocate temporary storage
[02628] c52e: d1 1c                  dw      dealloc
[02629] c530: 60                     irx                        ; recover character count
[02630] c531: f0                     ldx
[02631] c532: ae                     plo     re                 ; into re
[02632] c533: f8 01       left_go:   ldi     high buffer        ; setup destination buffer
[02633] c535: bd                     phi     rd
[02634] c536: f8 b3                  ldi     low buffer
[02635] c538: ad                     plo     rd
[02636] c539: 8e          left_lp:   glo     re                 ; see if done
[02637] c53a: c2 c5 0e               lbz     str_term           ; jump if so
[02638] c53d: 2e                     dec     re                 ; decrement re
[02639] c53e: 4f                     lda     rf                 ; get byte from source
[02640] c53f: 5d                     str     rd                 ; place into destination
[02641] c540: 1d                     inc     rd
[02642] c541: c0 c5 39               lbr     left_lp            ; loop until done
[02643]                   
[02644]                   ; *******************
[02645]                   ; *** Process LEN ***
[02646]                   ; *******************
[02647] c544: d4          fn_len:    sep     scall              ; get argument
[02648] c545: c7 46                  dw      sexpr
[02649] c547: c3 d3 89               lbdf    err_ret            ; jump if error occurred
[02650] c54a: d7                     sep     r7                 ; retrieve string address
[02651] c54b: 58                     db      ex_pop.0
[02652] c54c: d4                     sep     scall              ; deallocate temporary storage
[02653] c54d: d1 1c                  dw      dealloc
[02654] c54f: d7                     sep     r7                 ; put it in RD
[02655] c550: 72                     db      rf_rd.0
[02656] c551: f8 00                  ldi     0                  ; set count to 0
[02657] c553: bf                     phi     rf
[02658] c554: af                     plo     rf
[02659] c555: 4d          len_lp:    lda     rd                 ; get byte from string
[02660] c556: fb ff                  xri     0ffh               ; see if last byte was read
[02661] c558: c2 c5 5f               lbz     len_dn             ; jump if so
[02662] c55b: 1f                     inc     rf                 ; increment count
[02663] c55c: c0 c5 55               lbr     len_lp
[02664] c55f: d7          len_dn:    sep     r7                 ; push answer onto stack
[02665] c560: 6a                     db      ex_push.0
[02666] c561: c0 c3 d1               lbr     closed             ; finish up
[02667]                   
[02668]                   ; ********************
[02669]                   ; *** Process MID$ ***
[02670]                   ; ********************
[02671] c564: d4          fn_mid:    sep     scall              ; get first argument
[02672] c565: c7 46                  dw      sexpr
[02673] c567: c3 d3 89               lbdf    err_ret            ; jump if error occurred
[02674] c56a: 4a                     lda     ra                 ; get next token
[02675] c56b: ff 8d                  smi     08dh               ; must be a comma
[02676] c56d: ca d3 84               lbnz    syn_err            ; else syntax error
[02677] c570: d4                     sep     scall              ; get start argument
[02678] c571: c2 90                  dw      expr
[02679] c573: c3 d3 89               lbdf    err_ret            ; jump if error occurred
[02680] c576: d7                     sep     r7                 ; get start
[02681] c577: 58                     db      ex_pop.0
[02682] c578: 29                     dec     r9                 ; keep on stack as well
[02683] c579: 29                     dec     r9
[02684] c57a: 8f                     glo     rf                 ; zero is not allowed
[02685] c57b: c2 d3 87               lbz     val_err
[02686] c57e: 4a                     lda     ra                 ; get next token
[02687] c57f: ff 8d                  smi     08dh               ; must be a comma
[02688] c581: ca d3 84               lbnz    syn_err            ; else syntax error
[02689] c584: d4                     sep     scall              ; get count argument
[02690] c585: c2 90                  dw      expr
[02691] c587: c3 d3 89               lbdf    err_ret            ; jump if error occurred
[02692] c58a: d7                     sep     r7                 ; retrieve count
[02693] c58b: 58                     db      ex_pop.0
[02694] c58c: 8f                     glo     rf                 ; save it
[02695] c58d: 73                     stxd
[02696] c58e: d7                     sep     r7                 ; get position
[02697] c58f: 58                     db      ex_pop.0
[02698] c590: 8f                     glo     rf                 ; save position on stack
[02699] c591: 73                     stxd
[02700] c592: d7                     sep     r7                 ; get source string address
[02701] c593: 58                     db      ex_pop.0
[02702] c594: 29                     dec     r9                 ; keep address on stack
[02703] c595: 29                     dec     r9
[02704] c596: d4                     sep     scall              ; clear temporary storage
[02705] c597: d1 1c                  dw      dealloc
[02706] c599: d7                     sep     r7                 ; get source string address
[02707] c59a: 58                     db      ex_pop.0
[02708] c59b: 60                     irx                        ; recover star position
[02709] c59c: f0                     ldx                        ; into low re
[02710] c59d: ae                     plo     re
[02711] c59e: 2e          mid_lp1:   dec     re
[02712] c59f: 8e                     glo     re                 ; see if done
[02713] c5a0: c2 c5 ad               lbz     mid_dn             ; jump if so
[02714] c5a3: 0f                     ldn     rf                 ; get character
[02715] c5a4: fb ff                  xri     0ffh               ; check for terminator
[02716] c5a6: c2 c5 ad               lbz     mid_dn             ; jump if found
[02717] c5a9: 1f                     inc     rf                 ; move source forward
[02718] c5aa: c0 c5 9e               lbr     mid_lp1            ; loop until start found
[02719] c5ad: f8 01       mid_dn:    ldi     high buffer        ; setup destination buffer
[02720] c5af: bd                     phi     rd
[02721] c5b0: f8 b3                  ldi     low buffer
[02722] c5b2: ad                     plo     rd
[02723] c5b3: 60                     irx                        ; recover count
[02724] c5b4: f0                     ldx
[02725] c5b5: ae                     plo     re
[02726] c5b6: 8e          mid_lp2:   glo     re                 ; see if done
[02727] c5b7: c2 c5 c8               lbz     mid_dn2            ; jump if so
[02728] c5ba: 2e                     dec     re                 ; decrement count
[02729] c5bb: 4f                     lda     rf                 ; get byte from string
[02730] c5bc: fb ff                  xri     0ffh               ; see if end of string
[02731] c5be: c2 c5 c8               lbz     mid_dn2            ; jump if so
[02732] c5c1: fb ff                  xri     0ffh               ; recover character
[02733] c5c3: 5d                     str     rd                 ; store into result
[02734] c5c4: 1d                     inc     rd
[02735] c5c5: c0 c5 b6               lbr     mid_lp2            ; loop back until done
[02736] c5c8: f8 ff       mid_dn2:   ldi     0ffh               ; terminate string
[02737] c5ca: 5d                     str     rd
[02738] c5cb: f8 01                  ldi     high buffer        ; setup destination buffer
[02739] c5cd: bf                     phi     rf
[02740] c5ce: f8 b3                  ldi     low buffer
[02741] c5d0: af                     plo     rf
[02742] c5d1: d4                     sep     scall              ; copy string to heap
[02743] c5d2: c7 0c                  dw      str2heap
[02744] c5d4: c0 c3 d1               lbr     closed             ; finish up
[02745]                   
[02746]                   
[02747]                   
[02748]                   ; **********************
[02749]                   ; *** Process RIGHT$ ***
[02750]                   ; **********************
[02751] c5d7: d4          fn_right:  sep     scall              ; get first argument
[02752] c5d8: c7 46                  dw      sexpr
[02753] c5da: c3 d3 89               lbdf    err_ret            ; jump if error occurred
[02754] c5dd: 4a                     lda     ra                 ; get next token
[02755] c5de: ff 8d                  smi     08dh               ; must be a comma
[02756] c5e0: ca d3 84               lbnz    syn_err            ; else syntax error
[02757] c5e3: d4                     sep     scall              ; get length argument
[02758] c5e4: c2 90                  dw      expr
[02759] c5e6: c3 d3 89               lbdf    err_ret            ; jump if error occurred
[02760] c5e9: d7                     sep     r7                 ; get number of characters
[02761] c5ea: 58                     db      ex_pop.0
[02762] c5eb: 8f                     glo     rf                 ; move to re
[02763] c5ec: 73                     stxd                       ; place on stack
[02764] c5ed: d7                     sep     r7                 ; point to buffer
[02765] c5ee: 09                     db      set_buf.0
[02766] c5ef: d7                     sep     r7                 ; get source address
[02767] c5f0: 58                     db      ex_pop.0
[02768] c5f1: d4                     sep     scall              ; deallocate temporary storage
[02769] c5f2: d1 1c                  dw      dealloc
[02770] c5f4: f8 00                  ldi     0                  ; setup character count
[02771] c5f6: ae                     plo     re
[02772] c5f7: 4f          right_lp1: lda     rf                 ; get byte from source
[02773] c5f8: fb ff                  xri     0ffh               ; see if terminator
[02774] c5fa: c2 c6 01               lbz     right_1            ; jump if so
[02775] c5fd: 1e                     inc     re                 ; increment count
[02776] c5fe: c0 c5 f7               lbr     right_lp1          ; keep looking for end
[02777] c601: 60          right_1:   irx                        ; point to requested count
[02778] c602: f0                     ldx                        ; read it
[02779] c603: ab                     plo     rb                 ; copy it here
[02780] c604: bb                     phi     rb
[02781] c605: 2f                     dec     rf                 ; point to terminator
[02782] c606: 8b          right_lp2: glo     rb                 ; done yet
[02783] c607: c2 c6 14               lbz     right_f            ; jump if so
[02784] c60a: 8e                     glo     re                 ; also check against length
[02785] c60b: c2 c6 14               lbz     right_f
[02786] c60e: 2f                     dec     rf                 ; move back one char
[02787] c60f: 2b                     dec     rb                 ; decrement request count
[02788] c610: 2e                     dec     re                 ; and size
[02789] c611: c0 c6 06               lbr     right_lp2          ; and loop until 1 is zero
[02790] c614: 9b          right_f:   ghi     rb                 ; get request count
[02791] c615: ae                     plo     re                 ; place into re
[02792] c616: c0 c5 33               lbr     left_go            ; copy the string to the buffer
[02793]                   
[02794]                   
[02795]                   ; ********************
[02796]                   ; *** Process STR$  and HEX$ ***
[02797]                   ; ********************
[02798] c619: d4          fn_hex:	   sep     scall
[02799] c61a: c2 90       	   dw      expr
[02800] c61c: c3 d3 89               lbdf    err_ret
[02801] c61f: d7          	sep     r7
[02802] c620: 58          	db ex_pop.0
[02803] c621: d7          	sep r7
[02804] c622: 72          	db rf_rd.0
[02805] c623: d7          	sep r7
[02806] c624: 09          	db set_buf.0
[02807] c625: d4          	sep scall
[02808] c626: ff 4b       	dw f_hexout4
[02809] c628: 30 39       	br fn_strhex
[02810] c62a: d4          fn_str:    sep     scall              ; get argument
[02811] c62b: c2 90                  dw      expr
[02812] c62d: c3 d3 89               lbdf    err_ret            ; jump if error resulted
[02813] c630: d7                     sep     r7                 ; retrieve value
[02814] c631: 58                     db      ex_pop.0
[02815] c632: d7                     sep     r7                 ; transfer to RD
[02816] c633: 72                     db      rf_rd.0
[02817] c634: d7                     sep     r7                 ; need a buffer
[02818] c635: 09                     db      set_buf.0
[02819] c636: d4                     sep     scall              ; convert number to ascii
[02820] c637: ff 63                  dw      f_intout
[02821]                   fn_strhex:
[02822] c639: f8 ff                  ldi     0ffh               ; terminate it
[02823] c63b: 5f                     str     rf
[02824] c63c: 1f                     inc     rf
[02825] c63d: d7                     sep     r7                 ; move address to rd
[02826] c63e: 72                     db      rf_rd.0
[02827] c63f: d7          copy_str:  sep     r7                 ; point to beginning of buffer
[02828] c640: 09                     db      set_buf.0
[02829] c641: d4                     sep     scall              ; copy string to heap
[02830] c642: c7 0c                  dw      str2heap
[02831] c644: c3 d3 89               lbdf    err_ret            ; jump on error
[02832] c647: c0 c3 d1               lbr     closed             ; finish up
[02833]                   
[02834] c64a: f8 0a       om_err:    ldi     ERR_NOMEM          ; indicate out of memory
[02835] c64c: ff 00                  smi     0
[02836] c64e: d5                     sep     sret               ; adn return
[02837]                   ; *******************
[02838]                   ; *** Process VAL ***
[02839]                   ; *******************
[02840] c64f: d4          fn_val:    sep     scall              ; get argument
[02841] c650: c7 46                  dw      sexpr
[02842] c652: c3 d3 89               lbdf    err_ret            ; jump if error occurred
[02843] c655: d7                     sep     r7                 ; retrieve string address
[02844] c656: 58                     db      ex_pop.0
[02845] c657: d4                     sep     scall              ; deallocate temporary storage
[02846] c658: d1 1c                  dw      dealloc
[02847]                   	;;  the problem here is we have a terminator of FF and
[02848]                   	;;  BIOS thinks the terminator is 0
[02849] c65a: f8 01       	   ldi     high ibuffer
[02850] c65c: bd          	   phi     rd  		; we will use RD and ibuffer for a second
[02851] c65d: f8 63       	   ldi     low ibuffer
[02852] c65f: ad          	   plo     rd
[02853] c660: 0f          fn_vallp:  ldn     rf
[02854] c661: fb ff       	   xri     0ffh
[02855] c663: 32 6a       	   bz     fn_vall0
[02856] c665: 4f                     lda     rf
[02857] c666: 5d           	   str     rd
[02858] c667: 1d          	   inc     rd
[02859] c668: 30 60       	   br      fn_vallp
[02860] c66a: f8 00       fn_vall0:  ldi	   0
[02861] c66c: 5d          	   str     rd
[02862] c66d: f8 01       	   ldi     high ibuffer	;
[02863] c66f: bf          	   phi     rf
[02864] c670: f8 63       	   ldi     low ibuffer
[02865] c672: af          	   plo     rf
[02866] c673: d4          	   sep     scall
[02867] c674: ff 7b       	   dw      f_idnum
[02868] c676: c3 c6 80    	   lbdf    valdec
[02869] c679: 32 80       	   bz      valdec
[02870] c67b: d4          	   sep	   scall
[02871] c67c: ff 45       	   dw      f_hexin
[02872] c67e: 30 83                  br      valhex
[02873] c680: d4          valdec:	   sep     scall              ; convert to integer
[02874] c681: ff 5d                  dw      f_atoi
[02875] c683: 9d          valhex:	   ghi     rd                 ; put back into rf
[02876] c684: bf                     phi     rf
[02877] c685: 8d                     glo     rd
[02878] c686: af                     plo     rf
[02879] c687: c0 c5 5f    valdn:	   lbr     len_dn             ; finish
[02880]                   
[02881] c68a: f8 05       new_mexpr: ldi     high expstack       ; setup expression stack
[02882] c68c: b9                     phi     r9
[02883] c68d: f8 b6                  ldi     low expstack
[02884] c68f: a9                     plo     r9
[02885] c690: 0a          mexpr:     ldn     ra                  ; get first char from expression
[02886] c691: ff fd                  smi     TKN_QSTR            ; see if a string
[02887] c693: c2 c6 cb               lbz     mexpr_s             ; jump if so
[02888] c696: ff 01                  smi     1                   ; see if numeric
[02889] c698: c2 c6 d1               lbz     mexpr_n             ; jump if so
[02890] c69b: 0a                     ldn     ra                  ; see if starts with a variable
[02891] c69c: d4                     sep     scall
[02892] c69d: ff 72                  dw      f_isalpha
[02893] c69f: cb c6 b8               lbnf    mexpr_nv            ; jump if not a variable
[02894] c6a2: 8a                     glo     ra                  ; save variable address
[02895] c6a3: 73                     stxd
[02896] c6a4: 9a                     ghi     ra
[02897] c6a5: 73                     stxd
[02898] c6a6: d4                     sep     scall               ; and retrieve variable
[02899] c6a7: c8 7b                  dw      get_var
[02900] c6a9: ae                     plo     re
[02901] c6aa: 60                     irx                         ; recover original ra
[02902] c6ab: 72                     ldxa
[02903] c6ac: ba                     phi     ra
[02904] c6ad: f0                     ldx
[02905] c6ae: aa                     plo     ra
[02906] c6af: 8e                     glo     re
[02907] c6b0: ff 03                  smi     3                   ; is it a string variable
[02908] c6b2: c2 c6 cb               lbz     mexpr_s             ; jump if so
[02909] c6b5: c0 c6 d1               lbr     mexpr_n             ; otherwise numeric
[02910] c6b8: 0a          mexpr_nv:  ldn     ra                  ; recover character
[02911] c6b9: ff 1a                  smi     CMD_START           ; check if string function
[02912] c6bb: cb c6 d1               lbnf    mexpr_n             ; jump if numeric function
[02913] c6be: ff a0                  smi     0a0h
[02914] c6c0: cb c6 d1               lbnf    mexpr_n             ; jump if numeric function
[02915] c6c3: ff 06                  smi     strfuncct                   ; check high range of string functions
[02916] c6c5: cb c6 cb               lbnf    mexpr_s
[02917] c6c8: c0 c6 d1               lbr     mexpr_n
[02927]                   #else
[02928] c6cb: d4          mexpr_s:   sep     scall               ; call string evaluator
[02929] c6cc: c7 46                  dw      sexpr
[02930] c6ce: f8 03                  ldi     3                   ; signal string result
[02931] c6d0: d5                     sep     sret                ; and return
[02932] c6d1: d4          mexpr_n:   sep     scall               ; call numeric evaluator
[02933] c6d2: c2 90                  dw      expr
[02934] c6d4: f8 02       mexpr_r:   ldi     2                   ; signal numeric result (note sexpr can return here)
[02935] c6d6: d5                     sep     sret                ; and return
[02936]                   #endif
[02937]                   
[02938]                   
[02939]                   ; *****************************************************************
[02940]                   ; **** Strcmp compares the strings pointing to by R(D) and R(F) ***
[02941]                   ; **** Returns:                                                 ***
[02942]                   ; ****    R(F) = R(D)     0                                     ***
[02943]                   ; ****    R(F) < R(D)     -1 (255)                              ***
[02944]                   ; ****    R(F) > R(D)     1                                     ***
[02945]                   ; *****************************************************************
[02946] c6d7: 4d          strcmp:  lda     rd          ; get next byte in string
[02947] c6d8: fb ff                xri     0ffh        ; check for end
[02948] c6da: c2 c6 ed             lbz      strcmpe     ; found end of first string
[02949] c6dd: fb ff                xri     0ffh        ; restore character
[02950] c6df: 52                   str     r2          ; store into memory
[02951] c6e0: 4f                   lda     rf          ; get byte from first string
[02952] c6e1: f7                   sm                  ; subtract 2nd byte from it
[02953] c6e2: c2 c6 d7             lbz      strcmp      ; so far a match, keep looking
[02954] c6e5: 3b ea                bnf     strcmp1     ; jump if first string is smaller
[02955] c6e7: f8 01                ldi     1           ; indicate first string is larger
[02956] c6e9: c8                   lskp                ; and return to caller
[02957] c6ea: f8 ff       strcmp1: ldi     255         ; return -1, first string is smaller
[02958] c6ec: d5                   sep     sret        ; return to calelr
[02959] c6ed: 4f          strcmpe: lda     rf          ; get byte from second string
[02960] c6ee: fb ff                xri     0ffh        ; check for end of 2nd string
[02961] c6f0: c2 c6 f6             lbz      strcmpm     ; jump if also zero
[02962] c6f3: f8 01                ldi     1           ; first string is smaller (returns -1)
[02963] c6f5: d5                   sep     sret        ; return to caller
[02964] c6f6: f8 00       strcmpm: ldi     0           ; strings are a match
[02965] c6f8: d5                   sep     sret        ; return to caller
[02966]                   
[02967] c6f9: 1a          docmp:     inc     ra                  ; move past =
[02968] c6fa: d4                     sep     scall               ; get next argument
[02969] c6fb: c8 20                  dw      sexpr_l1
[02970] c6fd: c3 d3 89               lbdf    err_ret             ; jump in case of error
[02971] c700: d7                     sep     r7                  ; retrieve second argument
[02972] c701: 58                     db      ex_pop.0
[02973] c702: d7                     sep     r7                  ; move it to rd
[02974] c703: 72                     db      rf_rd.0
[02975] c704: d7                     sep     r7                  ; retrieve first argument
[02976] c705: 58                     db      ex_pop.0
[02977] c706: d4                     sep     scall               ; compare teh strings
[02978] c707: c6 d7                  dw      strcmp
[02979] c709: fc 00                  adi     0                   ; signal no error
[02980] c70b: d5                     sep     sret                ; return
[02981]                   
[02982]                   ; *****************************
[02983]                   ; *** Copy string into heap ***
[02984]                   ; *** RF - String to copy   ***
[02985]                   ; *** Returns: RF - address ***
[02986]                   ; *****************************
[02987] c70c: f8 00       str2heap:  ldi     0                   ; setup count
[02988] c70e: bd                     phi     rd
[02989] c70f: ad                     plo     rd
[02990] c710: 8f                     glo     rf                  ; save string address
[02991] c711: 73                     stxd
[02992] c712: 9f                     ghi     rf
[02993] c713: 73                     stxd
[02994] c714: 1d          str_hp_l1: inc     rd                  ; increment count
[02995] c715: 4f                     lda     rf                  ; get byte from string
[02996] c716: fb ff                  xri     0ffh                ; check for terminator
[02997] c718: ca c7 14               lbnz    str_hp_l1           ; jump if not yet found
[02998] c71b: 8d                     glo     rd                  ; save count
[02999] c71c: 73                     stxd
[03000] c71d: af                     plo     rf                  ; and put into rf
[03001] c71e: 9d                     ghi     rd
[03002] c71f: 73                     stxd
[03003] c720: bf                     phi     rf
[03004] c721: d4                     sep     scall               ; allocate the memory
[03005] c722: d1 78                  dw      alloc
[03006] c724: 60                     irx                         ; recover count
[03007] c725: 72                     ldxa
[03008] c726: bb                     phi     rb
[03009] c727: 72                     ldxa
[03010] c728: ab                     plo     rb
[03011] c729: 72                     ldxa                        ; and source address
[03012] c72a: bd                     phi     rd
[03013] c72b: f0                     ldx
[03014] c72c: ad                     plo     rd
[03015] c72d: c3 d3 89               lbdf    err_ret             ; jump if error occurred
[03016] c730: d7                     sep     r7                  ; put address onto expression stack
[03017] c731: 6a                     db      ex_push.0
[03018] c732: 4d          str_hp_l2: lda     rd                  ; read byte from source
[03019] c733: 5f                     str     rf                  ; store into destination
[03020] c734: 1f                     inc     rf
[03021] c735: 2b                     dec     rb                  ; decrement count
[03022] c736: 8b                     glo     rb                  ; see if done
[03023] c737: 52                     str     r2
[03024] c738: 9b                     ghi     rb
[03025] c739: f1                     or
[03026] c73a: ca c7 32               lbnz    str_hp_l2
[03027] c73d: fc 00                  adi     0                   ; signal no error
[03028] c73f: d5                     sep     sret                ; and return
[03029]                   
[03030]                   ; **************************************************
[03031]                   ; *** Process string expression pointed to by RA ***
[03032]                   ; **************************************************
[03033] c740: f8 05       new_sexpr: ldi     high expstack       ; setup expression stack
[03034] c742: b9                     phi     r9
[03035] c743: f8 b6                  ldi     low expstack
[03036] c745: a9                     plo     r9
[03037] c746: d4          sexpr:     sep     scall               ; get argument
[03038] c747: c8 20                  dw      sexpr_l1
[03039] c749: c3 d3 89               lbdf    err_ret             ; jump on error
[03040] c74c: 0a                     ldn     ra                  ; check for relational symbols
[03041] c74d: ff 86                  smi     86h                 ; check for =
[03042] c74f: ca c7 79               lbnz    sexpr_a             ; jump if not
[03043] c752: d4                     sep     scall               ; call string comparison
[03044] c753: c6 f9                  dw      docmp
[03045] c755: c3 d3 89               lbdf    err_ret             ; jump on error
[03046] c758: ca c7 74               lbnz    sfalse              ; jump if false
[03047] c75b: f8 ff       strue:     ldi     0ffh                ; put -1 on stack
[03048] c75d: e9          s_stack:   sex     r9                  ; point to expression stack
[03049] c75e: 73                     stxd
[03050] c75f: 73                     stxd
[03051] c760: e2                     sex     r2                  ; point x back to correct stack
[03052] c761: f8 c6       sfix:      ldi     high mexpr_r        ; change to numeric return
[03053] c763: b6                     phi     r6
[03054] c764: f8 d4                  ldi     low mexpr_r
[03055] c766: a6                     plo     r6
[03059]                   #else
[03060] c767: 0a                     ldn     ra
[03061] c768: 32 71                  bz      sfix0
[03062] c76a: ff 9f                  smi     09fh   ; then
[03063] c76c: 32 71                  bz      sfix0
[03064] c76e: c0 c2 96               lbr     level_1c
[03065] c771: fc 00       sfix0:     adi     0
[03066] c773: d5                     sep     sret
[03067]                   #endif
[03068]                   
[03069] c774: f8 00       sfalse:    ldi     0                   ; need a zero on the stack
[03070] c776: c0 c7 5d               lbr     s_stack             ; finish up
[03071] c779: ff 01       sexpr_a:   smi     1                   ; check for <=
[03072] c77b: ca c7 8f               lbnz    sexpr_b             ; jump if not
[03073] c77e: d4                     sep     scall               ; call string comparison
[03074] c77f: c6 f9                  dw      docmp
[03075] c781: c3 d3 89               lbdf    err_ret             ; jump on error
[03076] c784: c2 c7 5b               lbz     strue               ; jump if equal
[03077] c787: fb ff                  xri     0ffh
[03078] c789: c2 c7 5b               lbz     strue
[03079] c78c: c0 c7 74               lbr     sfalse
[03080] c78f: ff 01       sexpr_b:   smi     1                   ; check for >=
[03081] c791: ca c7 a5               lbnz    sexpr_c             ; jump if not
[03082] c794: d4                     sep     scall               ; call string comparison
[03083] c795: c6 f9                  dw      docmp
[03084] c797: c3 d3 89               lbdf    err_ret             ; jump on error
[03085] c79a: c2 c7 5b               lbz     strue               ; jump if equal
[03086] c79d: fb ff                  xri     0ffh
[03087] c79f: ca c7 5b               lbnz    strue
[03088] c7a2: c0 c7 74               lbr     sfalse
[03089] c7a5: ff 01       sexpr_c:   smi     1                   ; check for >=
[03090] c7a7: ca c7 b6               lbnz    sexpr_d             ; jump if not
[03091] c7aa: d4                     sep     scall               ; call string comparison
[03092] c7ab: c6 f9                  dw      docmp
[03093] c7ad: c3 d3 89               lbdf    err_ret             ; jump on error
[03094] c7b0: ca c7 5b               lbnz    strue               ; jump if equal
[03095] c7b3: c0 c7 74               lbr     sfalse
[03096] c7b6: ff 01       sexpr_d:   smi     1                   ; check for <
[03097] c7b8: ca c7 cc               lbnz    sexpr_e             ; jump if not
[03098] c7bb: d4                     sep     scall               ; call string comparison
[03099] c7bc: c6 f9                  dw      docmp
[03100] c7be: c3 d3 89               lbdf    err_ret             ; jump on error
[03101] c7c1: c2 c7 74               lbz     sfalse              ; false if they were equal
[03102] c7c4: fb ff                  xri     0ffh
[03103] c7c6: c2 c7 5b               lbz     strue
[03104] c7c9: c0 c7 74               lbr     sfalse
[03105] c7cc: ff 01       sexpr_e:   smi     1                   ; check for >
[03106] c7ce: ca c7 e2               lbnz    sexpr_f             ; jump if not
[03107] c7d1: d4                     sep     scall               ; call string comparison
[03108] c7d2: c6 f9                  dw      docmp
[03109] c7d4: c3 d3 89               lbdf    err_ret             ; jump on error
[03110] c7d7: c2 c7 74               lbz     sfalse              ; false if they were equal
[03111] c7da: fb ff                  xri     0ffh
[03112] c7dc: ca c7 5b               lbnz    strue
[03113] c7df: c0 c7 74               lbr     sfalse
[03114]                   
[03115] c7e2: 0a          sexpr_f:   ldn     ra                  ; recover symbol
[03116] c7e3: ff 80                  smi     80h
[03117] c7e5: ca c8 1d               lbnz    sexpr_g             ; jump if not +
[03118] c7e8: 1a                     inc     ra                  ; move past plus
[03119] c7e9: d4                     sep     scall               ; get next argument
[03120] c7ea: c8 20                  dw      sexpr_l1
[03121] c7ec: c3 d3 89               lbdf    err_ret             ; jump in case of error
[03122] c7ef: d7                     sep     r7                  ; recover 2nd string
[03123] c7f0: 58                     db      ex_pop.0
[03124] c7f1: d4                     sep     scall               ; deallocate temporary storage
[03125] c7f2: d1 1c                  dw      dealloc
[03126] c7f4: d7                     sep     r7                  ; move to rd
[03127] c7f5: 72                     db      rf_rd.0
[03128] c7f6: d7                     sep     r7                  ; recover 1st string
[03129] c7f7: 58                     db      ex_pop.0
[03130] c7f8: d4                     sep     scall               ; deallocate temporary storage
[03131] c7f9: d1 1c                  dw      dealloc
[03132] c7fb: f8 01                  ldi     high buffer         ; setup buffer
[03133] c7fd: bb                     phi     rb
[03134] c7fe: f8 b3                  ldi     low buffer
[03135] c800: ab                     plo     rb
[03136] c801: 4f          cat_lp1:   lda     rf                  ; read byte from 1st string
[03137] c802: 5b                     str     rb                  ; store into buffer
[03138] c803: 1b                     inc     rb
[03139] c804: fb ff                  xri     0ffh                ; was terminator written
[03140] c806: ca c8 01               lbnz    cat_lp1             ; loop back if not
[03141] c809: 2b                     dec     rb                  ; need to overwrite terminator
[03142] c80a: 4d          cat_lp2:   lda     rd                  ; read byte from 2nd string
[03143] c80b: 5b                     str     rb                  ; store into buffer
[03144] c80c: 1b                     inc     rb
[03145] c80d: fb ff                  xri     0ffh                ; was terminator written
[03146] c80f: ca c8 0a               lbnz    cat_lp2             ; loop back if not
[03147] c812: d7                     sep     r7                  ; get beginning of buffer
[03148] c813: 09                     db      set_buf.0
[03149] c814: d4                     sep     scall               ; and copy string to heap
[03150] c815: c7 0c                  dw      str2heap
[03151] c817: c3 d3 89               lbdf    err_ret             ; jump if error
[03152] c81a: c0 c7 e2               lbr     sexpr_f             ; loop back for possibly more plusses
[03153]                   
[03154] c81d: fc 00       sexpr_g:   adi     0                   ; signal no error
[03155] c81f: d5                     sep     sret                ; and return
[03156]                   
[03157] c820: 0a          sexpr_l1:  ldn     ra                  ; get next byte
[03158] c821: ff fd                  smi     TKN_QSTR            ; is it a quoted string
[03159] c823: ca c8 36               lbnz    sexpr_l1a           ; jump if not
[03160] c826: 1a                     inc     ra                  ; point to string
[03161] c827: e9                     sex     r9                  ; place address on expression stack
[03162] c828: 8a                     glo     ra
[03163] c829: 73                     stxd
[03164] c82a: 9a                     ghi     ra
[03165] c82b: 73                     stxd
[03166] c82c: e2                     sex     r2                  ; point X back to real stack
[03167] c82d: 4a          sexpr_lp1: lda     ra                  ; need to find end
[03168] c82e: fb ff                  xri     0ffh                ; check for terminator
[03169] c830: ca c8 2d               lbnz    sexpr_lp1           ; loop until found
[03170] c833: fc 00                  adi     0                   ; signal no error
[03171] c835: d5                     sep     sret                ; return with value
[03172] c836: 4a          sexpr_l1a: lda     ra                  ; get token again
[03173] c837: ff 1a                  smi     CMD_START           ; remove bias
[03174] c839: ff a0                  smi     0a0h                ; check for str$
[03175] c83b: c2 c6 2a               lbz     fn_str              ; jump if so
[03176] c83e: ff 01                  smi     1                   ; check for chr$
[03177] c840: c2 c4 ff               lbz     fn_chr              ; jump if so
[03178] c843: ff 01                  smi     1                   ; check for left$
[03179] c845: c2 c5 15               lbz     fn_left             ; jump if so
[03180] c848: ff 01                  smi     1                   ; check for right$
[03181] c84a: c2 c5 d7               lbz     fn_right            ; jump if so
[03182] c84d: ff 01                  smi     1                   ; check for mid$
[03183] c84f: c2 c5 64               lbz     fn_mid              ; jump if so
[03184] c852: ff 01                  smi	   1		       ; check for hex$
[03185] c854: c2 c6 19    	        lbz     fn_hex
[03186] c857: 2a                     dec     ra                  ; move back
[03187] c858: 0a                     ldn     ra                  ; see if possible variable
[03188] c859: d4                     sep     scall
[03189] c85a: ff 72                  dw      f_isalpha
[03190] c85c: cb d3 84               lbnf    syn_err             ; jump if not a possible variable
[03191] c85f: d4                     sep     scall               ; get variable address
[03192] c860: c8 7b                  dw      get_var
[03193] c862: ff 03                  smi     3                   ; must be a string variable
[03194] c864: ca d3 84               lbnz    syn_err             ; else error
[03195] c867: 4f                     lda     rf                  ; get pointed to data
[03196] c868: ae                     plo     re
[03197] c869: 0f                     ldn     rf
[03198] c86a: af                     plo     rf                  ; and set rf to it
[03199] c86b: 8e                     glo     re
[03200] c86c: bf                     phi     rf
[03201] c86d: d7                     sep     r7                  ; place onto expression stack
[03202] c86e: 6a                     db      ex_push.0
[03203] c86f: fc 00                  adi     0                   ; no errors
[03204] c871: d5                     sep     sret                ; return
[03205]                   
[03206] c872: 4a          sclosed:   lda     ra                  ; next token must be a )
[03207] c873: ff 85                  smi     085h
[03208] c875: ca d3 84               lbnz    syn_err             ; else syntax error
[03209] c878: fc 00                  adi     0                   ; signal no error
[03210] c87a: d5                     sep     sret                ; and return
[03211]                   
[03212]                   ; ******************************************************************************
[03213]                   ; ***                           End of L2 functions                          ***
[03214]                   ; ******************************************************************************
[03215]                   #endif
[03216]                   
[03217]                   ; **********************************************
[03218]                   ; *** Find variable address pointed to by RA ***
[03219]                   ; *** Returns: RF - address of value         ***
[03220]                   ; **********************************************
[03244]                   #else
[03245]                   
[03246] c87b: f8 01       get_var:   ldi     high var_pos        ; need variable table
[03247] c87d: bf                     phi     rf
[03248] c87e: f8 06                  ldi     low var_pos
[03249] c880: af                     plo     rf
[03250] c881: 4f                     lda     rf                  ; read variable table address
[03251] c882: ae                     plo     re                  ; save high byte for a moment
[03252] c883: 0f                     ldn     rf                  ; get low byte
[03253] c884: af                     plo     rf                  ; make RF variable table pointer
[03254] c885: 8e                     glo     re
[03255] c886: bf                     phi     rf
[03256] c887: 0f          var_lp:    ldn     rf                  ; see if at end of table
[03257] c888: c2 c8 de               lbz     var_new             ; yep, so new variable
[03258] c88b: d7                     sep     r7                  ; make a copy of this position
[03259] c88c: 72                     db      rf_rd.0
[03260] c88d: 1f                     inc     rf                  ; move past size
[03261] c88e: 8a                     glo     ra                  ; also keep RA
[03262] c88f: ab                     plo     rb
[03263] c890: 9a                     ghi     ra
[03264] c891: bb                     phi     rb
[03265] c892: ea                     sex     ra                  ; make X point to data stream
[03266] c893: 4f          var_slp:   lda     rf                  ; get next byte from variable table
[03267] c894: ae                     plo     re
[03268] c895: fe                     shl                         ; shift high bit to DF
[03269] c896: 8e                     glo     re                  ; and then value back
[03270] c897: c3 c8 af               lbdf    var_lst             ; jump if on last character
[03271] c89a: f7                     sm                          ; compare entries
[03272] c89b: 1a                     inc     ra                  ; move ra to next character before testing
[03273] c89c: c2 c8 93               lbz     var_slp             ; jump on match
[03274] c89f: 9b          no_mtch:   ghi     rb                  ; no match, so reset ra
[03275] c8a0: ba                     phi     ra
[03276] c8a1: 8b                     glo     rb
[03277] c8a2: aa                     plo     ra
[03278] c8a3: ed                     sex     rd                  ; point X to next variable offset
[03279] c8a4: 8d                     glo     rd                  ; add into position
[03280] c8a5: f4                     add
[03281] c8a6: af                     plo     rf                  ; and place into RF
[03282] c8a7: 9d                     ghi     rd
[03283] c8a8: 7c 00                  adci    0
[03284] c8aa: bf                     phi     rf                  ; rf now pointing at next variable entry
[03285] c8ab: e2                     sex     r2                  ; point X back to stack
[03286] c8ac: c0 c8 87               lbr     var_lp              ; and check next entry
[03287] c8af: fa 7f       var_lst:   ani     07fh                ; clear high bit
[03288] c8b1: ae                     plo     re                  ; keep a copy
[03289] c8b2: ff 04                  smi     4                   ; is variable an arry
[03290] c8b4: c2 c8 d5               lbz     is_array            ; jump if so
[03291] c8b7: 8e                     glo     re                  ; recover re
[03292] c8b8: f7                     sm                          ; check for match
[03293] c8b9: ca c8 9f               lbnz    no_mtch             ; jump if not
[03294] c8bc: 1a                     inc     ra                  ; move ra past variable name
[03295] c8bd: 0a                     ldn     ra                  ; need to make sure variable is ended
[03296] c8be: d4                     sep     scall
[03297] c8bf: ff 78                  dw      f_isalnum
[03298] c8c1: c3 c8 9f               lbdf    no_mtch             ; no match if still variable name
[03299] c8c4: ae                     plo     re
[03300] c8c5: ff 24                  smi     '$'                 ; make sure not a string
[03301] c8c7: c2 c8 9f               lbz     no_mtch
[03302] c8ca: 8e                     glo     re
[03303] c8cb: ff 84                  smi     084h                ; make sure not an array
[03304] c8cd: c2 c8 9f               lbz     no_mtch             ; else no match
[03305] c8d0: 4f                     lda     rf                  ; get type
[03306] c8d1: e2                     sex     r2                  ; point X back to stack
[03307] c8d2: fc 00                  adi     0                   ; signal no error
[03308] c8d4: d5                     sep     sret                ; so return
[03309] c8d5: 4a          is_array:  lda     ra                  ; next token must also be a (
[03310] c8d6: ff 84                  smi     84h
[03311] c8d8: ca c8 9f               lbnz    no_mtch             ; else no match
[03312] c8db: c0 c9 33               lbr     array               ; item found was an array, proccess it
[03313]                   
[03314] c8de: 8f          var_new:   glo     rf                  ; save this position
[03315] c8df: ad                     plo     rd
[03316] c8e0: 9f                     ghi     rf
[03317] c8e1: bd                     phi     rd
[03318] c8e2: 1f                     inc     rf                  ; move past size
[03319] c8e3: 4a          var_nmlp:  lda     ra                  ; read byte from token stream
[03320] c8e4: d4                     sep     scall               ; see if valid for variable name
[03321] c8e5: ff 78                  dw      f_isalnum
[03322] c8e7: cb c8 ef               lbnf    var_nmdn            ; jump if done with name
[03323] c8ea: 5f                     str     rf                  ; store into variable entry
[03324] c8eb: 1f                     inc     rf
[03325] c8ec: c0 c8 e3               lbr     var_nmlp            ; loop back until full name is copied
[03326] c8ef: ff 24       var_nmdn:  smi     '$'                 ; check for string variables
[03327] c8f1: ca c9 13               lbnz    var_notst           ; jump if not a string
[03328] c8f4: f8 a4                  ldi     ('$')+80h           ; append to variable name
[03329] c8f6: 5f                     str     rf
[03330] c8f7: 1f                     inc     rf
[03331] c8f8: f8 03                  ldi     3                   ; signify a string
[03332] c8fa: 5f                     str     rf
[03333] c8fb: 1f                     inc     rf
[03334] c8fc: f8 d4                  ldi     high term           ; point to a null string
[03335] c8fe: 5f                     str     rf
[03336] c8ff: 1f                     inc     rf
[03337] c900: f8 d9                  ldi     low term
[03338] c902: 5f                     str     rf
[03339] c903: 1f                     inc     rf
[03340] c904: 8f                     glo     rf                  ; need to find offset
[03341] c905: 52                     str     r2
[03342] c906: 8d                     glo     rd
[03343] c907: f5                     sd
[03344] c908: 5d                     str     rd                  ; store offset at beginning of entry
[03345] c909: f8 00                  ldi     0                   ; write end of variable table entry
[03346] c90b: 5f                     str     rf
[03347] c90c: 2f                     dec     rf                  ; move back to address field
[03348] c90d: 2f                     dec     rf
[03349] c90e: fc 00                  adi     0                   ; signal no error
[03350] c910: f8 03                  ldi     3                   ; signal string variable
[03351] c912: d5                     sep     sret                ; and return to caller
[03352]                   
[03353] c913: 2a          var_notst: dec     ra                  ; move RA back
[03354] c914: 2f                     dec     rf                  ; point to last char of varname
[03355] c915: 0f                     ldn     rf                  ; and retrieve it
[03356] c916: f9 80                  ori     80h                 ; set high bit
[03357] c918: 5f                     str     rf                  ; and write it back
[03358] c919: 1f                     inc     rf                  ; move to type field
[03359] c91a: f8 02                  ldi     2                   ; only integers for now
[03360] c91c: 5f                     str     rf
[03361] c91d: 1f                     inc     rf
[03362] c91e: f8 00                  ldi     0                   ; new vars have zero for their value
[03363] c920: 5f                     str     rf
[03364] c921: 1f                     inc     rf                  ; move past value field
[03365] c922: 5f                     str     rf
[03366] c923: 1f                     inc     rf
[03367] c924: 8f                     glo     rf                  ; need to find offset
[03368] c925: 52                     str     r2
[03369] c926: 8d                     glo     rd
[03370] c927: f5                     sd
[03371] c928: 5d                     str     rd                  ; store offset at beginning of entry
[03372] c929: f8 00                  ldi     0                   ; write end of variable table entry
[03373] c92b: 5f                     str     rf
[03374] c92c: 2f                     dec     rf                  ; move rf to value field
[03375] c92d: 2f                     dec     rf
[03376] c92e: fc 00                  adi     0                   ; signal no error
[03377] c930: f8 02                  ldi     2                   ; signal integer variable
[03378] c932: d5                     sep     sret                ; and return to caller
[03379]                   ; ******************************************
[03380]                   ; *** process an array variable location ***
[03381]                   ; ******************************************
[03382] c933: e2          array:     sex     r2                  ; point X back to stack
[03383] c934: 1f                     inc     rf                  ; should now be pointing to array address
[03384] c935: 4f                     lda     rf                  ; retreive it
[03385] c936: ae                     plo     re
[03386] c937: 0f                     ldn     rf
[03387] c938: af                     plo     rf
[03388] c939: 8e                     glo     re
[03389] c93a: bf                     phi     rf                  ; rf now points to array descriptor
[03390] c93b: 99                     ghi     r9                  ; see if expression stack is defined
[03391] c93c: ca c9 49               lbnz    array_1             ; jump if it is
[03392] c93f: 89                     glo     r9
[03393] c940: ca c9 49               lbnz    array_1
[03394] c943: f8 05                  ldi     high expstack       ; setup expression stack
[03395] c945: b9                     phi     r9
[03396] c946: f8 b6                  ldi     low expstack
[03397] c948: a9                     plo     r9
[03398] c949: d7          array_1:   sep     r7                  ; move address to RD
[03399] c94a: 72                     db      rf_rd.0
[03400] c94b: f8 00                  ldi     0                   ; set initial accumulation to 0
[03401] c94d: bf                     phi     rf
[03402] c94e: af                     plo     rf
[03403] c94f: d7                     sep     r7
[03404] c950: 6a                     db      ex_push.0           ; tos now has accumultaion
[03405] c951: 4d                     lda     rd                  ; get number of dimensions
[03406] c952: 73                     stxd                        ; save it
[03407] c953: d7                     sep     r7                  ; save this position
[03408] c954: b8                     db      push_rd.0
[03409]                   ; Number of dimensions is on stack, RD->dimension size, on top of stack
[03410] c955: d4          ar_mullp2: sep     scall               ; get next dimension
[03411] c956: c2 90                  dw      expr
[03412] c958: c3 c9 d4               lbdf    err3_ret            ; exit if error
[03413] c95b: d7                     sep     r7                  ; recvoer array descriptor address
[03414] c95c: be                     db      pop_rd.0
[03415] c95d: 4d                     lda     rd                  ; get dimension size
[03416] c95e: 73                     stxd                        ; place onto stack
[03417] c95f: 0d                     ldn     rd                  ; lsb of size
[03418] c960: 52                     str     r2                  ; also on stack
[03419] c961: 2d                     dec     rd
[03420] c962: d7                     sep     r7                  ; recover first dimension
[03421] c963: 58                     db      ex_pop.0
[03422] c964: 29                     dec     r9                  ; and keep on expression stack
[03423] c965: 29                     dec     r9
[03424] c966: 8f                     glo     rf                  ; check range
[03425] c967: f7                     sm
[03426] c968: 60                     irx                         ; point x to msb
[03427] c969: 9f                     ghi     rf                  ; continue subtraction
[03428] c96a: 77                     smb
[03429] c96b: c3 c9 cd               lbdf    dim_err             ; jump on dimension error
[03430] c96e: 60                     irx                         ; recover dimension count
[03431] c96f: f0                     ldx
[03432] c970: ff 01                  smi     1                   ; and subtract 1
[03433] c972: c2 c9 a8               lbz     array_dn            ; jump if done processing arguments
[03434] c975: ae                     plo     re                  ; save this
[03435] c976: d7                     sep     r7                  ; put dimension pointer on stack
[03436] c977: b8                     db      push_rd.0
[03437] c978: 8e                     glo     re                  ; get it back
[03438] c979: 73                     stxd                        ; put dim count back on stack
[03439] c97a: 1d                     inc     rd
[03440] c97b: 1d                     inc     rd
[03441] c97c: 73          ar_mullp:  stxd                        ; save dimension count
[03442] c97d: 4d                     lda     rd                  ; get next dimension size
[03443] c97e: bf                     phi     rf                  ; into rf
[03444] c97f: 4d                     lda     rd
[03445] c980: af                     plo     rf
[03446] c981: d7                     sep     r7                  ; place onto expression stack
[03447] c982: 6a                     db      ex_push.0
[03448] c983: d7                     sep     r7                  ; save pointer
[03449] c984: b8                     db      push_rd.0
[03450] c985: d4                     sep     scall               ; multiply numbers
[03451] c986: c2 2e                  dw      ex_mul
[03452] c988: d7                     sep     r7                  ; recover rd
[03453] c989: be                     db      pop_rd.0
[03454] c98a: 60                     irx                         ; and dimension count
[03455] c98b: f0                     ldx
[03456] c98c: ff 01                  smi     1                   ; minus 1
[03457] c98e: ca c9 7c               lbnz    ar_mullp            ; morre multiplications to go
[03458] c991: d4                     sep     scall               ; add total to accumulation
[03459] c992: c0 cb                  dw      ex_add
[03460] c994: 60                     irx                         ; recover dimentsion count
[03461] c995: f0                     ldx
[03462] c996: ae                     plo     re                  ; set aside
[03463] c997: d7                     sep     r7                  ; get dimension pointer
[03464] c998: be                     db      pop_rd.0
[03465] c999: 1d                     inc     rd                  ; move to next dimension
[03466] c99a: 1d                     inc     rd
[03467] c99b: 8e                     glo     re                  ; get dimension count
[03468] c99c: 73                     stxd                        ; and save
[03469] c99d: d7                     sep     r7                  ; and put back on stack
[03470] c99e: b8                     db      push_rd.0
[03471] c99f: 4a                     lda     ra                  ; get next token
[03472] c9a0: ff 8d                  smi     08dh                ; must be a comma
[03473] c9a2: ca c9 d4               lbnz    err3_ret            ; error if not
[03474] c9a5: c0 c9 55               lbr     ar_mullp2           ; loop back
[03475] c9a8: 1d          array_dn:  inc     rd                  ; move past final dimension
[03476] c9a9: 1d                     inc     rd
[03477] c9aa: d7                     sep     r7                  ; save location
[03478] c9ab: b8                     db      push_rd.0
[03479] c9ac: d4                     sep     scall               ; add last dimension to toal
[03480] c9ad: c0 cb                  dw      ex_add
[03481] c9af: d7                     sep     r7                  ; get cell number
[03482] c9b0: 58                     db      ex_pop.0
[03483] c9b1: 8f                     glo     rf                  ; multiply by 2
[03484] c9b2: fe                     shl
[03485] c9b3: af                     plo     rf
[03486] c9b4: 9f                     ghi     rf
[03487] c9b5: 7e                     shlc
[03488] c9b6: bf                     phi     rf
[03489] c9b7: d7                     sep     r7                  ; and put back onto stack
[03490] c9b8: 6a                     db      ex_push.0
[03491] c9b9: d7                     sep     r7                  ; recover location
[03492] c9ba: a4                     db      pop_rf.0
[03493] c9bb: d7                     sep     r7                  ; add to base addres
[03494] c9bc: 6a                     db      ex_push.0
[03495] c9bd: d4                     sep     scall
[03496] c9be: c0 cb                  dw      ex_add
[03497] c9c0: d7                     sep     r7                  ; get final cell number
[03498] c9c1: 58                     db      ex_pop.0
[03499] c9c2: 4a                     lda     ra                  ; last token must be a )
[03500] c9c3: ff 85                  smi     85h
[03501] c9c5: ca d3 84               lbnz    syn_err             ; else error
[03502] c9c8: f8 02                  ldi     2                   ; array is integer
[03503] c9ca: fc 00                  adi     0                   ; signal success
[03504] c9cc: d5                     sep     sret                ; return to caller
[03505]                   
[03506]                   
[03507] c9cd: f8 0b       dim_err:   ldi     ERR_BADDIM          ; signal bad dimensions
[03508] c9cf: ff 00                  smi     0
[03509] c9d1: c0 c9 d6               lbr     err1_ret            ; and return
[03510] c9d4: 60          err3_ret:  irx                         ; dump 3 bytes off the stack
[03511] c9d5: 60          err2_ret:  irx
[03512] c9d6: 60          err1_ret:  irx
[03513] c9d7: d5                     sep     sret                ; and return
[03514]                   
[03515]                   #endif
[03516]                   
[03517]                   
[03518]                   ; ******************************************************************************
[03519]                   ; ***                         Start of L1 statements                         ***
[03520]                   ; ******************************************************************************
[03521]                   ; *******************
[03522]                   ; *** Process END ***
[03523]                   ; *******************
[03524] c9d8: f8 00       ex_end:    ldi     0                   ; terminate program execution
[03525] c9da: bc                     phi     rc
[03526] c9db: ac                     plo     rc
[03527] c9dc: c0 d3 68               lbr     exec_dn             ; finish up
[03528]                   
[03529]                   ; *********************
[03530]                   ; *** Process GOSUB ***
[03531]                   ; *********************
[03532] c9df: d4          ex_gosub:  sep     scall               ; evaluate expression for line number
[03533] c9e0: c2 8a                  dw      new_expr
[03534] c9e2: c3 d3 84               lbdf    syn_err             ; jump on error
[03535] c9e5: d7                     sep     r7                  ; retrieve line number
[03536] c9e6: 58                     db      ex_pop.0
[03537] c9e7: d7                     sep     r7                  ; move it to rd
[03538] c9e8: 72                     db      rf_rd.0
[03539] c9e9: 8c                     glo     rc                  ; save line in case of error
[03540] c9ea: 73                     stxd
[03541] c9eb: 9c                     ghi     rc
[03542] c9ec: 73                     stxd
[03543] c9ed: 9c                     ghi     rc                  ; save current line to gosub stack
[03544] c9ee: 58                     str     r8
[03545] c9ef: 18                     inc     r8
[03546] c9f0: 8c                     glo     rc
[03547] c9f1: 58                     str     r8
[03548] c9f2: 18                     inc     r8
[03549] c9f3: d7                     sep     r7                  ; find line
[03550] c9f4: 19                     db      find_ln.0
[03551] c9f5: cb ca 23               lbnf    no_line             ; jump if line was not found
[03552] c9f8: 60                     irx                         ; remove old line. Mark Albene
[03553] c9f9: 60                     irx
[03554] c9fa: 9a                     ghi     ra                  ; save current pointer to gosub stack
[03555] c9fb: 58                     str     r8
[03556] c9fc: 18                     inc     r8
[03557] c9fd: 8a                     glo     ra
[03558] c9fe: 58                     str     r8
[03559] c9ff: 18                     inc     r8
[03560] ca00: c0 ca 1c               lbr     goto_go             ; then treat like goto
[03561]                   
[03562]                   ; ********************
[03563]                   ; *** Process GOTO ***
[03564]                   ; ********************
[03565] ca03: d4          ex_goto:   sep     scall               ; evaluate expression for line number
[03566] ca04: c2 8a                  dw      new_expr
[03567] ca06: c3 d3 89               lbdf    err_ret             ; jump on error
[03568] ca09: 0a                     ldn     ra                  ; must be terminator
[03569] ca0a: ca d3 84               lbnz    syn_err
[03570] ca0d: d7          goto_go2:  sep     r7                  ; retrieve line number
[03571] ca0e: 58                     db      ex_pop.0
[03572] ca0f: d7                     sep     r7                  ; move it to rd
[03573] ca10: 72                     db      rf_rd.0
[03574] ca11: 8c                     glo     rc                  ; save line in case of error
[03575] ca12: 73                     stxd
[03576] ca13: 9c                     ghi     rc
[03577] ca14: 73                     stxd
[03578] ca15: d7                     sep     r7                  ; find line
[03579] ca16: 19                     db      find_ln.0
[03580] ca17: cb ca 23               lbnf    no_line             ; jump if line was not found
[03581] ca1a: 60                     irx                         ; get rid of old line
[03582] ca1b: 60                     irx
[03583] ca1c: 9c          goto_go:   ghi     rc                  ; copy line address to RA
[03584] ca1d: ba                     phi     ra
[03585] ca1e: 8c                     glo     rc
[03586] ca1f: aa                     plo     ra
[03587] ca20: c0 d3 77               lbr     exec_tst            ; execute from new line
[03588] ca23: 60          no_line:   irx                         ; recover current line
[03589] ca24: 72                     ldxa
[03590] ca25: bc                     phi     rc
[03591] ca26: f0                     ldx
[03592] ca27: ac                     plo     rc
[03593] ca28: f8 03       err_noln:  ldi     ERR_NOLIN           ; signal line not found
[03594] ca2a: ff 00                  smi     0                   ; signal error
[03595] ca2c: d5                     sep     sret                ; and return
[03596]                   
[03597]                   ; ******************
[03598]                   ; *** Process IF ***
[03599]                   ; ******************
[03600] ca2d: d4          ex_if:     sep     scall               ; evaluate expression
[03603]                   #else
[03604] ca2e: c6 8a                  dw      new_mexpr
[03605]                   #endif
[03606] ca30: c3 d3 89               lbdf    err_ret             ; jump on error
[03607] ca33: d7                     sep     r7                  ; retrieve result
[03608] ca34: 58                     db      ex_pop.0
[03609] ca35: 8f                     glo     rf                  ; see if success
[03610] ca36: 52                     str     r2
[03611] ca37: 9f                     ghi     rf
[03612] ca38: f1                     or
[03613] ca39: c2 d3 68               lbz     exec_dn             ; jump if IF failed test
[03620]                   #else
[03621] ca3c: 4a          if_chk:    lda     ra                  ; check for NOT OPTIONAL THEN
[03622] ca3d: ff 9f                  smi     09fh
[03623] ca3f: 32 43                  bz     if_exec             ; not there, so just continue
[03624]                              ; it would be nice to check for end of line but there is no clear end of line unless you parse numbers and tokens so
[03625]                              ; you don't hit a zero accidentally
[03626] ca41: 30 3c                  br      if_chk             ; and continue
[03627] ca43: 0a          if_exec:   ldn ra
[03628] ca44: ff fe                  smi  TKN_NUM
[03629] ca46: ca d3 39               lbnz execute
[03630]                              ; implied GOTO
[03631] ca49: c0 ca 03               lbr ex_goto
[03632]                   
[03633]                   #endif
[03634]                   
[03635]                   ; *********************
[03636]                   ; *** Process INPUT ***
[03637]                   ; *********************
[03638] ca4c: 0a          ex_input:  ldn     ra                  ; get next token
[03639] ca4d: ff fd                  smi     TKN_QSTR            ; is it a quoted string
[03640] ca4f: c2 ca 97               lbz     input_pr            ; jump if so
[03641] ca52: 0a          input_lp:  ldn     ra                  ; see if done
[03642] ca53: c2 cb a0               lbz     chk_term            ; jump if so
[03643] ca56: 0a                     ldn     ra                  ; get character
[03644] ca57: d4                     sep     scall               ; must be a variable name
[03645] ca58: ff 72                  dw      f_isalpha
[03646] ca5a: cb d3 84               lbnf    syn_err             ; otherwise error
[03647] ca5d: d4                     sep     scall               ; get variable address
[03648] ca5e: c8 7b                  dw      get_var
[03649] ca60: c3 d3 89               lbdf    err_ret
[03650]                   #if LEVEL>=2
[03651] ca63: ff 02                  smi     2                   ; is variable an integer
[03652] ca65: c2 ca 7a               lbz     inp_num             ; jump if so
[03653] ca68: d4                     sep     scall               ; deallocate previous value
[03654] ca69: d0 9c                  dw      de_str
[03655] ca6b: f8 05                  ldi     high expstack       ; setup expression stack
[03656] ca6d: b9                     phi     r9
[03657] ca6e: f8 b6                  ldi     low expstack
[03658] ca70: a9                     plo     r9
[03659] ca71: d4                     sep     scall               ; get string input
[03660] ca72: bd ba                  dw      get_sinput
[03661] ca74: c0 ca 80               lbr     inp_cnt             ; store value
[03662] ca77: c0 d3 84       lbr  syn_err
[03663]                   #endif
[03664] ca7a: d4          inp_num:   sep     scall               ; get input
[03665] ca7b: bd eb                  dw      get_input
[03666] ca7d: c3 d3 89               lbdf    err_ret             ; jump on error
[03667] ca80: 9d          inp_cnt:   ghi     rd                  ; store into variable
[03668] ca81: 5f                     str     rf
[03669] ca82: 1f                     inc     rf
[03670] ca83: 8d                     glo     rd
[03671] ca84: 5f                     str     rf
[03672] ca85: 0a                     ldn     ra                  ; get next token
[03673] ca86: c2 cb a0               lbz     chk_term            ; jump if terminator
[03674] ca89: ff 93                  smi     093h                ; colon also ends input
[03675] ca8b: c2 cb a0               lbz     chk_term
[03676] ca8e: 4a                     lda     ra                  ; get next token
[03677] ca8f: ff 8d                  smi     08dh                ; must be a comma
[03678] ca91: c2 ca 52               lbz     input_lp            ; process next variable
[03679] ca94: c0 d3 84               lbr     syn_err             ; otherwise error
[03680] ca97: 1a          input_pr:  inc     ra                  ; move past quote token
[03681] ca98: 4a          prompt_lp: lda     ra                  ; get byte from token stream
[03682] ca99: fb ff                  xri     0ffh                ; see if last character
[03683] ca9b: c2 ca a6               lbz     prompt_dn           ; jump if so
[03684] ca9e: fb ff                  xri     0ffh                ; otherwise restore character
[03685] caa0: d4                     sep     scall               ; and output it
[03686] caa1: ff 03                  dw      TYPE
[03687] caa3: c0 ca 98               lbr     prompt_lp           ; loop back until done
[03688] caa6: 4a          prompt_dn: lda     ra                  ; get next token
[03689] caa7: ff 8c                  smi     08ch                ; must be a semicolon
[03690] caa9: ca d3 84               lbnz    syn_err             ; otherwise error
[03691] caac: c0 ca 52               lbr     input_lp            ; loop back to get input
[03692]                   
[03693]                   ; *******************
[03694]                   ; *** Process LET ***
[03695]                   ; *******************
[03696] caaf: 0a          ex_let:    ldn     ra                  ; get next char
[03697] cab0: d4                     sep     scall               ; it must be alph
[03698] cab1: ff 72                  dw      f_isalpha
[03699] cab3: cb d3 84               lbnf    syn_err             ; otherwise syntax error
[03700] cab6: f8 00                  ldi     0                   ; mark expression stack as undefined
[03701] cab8: b9                     phi     r9
[03702] cab9: a9                     plo     r9
[03703] caba: d4                     sep     scall               ; get variable address
[03704] cabb: c8 7b                  dw      get_var
[03705] cabd: c3 d3 89               lbdf    err_ret
[03706] cac0: ae                     plo     re                  ; save variable type
[03707] cac1: 4a                     lda     ra                  ; next token must be an =
[03708] cac2: ff 86                  smi     86h
[03709] cac4: ca d3 84               lbnz    syn_err             ; jump on error
[03710] cac7: 8f                     glo     rf                  ; save variable address
[03711] cac8: 73                     stxd
[03712] cac9: 9f                     ghi     rf
[03713] caca: 73                     stxd
[03714] cacb: 8e                     glo     re                  ; save variable type
[03715] cacc: 73                     stxd
[03716]                   #if LEVEL>=2
[03717] cacd: d4                     sep     scall               ; dealloate possible string variable
[03718] cace: d0 9c                  dw      de_str
[03719]                   #endif
[03720] cad0: d4                     sep     scall               ; evaluate expression
[03723]                   #else
[03724] cad1: c6 8a                  dw      new_mexpr
[03725]                   #endif
[03726] cad3: c3 d3 89               lbdf    err_ret             ; jump if error occurred
[03727] cad6: 60                     irx                         ; need to check types
[03728] cad7: f3                     xor
[03729] cad8: ae                     plo     re
[03730] cad9: 60                     irx                         ; get variable address
[03731] cada: 72                     ldxa
[03732] cadb: bd                     phi     rd
[03733] cadc: f0                     ldx
[03734] cadd: ad                     plo     rd
[03735] cade: 8e                     glo     re
[03736] cadf: ca d3 84               lbnz    syn_err             ; syntax error if types do not match
[03737] cae2: d7                     sep     r7                  ; recover result
[03738] cae3: 58                     db      ex_pop.0
[03739] cae4: 9f                     ghi     rf                  ; write value to variable
[03740] cae5: 5d                     str     rd
[03741] cae6: 1d                     inc     rd
[03742] cae7: 8f                     glo     rf
[03743] cae8: 5d                     str     rd
[03744] cae9: c0 cb a0               lbr     chk_term            ; done
[03745]                   
[03746]                   ; ****************************
[03747]                   ; *** Process LIST command ***
[03748]                   ; ****************************
[03749] caec: f8 00       ex_list:   ldi     0                   ; setup list boundaries
[03750] caee: b8                     phi     r8
[03751] caef: a8                     plo     r8
[03752] caf0: f8 ff                  ldi     0ffh
[03753] caf2: b9                     phi     r9
[03754] caf3: a9                     plo     r9
[03755] caf4: 29                     dec     r9
[03756] caf5: 0a                     ldn     ra                  ; get next token
[03757] caf6: c2 cb 24               lbz     ex_flist            ; jump if full list requested
[03758] caf9: ff 81                  smi     81h                 ; is it the minus
[03759] cafb: c2 cb 0c               lbz     to_end              ; jump if so
[03760] cafe: 4a                     lda     ra                  ; get token again
[03761] caff: ff fe                  smi     TKN_NUM             ; must be a number
[03762] cb01: ca d3 84               lbnz    syn_err             ; otherwise error
[03763] cb04: 4a                     lda     ra                  ; retrieve number into r8
[03764] cb05: b8                     phi     r8
[03765] cb06: 4a                     lda     ra
[03766] cb07: a8                     plo     r8
[03767] cb08: 0a                     ldn     ra                  ; see if single line
[03768] cb09: c2 cb 7b               lbz     list_1              ; jump if so
[03769] cb0c: 4a          to_end:    lda     ra
[03770] cb0d: ff 81                  smi     81h                 ; must now be a minus sign
[03771] cb0f: ca d3 84               lbnz    syn_err             ; else error
[03772] cb12: 0a                     ldn     ra                  ; see if open end
[03773] cb13: c2 cb 24               lbz     ex_flist            ; jump if so
[03774] cb16: 4a                     lda     ra                  ; and retrieve it
[03775] cb17: ff fe                  smi     TKN_NUM             ; must be a number
[03776] cb19: ca d3 84               lbnz    syn_err             ; otherwise error
[03777] cb1c: 4a                     lda     ra                  ; retrieve number into R9
[03778] cb1d: b9                     phi     r9
[03779] cb1e: 4a                     lda     ra
[03780] cb1f: a9                     plo     r9
[03781] cb20: 0a                     ldn     ra                  ; must be followd by terminator
[03782] cb21: ca d3 84               lbnz    syn_err
[03783] cb24: 8a          ex_flist:  glo     ra                  ; save token address
[03784] cb25: 73                     stxd
[03785] cb26: 9a                     ghi     ra
[03786] cb27: 73                     stxd
[03787] cb28: 8c                     glo     rc                  ; save line address
[03788] cb29: 73                     stxd
[03789] cb2a: 9c                     ghi     rc
[03790] cb2b: 73                     stxd
[03791] cb2c: f8 05                  ldi     high basic          ; point to basic storage
[03792] cb2e: ba                     phi     ra                  ; put into ra and rc
[03793] cb2f: bc                     phi     rc
[03794] cb30: f8 b7                  ldi     low basic
[03795] cb32: aa                     plo     ra
[03796] cb33: ac                     plo     rc
[03797] cb34: 0a          flist_lp:  ldn     ra                  ; get line size
[03798] cb35: c2 cb 6f               lbz     flist_dn            ; jump if done
[03799] cb38: 1a                     inc     ra                  ; retrieve line number
[03800] cb39: 4a                     lda     ra
[03801] cb3a: bd                     phi     rd
[03802] cb3b: 0a                     ldn     ra
[03803] cb3c: ad                     plo     rd
[03804] cb3d: 2a                     dec     ra                  ; put pointer back
[03805] cb3e: 2a                     dec     ra
[03806] cb3f: 88                     glo     r8                  ; perform line-R8
[03807] cb40: 52                     str     r2
[03808] cb41: 8d                     glo     rd
[03809] cb42: f7                     sm
[03810] cb43: 98                     ghi     r8
[03811] cb44: 52                     str     r2
[03812] cb45: 9d                     ghi     rd
[03813] cb46: 77                     smb
[03814] cb47: cb cb 64               lbnf    no_show             ; jump if line number was too small
[03815] cb4a: 19                     inc     r9
[03816] cb4b: 89                     glo     r9                  ; now line-R9
[03817] cb4c: 52                     str     r2
[03818] cb4d: 8d                     glo     rd
[03819] cb4e: f7                     sm
[03820] cb4f: 99                     ghi     r9
[03821] cb50: 52                     str     r2
[03822] cb51: 9d                     ghi     rd
[03823] cb52: 77                     smb
[03824] cb53: 29                     dec     r9
[03825] cb54: c3 cb 64               lbdf    no_show             ; jump if line number was too large
[03826] cb57: d7          show:      sep     r7                  ; setup output buffer
[03827] cb58: 09                     db      set_buf.0
[03828] cb59: d4                     sep     scall               ; detokenize the line
[03829] cb5a: bc e4                  dw      detoken
[03830] cb5c: d7                     sep     r7                  ; point to output buffer
[03831] cb5d: 09                     db      set_buf.0
[03832] cb5e: d4                     sep     scall               ; display it
[03833] cb5f: ff 09                  dw      MSG
[03834] cb61: d4                     sep     scall               ; need a cr/lf
[03835] cb62: bd 71                  dw      do_crlf
[03836] cb64: d7          no_show:   sep     r7                  ; find next line
[03837] cb65: 48                     db      next_ln.0
[03838] cb66: 9f                     ghi     rf                  ; transfer address
[03839] cb67: ba                     phi     ra
[03840] cb68: bc                     phi     rc
[03841] cb69: 8f                     glo     rf
[03842] cb6a: aa                     plo     ra
[03843] cb6b: ac                     plo     rc
[03844] cb6c: c0 cb 34               lbr     flist_lp            ; display next line
[03845] cb6f: 60          flist_dn:  irx                         ; recover consumed registers
[03846] cb70: 72                     ldxa
[03847] cb71: bc                     phi     rc
[03848] cb72: 72                     ldxa
[03849] cb73: ac                     plo     rc
[03850] cb74: 72                     ldxa
[03851] cb75: ba                     phi     ra
[03852] cb76: f0                     ldx
[03853] cb77: aa                     plo     ra
[03854] cb78: c0 cb a0               lbr     chk_term            ; goot at this opint
[03855] cb7b: 98          list_1:    ghi     r8                  ; transfer number
[03856] cb7c: bd                     phi     rd
[03857] cb7d: 88                     glo     r8
[03858] cb7e: ad                     plo     rd
[03859] cb7f: d7                     sep     r7                  ; find the line
[03860] cb80: 19                     db      find_ln.0
[03861] cb81: 9c                     ghi     rc                  ; transfer address
[03862] cb82: ba                     phi     ra
[03863] cb83: 8c                     glo     rc
[03864] cb84: aa                     plo     ra
[03865] cb85: f8 00                  ldi     0                   ; zero RC
[03866] cb87: bc                     phi     rc
[03867] cb88: ac                     plo     rc
[03868] cb89: cb ca 28               lbnf    err_noln            ; jump if line was not found
[03869] cb8c: d7                     sep     r7
[03870] cb8d: 09                     db      set_buf.0
[03871] cb8e: d4                     sep     scall               ; detokenize the line
[03872] cb8f: bc e4                  dw      detoken
[03873] cb91: d7                     sep     r7                  ; point to output buffer
[03874] cb92: 09                     db      set_buf.0
[03875] cb93: d4                     sep     scall               ; display it
[03876] cb94: ff 09                  dw      MSG
[03877] cb96: d4                     sep     scall               ; need a cr/lf
[03878] cb97: bd 71                  dw      do_crlf
[03879] cb99: f8 00                  ldi     0                   ; make sure no program continues
[03880] cb9b: bc                     phi     rc
[03881] cb9c: ac                     plo     rc
[03882] cb9d: c0 cb a0               lbr     chk_term            ; done
[03883]                   
[03884]                   
[03885]                   
[03886] cba0: 0a          chk_term:  ldn     ra                  ; get next token
[03887] cba1: c2 d3 39               lbz     execute
[03888] cba4: ff 93                  smi     093h                ; colon is also valid
[03889] cba6: ca d3 84               lbnz    syn_err             ; should have been zero
[03890] cba9: c0 cb af               lbr     exec_coln
[03891] cbac: fc 00       exec_good: adi     0                   ; signal no error
[03892] cbae: d5                     sep     sret                ; return to caller
[03893] cbaf: 1a          exec_coln: inc     ra                  ; move past colon
[03894] cbb0: c0 d3 39               lbr     execute             ; continue processing line
[03895]                   
[03896]                   ; *******************
[03897]                   ; *** Process NEW ***
[03898]                   ; *******************
[03899] cbb3: f8 00       ex_new:    ldi     0                   ; terminate program execution
[03900] cbb5: bc                     phi     rc
[03901] cbb6: ac                     plo     rc
[03902] cbb7: d7                     sep     r7                  ; set first byte of basic area to 0
[03903] cbb8: c5                     db      set_byte.0
[03904] cbb9: 05 b7                  dw      basic
[03905] cbbb: 00                     db      0
[03906] cbbc: d4                     sep     scall               ; setup variable table
[03907] cbbd: bf 36                  dw      rst_vars
[03908] cbbf: c0 d3 68               lbr     exec_dn             ; finish up
[03909]                   
[03910]                   ; *******************
[03911]                   ; *** Process OUT ***
[03912]                   ; *******************
[03913] cbc2: d4          ex_out:    sep     scall               ; get first argument
[03914] cbc3: c2 8a                  dw      new_expr
[03915] cbc5: c3 d3 89               lbdf    err_ret             ; jump on error
[03916] cbc8: 4a                     lda     ra                  ; get next token
[03917] cbc9: ff 8d                  smi     08dh                ; must be a comma
[03918] cbcb: ca d3 84               lbnz    syn_err             ; otherwise syntax error
[03919] cbce: d7                     sep     r7                  ; retrieve value from stack
[03920] cbcf: 58                     db      ex_pop.0
[03921] cbd0: 8f                     glo     rf                  ; save address
[03922] cbd1: fa 07                  ani     7                   ; mask for correct range
[03923] cbd3: c2 d3 87               lbz     val_err             ; jump if invalid value
[03924] cbd6: fc 60                  adi     60h                 ; convert to out instruction
[03925] cbd8: 73                     stxd
[03926] cbd9: d4                     sep     scall               ; now get value
[03927] cbda: c2 8a                  dw      new_expr
[03928] cbdc: c3 d3 89               lbdf    err_ret             ; jump on error
[03929] cbdf: d7                     sep     r7                  ; retrieve value
[03930] cbe0: 58                     db      ex_pop.0
[03931] cbe1: 60                     irx                         ; recover address
[03932] cbe2: f0                     ldx
[03933] cbe3: bf                     phi     rf
[03934] cbe4: f8 d3                  ldi     0d3h                ; instruction to put reset P=3
[03935] cbe6: 73                     stxd
[03936] cbe7: 8f                     glo     rf                  ; put value onto stack
[03937] cbe8: 73                     stxd
[03938] cbe9: 9f                     ghi     rf                  ; get out instruction
[03939] cbea: 52                     str     r2
[03940] cbeb: d2                     sep     r2                  ; execute instructions on stack
[03941] cbec: 22                     dec     r2                  ; move stack back to correct address
[03942] cbed: c0 cb a0               lbr     chk_term            ; check termination
[03943]                   
[03944]                   ; ********************
[03945]                   ; *** Process PLOT ***
[03946]                   ; ********************
[03947] cbf0: d4          ex_plot:   sep     scall               ; evaluate argument
[03948] cbf1: c2 8a                  dw      new_expr
[03949] cbf3: c3 d3 89               lbdf    err_ret             ; jump if error occurred
[03950] cbf6: 0a                     ldn     ra                  ; see if comma is specified
[03951] cbf7: ff 8d                  smi     08dh
[03952] cbf9: ca cc 30               lbnz    ex_plotdn           ; jump if not
[03953] cbfc: 1a                     inc     ra                  ; move past comma
[03954] cbfd: d4                     sep     scall               ; evaluate second argument
[03955] cbfe: c2 90                  dw      expr
[03956] cc00: c3 d3 89               lbdf    err_ret
[03957] cc03: d7                     sep     r7                  ; point to buffer
[03958] cc04: 09                     db      set_buf.0
[03959] cc05: d7                     sep     r7                  ; add escape character
[03960] cc06: 53                     db      add_char.0
[03961] cc07: 1b                     db      01bh
[03962] cc08: d7                     sep     r7                  ; add escape character
[03963] cc09: 53                     db      add_char.0
[03964] cc0a: 5b                     db      '['
[03965] cc0b: d7                     sep     r7                  ; get top of expr stack in RD
[03966] cc0c: 61                     db      ex_pop_rd.0
[03967] cc0d: d4                     sep     scall               ; convert output
[03968] cc0e: ff 63                  dw      f_intout
[03969] cc10: d7                     sep     r7                  ; now need a semicolon
[03970] cc11: 53                     db      add_char.0
[03971] cc12: 3b                     db      ';'
[03972] cc13: d7                     sep     r7                  ; get top of expr stack in RD
[03973] cc14: 61                     db      ex_pop_rd.0
[03974] cc15: d4                     sep     scall               ; convert output
[03975] cc16: ff 63                  dw      f_intout
[03976] cc18: d7                     sep     r7                  ; now need a semicolon
[03977] cc19: 53                     db      add_char.0
[03978] cc1a: 48                     db      'H'
[03979] cc1b: d7                     sep     r7                  ; now need a semicolon
[03980] cc1c: 53                     db      add_char.0
[03981] cc1d: 00                     db      0
[03982] cc1e: d7                     sep     r7                  ; point to buffer
[03983] cc1f: 09                     db      set_buf.0
[03984] cc20: d4                     sep     scall               ; send escape sequence
[03985] cc21: ff 09                  dw      MSG
[03986] cc23: 0a                     ldn     ra                  ; get next character
[03987] cc24: ff 8d                  smi     08dh                ; is it a comma
[03988] cc26: ca cb a0               lbnz    chk_term            ; jump if not
[03989] cc29: 1a                     inc     ra                  ; move past comma
[03990] cc2a: d4                     sep     scall               ; get final argument
[03991] cc2b: c2 8a                  dw      new_expr
[03992] cc2d: c3 d3 89               lbdf    err_ret
[03993] cc30: d7          ex_plotdn: sep     r7                  ; retreive value
[03994] cc31: 58                     db      ex_pop.0
[03995] cc32: 8f                     glo     rf                  ; get low value
[03996] cc33: d4                     sep     scall               ; and display it
[03997] cc34: ff 03                  dw      TYPE
[03998] cc36: c0 cb a0               lbr     chk_term            ; done
[03999]                   
[04000]                   ; ********************
[04001]                   ; *** Process POKE ***
[04002]                   ; ********************
[04003] cc39: d4          ex_poke:   sep     scall               ; get first argument
[04004] cc3a: c2 8a                  dw      new_expr
[04005] cc3c: c3 d3 89               lbdf    err_ret             ; jump on error
[04006] cc3f: 4a                     lda     ra                  ; get next token
[04007] cc40: ff 8d                  smi     08dh                ; must be a comma
[04008] cc42: ca d3 84               lbnz    syn_err             ; otherwise syntax error
[04009] cc45: d7                     sep     r7                  ; retrieve value from stack
[04010] cc46: 58                     db      ex_pop.0
[04011] cc47: 8f                     glo     rf                  ; save address
[04012] cc48: 73                     stxd
[04013] cc49: 9f                     ghi     rf
[04014] cc4a: 73                     stxd
[04015] cc4b: d4                     sep     scall               ; now get value
[04016] cc4c: c2 8a                  dw      new_expr
[04017] cc4e: c3 d3 89               lbdf    err_ret             ; jump on error
[04018] cc51: d7                     sep     r7                  ; retrieve value
[04019] cc52: 58                     db      ex_pop.0
[04020] cc53: 60                     irx                         ; recover address
[04021] cc54: 72                     ldxa
[04022] cc55: bd                     phi     rd
[04023] cc56: f0                     ldx
[04024] cc57: ad                     plo     rd
[04025] cc58: 8f                     glo     rf                  ; get byte from value
[04026] cc59: 5d                     str     rd                  ; and poke into memory
[04027] cc5a: c0 cb a0               lbr     chk_term            ; check termination
[04028]                   
[04029]                   ; *********************
[04030]                   ; *** process PRINT ***
[04031]                   ; *********************
[04032] cc5d: 0a          ex_print:  ldn     ra                  ; get next symbol
[04033] cc5e: c2 cc bb               lbz     print_dn            ; jump if hit end
[04034] cc61: ff 93                  smi     093h                ; colon is also valid terminator
[04035] cc63: c2 cc bb               lbz     print_dn
[04036] cc66: 4a                     lda     ra
[04037] cc67: ae                     plo     re                  ; keep a copy
[04038] cc68: ff 8c                  smi     08ch                ; check for semicolon
[04039] cc6a: c2 cc a7               lbz     print_sc            ; jump if so
[04040] cc6d: 8e                     glo     re                  ; recover symbol
[04041] cc6e: ff 8d                  smi     08dh                ; check for comma
[04042] cc70: c2 cc b3               lbz     print_cm            ; jump if so
[04043] cc73: 8e                     glo     re                  ; recover symbol
[04051]                   #else
[04052] cc74: 2a                     dec     ra                  ; point to beginning of expression
[04053] cc75: d4                     sep     scall               ; evaluate it
[04054] cc76: c6 8a                  dw      new_mexpr
[04055] cc78: c3 d3 89               lbdf    err_ret             ; jump if error occurred
[04056] cc7b: ff 02                  smi     2                   ; was result an integer
[04057] cc7d: c2 cc 93               lbz     prt_int             ; jump if so
[04058] cc80: d7                     sep     r7                  ; retrieve string address
[04059] cc81: 58                     db      ex_pop.0
[04060] cc82: d4                     sep     scall               ; deallocate temporary storage
[04061] cc83: d1 1c                  dw      dealloc
[04062] cc85: 4f          print_qs:  lda     rf                  ; get next symbol
[04063] cc86: fb ff                  xri     0ffh                ; see if terminator found
[04064] cc88: c2 cc 5d               lbz     ex_print            ; jump if so
[04065] cc8b: fb ff                  xri     0ffh                ; restore character
[04066] cc8d: d4                     sep     scall               ; display the character
[04067] cc8e: ff 03                  dw      TYPE
[04068] cc90: c0 cc 85               lbr     print_qs            ; loop back until done
[04069]                   #endif
[04070] cc93: d7          prt_int:   sep     r7                  ; retrieve final value
[04071] cc94: 58                     db      ex_pop.0
[04072] cc95: d7                     sep     r7                  ; move to rd
[04073] cc96: 72                     db      rf_rd.0
[04074] cc97: d7                     sep     r7                  ; setup a buffer
[04075] cc98: 09                     db      set_buf.0
[04076] cc99: d4                     sep     scall               ; and convert number
[04077] cc9a: ff 63                  dw      f_intout
[04078] cc9c: f8 00                  ldi     0                   ; place terminator
[04079] cc9e: 5f                     str     rf
[04080] cc9f: d7                     sep     r7                  ; setup a buffer
[04081] cca0: 09                     db      set_buf.0
[04082] cca1: d4                     sep     scall               ; print value
[04083] cca2: ff 09                  dw      MSG
[04084] cca4: c0 cc 5d               lbr     ex_print            ; and look for other things to print
[04093]                   #endif
[04094] cca7: 0a          print_sc:  ldn     ra                  ; get next symbol
[04095] cca8: c2 cc b0               lbz     print_ncr           ; jump if no cr needed
[04096] ccab: ff 93                  smi     093h                ; colon is also valid for end
[04097] ccad: ca cc 5d               lbnz    ex_print            ; continue printing
[04098] ccb0: c0 cb a0    print_ncr: lbr     chk_term
[04099] ccb3: f8 09       print_cm:  ldi     9                   ; need to output a tab
[04100] ccb5: d4                     sep     scall               ; send to terminal
[04101] ccb6: ff 03                  dw      TYPE
[04102] ccb8: c0 cc a7               lbr     print_sc            ; then process like semicolon
[04103] ccbb: d4          print_dn:  sep     scall               ; print a cr/lf
[04104] ccbc: ff 66                  dw      INMSG
[04105] ccbe: 0a 0d 00               db      10,13,0
[04106] ccc1: c0 cb a0               lbr     chk_term            ; and continue processing line
[04107]                   
[04108]                   ; **********************
[04109]                   ; *** Process RETURN ***
[04110]                   ; **********************
[04111] ccc4: 0a          ex_return: ldn     ra                  ; next token must be zero
[04112] ccc5: ca d3 84               lbnz    syn_err             ; else syntax error
[04113] ccc8: 88                     glo     r8                  ; make sure gosub stack is not empty
[04114] ccc9: ff b5                  smi     gosub_st.0
[04115] cccb: ca cc d9               lbnz    ret_good            ; jump if good
[04116] ccce: 98                     ghi     r8                  ; check high byte as well
[04117] cccf: ff 02                  smi     gosub_st.1
[04118] ccd1: ca cc d9               lbnz    ret_good
[04119] ccd4: ff 00                  smi     0                   ; signal an error
[04120] ccd6: f8 04                  ldi     ERR_INVRET
[04121] ccd8: d5                     sep     sret                ; and return to caller
[04122] ccd9: 28          ret_good:  dec     r8                  ; retrieve current token pointer
[04123] ccda: 08                     ldn     r8
[04124] ccdb: aa                     plo     ra
[04125] ccdc: 28                     dec     r8
[04126] ccdd: 08                     ldn     r8
[04127] ccde: ba                     phi     ra
[04128] ccdf: 28                     dec     r8                  ; retrieve current line pointer
[04129] cce0: 08                     ldn     r8
[04130] cce1: ac                     plo     rc
[04131] cce2: 28                     dec     r8
[04132] cce3: 08                     ldn     r8
[04133] cce4: bc                     phi     rc
[04134] cce5: c0 cb a0               lbr     chk_term            ; and continue
[04135]                   
[04136]                   ; *******************
[04137]                   ; *** Process RUN ***
[04138]                   ; *******************
[04139] cce8: f8 05       ex_run:    ldi     high basic          ; point to first program line
[04140] ccea: bc                     phi     rc                  ; placei into rc and ra
[04141] cceb: ba                     phi     ra
[04142] ccec: f8 b7                  ldi     low basic
[04143] ccee: ac                     plo     rc
[04144] ccef: aa                     plo     ra
[04145] ccf0: f8 02                  ldi     high gosub_st       ; setup gosub stack
[04146] ccf2: b8                     phi     r8
[04147] ccf3: f8 b5                  ldi     low gosub_st
[04148] ccf5: a8                     plo     r8
[04149] ccf6: d7                     sep     r7                  ; zero the input buffer
[04150] ccf7: c5                     db      set_byte.0
[04151] ccf8: 01 63                  dw      ibuffer
[04152] ccfa: 00                     db      0
[04153] ccfb: d7                     sep     r7                  ; setup input buffer pointer
[04154] ccfc: cd                     db      set_word.0
[04155] ccfd: 01 61                  dw      inp_pos
[04156] ccff: 01 63                  dw      ibuffer
[04157]                   #if LEVEL>=2
[04158] cd01: d4                     sep     scall               ; setup variable table
[04159] cd02: bf 36                  dw      rst_vars
[04160] cd04: d7                     sep     r7                  ; need to setup FOR stack
[04161] cd05: cd                     db      set_word.0
[04162] cd06: 01 0a                  dw      for_pos
[04163] cd08: 01 5c                  dw      for_st
[04164] cd0a: d7                     sep     r7                  ; need to setup DATA pointers
[04165] cd0b: cd                     db      set_word.0
[04166] cd0c: 01 02                  dw      data_lin
[04167] cd0e: 05 b7                  dw      basic
[04168] cd10: d7                     sep     r7                  ; point rf to beginning of basic
[04169] cd11: d6                     db      set_rf.0
[04170] cd12: 05 b7                  dw      basic
[04171] cd14: 1f                     inc     rf                  ; move to first token
[04172] cd15: 1f                     inc     rf
[04173] cd16: 1f                     inc     rf
[04174] cd17: 0f                     ldn     rf                  ; and retrieve it
[04175] cd18: ff 1a                  smi     CMD_START           ; subtract command offset
[04176] cd1a: ff 96                  smi     96h                 ; check for DATA
[04177] cd1c: ca cd 2e               lbnz    nodata
[04178] cd1f: 1f                     inc     rf                  ; otherwise point to first data item
[04179] cd20: f8 01                  ldi     high data_pos       ; setup data position
[04180] cd22: bd                     phi     rd
[04181] cd23: f8 04                  ldi     low data_pos
[04182] cd25: ad                     plo     rd
[04183] cd26: 9f                     ghi     rf                  ; and write pointer
[04184] cd27: 5d                     str     rd
[04185] cd28: 1d                     inc     rd
[04186] cd29: 8f                     glo     rf
[04187] cd2a: 5d                     str     rd
[04188] cd2b: c0 cd 31               lbr     yesdata             ; and skip looking for DATA
[04189] cd2e: d4          nodata:    sep     scall               ; find next data statement
[04190] cd2f: c0 73                  dw      find_data
[04191]                   #endif
[04192] cd31: c0 d3 77    yesdata:   lbr     exec_tst            ; start program execution
[04193]                   
[04194]                   ; ******************************************************************************
[04195]                   ; ***                           End of L1 statements                         ***
[04196]                   ; ******************************************************************************
[04197]                   
[04198]                   ; ************************
[04199]                   ; *** Exit from basic  ***
[04200]                   ; ************************
[04201] cd34: c0 80 03    ex_bye:    lbr     exitaddr
[04202]                   
[04203]                   #ifdef INROM
[04204]                   ; **********************************************************
[04205]                   ; ***                     Pico/Elf ROM                   ***
[04206]                   ; **********************************************************
[04207]                   ; ********************
[04208]                   ; *** Process SAVE ***
[04209]                   ; ********************
[04210] cd37: d4          ex_save:   sep     scall               ; open XMODEM channel
[04211] cd38: d4 00                  dw      xopenw
[04212] cd3a: f8 05 bf f8            mov     rf,basic            ; point to basic space
              b7 af 
[04213] cd40: d4                     sep     scall               ; get size of block
[04214] cd41: d3 8c                  dw      size_end
[04215] cd43: 9c 73 8c 73            push    rc                  ; save count
[04216] cd47: f8 01 bf f8            mov     rf,ibuffer          ; where to store it
              63 af 
[04217] cd4d: 9c                     ghi     rc                  ; write count
[04218] cd4e: 5f                     str     rf
[04219] cd4f: 1f                     inc     rf                  ; point to low byte
[04220] cd50: 8c                     glo     rc                  ; get low byte of count
[04221] cd51: 5f                     str     rf                  ; and store it
[04222] cd52: 2f                     dec     rf                  ; point back to high byte
[04223] cd53: f8 00 bc f8            mov     rc,2                ; 2 bytes to write
              02 ac 
[04224] cd59: d4                     sep     scall               ; write them to XMODEM channel
[04225] cd5a: d4 09                  dw      xwrite
[04226] cd5c: f8 05 bf f8            mov     rf,basic            ; point back to basic space
              b7 af 
[04227] cd62: 60 72 ac f0            pop     rc                  ; recover count
              bc 
[04228] cd67: d4                     sep     scall               ; write block to XMODEM channel
[04229] cd68: d4 09                  dw      xwrite
[04230] cd6a: d4                     sep     scall               ; close the XMODEM channel
[04231] cd6b: d4 0c                  dw      xclosew
[04232] cd6d: f8 00                  ldi     0                   ; signal end
[04233] cd6f: ac                     plo     rc
[04234] cd70: bc                     phi     rc
[04235] cd71: c0 d3 68               lbr     exec_dn             ; finish up
[04236]                   
[04237]                   ; ********************
[04238]                   ; *** Process LOAD ***
[04239]                   ; ********************
[04240] cd74: d4          ex_load:   sep     scall               ; attempt to open XMODEM channel
[04241] cd75: d4 03                  dw      xopenr
[04242] cd77: f8 01 bf f8            mov     rf,ibuffer          ; point to temporary buffer
              63 af 
[04243] cd7d: f8 00 bc f8            mov     rc,2                ; need to read 2 bytes
              02 ac 
[04244] cd83: d4                     sep     scall               ; get save size from XMODEM channel
[04245] cd84: d4 06                  dw      xread
[04246] cd86: f8 01 bf f8            mov     rf,ibuffer          ; point to bytes read
              63 af 
[04247] cd8c: 4f                     lda     rf                  ; get high byte of count
[04248] cd8d: bc                     phi     rc                  ; put into count
[04249] cd8e: 0f                     ldn     rf                  ; get low byte of count
[04250] cd8f: ac                     plo     rc                  ; put into count
[04251] cd90: f8 05 bf f8            mov     rf,basic            ; point to basic space
              b7 af 
[04252] cd96: d4                     sep     scall               ; Read from XMODEM channel
[04253] cd97: d4 06                  dw      xread
[04254] cd99: d4                     sep     scall               ; close the XMODEM channel
[04255] cd9a: d4 0f                  dw      xcloser
[04256] cd9c: d4                     sep     scall               ; setup variable table
[04257] cd9d: bf 36                  dw      rst_vars
[04258] cd9f: f8 00                  ldi     0                   ; signal end
[04259] cda1: ac                     plo     rc
[04260] cda2: bc                     phi     rc
[04261] cda3: c0 d3 68               lbr     exec_dn             ; finish up
[04262]                   #endif
[04263]                   
[04385]                   #endif
[04386]                   
[04387]                   #if LEVEL>=2
[04388]                   ; ******************************************************************************
[04389]                   ; ***                         Start of L2 statements                         ***
[04390]                   ; ******************************************************************************
[04391]                   ; *********************
[04392]                   ; *** Process CLEAR ***
[04393]                   ; *********************
[04394] cda6: d4          ex_clear:  sep     scall              ; reset variables nad heap
[04395] cda7: bf 36                  dw      rst_vars
[04396] cda9: c0 cb a0               lbr     chk_term           ; finished
[04397]                   
[04398]                   ; *******************
[04399]                   ; *** Process FOR ***
[04400]                   ; *******************
[04401] cdac: 0a          ex_for:    ldn     ra                  ; get next token
[04402] cdad: d4                     sep     scall               ; it must be alpha (variable)
[04403] cdae: ff 72                  dw      f_isalpha
[04404] cdb0: cb d3 84               lbnf    syn_err             ; otherwise syntax error
[04405] cdb3: d4                     sep     scall               ; get variable address
[04406] cdb4: c8 7b                  dw      get_var
[04407] cdb6: c3 d3 89               lbdf    err_ret
[04408] cdb9: f8 01                  ldi     high for_pos        ; get current pointer
[04409] cdbb: bd                     phi     rd
[04410] cdbc: f8 0a                  ldi     low for_pos
[04411] cdbe: ad                     plo     rd
[04412] cdbf: 4d                     lda     rd
[04413] cdc0: bb                     phi     rb
[04414] cdc1: 4d                     lda     rd
[04415] cdc2: ab                     plo     rb
[04416] cdc3: 8b          for_lp:    glo     rb                  ; make sure it is not empty
[04417] cdc4: fb 5c                  xri     for_st.0
[04418] cdc6: ae                     plo     re                  ; save first result
[04419] cdc7: 9b                     ghi     rb
[04420] cdc8: fb 01                  xri     for_st.1
[04421] cdca: 52                     str     r2                  ; or with first result
[04422] cdcb: 8e                     glo     re
[04423] cdcc: f1                     or
[04424] cdcd: c2 cd f7               lbz     for_new             ; jump if end of for stack
[04425]                   
[04426] cdd0: 1b                     inc     rb                  ; point to var address msb
[04427] cdd1: eb                     sex     rb                  ; use this as data pointer
[04428] cdd2: 9f                     ghi     rf                  ; compare against IF variable address
[04429] cdd3: f3                     xor
[04430] cdd4: ae                     plo     re                  ; keep temporary value
[04431] cdd5: 1b                     inc     rb                  ; move to lsb
[04432] cdd6: 8f                     glo     rf
[04433] cdd7: f3                     xor                         ; and compare
[04434] cdd8: e2                     sex     r2                  ; point x back to stack
[04435] cdd9: 52                     str     r2                  ; put temp value here
[04436] cdda: 8e                     glo     re                  ; get high temp value
[04437] cddb: f1                     or                          ; and combine with first value
[04438] cddc: 2b                     dec     rb                  ; move to beginning of entry
[04439] cddd: 2b                     dec     rb                  ; back to free spot
[04440] cdde: ca cd ec               lbnz    for_nxt             ; jump if entry was not a match
[04441] cde1: 8b                     glo     rb                  ; clear entry and reuse
[04442] cde2: fc 0a                  adi     10
[04443] cde4: ab                     plo     rb
[04444] cde5: 9b                     ghi     rb
[04445] cde6: 7c 00                  adci    0
[04446] cde8: bb                     phi     rb
[04447] cde9: c0 ce 01               lbr     for_go
[04448] cdec: 8b          for_nxt:   glo     rb                  ; move to next entry
[04449] cded: fc 0a                  adi     10
[04450] cdef: ab                     plo     rb
[04451] cdf0: 9b                     ghi     rb
[04452] cdf1: 7c 00                  adci    0
[04453] cdf3: bb                     phi     rb
[04454] cdf4: c0 cd c3               lbr     for_lp
[04455]                   
[04456]                   
[04457] cdf7: f8 01       for_new:   ldi     high for_pos        ; get current pointer
[04458] cdf9: bd                     phi     rd
[04459] cdfa: f8 0a                  ldi     low for_pos
[04460] cdfc: ad                     plo     rd
[04461] cdfd: 4d                     lda     rd
[04462] cdfe: bb                     phi     rb
[04463] cdff: 4d                     lda     rd
[04464] ce00: ab                     plo     rb
[04465] ce01: eb          for_go:    sex     rb                  ; point X to for stack
[04466] ce02: 8c                     glo     rc                  ; put RC onto stack
[04467] ce03: 73                     stxd
[04468] ce04: 9c                     ghi     rc
[04469] ce05: 73                     stxd
[04470] ce06: e2                     sex     r2                  ; point X back to stack
[04471] ce07: 4a                     lda     ra                  ; get next token
[04472] ce08: ff 86                  smi     086h                ; must be =
[04473] ce0a: ca d3 84               lbnz    syn_err             ; otherwise error
[04474] ce0d: 8f                     glo     rf                  ; save variable address for now
[04475] ce0e: 73                     stxd
[04476] ce0f: 9f                     ghi     rf
[04477] ce10: 73                     stxd
[04478] ce11: 8b                     glo     rb                  ; save rb
[04479] ce12: 73                     stxd
[04480] ce13: 9b                     ghi     rb
[04481] ce14: 73                     stxd
[04482] ce15: d4                     sep     scall               ; get start value
[04483] ce16: c2 8a                  dw      new_expr
[04484] ce18: 60                     irx                         ; recover rb
[04485] ce19: 72                     ldxa
[04486] ce1a: bb                     phi     rb
[04487] ce1b: f0                     ldx
[04488] ce1c: ab                     plo     rb
[04489] ce1d: c3 d3 89               lbdf    err_ret             ; jump if error
[04490] ce20: d7                     sep     r7                  ; get value
[04491] ce21: 58                     db      ex_pop.0
[04492] ce22: 60                     irx                         ; recover variable address
[04493] ce23: 72                     ldxa
[04494] ce24: bd                     phi     rd
[04495] ce25: f0                     ldx
[04496] ce26: ad                     plo     rd
[04497] ce27: 22                     dec     r2                  ; keep variable address on stack
[04498] ce28: 22                     dec     r2
[04499] ce29: 9f                     ghi     rf                  ; write start into variable
[04500] ce2a: 5d                     str     rd
[04501] ce2b: 1d                     inc     rd
[04502] ce2c: 8f                     glo     rf
[04503] ce2d: 5d                     str     rd
[04504] ce2e: 4a                     lda     ra                  ; get next token
[04505] ce2f: ff 1a                  smi     CMD_START           ; offset for commands
[04506] ce31: ff 92                  smi     092h                ; must be TO
[04507] ce33: ca d3 84               lbnz    syn_err             ; else syntax error
[04508] ce36: 8b                     glo     rb                  ; save rb
[04509] ce37: 73                     stxd
[04510] ce38: 9b                     ghi     rb
[04511] ce39: 73                     stxd
[04512] ce3a: d4                     sep     scall               ; evaluate ending value
[04513] ce3b: c2 8a                  dw      new_expr
[04514] ce3d: ae                     plo     re
[04515] ce3e: 60                     irx                         ; recover rb
[04516] ce3f: 72                     ldxa
[04517] ce40: bb                     phi     rb
[04518] ce41: f0                     ldx
[04519] ce42: ab                     plo     rb
[04520] ce43: 8e                     glo     re
[04521] ce44: c3 d3 89               lbdf    err_ret             ; jump on error
[04522] ce47: f8 01                  ldi     1                   ; default step is 1
[04523] ce49: af                     plo     rf
[04524] ce4a: f8 00                  ldi     0
[04525] ce4c: bf                     phi     rf
[04526] ce4d: d7                     sep     r7                  ; put step onto stack
[04527] ce4e: 6a                     db      ex_push.0
[04528] ce4f: 0a                     ldn     ra                  ; need to check for STEP
[04529] ce50: ff 1a                  smi     CMD_START           ; offset for commands
[04530] ce52: ff 94                  smi     094h                ; check for STEP
[04531] ce54: ca ce 6b               lbnz    no_step             ; jump if not
[04532] ce57: d7                     sep     r7                  ; drop default step from stack
[04533] ce58: 58                     db      ex_pop.0
[04534] ce59: 8b                     glo     rb                  ; save rb
[04535] ce5a: 73                     stxd
[04536] ce5b: 9b                     ghi     rb
[04537] ce5c: 73                     stxd
[04538] ce5d: 1a                     inc     ra                  ; move past STEP token
[04539] ce5e: d4                     sep     scall               ; evaluate step
[04540] ce5f: c2 90                  dw      expr
[04541] ce61: ae                     plo     re
[04542] ce62: 60                     irx                         ; recover rb
[04543] ce63: 72                     ldxa
[04544] ce64: bb                     phi     rb
[04545] ce65: f0                     ldx
[04546] ce66: ab                     plo     rb
[04547] ce67: 8e                     glo     re
[04548] ce68: c3 d3 89               lbdf    err_ret             ; jump on error
[04549]                   
[04550] ce6b: d7          no_step:   sep     r7                  ; retrieve end value
[04551] ce6c: 58                     db      ex_pop.0
[04552] ce6d: d7                     sep     r7                  ; transfer to rd
[04553] ce6e: 72                     db      rf_rd.0
[04554] ce6f: d7                     sep     r7                  ; retrieve end value
[04555] ce70: 58                     db      ex_pop.0
[04556] ce71: eb                     sex     rb                  ; write RA onto stack
[04557] ce72: 8a                     glo     ra
[04558] ce73: 73                     stxd
[04559] ce74: 9a                     ghi     ra
[04560] ce75: 73                     stxd
[04561] ce76: 8f                     glo     rf                  ; now end value
[04562] ce77: 73                     stxd
[04563] ce78: 9f                     ghi     rf
[04564] ce79: 73                     stxd
[04565] ce7a: 8d                     glo     rd                  ; now step
[04566] ce7b: 73                     stxd
[04567] ce7c: 9d                     ghi     rd
[04568] ce7d: 73                     stxd
[04569] ce7e: e2                     sex     r2                  ; need to retrieve variable address
[04570] ce7f: 60                     irx
[04571] ce80: 72                     ldxa
[04572] ce81: bf                     phi     rf
[04573] ce82: f0                     ldx
[04574] ce83: af                     plo     rf
[04575] ce84: eb                     sex     rb                  ; need to write to for stack
[04576] ce85: 8f                     glo     rf
[04577] ce86: 73                     stxd
[04578] ce87: 9f                     ghi     rf
[04579] ce88: 73                     stxd
[04580] ce89: e2                     sex     r2                  ; point X back to proper stack
[04581] ce8a: f8 01                  ldi     high for_pos        ; need to write new forstack value
[04582] ce8c: bf                     phi     rf
[04583] ce8d: f8 0a                  ldi     low for_pos
[04584] ce8f: af                     plo     rf
[04585] ce90: 9b                     ghi     rb
[04586] ce91: 5f                     str     rf
[04587] ce92: 1f                     inc     rf
[04588] ce93: 8b                     glo     rb
[04589] ce94: 5f                     str     rf
[04590] ce95: c0 cb a0               lbr     chk_term            ; done processing
[04591]                   
[04592]                   ; ********************
[04593]                   ; *** Process NEXT ***
[04594]                   ; ********************
[04595] ce98: 0a          ex_next:   ldn     ra                  ; need to see if a variable is specified
[04596] ce99: c2 ce f1               lbz     next_nv             ; jump for no variable version
[04597] ce9c: ff 93                  smi     093h                ; colon is also valid
[04598] ce9e: c2 ce f1               lbz     next_nv
[04599] cea1: 0a                     ldn     ra                  ; recover token
[04600] cea2: d4                     sep     scall               ; must now be a variable
[04601] cea3: ff 72                  dw      f_isalpha
[04602] cea5: cb d3 84               lbnf    syn_err             ; else syntax error
[04603] cea8: d4                     sep     scall               ; get address for specified variable
[04604] cea9: c8 7b                  dw      get_var
[04605] ceab: c3 d3 89               lbdf    err_ret
[04606] ceae: d7                     sep     r7                  ; get FOR stack into RB
[04607] ceaf: dc                     db      get_rb.0
[04608] ceb0: 01 0a                  dw      for_pos
[04609]                   
[04610] ceb2: 8b          next_lp:   glo     rb                  ; make sure it is not empty
[04611] ceb3: fb 5c                  xri     for_st.0
[04612] ceb5: ae                     plo     re                  ; save first result
[04613] ceb6: 9b                     ghi     rb
[04614] ceb7: fb 01                  xri     for_st.1
[04615] ceb9: 52                     str     r2                  ; or with first result
[04616] ceba: 8e                     glo     re
[04617] cebb: f1                     or
[04618] cebc: c2 cf 54               lbz     next_nf             ; jump if next without for
[04619] cebf: eb                     sex     rb                  ; get inner loop variable
[04620] cec0: 60                     irx
[04621] cec1: 72                     ldxa
[04622] cec2: bd                     phi     rd
[04623] cec3: f0                     ldx
[04624] cec4: ad                     plo     rd
[04625] cec5: 2b                     dec     rb                  ; move pointer back
[04626] cec6: 2b                     dec     rb
[04627] cec7: e2                     sex     r2                  ; X back to stack
[04628] cec8: 8f                     glo     rf                  ; compare addresses
[04629] cec9: 52                     str     r2
[04630] ceca: 8d                     glo     rd
[04631] cecb: f3                     xor
[04632] cecc: ae                     plo     re                  ; keep result
[04633] cecd: 9f                     ghi     rf
[04634] cece: 52                     str     r2
[04635] cecf: 9d                     ghi     rd
[04636] ced0: f3                     xor
[04637] ced1: 52                     str     r2                  ; or with first result
[04638] ced2: 8e                     glo     re
[04639] ced3: f1                     or
[04640] ced4: c2 ce f1               lbz     next_nv             ; match, so continue
[04641] ced7: 8b                     glo     rb                  ; need to drop loop
[04642] ced8: fc 0a                  adi     10
[04643] ceda: ab                     plo     rb
[04644] cedb: 9b                     ghi     rb
[04645] cedc: 7c 00                  adci    0
[04646] cede: bb                     phi     rb
[04647] cedf: 9e                     ghi     re                  ; save baud constant
[04648] cee0: 52                     str     r2
[04649] cee1: f8 01                  ldi     high for_pos        ; need to write new pointer
[04650] cee3: be                     phi     re
[04651] cee4: f8 0a                  ldi     low for_pos
[04652] cee6: ae                     plo     re
[04653] cee7: 9b                     ghi     rb
[04654] cee8: 5e                     str     re
[04655] cee9: 1e                     inc     re
[04656] ceea: 8b                     glo     rb
[04657] ceeb: 5e                     str     re
[04658] ceec: f0                     ldx                         ; recover baud constant
[04659] ceed: be                     phi     re
[04660] ceee: c0 ce b2               lbr     next_lp             ; see if next loop is correct
[04661] cef1: d7          next_nv:   sep     r7                  ; get FOR stack into RB
[04662] cef2: dc                     db      get_rb.0
[04663] cef3: 01 0a                  dw      for_pos
[04664] cef5: 8b                     glo     rb                  ; make sure it is not empty
[04665] cef6: fb 5c                  xri     for_st.0
[04666] cef8: ae                     plo     re                  ; save first result
[04667] cef9: 9b                     ghi     rb
[04668] cefa: fb 01                  xri     for_st.1
[04669] cefc: 52                     str     r2                  ; or with first result
[04670] cefd: 8e                     glo     re
[04671] cefe: f1                     or
[04672] ceff: c2 cf 54               lbz     next_nf             ; jump if next without for
[04673] cf02: eb                     sex     rb                  ; use RB for the stack
[04674] cf03: 60                     irx                         ; recover variable address
[04675] cf04: 72                     ldxa
[04676] cf05: bf                     phi     rf
[04677] cf06: 72                     ldxa
[04678] cf07: af                     plo     rf
[04679] cf08: 72                     ldxa                        ; retrieve step
[04680] cf09: bd                     phi     rd
[04681] cf0a: ae                     plo     re                  ; keep copy of high byte of step
[04682] cf0b: 72                     ldxa
[04683] cf0c: ad                     plo     rd
[04684] cf0d: ef                     sex     rf                  ; now poiht X to variable
[04685] cf0e: 60                     irx                         ; sb
[04686] cf0f: 8d                     glo     rd                  ; add in step to variable value
[04687] cf10: f4                     add
[04688] cf11: 73                     stxd                        ; store back into variable
[04689] cf12: ad                     plo     rd                  ; and keep in rd
[04690] cf13: 9d                     ghi     rd                  ; now high byte
[04691] cf14: 74                     adc
[04692] cf15: 5f                     str     rf                  ; place back into variable
[04693] cf16: bd                     phi     rd
[04694] cf17: eb                     sex     rb                  ; now point at end value
[04695] cf18: 60                     irx                         ; lsb
[04696] cf19: 8e                     glo     re                  ; get sign of step
[04697] cf1a: fe                     shl                         ; shift into df
[04698] cf1b: cb cf 2a               lbnf    next_p              ; jump if positive
[04699] cf1e: 8d                     glo     rd                  ; do RD-end
[04700] cf1f: f7                     sm
[04701] cf20: 2b                     dec     rb
[04702] cf21: 9d                     ghi     rd
[04703] cf22: 75                     sdb
[04704] cf23: fe                     shl                         ; shift sign into DF
[04705] cf24: c3 cf 47               lbdf    next_ne             ; jump if not at end
[04706] cf27: c0 cf 33               lbr     next_ok
[04707] cf2a: 8d          next_p:    glo     rd                  ; do end-RD
[04708] cf2b: f5                     sd
[04709] cf2c: 2b                     dec     rb                  ; point to msb
[04710] cf2d: 9d                     ghi     rd
[04711] cf2e: 75                     sdb
[04712] cf2f: fe                     shl                         ; shift sign into DF
[04713] cf30: cb cf 47               lbnf    next_ne             ; jump if not at end
[04714] cf33: 60          next_ok:   irx                         ; lsb of end
[04715] cf34: 60                     irx                         ; msb or ra
[04716] cf35: 60                     irx                         ; lsb of ra
[04717] cf36: 60                     irx                         ; msb of rc
[04718] cf37: 60                     irx                         ; lsb of rc, item is now off the stack
[04719] cf38: e2                     sex     r2                  ; put X back on proper stack
[04720] cf39: f8 01                  ldi     high for_pos        ; need to write new forstack value
[04721] cf3b: bf                     phi     rf
[04722] cf3c: f8 0a                  ldi     low for_pos
[04723] cf3e: af                     plo     rf
[04724] cf3f: 9b                     ghi     rb
[04725] cf40: 5f                     str     rf
[04726] cf41: 1f                     inc     rf
[04727] cf42: 8b                     glo     rb
[04728] cf43: 5f                     str     rf
[04729] cf44: c0 cb a0               lbr     chk_term            ; done processing
[04730] cf47: 60          next_ne:   irx                         ; lsb of end
[04731] cf48: 60                     irx                         ; msb of ra
[04732] cf49: 72                     ldxa                        ; retrieve token pointer
[04733] cf4a: ba                     phi     ra
[04734] cf4b: 72                     ldxa
[04735] cf4c: aa                     plo     ra
[04736] cf4d: 72                     ldxa                        ; retrieve current line
[04737] cf4e: bc                     phi     rc
[04738] cf4f: f0                     ldx
[04739] cf50: ac                     plo     rc
[04740] cf51: c0 cb a0               lbr     chk_term            ; continue
[04741] cf54: f8 08       next_nf:   ldi     ERR_NOFOR
[04742] cf56: ff 00                  smi     0                   ; signal an error
[04743] cf58: d5                     sep     sret                ; and return
[04744]                   
[04745]                   ; ***********************
[04746]                   ; *** Process ON GOTO ***
[04747]                   ; ***********************
[04748] cf59: d4          ex_on:     sep     scall               ; get first argument
[04749] cf5a: c2 8a                  dw      new_expr
[04750] cf5c: c3 d3 89               lbdf    err_ret             ; jump if error occurred
[04751] cf5f: 4a                     lda     ra                  ; get next token
[04752] cf60: ff 1a                  smi     CMD_START           ; offset for commands
[04753] cf62: ff 83                  smi     83h                 ; look for GOTO
[04754] cf64: c2 cf 6a               lbz     on_goto             ; jump if so
[04755] cf67: c0 d3 84               lbr     syn_err             ; otherwise syntax error
[04756] cf6a: d7          on_goto:   sep     r7                  ; retrieve value
[04757] cf6b: 58                     db      ex_pop.0
[04758] cf6c: 8f                     glo     rf                  ; get low byte
[04759] cf6d: 73          on_gotolp: stxd                        ; and preserve
[04760] cf6e: 0a                     ldn     ra                  ; see if hit terminator
[04761] cf6f: c2 cb a0               lbz     chk_term            ; jump if so
[04762] cf72: ff 93                  smi     093h                ; colon is also valid
[04763] cf74: c2 cb a0               lbz     chk_term
[04764] cf77: d4                     sep     scall               ; evaluate line number
[04765] cf78: c2 8a                  dw      new_expr
[04766] cf7a: c3 d3 89               lbdf    err_ret             ; jump if error occurred
[04767] cf7d: 60                     irx                         ; recover ON expression
[04768] cf7e: f0                     ldx
[04769] cf7f: ff 01                  smi     1                   ; subtract 1
[04770] cf81: c2 ca 0d               lbz     goto_go2            ; jump if correct entry is found
[04771] cf84: ae                     plo     re                  ; save count
[04772] cf85: 0a                     ldn     ra                  ; check next token
[04773] cf86: c2 cb a0               lbz     chk_term            ; jump if terminator
[04774] cf89: ff 93                  smi     093h                ; or colon
[04775] cf8b: c2 cb a0               lbz     chk_term
[04776] cf8e: 4a                     lda     ra                  ; now must be a comma
[04777] cf8f: ff 8d                  smi     8dh
[04778] cf91: ca d3 84               lbnz    syn_err             ; jump if not
[04779] cf94: 8e                     glo     re                  ; recover count
[04780] cf95: c0 cf 6d               lbr     on_gotolp           ; and keep lookin
[04781]                   
[04782]                   ; **********************
[04783]                   ; *** Process RANDOM ***
[04784]                   ; **********************
[04785] cf98: d4          ex_random: sep     scall              ; get input from user
[04786] cf99: bd eb                  dw      get_input
[04787] cf9b: c3 d3 89               lbdf    err_ret
[04788] cf9e: f8 01                  ldi     high lfsr          ; point to lfsr register
[04789] cfa0: bf                     phi     rf
[04790] cfa1: f8 5d                  ldi     low lfsr
[04791] cfa3: af                     plo     rf
[04792] cfa4: f8 00                  ldi     0
[04793] cfa6: 5f                     str     rf
[04794] cfa7: 1f                     inc     rf
[04795] cfa8: f8 01                  ldi     1
[04796] cfaa: 5f                     str     rf
[04797] cfab: 1f                     inc     rf
[04798] cfac: 9d                     ghi     rd                 ; write new seed to it
[04799] cfad: 5f                     str     rf
[04800] cfae: 1f                     inc     rf
[04801] cfaf: 8d                     glo     rd
[04802] cfb0: 5f                     str     rf
[04803] cfb1: c0 cb a0               lbr     chk_term           ; done
[04804]                   
[04805]                   
[04806]                   ; ********************
[04807]                   ; *** Process READ ***
[04808]                   ; ********************
[04809] cfb4: 0a          ex_read:   ldn     ra                  ; get next token
[04810] cfb5: 0a          read_lp:   ldn     ra                  ; see if done
[04811] cfb6: c2 cb a0               lbz     chk_term            ; jump if so
[04812] cfb9: 0a                     ldn     ra                  ; get character
[04813] cfba: d4                     sep     scall               ; must be a variable name
[04814] cfbb: ff 72                  dw      f_isalpha
[04815] cfbd: cb d3 84               lbnf    syn_err             ; otherwise error
[04816] cfc0: d4                     sep     scall               ; get variable address
[04817] cfc1: c8 7b                  dw      get_var
[04818] cfc3: c3 d3 89               lbdf    err_ret
[04819] cfc6: 8f                     glo     rf                  ; save variable position
[04820] cfc7: 73                     stxd
[04821] cfc8: 9f                     ghi     rf
[04822] cfc9: 73                     stxd
[04823] cfca: d4                     sep     scall               ; get input
[04824] cfcb: c0 26                  dw      get_data
[04825] cfcd: c3 d3 89               lbdf    err_ret             ; jump on error
[04826] cfd0: 60                     irx                         ; recover variable address
[04827] cfd1: 72                     ldxa
[04828] cfd2: bf                     phi     rf
[04829] cfd3: f0                     ldx
[04830] cfd4: af                     plo     rf
[04831] cfd5: 9d                     ghi     rd                  ; store into variable
[04832] cfd6: 5f                     str     rf
[04833] cfd7: 1f                     inc     rf
[04834] cfd8: 8d                     glo     rd
[04835] cfd9: 5f                     str     rf
[04836] cfda: 0a                     ldn     ra                  ; get next token
[04837] cfdb: c2 cb a0               lbz     chk_term            ; jump if terminator
[04838] cfde: ff 93                  smi     093h                ; colon also ends input
[04839] cfe0: c2 cb a0               lbz     chk_term
[04840] cfe3: 4a                     lda     ra                  ; get next token
[04841] cfe4: ff 8d                  smi     08dh                ; must be a comma
[04842] cfe6: c2 cf b5               lbz     read_lp             ; process next variable
[04843] cfe9: c0 d3 84               lbr     syn_err             ; otherwise error
[04844]                   
[04845]                   ; ***********************
[04846]                   ; *** Process RESTORE ***
[04847]                   ; ***********************
[04848] cfec: 0a          ex_restore: ldn    ra                  ; see if there is an argument
[04849] cfed: c2 d0 1f               lbz     rst_strt            ; jump if not
[04850] cff0: ff 93                  smi     093h                ; colon is also valid
[04851] cff2: c2 d0 1f               lbz     rst_strt
[04852] cff5: d4                     sep     scall               ; otherwise evaluate argument
[04853] cff6: c2 8a                  dw      new_expr
[04854] cff8: c3 d3 89               lbdf    err_ret             ; jump if error occurrecd
[04855] cffb: 8c                     glo     rc                  ; save rc
[04856] cffc: 73                     stxd
[04857] cffd: 9c                     ghi     rc
[04858] cffe: 73                     stxd
[04859] cfff: d7                     sep     r7                  ; retrieve line number
[04860] d000: 58                     db      ex_pop.0
[04861] d001: d7                     sep     r7                  ; transfer to rd
[04862] d002: 72                     db      rf_rd.0
[04863] d003: d7                     sep     r7                  ; then find line number
[04864] d004: 19                     db      find_ln.0
[04865] d005: 9c                     ghi     rc                  ; move to rd
[04866] d006: bd                     phi     rd
[04867] d007: 8c                     glo     rc
[04868] d008: ad                     plo     rd
[04869] d009: 60                     irx                         ; retrieve original rc
[04870] d00a: 72                     ldxa
[04871] d00b: bc                     phi     rc
[04872] d00c: f0                     ldx
[04873] d00d: ac                     plo     rc
[04874] d00e: cb ca 28               lbnf    err_noln            ; no line error
[04875] d011: f8 01                  ldi     high data_lin       ; point to pointer location
[04876] d013: bf                     phi     rf
[04877] d014: f8 02                  ldi     low data_lin
[04878] d016: af                     plo     rf
[04879] d017: 9d                     ghi     rd                  ; save pointer
[04880] d018: 5f                     str     rf
[04881] d019: 1f                     inc     rf
[04882] d01a: 8d                     glo     rd
[04883] d01b: 5f                     str     rf
[04884] d01c: c0 d0 2c               lbr     rest_cnt            ; ok, continue
[04885] d01f: f8 01       rst_strt:  ldi     high data_lin       ; point to pointer location
[04886] d021: bf                     phi     rf
[04887] d022: f8 02                  ldi     low data_lin
[04888] d024: af                     plo     rf
[04889] d025: f8 05                  ldi     high basic          ; restore to beginning of basic
[04890] d027: 5f                     str     rf
[04891] d028: 1f                     inc     rf
[04892] d029: f8 b7                  ldi     low basic
[04893] d02b: 5f                     str     rf
[04894] d02c: 2f          rest_cnt:  dec     rf                  ; retrieve pointer
[04895] d02d: 4f                     lda     rf                  ; into rd
[04896] d02e: bd                     phi     rd
[04897] d02f: 4f                     lda     rf
[04898] d030: ad                     plo     rd
[04899] d031: 1d                     inc     rd                  ; move to first token
[04900] d032: 1d                     inc     rd
[04901] d033: 1d                     inc     rd
[04902] d034: 0d                     ldn     rd                  ; and get it
[04903] d035: ff 1a                  smi     CMD_START           ; subtract command offset
[04904] d037: ff 96                  smi     96h                 ; check for DATA
[04905] d039: ca d0 4b               lbnz    nodata2
[04906] d03c: 1d                     inc     rd                  ; otherwise point to first data item
[04907] d03d: f8 01                  ldi     high data_pos       ; setup data position
[04908] d03f: bf                     phi     rf
[04909] d040: f8 04                  ldi     low data_pos
[04910] d042: af                     plo     rf
[04911] d043: 9d                     ghi     rd                  ; and write pointer
[04912] d044: 5f                     str     rf
[04913] d045: 1f                     inc     rf
[04914] d046: 8d                     glo     rd
[04915] d047: 5f                     str     rf
[04916] d048: c0 cb a0               lbr     chk_term            ; done
[04917] d04b: d4          nodata2:   sep     scall               ; find next data statement
[04918] d04c: c0 73                  dw      find_data
[04919] d04e: c0 cb a0               lbr     chk_term            ; done
[04920]                   
[04921]                   ; **************************************************
[04922]                   ; *** See if an address is bound to a string var ***
[04923]                   ; *** RF - Address to check                      ***
[04924]                   ; *** Returns: DF=1 - address in use             ***
[04925]                   ; **************************************************
[04926] d051: 8f          chk_var:   glo     rf                  ; put address to check on the stack
[04927] d052: 73                     stxd
[04928] d053: 9f                     ghi     rf
[04929] d054: 73                     stxd
[04930] d055: f8 01                  ldi     high var_pos        ; need to get variable pointer
[04931] d057: bf                     phi     rf
[04932] d058: f8 06                  ldi     low var_pos
[04933] d05a: af                     plo     rf
[04934] d05b: 4f                     lda     rf                  ; retrieve the pointer into RF
[04935] d05c: ae                     plo     re
[04936] d05d: 0f                     ldn     rf
[04937] d05e: af                     plo     rf
[04938] d05f: 8e                     glo     re
[04939] d060: bf                     phi     rf
[04940] d061: 0f          chk_varlp: ldn     rf                  ; get byte
[04941] d062: c2 d0 94               lbz     chk_no              ; jump if at end of table
[04942] d065: 52                     str     r2                  ; add to address
[04943] d066: 8f                     glo     rf
[04944] d067: f4                     add
[04945] d068: af                     plo     rf
[04946] d069: 9f                     ghi     rf
[04947] d06a: 7c 00                  adci    0
[04948] d06c: bf                     phi     rf
[04949] d06d: 2f                     dec     rf                  ; move to type
[04950] d06e: 2f                     dec     rf
[04951] d06f: 2f                     dec     rf
[04952] d070: 4f                     lda     rf                  ; get type
[04953] d071: ff 03                  smi     3                   ; is it a string var
[04954] d073: ca d0 8f               lbnz    chk_nst             ; jump if not a string
[04955] d076: 60                     irx                         ; move to low value of address
[04956] d077: 4f                     lda     rf                  ; get byte from variable address
[04957] d078: f7                     sm                          ; compare the values
[04958] d079: 60                     irx                         ; point to high byte of value
[04959] d07a: ca d0 89               lbnz    chk_n1              ; jump if no match
[04960] d07d: 0f                     ldn     rf                  ; get low byte
[04961] d07e: f7                     sm                          ; and compare it
[04962] d07f: ca d0 89               lbnz    chk_n1              ; jump if no match
[04963] d082: 22                     dec     r2                  ; move stack pointer back
[04964] d083: 22                     dec     r2
[04965] d084: ff 00                  smi     0                   ; signal variable in use
[04966] d086: c0 d0 96               lbr     chk_dn              ; finished
[04967] d089: 22          chk_n1:    dec     r2                  ; move stack pointer back
[04968] d08a: 22                     dec     r2
[04969] d08b: 1f                     inc     rf                  ; move to next variable
[04970] d08c: c0 d0 61               lbr     chk_varlp           ; and check it
[04971] d08f: 1f          chk_nst:   inc     rf                  ; move to next variable
[04972] d090: 1f                     inc     rf
[04973] d091: c0 d0 61               lbr     chk_varlp
[04974] d094: fc 00       chk_no:    adi     0                   ; signal not in use
[04975] d096: 60          chk_dn:    irx                         ; recover address
[04976] d097: 72                     ldxa
[04977] d098: bf                     phi     rf
[04978] d099: f0                     ldx
[04979] d09a: af                     plo     rf
[04980] d09b: d5                     sep     sret                ; and return
[04981]                   
[04982]                   ; ******************************************************
[04983]                   ; *** Deallocate a string variables prior assignment ***
[04984]                   ; *** RD - pointer to string variable address field  ***
[04985]                   ; ******************************************************
[04986] d09c: 2f          de_str:    dec     rf                  ; get variable type
[04987] d09d: 4f                     lda     rf                  ; and get it
[04988] d09e: ff 03                  smi     3                   ; is it a string
[04989] d0a0: ca bc bf               lbnz    return              ; jump if not
[04990] d0a3: 8f                     glo     rf                  ; save address
[04991] d0a4: 73                     stxd
[04992] d0a5: 9f                     ghi     rf
[04993] d0a6: 73                     stxd
[04994] d0a7: 0f                     ldn     rf                  ; get variable binding
[04995] d0a8: ae                     plo     re
[04996] d0a9: f8 00                  ldi     0                   ; delete binding
[04997] d0ab: 5f                     str     rf
[04998] d0ac: 1f                     inc     rf
[04999] d0ad: 0f                     ldn     rf
[05000] d0ae: af                     plo     rf                  ; into rf
[05001] d0af: 8e                     glo     re
[05002] d0b0: bf                     phi     rf
[05003] d0b1: d4                     sep     scall               ; dealloate current binding
[05004] d0b2: d1 1c                  dw      dealloc
[05005] d0b4: 60                     irx                         ; recover address
[05006] d0b5: 72                     ldxa
[05007] d0b6: bf                     phi     rf
[05008] d0b7: f0                     ldx
[05009] d0b8: af                     plo     rf
[05010] d0b9: d5                     sep     sret                ; and return
[05011]                   
[05012]                   ; **************************************
[05013]                   ; *** Consolidate heap memory blocks ***
[05014]                   ; **************************************
[05015] d0ba: 8f          consol:    glo     rf                  ; save consumed registers
[05016] d0bb: 73                     stxd
[05017] d0bc: 9f                     ghi     rf
[05018] d0bd: 73                     stxd
[05019] d0be: 8d                     glo     rd                  ; save consumed registers
[05020] d0bf: 73                     stxd
[05021] d0c0: 9d                     ghi     rd
[05022] d0c1: 73                     stxd
[05023] d0c2: f8 01                  ldi    high heap            ; need to see if below heap
[05024] d0c4: bf                     phi    rf
[05025] d0c5: f8 08                  ldi    low heap
[05026] d0c7: af                     plo    rf
[05027] d0c8: 4f                     lda    rf                   ; retrieve the pointer
[05028] d0c9: ae                     plo    re
[05029] d0ca: 0f                     ldn    rf
[05030] d0cb: af                     plo    rf
[05031] d0cc: 8e                     glo    re
[05032] d0cd: bf                     phi    rf
[05033] d0ce: 0f          cons_lp:   ldn    rf                   ; get flag byte
[05034] d0cf: c2 d0 f1               lbz    cons_z               ; jump if free block
[05035] d0d2: fb ff                  xri    0ffh                 ; see if end of heap
[05036] d0d4: c2 d0 e7               lbz    cons_dn              ; jump if so
[05037] d0d7: d7          cons_nxt:  sep    r7                   ; copy rf to rd
[05038] d0d8: 72                     db     rf_rd.0
[05039] d0d9: 1d                     inc    rd                   ; point to lsb of size
[05040] d0da: 1d                     inc    rd
[05041] d0db: ed                     sex    rd                   ; use this as data pointer
[05042] d0dc: 8f                     glo    rf                   ; and add to rf
[05043] d0dd: f4                     add
[05044] d0de: af                     plo    rf
[05045] d0df: 2d                     dec    rd
[05046] d0e0: 9f                     ghi    rf
[05047] d0e1: 74                     adc
[05048] d0e2: bf                     phi    rf
[05049] d0e3: e2                     sex    r2                   ; put stack back
[05050] d0e4: c0 d0 ce               lbr    cons_lp              ; loop until done
[05051] d0e7: 60          cons_dn:   irx                         ; recover consumed registers
[05052] d0e8: 72                     ldxa
[05053] d0e9: bd                     phi    rd
[05054] d0ea: 72                     ldxa
[05055] d0eb: ad                     plo    rd
[05056] d0ec: 72                     ldxa
[05057] d0ed: bf                     phi    rf
[05058] d0ee: f0                     ldx
[05059] d0ef: af                     plo    rf
[05060] d0f0: d5                     sep    sret                 ; and return
[05061] d0f1: d7          cons_z:    sep    r7                   ; copy rf to rd
[05062] d0f2: 72                     db     rf_rd.0
[05063] d0f3: 1f                     inc    rf                   ; point to lsb of block size
[05064] d0f4: 1f                     inc    rf
[05065] d0f5: ef                     sex    rf                   ; use this as data pointer
[05066] d0f6: 8d                     glo    rd                   ; add block size to address
[05067] d0f7: f4                     add
[05068] d0f8: ad                     plo    rd
[05069] d0f9: 2f                     dec    rf
[05070] d0fa: 9d                     ghi    rd
[05071] d0fb: 74                     adc
[05072] d0fc: bd                     phi    rd
[05073] d0fd: 2f                     dec    rf                   ; rf back to flag byte
[05074] d0fe: e2                     sex    r2                   ; X back to stack
[05075] d0ff: 0d                     ldn    rd                   ; get flag byte of next entry
[05076] d100: fb ff                  xri    0ffh                 ; check for end
[05077] d102: c2 d0 e7               lbz    cons_dn              ; jump of at end
[05078] d105: fb ff                  xri    0ffh
[05079] d107: ca d0 d7               lbnz   cons_nxt             ; jump if not an empty block
[05080] d10a: 1d                     inc    rd                   ; move next entry pointer to lsb of size
[05081] d10b: 1d                     inc    rd
[05082] d10c: 1f                     inc    rf                   ; move curernt pointer to lsb
[05083] d10d: 1f                     inc    rf
[05084] d10e: ed                     sex    rd                   ; use 2nd entry as data
[05085] d10f: 0f                     ldn    rf                   ; add sizes together
[05086] d110: f4                     add
[05087] d111: 5f                     str    rf
[05088] d112: 2f                     dec    rf                   ; move poitners to msb
[05089] d113: 2d                     dec    rd
[05090] d114: 0f                     ldn    rf
[05091] d115: 74                     adc
[05092] d116: 5f                     str    rf
[05093] d117: e2                     sex    r2                   ; set x back to stack
[05094] d118: 2f                     dec    rf                   ; move back to flag byte
[05095] d119: c0 d0 ce               lbr    cons_lp              ; and keep looking
[05096]                   
[05097]                   ; *******************************
[05098]                   ; *** Deallocate heap memory  ***
[05099]                   ; *** RF - address to dealloc ***
[05100]                   ; *******************************
[05101] d11c: d4          dealloc:   sep    scall                ; see if variable uses address
[05102] d11d: d0 51                  dw     chk_var
[05103] d11f: c3 bc bf               lbdf   return               ; do not deallocate if variable is using
[05104] d122: 8d                     glo    rd                   ; preserve RD
[05105] d123: 73                     stxd
[05106] d124: 9d                     ghi    rd
[05107] d125: 73                     stxd
[05108] d126: f8 01                  ldi    high heap            ; need to see if below heap
[05109] d128: bd                     phi    rd
[05110] d129: f8 08                  ldi    low heap
[05111] d12b: ad                     plo    rd
[05112] d12c: 1d                     inc    rd                   ; point to low byte
[05113] d12d: ed                     sex    rd                   ; use rd as data pointer
[05114] d12e: 8f                     glo    rf                   ; subtract request address
[05115] d12f: f7                     sm
[05116] d130: 2d                     dec    rd                   ; point to msb
[05117] d131: 9f                     ghi    rf
[05118] d132: 77                     smb
[05119] d133: e2                     sex    r2                   ; point X back to stack
[05120] d134: 60                     irx                         ; recover RD
[05121] d135: 72                     ldxa
[05122] d136: bd                     phi    rd
[05123] d137: f0                     ldx
[05124] d138: ad                     plo    rd
[05125] d139: cb bc bf               lbnf   return               ; jump if address is not in heap
[05126] d13c: 2f                     dec    rf                   ; move to flag byte
[05127] d13d: 2f                     dec    rf
[05128] d13e: 2f                     dec    rf
[05129] d13f: f8 00                  ldi    0                    ; mark as unused block
[05130] d141: 5f                     str    rf
[05131] d142: 1f                     inc    rf                   ; restore rf
[05132] d143: 1f                     inc    rf
[05133] d144: 1f                     inc    rf
[05134] d145: d4                     sep    scall                ; consolidate free blocks
[05135] d146: d0 ba                  dw     consol
[05136] d148: d5                     sep    sret                 ; and return to caller
[05137]                   
[05138]                   ; ******************************************
[05139]                   ; *** Check for heap/var table collision ***
[05140]                   ; *** Returns: DF=1 out of memory        ***
[05141]                   ; ******************************************
[05142] d149: 8f          chk_om:    glo     rf                   ; save consumed registers
[05143] d14a: 73                     stxd
[05144] d14b: 9f                     ghi     rf
[05145] d14c: 73                     stxd
[05146] d14d: 8d                     glo     rd                   ; save consumed registers
[05147] d14e: 73                     stxd
[05148] d14f: 9d                     ghi     rd
[05149] d150: 73                     stxd
[05150] d151: d4                     sep     scall                ; get end of variables
[05151] d152: c0 09                  dw      end_vars
[05152] d154: f8 01                  ldi     high heap            ; point to heap pointer
[05153] d156: bd                     phi     rd
[05154] d157: f8 08                  ldi     low heap
[05155] d159: ad                     plo     rd
[05156] d15a: 1d                     inc     rd                   ; point to lsb
[05157] d15b: ed                     sex     rd                   ; point x to heap pointer
[05158] d15c: 8f                     glo     rf                   ; perform vars-heap
[05159] d15d: f7                     sm
[05160] d15e: 2d                     dec     rd
[05161] d15f: 9f                     ghi     rf
[05162] d160: 77                     smb
[05163] d161: e2                     sex     r2                   ; point X back to stack
[05164] d162: cb d1 6a               lbnf    not_om               ; jump if no overlap
[05165] d165: ff 00                  smi     0                    ; signal memory error
[05166] d167: f8 0a                  ldi     ERR_NOMEM
[05167] d169: c8                     lskp
[05168] d16a: fc 00       not_om:    adi     0                    ; signal good
[05169] d16c: ae                     plo     re                   ; save return value
[05170] d16d: 60                     irx                          ; recover consumed registers
[05171] d16e: 72                     ldxa
[05172] d16f: bd                     phi     rd
[05173] d170: 72                     ldxa
[05174] d171: ad                     plo     rd
[05175] d172: 72                     ldxa
[05176] d173: bf                     phi     rf
[05177] d174: f0                     ldx
[05178] d175: af                     plo     rf
[05179] d176: 8e                     glo     re                  ; recover result code
[05180] d177: d5                     sep     sret                ; and return
[05181]                   
[05182]                   ; **********************************
[05183]                   ; *** Allocate space on the heap ***
[05184]                   ; *** RF - size to allocate      ***
[05185]                   ; *** Returns: RF - address      ***
[05186]                   ; ***          DF=1 - no memory  ***
[05187]                   ; **********************************
[05188] d178: f8 01       alloc:     ldi     high heap           ; get heap pointer
[05189] d17a: bd                     phi     rd
[05190] d17b: f8 08                  ldi     low heap
[05191] d17d: ad                     plo     rd
[05192] d17e: 4d                     lda     rd                  ; and retrieve it
[05193] d17f: ae                     plo     re
[05194] d180: 0d                     ldn     rd
[05195] d181: ad                     plo     rd
[05196] d182: 8e                     glo     re
[05197] d183: bd                     phi     rd                  ; rd now has heap pointer
[05198] d184: 1f                     inc     rf                  ; include header size in comparisons
[05199] d185: 1f                     inc     rf
[05200] d186: 1f                     inc     rf
[05201] d187: 0d          alloc_lp1: ldn     rd                  ; get flag byte
[05202] d188: c2 d1 a1               lbz     alloc_z             ; check empty block
[05203] d18b: fb ff                  xri     0ffh                ; see if at end of memory
[05204] d18d: c2 d2 01               lbz     alloc_e             ; jump if so
[05205]                   
[05206] d190: 1d          alloc_no:  inc     rd                  ; point to msb of size
[05207] d191: 4d                     lda     rd                  ; retrieve it
[05208] d192: 73                     stxd                        ; place onto stack
[05209] d193: 0d                     ldn     rd                  ; get lsb
[05210] d194: 52                     str     r2                  ; and place in memory
[05211] d195: 2d                     dec     rd                  ; move rd back to flag byte
[05212] d196: 2d                     dec     rd
[05213] d197: 8d                     glo     rd                  ; and add offset
[05214] d198: f4                     add
[05215] d199: ad                     plo     rd
[05216] d19a: 60                     irx                         ; point to next location
[05217] d19b: 9d                     ghi     rd
[05218] d19c: 74                     adc
[05219] d19d: bd                     phi     rd                  ; rd now has new offset
[05220] d19e: c0 d1 87               lbr     alloc_lp1           ; check this entry
[05221] d1a1: 1d          alloc_z:   inc     rd                  ; move to lsb of block size
[05222] d1a2: 1d                     inc     rd
[05223] d1a3: ed                     sex     rd                  ; use size as data pointer
[05224] d1a4: 8f                     glo     rf                  ; perform SIZEb - SIZEr
[05225] d1a5: f5                     sd
[05226] d1a6: 52                     str     r2                  ; save result
[05227] d1a7: 2d                     dec     rd                  ; move to msb
[05228] d1a8: 9f                     ghi     rf                  ; and continue subtraction
[05229] d1a9: 75                     sdb
[05230] d1aa: ae                     plo     re                  ; RE:[R2] has difference
[05231] d1ab: 2d                     dec     rd                  ; rd now back at flag
[05232] d1ac: e2                     sex     r2                  ; X back to stack
[05233] d1ad: cb d1 90               lbnf    alloc_no            ; jump if not enough space
[05234] d1b0: f8 01                  ldi     1                   ; allocate this block
[05235] d1b2: 5d                     str     rd
[05236] d1b3: 02                     ldn     r2                  ; see if difference is greater than 5 bytes
[05237] d1b4: ff 05                  smi     5
[05238] d1b6: 8e                     glo     re
[05239] d1b7: 7f 00                  smbi    0
[05240] d1b9: cb d1 f7               lbnf    no_split            ; jump if block too small to split
[05241] d1bc: 9e                     ghi     re                  ; save baud constant
[05242] d1bd: 73                     stxd
[05243] d1be: 1d                     inc     rd                  ; retrieve current block size
[05244] d1bf: 4d                     lda     rd                  ; retreive current size
[05245] d1c0: be                     phi     re
[05246] d1c1: 0d                     ldn     rd
[05247] d1c2: ae                     plo     re                  ; re now has original block size
[05248] d1c3: 8f                     glo     rf                  ; write new block size
[05249] d1c4: 5d                     str     rd
[05250] d1c5: 2d                     dec     rd
[05251] d1c6: 9f                     ghi     rf
[05252] d1c7: 5d                     str     rd                  ; rd is at msb of block size
[05253] d1c8: 8e                     glo     re                  ; find size for next block
[05254] d1c9: 52                     str     r2
[05255] d1ca: 8f                     glo     rf
[05256] d1cb: f5                     sd
[05257] d1cc: ae                     plo     re
[05258] d1cd: 9e                     ghi     re
[05259] d1ce: 52                     str     r2
[05260] d1cf: 9f                     ghi     rf
[05261] d1d0: 75                     sdb
[05262] d1d1: be                     phi     re                  ; re now has size of next block
[05263] d1d2: 2d                     dec     rd                  ; move rd back to flags byte
[05264] d1d3: 8d                     glo     rd                  ; save this address
[05265] d1d4: 73                     stxd
[05266] d1d5: 9d                     ghi     rd
[05267] d1d6: 73                     stxd
[05268] d1d7: 8f                     glo     rf                  ; add in block size
[05269] d1d8: 52                     str     r2
[05270] d1d9: 8d                     glo     rd
[05271] d1da: f4                     add
[05272] d1db: ad                     plo     rd
[05273] d1dc: 9f                     ghi     rf
[05274] d1dd: 52                     str     r2
[05275] d1de: 9d                     ghi     rd
[05276] d1df: 74                     adc
[05277] d1e0: bd                     phi     rd
[05278] d1e1: f8 00                  ldi     0                   ; signal an empty block
[05279] d1e3: 5d                     str     rd
[05280] d1e4: 1d                     inc     rd
[05281] d1e5: 9e                     ghi     re                  ; write block size
[05282] d1e6: 5d                     str     rd
[05283] d1e7: 1d                     inc     rd
[05284] d1e8: 8e                     glo     re
[05285] d1e9: 5d                     str     rd
[05286] d1ea: 60                     irx                         ; recover entry address
[05287] d1eb: 72                     ldxa
[05288] d1ec: bf                     phi     rf                  ; into rf
[05289] d1ed: 72                     ldxa
[05290] d1ee: af                     plo     rf
[05291] d1ef: f0                     ldx                         ; also recover baud constant
[05292] d1f0: be                     phi     re
[05293] d1f1: 1f                     inc     rf                  ; move to first free memory address
[05294] d1f2: 1f                     inc     rf
[05295] d1f3: 1f                     inc     rf
[05296] d1f4: fc 00                  adi     0                   ; signal no error
[05297] d1f6: d5                     sep     sret                ; and return
[05298]                   
[05299] d1f7: 1d          no_split:  inc     rd                  ; move to first spot in memory
[05300] d1f8: 1d                     inc     rd
[05301] d1f9: 1d                     inc     rd
[05302] d1fa: 9d                     ghi     rd                  ; and transfer to RF
[05303] d1fb: bf                     phi     rf
[05304] d1fc: 8d                     glo     rd
[05305] d1fd: af                     plo     rf
[05306] d1fe: fc 00                  adi     0                   ; signal success
[05307] d200: d5                     sep     sret                ; and return
[05308]                   
[05309] d201: 2f          alloc_e:   dec     rf                  ; rf back to its original value
[05310] d202: 2f                     dec     rf
[05311] d203: 2f                     dec     rf
[05312] d204: f8 01                  ldi     high heap           ; get heap pointer
[05313] d206: bd                     phi     rd
[05314] d207: f8 08                  ldi     low heap
[05315] d209: ad                     plo     rd
[05316] d20a: 4d                     lda     rd                  ; and retrieve it
[05317] d20b: ae                     plo     re
[05318] d20c: 8f                     glo     rf                  ; subtract size from pointer
[05319] d20d: 52                     str     r2
[05320] d20e: 0d                     ldn     rd
[05321] d20f: f7                     sm
[05322] d210: ad                     plo     rd
[05323] d211: 9f                     ghi     rf                  ; now high byte
[05324] d212: 52                     str     r2
[05325] d213: 8e                     glo     re
[05326] d214: 77                     smb
[05327] d215: bd                     phi     rd
[05328] d216: 2d                     dec     rd                  ; decrement 3 for flag and offset
[05329] d217: 2d                     dec     rd
[05330] d218: 2d                     dec     rd                  ; now pointing at new block
[05331] d219: 9e                     ghi     re                  ; save baud constant
[05332] d21a: 52                     str     r2
[05333] d21b: f8 01                  ldi     high heap           ; need to save new heap pointer
[05334] d21d: be                     phi     re
[05335] d21e: f8 08                  ldi     low heap
[05336] d220: ae                     plo     re
[05337] d221: 9d                     ghi     rd                  ; write pointer
[05338] d222: 5e                     str     re
[05339] d223: 1e                     inc     re
[05340] d224: 8d                     glo     rd
[05341] d225: 5e                     str     re
[05342] d226: 02                     ldn     r2                  ; recover re
[05343] d227: be                     phi     re
[05344]                   
[05345] d228: d4                     sep     scall               ; check if memory error
[05346] d229: d1 49                  dw      chk_om
[05347] d22b: c3 d3 89               lbdf    err_ret             ; jump if error
[05348] d22e: 1f                     inc     rf                  ; change request size to add header
[05349] d22f: 1f                     inc     rf
[05350] d230: 1f                     inc     rf
[05351] d231: f8 01                  ldi     1                   ; set block as used
[05352] d233: 5d                     str     rd
[05353] d234: 1d                     inc     rd
[05354] d235: 9f                     ghi     rf                  ; store size
[05355] d236: 5d                     str     rd
[05356] d237: 1d                     inc     rd
[05357] d238: 8f                     glo     rf
[05358] d239: 5d                     str     rd
[05359] d23a: 1d                     inc     rd                  ; move pointer to fisrt of memory block
[05360] d23b: 8d                     glo     rd                  ; and transfer to rf
[05361] d23c: af                     plo     rf
[05362] d23d: 9d                     ghi     rd
[05363] d23e: bf                     phi     rf
[05364] d23f: fc 00                  adi     0                   ; signal success
[05365] d241: d5                     sep     sret                ; and return
[05366]                   
[05367]                   
[05368]                   ; *******************
[05369]                   ; *** Process DIM ***
[05370]                   ; *******************
[05371] d242: 0a          ex_dim:    ldn     ra                  ; see if terminator
[05372] d243: c2 cb a0               lbz     chk_term            ; jump if so
[05373] d246: ff 93                  smi     093h                ; colon is also valid
[05374] d248: c2 cb a0               lbz     chk_term            ; end on colon as well
[05375] d24b: 0a                     ldn     ra                  ; check for valid variable name
[05376] d24c: d4                     sep     scall
[05377] d24d: ff 72                  dw      f_isalpha
[05378] d24f: cb d3 84               lbnf    syn_err             ; jump if not possible variable
[05379] d252: d4                     sep     scall               ; get end of variable table
[05380] d253: c0 09                  dw      end_vars
[05381] d255: d7                     sep     r7                  ; copy rf to rd
[05382] d256: 72                     db      rf_rd.0
[05383] d257: 1f                     inc     rf                  ; point to name field
[05384] d258: 4a          dim_lp1:   lda     ra                  ; get byte from input stream
[05385] d259: d4                     sep     scall               ; see if valid for variable names
[05386] d25a: ff 78                  dw      f_isalnum
[05387] d25c: cb d2 64               lbnf    dim_2               ; jump if not
[05388] d25f: 5f                     str     rf                  ; store into variable entry
[05389] d260: 1f                     inc     rf
[05390] d261: c0 d2 58               lbr     dim_lp1             ; loop until end of name found
[05391] d264: 2a          dim_2:     dec     ra                  ; need to reget last char
[05392] d265: 4a                     lda     ra
[05393] d266: fb 84                  xri     84h                 ; must be a (
[05394] d268: ca d3 84               lbnz    syn_err             ; else syntax error
[05395] d26b: fb 84                  xri     84h                 ; put it back
[05396] d26d: 5f                     str     rf                  ; and store into output buffer
[05397] d26e: 1f                     inc     rf
[05398] d26f: f8 12                  ldi     12h                 ; indicator for integer array
[05399] d271: 5f                     str     rf
[05400] d272: 1f                     inc     rf
[05401]                   
[05402] d273: 1f            inc rf
[05403] d274: 1f            inc rf
[05404] d275: f8 00         ldi 0
[05405] d277: 5f            str rf
[05406] d278: 2f            dec rf
[05407] d279: 2f            dec rf
[05408]                   
[05409] d27a: 8d                     glo     rd                  ; can now compute size
[05410] d27b: 52                     str     r2
[05411] d27c: 8f                     glo     rf
[05412] d27d: f7                     sm
[05413] d27e: fc 02                  adi     2                   ; add in 3 bytes for address and size
[05414] d280: 5d                     str     rd                  ; store into size
[05415] d281: 8f                     glo     rf                  ; save address for later
[05416] d282: 73                     stxd
[05417] d283: 9f                     ghi     rf
[05418] d284: 73                     stxd
[05419] d285: d4                     sep     scall               ; process first argument
[05420] d286: c2 8a                  dw      new_expr
[05421] d288: c3 d3 36               lbdf    ret_2               ; jump if error occurred
[05422] d28b: d7                     sep     r7                  ; need to add 1
[05423] d28c: 58                     db      ex_pop.0
[05424] d28d: 1f                     inc     rf
[05425] d28e: d7                     sep     r7
[05426] d28f: 6a                     db      ex_push
[05427] d290: f8 01                  ldi     1                   ; indicate 1 dimension
[05428] d292: 73                     stxd
[05429] d293: 0a          dim_args:  ldn     ra                  ; need to check next token
[05430] d294: ff 8d                  smi     08dh                ; is it a comma
[05431] d296: ca d2 ad               lbnz    single
[05432] d299: 1a                     inc     ra                  ; move past comma
[05433] d29a: d4                     sep     scall               ; evaluate second argument
[05434] d29b: c2 90                  dw      expr
[05435] d29d: c3 d3 36               lbdf    ret_2               ; jump if error occurred
[05436] d2a0: d7                     sep     r7                  ; need to add 1
[05437] d2a1: 58                     db      ex_pop.0
[05438] d2a2: 1f                     inc     rf
[05439] d2a3: d7                     sep     r7
[05440] d2a4: 6a                     db      ex_push
[05441] d2a5: 60                     irx                         ; get argument count
[05442] d2a6: f0                     ldx
[05443] d2a7: fc 01                  adi     1
[05444] d2a9: 73                     stxd                        ; and keep on stack
[05445] d2aa: c0 d2 93               lbr     dim_args            ; loop for possible other dimensions
[05446] d2ad: 99          single:    ghi     r9                  ; set rb=r9
[05447] d2ae: bb                     phi     rb
[05448] d2af: 89                     glo     r9
[05449] d2b0: ab                     plo     rb
[05450] d2b1: 60                     irx                         ; recover dimension count
[05451] d2b2: f0                     ldx
[05452] d2b3: 22                     dec     r2                  ; and keep on stack
[05453] d2b4: 1b                     inc     rb                  ; point rb to first argument
[05454] d2b5: ae                     plo     re                  ; put count into re
[05455] d2b6: 4b          copylp1:   lda     rb                  ; get argument
[05456] d2b7: bf                     phi     rf
[05457] d2b8: 4b                     lda     rb
[05458] d2b9: af                     plo     rf
[05459] d2ba: d7                     sep     r7                  ; make copy on top of expression stack
[05460] d2bb: 6a                     db      ex_push.0
[05461] d2bc: 2e                     dec     re                  ; see if done
[05462] d2bd: 8e                     glo     re                  ; get count
[05463] d2be: ca d2 b6               lbnz    copylp1             ; jump if not doen
[05464] d2c1: 60                     irx                         ; get dimension count
[05465] d2c2: f0                     ldx
[05466] d2c3: 73                     stxd                        ; keep on stack twice
[05467] d2c4: 73                     stxd
[05468] d2c5: 60          mullp:     irx                         ; get count
[05469] d2c6: f0                     ldx
[05470] d2c7: ff 01                  smi     1                   ; minus 1
[05471] d2c9: c2 d2 d3               lbz     muldn               ; jump if no more multiplies needed
[05472] d2cc: 73                     stxd                        ; put count back on stack
[05473] d2cd: d4                     sep     scall               ; and multiply top 2 elements
[05474] d2ce: c2 2e                  dw      ex_mul
[05475] d2d0: c0 d2 c5               lbr     mullp               ; jump back and see if done
[05476] d2d3: 4a          muldn:     lda     ra                  ; get next token
[05477] d2d4: ff 85                  smi     085h                ; must be a )
[05478] d2d6: ca d3 36               lbnz    ret_2               ; else syntax error
[05479] d2d9: d7                     sep     r7                  ; get dimension
[05480] d2da: 58                     db      ex_pop.0
[05481] d2db: 8f                     glo     rf                  ; 2 bytes per entry
[05482] d2dc: fe                     shl
[05483] d2dd: af                     plo     rf
[05484] d2de: 9f                     ghi     rf
[05485] d2df: 7e                     shlc
[05486] d2e0: bf                     phi     rf
[05487] d2e1: 1f                     inc     rf                  ; also space for size and dimensions
[05488] d2e2: 60                     irx                         ; get number of dimensions
[05489] d2e3: f0                     ldx
[05490] d2e4: 22                     dec     r2                  ; and keep on stack
[05491] d2e5: 1f          mullp2:    inc     rf
[05492] d2e6: 1f                     inc     rf
[05493] d2e7: ff 01                  smi     1                   ; subtract 1 from count
[05494] d2e9: ca d2 e5               lbnz    mullp2              ; loop back if need more space
[05495] d2ec: d4                     sep     scall               ; allocate the memory
[05496] d2ed: d1 78                  dw      alloc
[05497] d2ef: c3 d3 32               lbdf    om_error            ; jump if could not allocate the memory
[05498] d2f2: 60                     irx                         ; retrieve address
[05499] d2f3: 72                     ldxa                        ; first is the dimension count
[05500] d2f4: ab                     plo     rb                  ; set it aside for now
[05501] d2f5: 72                     ldxa
[05502] d2f6: bd                     phi     rd
[05503] d2f7: f0                     ldx
[05504] d2f8: ad                     plo     rd
[05505] d2f9: 9f                     ghi     rf                  ; write address into variable record
[05506] d2fa: 5d                     str     rd
[05507] d2fb: 1d                     inc     rd
[05508] d2fc: 8f                     glo     rf
[05509] d2fd: 5d                     str     rd
[05510] d2fe: 1d                     inc     rd
[05511] d2ff: f8 00                  ldi     0                   ; werite terminating zero
[05512] d301: 5d                     str     rd
[05513] d302: 8b                     glo     rb                  ; get dimension count
[05514] d303: 5f                     str     rf
[05515] d304: 1f                     inc     rf
[05516] d305: ae                     plo     re                  ; and place into re
[05517] d306: d7                     sep     r7                  ; move rf to rd
[05518] d307: 72                     db      rf_rd.0
[05519] d308: 99                     ghi     r9                  ; set rb=r9
[05520] d309: bb                     phi     rb
[05521] d30a: 89                     glo     r9
[05522] d30b: ab                     plo     rb
[05523] d30c: 1b                     inc     rb
[05524] d30d: 8e                     glo     re                  ; get dimenstion count
[05525] d30e: 1d          dim_lp4:   inc     rd                  ; move pointer
[05526] d30f: 1d                     inc     rd
[05527] d310: ff 01                  smi     1                   ; subtract from count
[05528] d312: ca d3 0e               lbnz    dim_lp4             ; loop until done
[05529] d315: 4b          dim_lp3:   lda     rb
[05530] d316: 5d                     str     rd
[05531] d317: 2d                     dec     rd
[05532] d318: 4b                     lda     rb
[05533] d319: 5d                     str     rd
[05534] d31a: 2d                     dec     rd
[05535] d31b: 2e                     dec     re                  ; see if done with dimensions
[05536] d31c: 8e                     glo     re
[05537] d31d: ca d3 15               lbnz    dim_lp3             ; loop back if not
[05538]                   
[05539] d320: 0a                     ldn     ra                  ; check ending
[05540] d321: c2 cb a0               lbz     chk_term            ; done if terminator found
[05541] d324: ff 93                  smi     093h                ; colon is also valid
[05542] d326: c2 cb a0               lbz     chk_term            ; end on colon as well
[05543] d329: 4a                     lda     ra                  ; otherwise must be a comma
[05544] d32a: ff 8d                  smi     8dh
[05545] d32c: ca d3 84               lbnz    syn_err
[05546] d32f: c0 d2 42               lbr     ex_dim              ; loop for more
[05547]                   
[05548]                   
[05549] d332: f8 0a       om_error:  ldi     ERR_NOMEM           ; indicate out of memory
[05550] d334: ff 00                  smi     0
[05551] d336: 60          ret_2:     irx                         ; remove rf from stack
[05552] d337: 60                     irx
[05553] d338: d5                     sep     sret                ; and return
[05554]                   
[05555]                   ; ******************************************************************************
[05556]                   ; ***                           End of L2 statements                         ***
[05557]                   ; ******************************************************************************
[05558]                   #endif
[05559]                   
[05560]                   ; ******************************************
[05561]                   ; *** Now for the BASIC execution engine ***
[05562]                   ; *** RA - address of tokens to execute  ***
[05563]                   ; *** RC - current line number           ***
[05564]                   ; *** Returns: DF=0 - success            ***
[05565]                   ; ***          DF=1 - Error              ***
[05566]                   ; ***             D - Error code         ***
[05567]                   ; ******************************************
[05568] d339: 3f 40       execute:   bn4     exec_1              ; jump if EF4 not asserted
[05569] d33b: f8 00                  ldi     ERR_BREAK           ; otherwise breat
[05570] d33d: ff 00                  smi     0
[05571] d33f: d5                     sep     sret
[05572] d340: 0a          exec_1:    ldn     ra                  ; get token
[05573] d341: c2 d3 68               lbz     exec_dn             ; jump if at end of statement
[05574] d344: ff fd                  smi     TKN_QSTR            ; quoted strings  cannot be first command
[05575] d346: c2 d3 84               lbz     syn_err             ; syntax error
[05576] d349: ff 01                  smi     1                   ; neither can numbers
[05577] d34b: c2 d3 84               lbz     syn_err
[05578] d34e: 0a                     ldn     ra                  ; get token again
[05579] d34f: d4                     sep     scall               ; see if possible variable
[05580] d350: ff 72                  dw      f_isalpha
[05581] d352: c3 ca af               lbdf    ex_let              ; if so, treat as LET
[05582] d355: fa 80                  ani     080h                ; see if token or unquoted string
[05583] d357: c2 d3 84               lbz     syn_err             ; for now, unqoted strings are erros
[05584] d35a: 4a                     lda     ra                  ; get token
[05585] d35b: fa 7f                  ani     07fh                ; strip token bit
[05586] d35d: ff 1a                  smi     CMD_START           ; check for PRINT
[05587] d35f: cb d3 84               lbnf    syn_err             ; jump if function instead of statement
[05588] d362: af                     plo     rf
[05589] d363: d7                     sep     r7                  ; execute command
[05590] d364: 8c                     db      do_cmd.0
[05591]                   
[05592] d365: c0 d3 84               lbr     syn_err             ; failed to find command
[05593]                   
[05594] d368: 8c          exec_dn:   glo     rc                  ; see if we were in run mode
[05595] d369: 52                     str     r2
[05596] d36a: 9c                     ghi     rc
[05597] d36b: f1                     or
[05598] d36c: c2 d3 7b               lbz     good_ret            ; if not, then good return
[05599] d36f: d7          exec_run:  sep     r7                  ; need to get next line
[05600] d370: 48                     db      next_ln.0
[05601] d371: 9f                     ghi     rf                  ; setup addresses
[05602] d372: bc                     phi     rc
[05603] d373: ba                     phi     ra
[05604] d374: 8f                     glo     rf
[05605] d375: ac                     plo     rc
[05606] d376: aa                     plo     ra
[05607] d377: 0a          exec_tst:  ldn     ra                  ; see if at end of program
[05608] d378: ca d3 7e               lbnz    exec_go             ; execute new line if not
[05609] d37b: fc 00       good_ret:  adi     0                   ; signal no errors
[05610] d37d: d5                     sep     sret                ; and return
[05611] d37e: 1a          exec_go:   inc     ra                  ; move past size and line number
[05612] d37f: 1a                     inc     ra
[05613] d380: 1a                     inc     ra
[05614] d381: c0 d3 39               lbr     execute             ; and execute new line
[05615]                   
[05616] d384: f8 02       syn_err:   ldi     ERR_SYN             ; signal syntax error
[05617] d386: c8                     lskp
[05618] d387: f8 05       val_err:   ldi     ERR_VAL             ; signal syntax error
[05619] d389: ff 00       err_ret:   smi     0                   ; be sure error flag is set
[05620] d38b: d5                     sep     sret                ; and return
[05621]                   
[05622]                   ; *****************************************
[05623]                   ; *** Find size from RF to end of basic ***
[05624]                   ; *** RF - start of line                ***
[05625]                   ; *** Returns: RC - count of bytes      ***
[05626]                   ; *****************************************
[05627] d38c: 8f          size_end:  glo     rf                  ; save RF
[05628] d38d: 73                     stxd
[05629] d38e: 9f                     ghi     rf
[05630] d38f: 73                     stxd
[05631] d390: f8 00                  ldi     0                   ; setup count
[05632] d392: ac                     plo     rc
[05633] d393: bc                     phi     rc
[05634] d394: 0f          size_lp:   ldn     rf                  ; see if at end
[05635] d395: c2 d3 ab               lbz     size_dn             ; jump if end found
[05636] d398: ef                     sex     rf
[05637] d399: 8c                     glo     rc                  ; add count to total
[05638] d39a: f4                     add
[05639] d39b: ac                     plo     rc
[05640] d39c: 9c                     ghi     rc                  ; propagate carry
[05641] d39d: 7c 00                  adci    0
[05642] d39f: bc                     phi     rc
[05643] d3a0: 8f                     glo     rf                  ; add count into line position
[05644] d3a1: f4                     add
[05645] d3a2: af                     plo     rf                  ; and set as new line position
[05646] d3a3: 9f                     ghi     rf                  ; propagate carry
[05647] d3a4: 7c 00                  adci    0
[05648] d3a6: bf                     phi     rf
[05649] d3a7: e2                     sex     r2
[05650] d3a8: c0 d3 94               lbr     size_lp             ; keep looping until end
[05651] d3ab: 60          size_dn:   irx                         ; recover RF
[05652] d3ac: 72                     ldxa
[05653] d3ad: bf                     phi     rf
[05654] d3ae: f0                     ldx
[05655] d3af: af                     plo     rf
[05656] d3b0: 1c                     inc     rc                  ; add in program terminator
[05657] d3b1: d5                     sep     sret                ; and return to caller
[05658]                   
[05659]                   ;#ifdef ELFOS
[05660]                   ;o_inmsg:   lda     r6                  ; load byte from message
[05661]                   ;           lbz     return              ; return if done
[05662]                   ;           sep     scall               ; display byte
[05663]                   ;           dw      TYPE
[05664]                   ;           lbr     o_inmsg
[05665]                   ;#endif
[05666]                   
[05667]                   #ifndef ELFOS
[05668] d3b2: f8 05       begin2:    ldi     high stack          ; restart address here
[05669] d3b4: b2                     phi     r2
[05670] d3b5: f8 35                  ldi     low stack
[05671] d3b7: a2                     plo     r2
[05672] d3b8: f8 bb                  ldi     high restart        ; setup for start
[05673] d3ba: b6                     phi     r6
[05674] d3bb: f8 52                  ldi     low restart
[05675] d3bd: a6                     plo     r6
[05676] d3be: e2                     sex     r2                  ; point X to stack
[05677] d3bf: c0 ff 3f               lbr     f_initcall          ; setup SCALL and SRET
[05678] d3c2: f8 05       begin:     ldi     high stack          ; setup stack
[05679] d3c4: b2                     phi     r2
[05680] d3c5: f8 35                  ldi     low stack
[05681] d3c7: a2                     plo     r2
[05682] d3c8: f8 bb                  ldi     high start          ; setup for start
[05683] d3ca: b6                     phi     r6
[05684] d3cb: f8 af                  ldi     low start
[05685] d3cd: a6                     plo     r6
[05686] d3ce: e2                     sex     r2                  ; point X to stack
[05687] d3cf: c0 ff 3f               lbr     f_initcall          ; setup SCALL and SRET
[05688]                   #endif
[05689]                   
[05690]                   ; **********************************************************
[05691]                   ; ***** Convert string to uppercase, honor quoted text *****
[05692]                   ; **********************************************************
[05693] d3d2: 0f          touc:      ldn     rf                  ; check for quote
[05694] d3d3: ff 22                  smi     022h
[05695] d3d5: c2 d3 ef               lbz     touc_qt             ; jump if quote
[05696] d3d8: 0f                     ldn     rf                  ; get byte from string
[05697] d3d9: c2 d3 ee               lbz     touc_dn             ; jump if done
[05698] d3dc: ff 61                  smi     'a'                 ; check if below lc
[05699] d3de: cb d3 ea               lbnf    touc_nxt            ; jump if so
[05700] d3e1: ff 1b                  smi     27                  ; check upper rage
[05701] d3e3: c3 d3 ea               lbdf    touc_nxt            ; jump if above lc
[05702] d3e6: 0f                     ldn     rf                  ; otherwise convert character to lc
[05703] d3e7: ff 20                  smi     32
[05704] d3e9: 5f                     str     rf
[05705] d3ea: 1f          touc_nxt:  inc     rf                  ; point to next character
[05706] d3eb: c0 d3 d2               lbr     touc                ; loop to check rest of string
[05707] d3ee: d5          touc_dn:   sep     sret                ; return to caller
[05708] d3ef: 1f          touc_qt:   inc     rf                  ; move past quote
[05709] d3f0: 4f          touc_qlp:  lda     rf                  ; get next character
[05710] d3f1: c2 d3 ee               lbz     touc_dn             ; exit if terminator found
[05711] d3f4: ff 22                  smi     022h                ; check for quote charater
[05712] d3f6: c2 d3 d2               lbz     touc                ; back to main loop if quote
[05713] d3f9: c0 d3 f0               lbr     touc_qlp            ; otherwise keep looking
[05714]                   
[05715]                   
[05716] d3fc: ab          functable: db      ('+'+80h)           ; 0
[05717] d3fd: ad                     db      ('-'+80h)           ; 1
[05718] d3fe: aa                     db      ('*'+80h)           ; 2
[05719] d3ff: af                     db      ('/'+80h)           ; 3
[05720] d400: a8                     db      ('('+80h)           ; 4
[05721] d401: a9                     db      (')'+80h)           ; 5
[05722] d402: bd                     db      ('='+80h)           ; 6
[05723] d403: 3c bd                  db      '<',('='+80h)       ; 7
[05724] d405: 3e bd                  db      '>',('='+80h)       ; 8
[05725] d407: 3c be                  db      '<',('>'+80h)       ; 9
[05726] d409: bc                     db      ('<'+80h)           ; 10
[05727] d40a: be                     db      ('>'+80h)           ; 11
[05728] d40b: bb                     db      (';'+80h)           ; 12
[05729] d40c: ac                     db      (','+80h)           ; 13
[05730] d40d: 41 4e c4               db      'AN',('D'+80h)      ; 14
[05731] d410: a6                     db      ('&'+80h)           ; 15
[05732] d411: 4f d2                  db      'O',('R'+80h)       ; 16
[05733] d413: fc                     db      ('|'+80h)           ; 17
[05734] d414: de                     db      ('^'+80h)           ; 18
[05735] d415: ba                     db      (':'+80h)           ; 19
[05736] d416: 50 45 45 4b            db      'PEEK',('('+80h)    ; 20
              a8 
[05737] d41b: 46 52 45 a8            db      'FRE',('('+80h)     ; 21
[05738] d41f: 52 4e 44 a8            db      'RND',('('+80h)     ; 22
[05739] d423: 49 4e 50 a8            db      'INP',('('+80h)     ; 23
[05740] d427: 46 4c 47 a8            db      'FLG',('('+80h)     ; 24
[05741]                   
[05742] d42b: 55 53 52 a8            db      'USR',('('+80h)      ; 25
[05743]                   
[05744] d42f: 50 52 49 4e            db      'PRIN',('T'+80h)    ; 0
              d4 
[05745] d434: bf                     db      ('?'+80h)           ; 1
[05746] d435: 4c 45 d4               db      'LE',('T'+80h)      ; 2
[05747] d438: 47 4f 54 cf            db      'GOT',('O'+80h)     ; 3
[05748] d43c: 49 c6                  db      'I',('F'+80h)       ; 4
[05749] d43e: 54 48 45 ce            db      'THE',('N'+80h)     ; 5
[05750] d442: 45 4e c4               db      'EN',('D'+80h)      ; 6
[05751] d445: 47 4f 53 55            db      'GOSU',('B'+80h)    ; 7
              c2 
[05752] d44a: 52 45 54 55            db      'RETUR',('N'+80h)   ; 8
              52 ce 
[05753] d450: 52 45 cd               db      'RE',('M'+80h)      ; 9
[05754] d453: 49 4e 50 55            db      'INPU',('T'+80h)    ; 10
              d4 
[05755] d458: 50 4f 4b c5            db      'POK',('E'+80h)     ; 11
[05756] d45c: 4f 55 d4               db      'OU',('T'+80h)      ; 12
[05757] d45f: 50 4c 4f d4            db      'PLO',('T'+80h)     ; 13
[05758] d463: 52 55 ce               db      'RU',('N'+80h)      ; 14
[05759] d466: 4c 49 53 d4            db      'LIS',('T'+80h)     ; 15
[05760] d46a: 4e 45 d7               db      'NE',('W'+80h)      ; 16
[05761]                   #if LEVEL>=2
[05762] d46d: 46 4f d2               db      'FO',('R'+80h)      ; 17
[05763] d470: 54 cf                  db      'T',('O'+80h)       ; 18
[05764] d472: 4e 45 58 d4            db      'NEX',('T'+80h)     ; 19
[05765] d476: 53 54 45 d0            db      'STE',('P'+80h)     ; 20
[05766] d47a: 4f ce                  db      'O',('N'+80h)       ; 21
[05767] d47c: 44 41 54 c1            db      'DAT',('A'+80h)     ; 22
[05768] d480: 52 45 41 c4            db      'REA',('D'+80h)     ; 23
[05769] d484: 52 45 53 54            db      'RESTOR',('E'+80h)  ; 24
              4f 52 c5 
[05770] d48b: 44 49 cd               db      'DI',('M'+80h)      ; 25
[05771] d48e: 52 41 4e 44            db      'RANDO',('M'+80h)   ; 26
              4f cd 
[05772] d494: 56 41 52 50            db      'VARPTR',('('+80h)  ; 27
              54 52 a8 
[05773] d49b: 43 4c 45 41            db      'CLEA',('R'+80h)    ; 28
              d2 
[05774] d4a0: 4c 45 4e a8            db      'LEN',('('+80h)     ; 29
[05775] d4a4: 41 53 43 a8            db      'ASC',('('+80h)     ; 30
[05776] d4a8: 56 41 4c a8            db      'VAL',('('+80h)     ; 31
[05777] d4ac: 53 54 52 24            db      'STR$',('('+80h)    ; 32
              a8 
[05778] d4b1: 43 48 52 24            db      'CHR$',('('+80h)    ; 33
              a8 
[05779] d4b6: 4c 45 46 54            db      'LEFT$',('('+80h)   ; 34
              24 a8 
[05780] d4bc: 52 49 47 48            db      'RIGHT$',('('+80h)  ; 35
              54 24 a8 
[05781] d4c3: 4d 49 44 24            db      'MID$',('('+80h)    ; 36
              a8 
[05782] d4c8: 48 45 58 24    	   db	    'HEX$',('('+80h) ; ; 37
              a8 
[05783]                   
[05784]                   #endif
[05785] d4cd: 42 59 c5               db      'BY',('E'+80h)      ; 43
[05786]                   #ifdef INROM
[05787] d4d0: 53 41 56 c5            db      'SAV',('E'+80h)     ; 44
[05788] d4d4: 4c 4f 41 c4            db      'LOA',('D'+80h)     ; 45
[05789]                   #endif
[05800]                   #endif
[05801] d4d8: 00                     db      0
[05802] d4d9: ff          term:      db      0ffh
[05803] d4da: 0a 0d 00    crlf:      db      10,13,0
[05804]                   
[05805] d4dd:             endrom:    equ     $
[05806]                   
[05807]                   #ifndef ELFOS
[05808] d4dd:                        org     DATA
[05809]                   #endif
[05810]                   
[05813]                   #endif
[05814]                   
[05817]                   #endif
[05818]                   #if LEVEL>=2
[05819] 0100:             memory:    ds      2
[05820] 0102:             data_lin:  ds      2
[05821] 0104:             data_pos:  ds      2
[05822] 0106:             var_pos:   ds      2
[05823] 0108:             heap:      ds      2
[05824] 010a:             for_pos:   ds      2
[05825] 010c:                        ds      80
[05826] 015c:             for_st:    ds      1
[05827]                   #endif
[05828] 015d:             lfsr:      ds      4
[05829] 0161:             inp_pos:   ds      2                   ; pointer into INPUT buffer
[05830] 0163:             ibuffer:   ds      80                  ; holds input for INPUT
[05831] 01b3:             buffer:    ds      256                 ; input buffer
[05832] 02b3:             gosub_pos: ds      2
[05833] 02b5:             gosub_st:  ds      256
[05834] 03b5:             tokens:    ds      256                 ; buffer for tokenization
[05835] 04b5:                        ds      128                 ; space for stack
[05836] 0535:             stack:     ds      1
[05837] 0536:                        ds      128
[05838] 05b6:             expstack:  ds      1
[05842]                   #endif
[05843] 05b7:             basic:     ds      1
[05844] 05b8:             	   end    BASE
