1802 -> Native
2 Classes read.
186 Patterns read.
            # 0 "rcbasic.asm"
            # 0 "<built-in>"
            # 0 "<command-line>"
            # 1 "/usr/include/stdc-predef.h" 1 3 4
            # 0 "<command-line>" 2
            # 1 "rcbasic.asm"
    7 0000:             ; *******************************************************************
    8 0000:             ; *** This software is copyright 2006 by Michael H Riley ***
    9 0000:             ; *** You have permission to use, modify, copy, and distribute ***
   10 0000:             ; *** this software so long as this copyright notice is retained. ***
   11 0000:             ; *** This software may not be used in commercial applications ***
   12 0000:             ; *** without express written permission from the author. ***
   13 0000:             ; *******************************************************************
   14 0000:             
   15 0000:             ;[RLA] These are defined on the rcasm command line!
   16 0000:             ;[RLA] #define ELFOS ; build the version that runs under Elf/OS
   17 0000:             ;[RLA] #define 1 ; build the STG EPROM version
   18 0000:             ;[RLA] #define 2 2 ; feature level, 1 or 2
   19 0000:             ;[RLA] #define PICOROM ; define for Mike's PIcoElf version
   20 0000:             
   21 0000:             ;[RLA] rcasm doesn't have any way to do a logical "OR" of assembly
   22 0000:             ;[RLA} options, so define a master "ANYROM" option that's true for
   23 0000:             ;[RLA} any of the ROM conditions...
            # 26 "rcbasic.asm"
   25 0000:             include config.inc
   26 0000:             ; DO NOT EDIT THIS FILE - EDIT CONFIG. INSTEAD!!
            #define BOOTS	 08000H
            #define WARMB	 (08000H+3)
            #define HELP	 09400H
            #define RAMPAGE	 07F00H
            #define BIOS	 0FF00H
            #define EBIOS	 0F800H
            #define FORTH	 0D700H
            #define EDTASM	 09C00H
            #define BASIC	 0BA00H
            #define VISUAL	 0A900H
            #define XMODEM	 0D400H
   38 0000:             
   39 0000:             
   40 0000:             include bios.inc
   41 0000:             ; *******************************************************************
   42 0000:             ; *** This software is copyright 2006 by Michael H Riley          ***
   43 0000:             ; *** You have permission to use, modify, copy, and distribute    ***
   44 0000:             ; *** this software so long as this copyright notice is retained. ***
   45 0000:             ; *** This software may not be used in commercial applications    ***
   46 0000:             ; *** without express written permission from the author.         ***
   47 0000:             ; *******************************************************************
   48 0000:             
            #endif
   52 0000:             
   53 0000:             ; Define address for standard BIOS vectors
            #endif
   57 0000:             
   58 0000:             ; Define address for extended BIOS vectors
            #endif
   62 0000:             
            #ifndef TASM
   64 0000:             scall:      equ  r4                    ; register for SCALL
   65 0000:             sret:       equ  r5                    ; register for SRET
   66 0000:             
   67 0000:             call:       equ  0ffe0h                ; depricated
   68 0000:             ret:        equ  0fff1h                ; depricated
            #endif
   70 0000:             
   71 0000:             f_boot:     equ  (BIOS+00h)            ; boot from ide device
   72 0000:             f_type:     equ  (BIOS+03h)            ; type 1 character to console
   73 0000:             f_read:     equ  (BIOS+06h)            ; read 1 character from console
   74 0000:             f_msg:      equ  (BIOS+09h)            ; type asciiz string to console
   75 0000:             f_typex:    equ  (BIOS+0ch)            ; depricated, just returns now
   76 0000:             f_input:    equ  (BIOS+0fh)            ; read asciiz from console
   77 0000:             f_strcmp:   equ  (BIOS+12h)            ; compare 2 strings
   78 0000:             f_ltrim:    equ  (BIOS+15h)            ; trim leading spaces
   79 0000:             f_strcpy:   equ  (BIOS+18h)            ; copy an asciiz string
   80 0000:             f_memcpy:   equ  (BIOS+1bh)            ; copy memory
   81 0000:             f_wrtsec:   equ  (BIOS+1eh)            ; write floppy sector (depricated)
   82 0000:             f_rdsec:    equ  (BIOS+21h)            ; read floppy sector (depricated)
   83 0000:             f_seek0:    equ  (BIOS+24h)            ; floppy seek to track 0 (depricated)
   84 0000:             f_seek:     equ  (BIOS+27h)            ; floopy track seek (depricated)
   85 0000:             f_drive:    equ  (BIOS+2ah)            ; select floppy drive (depricated)
   86 0000:             f_setbd:    equ  (BIOS+2dh)            ; set console baud rate
   87 0000:             f_mul16:    equ  (BIOS+30h)            ; 16-bit multiply
   88 0000:             f_div16:    equ  (BIOS+33h)            ; 16-bit division
   89 0000:             f_idereset: equ  (BIOS+36h)            ; reset ide device
   90 0000:             f_idewrite: equ  (BIOS+39h)            ; write ide sector
   91 0000:             f_ideread:  equ  (BIOS+3ch)            ; read ide sector
   92 0000:             f_initcall: equ  (BIOS+3fh)            ; initialize R4 and R5
   93 0000:             f_bootide:  equ  (BIOS+42h)            ; boot from ide device
   94 0000:             f_hexin:    equ  (BIOS+45h)            ; convert ascii number to hex
   95 0000:             f_hexout2:  equ  (BIOS+48h)            ; convert hex to 2-digit ascii
   96 0000:             f_hexout4:  equ  (BIOS+4bh)            ; convert hex to 4-digit ascii
   97 0000:             f_tty:      equ  (BIOS+4eh)            ; type character to console
   98 0000:             f_mover:    equ  (BIOS+51h)            ; program relocator
   99 0000:             f_minimon:  equ  (BIOS+54h)            ; mini monitor
  100 0000:             f_freemem:  equ  (BIOS+57h)            ; determine memory size
  101 0000:             F_isnum:    equ  (BIOS+5ah)            ; determine if D is numeric
  102 0000:             f_atoi:     equ  (BIOS+5dh)            ; convert ascii to integer
  103 0000:             f_uintout:  equ  (BIOS+60h)            ; convert unsigned integer to ascii
  104 0000:             f_intout:   equ  (BIOS+63h)            ; convert signed integer to ascii
  105 0000:             f_inmsg:    equ  (BIOS+66h)            ; type in-line message
  106 0000:             f_inputl:   equ  (BIOS+69h)            ; read limited line from console
  107 0000:             f_brktest:  equ  (BIOS+6ch)            ; check for serial break
  108 0000:             f_findtkn:  equ  (BIOS+6fh)            ; find token in a token table
  109 0000:             f_isalpha:  equ  (BIOS+72h)            ; determine if D is alphabetic
  110 0000:             f_ishex:    equ  (BIOS+75h)            ; determine if D is hexadecimal
  111 0000:             f_isalnum:  equ  (BIOS+78h)            ; determine if D is alpha or numeric
  112 0000:             f_idnum:    equ  (BIOS+7bh)            ; determine type of ascii number
  113 0000:             f_isterm:   equ  (BIOS+7eh)            ; determine if D is a termination char
  114 0000:             f_getdev:   equ  (BIOS+81h)            ; get supported devices
  115 0000:             
  116 0000:             f_version:  equ  (BIOS+0f9h)           ; 3 bytes holding bios version number
  117 0000:             
  118 0000:             ; "Extended" BIOS vectors
  119 0000:             
  120 0000:             f_bread:     equ  (EBIOS+00h)        ; read from onboard serial port
  121 0000:             f_btype:     equ  (EBIOS+03h)        ; write to onboard serial port
  122 0000:             f_btest:     equ  (EBIOS+06h)        ; test onboard serial port
  123 0000:             f_utype:     equ  (EBIOS+09h)        ; write to disk board UART
  124 0000:             f_uread:     equ  (EBIOS+0ch)        ; read from disk board UART
  125 0000:             f_utest:     equ  (EBIOS+0fh)        ; test disk board UART
  126 0000:             f_usetbd:    equ  (EBIOS+12h)        ; set disk board UART baud rate and format
  127 0000:             f_gettod:    equ  (EBIOS+15h)        ; read time of day clock
  128 0000:             f_settod:    equ  (EBIOS+18h)        ; set time of day clock
  129 0000:             f_rdnvr:     equ  (EBIOS+1bh)        ; read non volatile RAM
  130 0000:             f_wrnvr:     equ  (EBIOS+1eh)        ; write non volatile RAM
  131 0000:             f_idesize:   equ  (EBIOS+21h)        ; return size of attached IDE drive(s)
  132 0000:             f_ideid:     equ  (EBIOS+24h)        ; return device data for IDE drive(s)
  133 0000:             f_tmtoas:    equ  (EBIOS+2ah)        ; time to ASCII string
  134 0000:             f_dttoas:    equ  (EBIOS+27h)        ; date to ASCII string
  135 0000:             f_rtctest:   equ  (EBIOS+2dh)        ; test size and presence of RTC/NVR
  136 0000:             f_astodt:    equ  (EBIOS+30h)        ; convert ASCII string to date
  137 0000:             f_astotm:    equ  (EBIOS+33h)        ; convert ASCII string to time
  138 0000:             f_nvrcchk:   equ  (EBIOS+36h)	    ; [RLA] compute NVR checksum
  139 0000:             
  140 0000:             
  141 0000:             
  142 0000:             
  143 0000:             
  144 0000:             
  145 0000:             ; R7 - Group 7 subroutines
  146 0000:             ; R8 - GOSUB stack
  147 0000:             ; R9 - Expression stack
  148 0000:             ; RA - Current token
  149 0000:             ; RC - Current line pointer
            # 51 "rcbasic.asm"
  151 0000:             ;[RLA] XMODEM entry vectors for the STG EPROM ...
  152 0000:             xopenw: equ XMODEM + 0*3
  153 0000:             xopenr: equ XMODEM + 1*3
  154 0000:             xread: equ XMODEM + 2*3
  155 0000:             xwrite: equ XMODEM + 3*3
  156 0000:             xclosew: equ XMODEM + 4*3
  157 0000:             xcloser: equ XMODEM + 5*3
  158 0000:             
  159 0000:             
  160 0000:             TKN_USTR: equ 0fch
  161 0000:             TKN_QSTR: equ 0fdh
  162 0000:             TKN_NUM: equ 0feh
  163 0000:             TKN_TERM: equ 0ffh
  164 0000:             
  165 0000:             ERR_BREAK: equ 0
  166 0000:             ERR_DIRECT: equ 1
  167 0000:             ERR_SYN: equ 2
  168 0000:             ERR_NOLIN: equ 3
  169 0000:             ERR_INVRET: equ 4
  170 0000:             ERR_VAL: equ 5
  171 0000:             ERR_FILE: equ 6
  172 0000:             ERR_INVLP: equ 7
  173 0000:             ERR_NOFOR: equ 8
  174 0000:             ERR_NODATA: equ 9
  175 0000:             ERR_NOMEM: equ 10
  176 0000:             ERR_BADDIM: equ 11
  177 0000:             ERR_UNSUP: equ 12
  178 0000:             
  179 0000:             CMD_START: equ 26
            # 123 "rcbasic.asm"
  181 0000:                        org BASIC
  182 ba00:             
  183 ba00:             
  184 ba00:             
  185 ba00:             
  186 ba00:             
  187 ba00:             
  188 ba00: c0 d2 d1               lbr begin ; jump to program start
  189 ba03: c0 d2 c1               lbr begin2
  190 ba06:             
  191 ba06:             
  192 ba06: d3                     sep r3 ; return to caller
  193 ba07: 43          group_7: lda r3 ; retrieve get subcode
  194 ba08: a7                     plo r7 ; and jump to it
  195 ba09: f8 01       set_buf: ldi high buffer ; point to input buffer
  196 ba0b: bf                     phi rf
  197 ba0c: f8 b3                  ldi low buffer
  198 ba0e: af                     plo rf
  199 ba0f: 30 06                  br group_7-1 ; and return
  200 ba11: f8 03       set_tkn: ldi high tokens ; point to input buffer
  201 ba13: ba                     phi ra
  202 ba14: f8 b5                  ldi low tokens
  203 ba16: aa                     plo ra
  204 ba17: 30 06                  br group_7-1 ; and return
  205 ba19:             
  206 ba19:             ; ***************************************
  207 ba19:             ; *** Find a line ***
  208 ba19:             ; *** RD - line number to find ***
  209 ba19:             ; *** Returns - RC - address of line ***
  210 ba19:             ; *** DF=1 - exact match ***
  211 ba19:             ; *** DF=0 - line is higher ***
  212 ba19:             ; ***************************************
  213 ba19: f8 05       find_ln: ldi high pgmtext ; point to beginning of basic storage
  214 ba1b: bc                     phi rc
  215 ba1c: f8 b7                  ldi low pgmtext
  216 ba1e: ac                     plo rc
  217 ba1f: 4c          find_lp: lda rc ; get line size
  218 ba20: 32 43                  bz find_eof ; jump if no more lines
  219 ba22: 1c                     inc rc ; point to lsb
  220 ba23: ec                     sex rc ; point data to line number
  221 ba24: 8d                     glo rd ; get requested line
  222 ba25: f7                     sm ; and subtract
  223 ba26: ae                     plo re ; save result
  224 ba27: 2c                     dec rc ; point to msb
  225 ba28: 9d                     ghi rd ; get msb of search line
  226 ba29: 77                     smb ; complete comparison
  227 ba2a: e2                     sex r2 ; point X back to stack
  228 ba2b: 52                     str r2 ; place into memory
  229 ba2c: 8e                     glo re ; get previous result
  230 ba2d: f1                     or ; and or them together
  231 ba2e: 32 3e                  bz find_ex ; found an exact match
  232 ba30: 3b 43                  bnf find_eof ; jump if line was high
  233 ba32: 2c                     dec rc ; point to line size
  234 ba33: ec                     sex rc ; point to size
  235 ba34: 8c                     glo rc ; and add into line position
  236 ba35: f4                     add
  237 ba36: ac                     plo rc
  238 ba37: 9c                     ghi rc ; propogate carry
  239 ba38: 7c 00                  adci 0
  240 ba3a: bc                     phi rc
  241 ba3b: e2                     sex r2 ; point X back to stack
  242 ba3c: 30 1f                  br find_lp ; and keep searching
  243 ba3e: 2c          find_ex: dec rc ; point back to line size
  244 ba3f: ff 00                  smi 0 ; signal exact match
  245 ba41: 30 06                  br group_7-1 ; and return
  246 ba43: 2c          find_eof: dec rc ; last position is pointer
  247 ba44: fc 00                  adi 0 ; signal line is higher/non existant
  248 ba46: 30 06                  br group_7-1 ; return to caller
  249 ba48:             ; ******************************************
  250 ba48:             ; *** Find next basic line ***
  251 ba48:             ; *** RC - pointer to basic line ***
  252 ba48:             ; *** Returns: RF - pointer to next line ***
  253 ba48:             ; ******************************************
  254 ba48: ec          next_ln: sex rc ; use rc as data pointer
  255 ba49: 8c                     glo rc ; get current low pointer
  256 ba4a: f4                     add ; and add in offset
  257 ba4b: af                     plo rf ; place into rf
  258 ba4c: 9c                     ghi rc ; get msb of address
  259 ba4d: 7c 00                  adci 0 ; propagate carry
  260 ba4f: bf                     phi rf ; rf now points to next line
  261 ba50: e2                     sex r2 ; point x back to stack
  262 ba51: 30 06                  br group_7-1 ; return to caller
  263 ba53:             
  264 ba53:             ; **************************************
  265 ba53:             ; *** Add inline character to buffer ***
  266 ba53:             ; *** RF - buffer ***
  267 ba53:             ; **************************************
  268 ba53: 43          add_char: lda r3 ; get byte to add to buffer
  269 ba54: 5f                     str rf ; store into buffer
  270 ba55: 1f                     inc rf ; increment it
  271 ba56: 30 06                  br group_7-1 ; and return to caller
  272 ba58:             
  273 ba58: e9          ex_pop: sex r9 ; point X to expression stack
  274 ba59: 60                     irx ; recover value
  275 ba5a: 72                     ldxa
  276 ba5b: bf                     phi rf
  277 ba5c: f0                     ldx
  278 ba5d: af                     plo rf
  279 ba5e: e2                     sex r2 ; point x back to proper stack
  280 ba5f: 30 06                  br group_7-1
  281 ba61:             
  282 ba61: e9          ex_pop_rd: sex r9 ; point X to expression stack
  283 ba62: 60                     irx ; recover value
  284 ba63: 72                     ldxa
  285 ba64: bd                     phi rd
  286 ba65: f0                     ldx
  287 ba66: ad                     plo rd
  288 ba67: e2                     sex r2 ; point x back to proper stack
  289 ba68: 30 06                  br group_7-1
  290 ba6a:             
  291 ba6a: e9          ex_push: sex r9 ; point X to expression stack
  292 ba6b: 8f                     glo rf ; place RF onto it
  293 ba6c: 73                     stxd
  294 ba6d: 9f                     ghi rf
  295 ba6e: 73                     stxd
  296 ba6f: e2                     sex r2 ; reset x back to main stack
  297 ba70: 30 06                  br group_7-1
  298 ba72:             
  299 ba72: 9f          rf_rd: ghi rf ; copy rf to rd
  300 ba73: bd                     phi rd
  301 ba74: 8f                     glo rf
  302 ba75: ad                     plo rd
  303 ba76: 30 06                  br group_7-1
  304 ba78:             
  305 ba78: f8 00       get_flags: ldi 0 ; start with zero
  306 ba7a: 3c 7e                  bn1 no_ef1 ; jump if ef1 not asserted
  307 ba7c: f9 01                  ori 1 ; indicate set
  308 ba7e: 3d 82       no_ef1: bn2 no_ef2 ; jump if ef2 not asserted
  309 ba80: f9 02                  ori 2 ; indicate set
  310 ba82: 3e 86       no_ef2: bn3 no_ef3 ; jump if ef2 not asserted
  311 ba84: f9 04                  ori 4 ; indicate set
  312 ba86: 3f 06       no_ef3: bn4 group_7-1 ; jump if ef2 not asserted
  313 ba88: f9 08                  ori 8 ; indicate set
  314 ba8a: 30 06                  br group_7-1
  315 ba8c:             
  316 ba8c:             ; ************************************
  317 ba8c:             ; *** process statement jump table ***
  318 ba8c:             ; ************************************
  319 ba8c: 8f          do_cmd: glo rf ; get command
  320 ba8d: fe                     shl ; multiply command by 2
  321 ba8e: 52                     str r2 ; prepare for add
  322 ba8f: f8 00                  ldi low cmd_table ; lsb of command table address
  323 ba91: f4                     add ; add in command offset
  324 ba92: a3                     plo r3 ; place into R3
  325 ba93: f8 bb                  ldi high cmd_table ; msb of command table
  326 ba95: b3                     phi r3 ; r3 now has command
  327 ba96: 43                     lda r3 ; read command address
  328 ba97: ae                     plo re
  329 ba98: 03                     ldn r3
  330 ba99: a3                     plo r3
  331 ba9a: 8e                     glo re
  332 ba9b: b3                     phi r3
  333 ba9c: 30 06                  br group_7-1
  334 ba9e:             
  335 ba9e: 8f          push_rf: glo rf
  336 ba9f: 73                     stxd
  337 baa0: 9f                     ghi rf
  338 baa1: 73                     stxd
  339 baa2: 30 06                  br group_7-1
  340 baa4:             
  341 baa4: 60          pop_rf: irx
  342 baa5: 72                     ldxa
  343 baa6: bf                     phi rf
  344 baa7: f0                     ldx
  345 baa8: af                     plo rf
  346 baa9: 30 06                  br group_7-1
  347 baab:             
  348 baab: 8b          push_rb: glo rb
  349 baac: 73                     stxd
  350 baad: 9b                     ghi rb
  351 baae: 73                     stxd
  352 baaf: 30 06                  br group_7-1
  353 bab1:             
  354 bab1: 60          pop_rb: irx
  355 bab2: 72                     ldxa
  356 bab3: bb                     phi rb
  357 bab4: f0                     ldx
  358 bab5: ab                     plo rb
  359 bab6: 30 06                  br group_7-1
  360 bab8:             
  361 bab8: 8d          push_rd: glo rd
  362 bab9: 73                     stxd
  363 baba: 9d                     ghi rd
  364 babb: 73                     stxd
  365 babc: 30 06                  br group_7-1
  366 babe:             
  367 babe: 60          pop_rd: irx
  368 babf: 72                     ldxa
  369 bac0: bd                     phi rd
  370 bac1: f0                     ldx
  371 bac2: ad                     plo rd
  372 bac3: 30 06                  br group_7-1
  373 bac5:             
  374 bac5: 43          set_byte: lda r3 ; get msb of address
  375 bac6: bf                     phi rf ; place into RF
  376 bac7: 43                     lda r3
  377 bac8: af                     plo rf
  378 bac9: 43          byte_go: lda r3 ; get value
  379 baca: 5f                     str rf ; and store
  380 bacb: 30 06                  br group_7-1
  381 bacd:             
  382 bacd: 43          set_word: lda r3 ; get msb of address
  383 bace: bf                     phi rf ; place into RF
  384 bacf: 43                     lda r3
  385 bad0: af                     plo rf
  386 bad1: 43                     lda r3 ; get value
  387 bad2: 5f                     str rf ; and store
  388 bad3: 1f                     inc rf
  389 bad4: 30 c9                  br byte_go
  390 bad6:             
  391 bad6: 43          set_rf: lda r3 ; get msb
  392 bad7: bf                     phi rf ; place into rf
  393 bad8: 43                     lda r3
  394 bad9: af                     plo rf
  395 bada: 30 06                  br group_7-1
  396 badc:             
  397 badc: 43          get_rb: lda r3 ; get msb of address
  398 badd: bb                     phi rb
  399 bade: 43                     lda r3
  400 badf: ab                     plo rb
  401 bae0: 4b                     lda rb ; retrieve it
  402 bae1: ae                     plo re
  403 bae2: 0b                     ldn rb
  404 bae3: ab                     plo rb
  405 bae4: 8e                     glo re
  406 bae5: bb                     phi rb ; rb is not pointing to for stack
  407 bae6: 30 06                  br group_7-1
  408 bae8:             
  409 bae8: 96          func_call: ghi r6 ; save last value to stack
  410 bae9: 73                     stxd
  411 baea: 86                     glo r6
  412 baeb: 73                     stxd
  413 baec: 93                     ghi r3 ; copy R3 to R6
  414 baed: b6                     phi r6
  415 baee: 83                     glo r3
  416 baef: a6                     plo r6
  417 baf0: 48                     lda r8 ; get function address
  418 baf1: b3                     phi r3 ; and put into r3
  419 baf2: 48                     lda r8
  420 baf3: a3                     plo r3
  421 baf4: 30 06                  br group_7-1 ; now execute it
  422 baf6:             
  423 baf6:             ; ***************************************************************************
  424 baf6:             ; *** End of group 7 subroutines ***
  425 baf6:             ; ***************************************************************************
  426 baf6:             
  427 baf6:                        org (BASIC+0100h)
  428 bb00: cb 6e       cmd_table: dw ex_print ; 0
  429 bb02: cb 6e                  dw ex_print ; 1
  430 bb04: c9 c0                  dw ex_let ; 2
  431 bb06: c9 1a                  dw ex_goto ; 3
  432 bb08: c9 44                  dw ex_if ; 4
  433 bb0a: d2 93                  dw syn_err ; 5 (THEN)
  434 bb0c: c8 ef                  dw ex_end ; 6
  435 bb0e: c8 f6                  dw ex_gosub ; 7
  436 bb10: cb d5                  dw ex_return ; 8
  437 bb12: d2 77                  dw exec_dn ; 9 (REM)
  438 bb14: c9 5d                  dw ex_input ; 10
  439 bb16: cb 4a                  dw ex_poke ; 11
  440 bb18: ca d3                  dw ex_out ; 12
  441 bb1a: cb 01                  dw ex_plot ; 13
  442 bb1c: cb f9                  dw ex_run ; 14
  443 bb1e: c9 fd                  dw ex_list ; 15
  444 bb20: ca c4                  dw ex_new ; 16
  445 bb22:             
  446 bb22: cc bd                  dw ex_for ; 17
  447 bb24: d2 93                  dw syn_err ; 18 (TO)
  448 bb26: cd a9                  dw ex_next ; 19
  449 bb28: d2 93                  dw syn_err ; 20 (NEXT)
  450 bb2a: ce 68                  dw ex_on ; 21
  451 bb2c: d2 77                  dw exec_dn ; 22 (DATA)
  452 bb2e: ce c3                  dw ex_read ; 23
  453 bb30: ce fb                  dw ex_restore ; 24
  454 bb32: d1 51                  dw ex_dim ; 25
  455 bb34: ce a7                  dw ex_random ; 26
  456 bb36: d2 93                  dw syn_err ; 27 (VARPTR)
  457 bb38: cc b7                  dw ex_clear ; 28
  458 bb3a: d2 93                  dw syn_err ; 29 (LEN)
  459 bb3c: d2 93                  dw syn_err ; 30 (ASC)
  460 bb3e: d2 93                  dw syn_err ; 31 (VAL)
  461 bb40: d2 93                  dw syn_err ; 32 (STR)
  462 bb42: d2 93                  dw syn_err ; 33 (CHR)
  463 bb44: d2 93                  dw syn_err ; 34 (LEFT)
  464 bb46: d2 93                  dw syn_err ; 35 (RIGHT)
  465 bb48: d2 93                  dw syn_err ; 35 (MID)
  466 bb4a:             
  467 bb4a: cc 45                  dw ex_bye ; 21
  468 bb4c:             
  469 bb4c:             
  470 bb4c:             
  471 bb4c:             
  472 bb4c:             
  473 bb4c: cc 48                  dw ex_save ; 22
  474 bb4e: cc 85                  dw ex_load ; 23
  475 bb50:             
  476 bb50:             
  477 bb50: f8 0c       restart: ldi 0ch ; form feed
  478 bb52: d4                     sep scall ; clear the screen
  479 bb53: ff 03                  dw f_type
  480 bb55: d4                     sep scall ; display welcome message
  481 bb56: ff 66                  dw f_inmsg
  482 bb58:             
  483 bb58:             
  484 bb58:             
  485 bb58:             
  486 bb58: 52 43 2f 42 
            61 73 69 63 
            20 4c 32 0a 
            0d                     db 'RC/Basic L2',10,13
  487 bb65:             
  488 bb65: 28 63 29 20 
            43 6f 70 79 
            72 69 67 68 
            74 20 32 30 
            30 36 20 62 
            79 20 4d 69 
            63 68 61 65 
            6c 20 48 2e 
            20 52 69 6c 
            65 79 0a 0d 
            0a 0d 00               db '(c) Copyright 2006 by Michael H. Riley',10,13,10,13,0
  489 bb90:             
  490 bb90:             
  491 bb90:             
  492 bb90: f8 ba                  ldi high group_7 ; setup group 7 subroutines
  493 bb92: b7                     phi r7
  494 bb93: f8 07                  ldi low group_7
  495 bb95: a7                     plo r7
  496 bb96: d4                     sep scall ; call bios to get end of memory
  497 bb97: ff 57                  dw f_freemem
  498 bb99: f8 00                  ldi 0 ; zero terminator in heap memory
  499 bb9b: 5f                     str rf
  500 bb9c: f8 01                  ldi high memory ; point to high memory storage
  501 bb9e: bd                     phi rd
  502 bb9f: f8 00                  ldi low memory
  503 bba1: ad                     plo rd
  504 bba2: 9f                     ghi rf ; store heap address
  505 bba3: 5d                     str rd
  506 bba4: 1d                     inc rd
  507 bba5: 8f                     glo rf
  508 bba6: 5d                     str rd
  509 bba7: d4                     sep scall ; setup variable table
  510 bba8: bf 34                  dw rst_vars
  511 bbaa: c0 bc 11               lbr mainlp
  512 bbad:             
  513 bbad: d4          start: sep scall ; display welcome message
  514 bbae:             
  515 bbae:             ; dw f_setbd
  516 bbae:             ; sep scall ; display welcome message
  517 bbae:             
  518 bbae: ff 66                  dw f_inmsg
  519 bbb0:             
  520 bbb0:             
  521 bbb0:             
  522 bbb0:             
  523 bbb0: 52 43 2f 42 
            61 73 69 63 
            20 4c 32 0a 
            0d                     db 'RC/Basic L2',10,13
  524 bbbd:             
  525 bbbd: 28 63 29 20 
            43 6f 70 79 
            72 69 67 68 
            74 20 32 30 
            30 36 20 62 
            79 20 4d 69 
            63 68 61 65 
            6c 20 48 2e 
            20 52 69 6c 
            65 79 0a 0d 
            0a 0d 00               db '(c) Copyright 2006 by Michael H. Riley',10,13,10,13,0
  526 bbe8: d4          picostrt: sep scall ; call bios to get end of memory
  527 bbe9: ff 57                  dw f_freemem
  528 bbeb: f8 01                  ldi high memory ; point to high memory storage
  529 bbed: bd                     phi rd
  530 bbee: f8 00                  ldi low memory
  531 bbf0: ad                     plo rd
  532 bbf1: 9f                     ghi rf ; store heap address
  533 bbf2: 5d                     str rd
  534 bbf3: 1d                     inc rd
  535 bbf4: 8f                     glo rf
  536 bbf5: 5d                     str rd
  537 bbf6: f8 ba                  ldi high group_7 ; setup group 7 subroutines
  538 bbf8: b7                     phi r7
  539 bbf9: f8 07                  ldi low group_7
  540 bbfb: a7                     plo r7
  541 bbfc: d7                     sep r7 ; mark no program loaded
  542 bbfd: cd                     db set_word.0
  543 bbfe: 05 b7                  dw pgmtext
  544 bc00: 00 00                  dw 0
  545 bc02: d7                     sep r7 ; set initial value in lfsr
  546 bc03: cd                     db set_word.0
  547 bc04: 01 5d                  dw lfsr
  548 bc06: 00 00                  dw 0
  549 bc08: d7                     sep r7 ; set initial value in lfsr
  550 bc09: cd                     db set_word.0
  551 bc0a: 01 5f                  dw (lfsr+2)
  552 bc0c: 00 01                  dw 1
  553 bc0e: d4                     sep scall ; setup variable table
  554 bc0f: bf 34                  dw rst_vars
  555 bc11:             
  556 bc11: d4          mainlp: sep scall ; display prompt
  557 bc12: ff 66                  dw f_inmsg
  558 bc14: 3e 00                  db '>',0
  559 bc16: d7                     sep r7 ; setup input buffer
  560 bc17: 09                     db set_buf.0
  561 bc18: d4                     sep scall ; get input from user
  562 bc19: ff 0f                  dw f_input
  563 bc1b: d4                     sep scall ; setup CR/LF
  564 bc1c: bd 6f                  dw do_crlf
  565 bc1e: d7                     sep r7 ; setup input buffer
  566 bc1f: 09                     db set_buf.0
  567 bc20: d4                     sep scall ; convert to uppercase
  568 bc21: d2 e1                  dw touc
  569 bc23: d7                     sep r7 ; setup input buffer
  570 bc24: 09                     db set_buf.0
  571 bc25: d7                     sep r7 ; setup token buffer
  572 bc26: 11                     db set_tkn.0
  573 bc27: d4                     sep scall ; tokenize input
  574 bc28: bf 65                  dw tokenize
  575 bc2a: 9a                     ghi ra ; save ending of tokens
  576 bc2b: bb                     phi rb
  577 bc2c: 8a                     glo ra
  578 bc2d: ab                     plo rb
  579 bc2e: d7                     sep r7 ; setup token buffer
  580 bc2f: 11                     db set_tkn.0
  581 bc30: 0a                     ldn ra ; get first token
  582 bc31: ff fe                  smi TKN_NUM ; is it numeric
  583 bc33: c2 be 7d               lbz insert_ln ; need to insert new line
  584 bc36: f8 00                  ldi 0 ; no current line
  585 bc38: ac                     plo rc
  586 bc39: bc                     phi rc
  587 bc3a: d7                     sep r7 ; set token address into RA
  588 bc3b: 11                     db set_tkn.0
  589 bc3c: d4                     sep scall ; execute commands
  590 bc3d: d2 48                  dw execute
  591 bc3f: c3 bc 4b               lbdf error ; jump if error occurred
  592 bc42: d4                     sep scall ; display error message
  593 bc43: ff 66                  dw f_inmsg
  594 bc45: 0a 0d 00               db 10,13,0
  595 bc48: c0 bc 11               lbr mainlp ; back to main loop
  596 bc4b: ad          error: plo rd ; put error code into RD
  597 bc4c: f8 00                  ldi 0 ; high byte is zero
  598 bc4e: bd                     phi rd
  599 bc4f: d4                     sep scall ; display error message
  600 bc50: ff 66                  dw f_inmsg
  601 bc52: 0a 0d 45 52 
            52 4f 52 3a 
            00                     db 10,13,'ERROR:',0
  602 bc5b: d7                     sep r7 ; setup buffer
  603 bc5c: 09                     db set_buf.0
  604 bc5d: d4                     sep scall ; convert error code
  605 bc5e: ff 60                  dw f_uintout
  606 bc60: f8 00                  ldi 0 ; terminate error code
  607 bc62: 5f                     str rf
  608 bc63: d7                     sep r7 ; setup buffer
  609 bc64: 09                     db set_buf.0
  610 bc65: d4                     sep scall ; display error code
  611 bc66: ff 09                  dw f_msg
  612 bc68: 8c                     glo rc ; see if program was running
  613 bc69: ca bc 79               lbnz was_run
  614 bc6c: 9c                     ghi rc
  615 bc6d: ca bc 79               lbnz was_run
  616 bc70: d4          error_cnt: sep scall ; display error message
  617 bc71: ff 66                  dw f_inmsg
  618 bc73: 0a 0d 00               db 10,13,0
  619 bc76: c0 bc 11               lbr mainlp
  620 bc79: d4          was_run: sep scall ; add to error message
  621 bc7a: ff 66                  dw f_inmsg
  622 bc7c: 20 69 6e 20 
            6c 69 6e 65 
            20 00                  db ' in line ',0
  623 bc86: 1c                     inc rc ; move past line size
  624 bc87: 4c                     lda rc ; get line number
  625 bc88: bd                     phi rd
  626 bc89: 0c                     ldn rc
  627 bc8a: ad                     plo rd
  628 bc8b: d7                     sep r7 ; setup buffer
  629 bc8c: 09                     db set_buf.0
  630 bc8d: d4                     sep scall ; convert error code
  631 bc8e: ff 60                  dw f_uintout
  632 bc90: f8 00                  ldi 0 ; terminate error code
  633 bc92: 5f                     str rf
  634 bc93: d7                     sep r7 ; setup buffer
  635 bc94: 09                     db set_buf.0
  636 bc95: d4                     sep scall ; display error code
  637 bc96: ff 09                  dw f_msg
  638 bc98: c0 bc 70               lbr error_cnt ; then continue
  639 bc9b:             
  640 bc9b:             
  641 bc9b:             
  642 bc9b:             ; ******************************************************************************
  643 bc9b:             ; *** Start of utility functions ***
  644 bc9b:             ; ******************************************************************************
  645 bc9b:             
  646 bc9b:             ; **************************************************
  647 bc9b:             ; *** Find end of basic program area ***
  648 bc9b:             ; *** Returns: RF - pointing to terminating null ***
  649 bc9b:             ; **************************************************
  650 bc9b: d7          bas_end: sep r7 ; point to basic program area
  651 bc9c: d6                     db set_rf.0
  652 bc9d: 05 b7                  dw pgmtext
  653 bc9f: 0f          bas_endlp: ldn rf ; see if at end
  654 bca0: ca bc a4               lbnz bas_end2 ; jump if not
  655 bca3: d5                     sep sret ; return to caller
  656 bca4: ef          bas_end2: sex rf ; need to add in offset
  657 bca5: 8f                     glo rf
  658 bca6: f4                     add
  659 bca7: af                     plo rf
  660 bca8: 9f                     ghi rf ; propagate carry
  661 bca9: 7c 00                  adci 0
  662 bcab: bf                     phi rf
  663 bcac: e2                     sex r2 ; point X back to stack
  664 bcad: c0 bc 9f               lbr bas_endlp ; loop until end is found
  665 bcb0:             
  666 bcb0:             ; *********************************************
  667 bcb0:             ; *** copy tokenized line into basic memory ***
  668 bcb0:             ; *** RA - tokenized line pointer ***
  669 bcb0:             ; *** RC - basic memory pointer ***
  670 bcb0:             ; *** RF.0 - count of bytes ***
  671 bcb0:             ; *********************************************
  672 bcb0: 8f          copy_ln: glo rf ; get count
  673 bcb1: fc 01                  adi 1 ; 1 higher
  674 bcb3: 5c                     str rc ; store into buffer
  675 bcb4: 1c                     inc rc
  676 bcb5: 4a          copy_lp: lda ra ; get byte from tokenized line
  677 bcb6: 5c                     str rc ; store into basic buffer
  678 bcb7: 1c                     inc rc
  679 bcb8: 2f                     dec rf ; decrement count
  680 bcb9: 8f                     glo rf ; need to see if done
  681 bcba: ca bc b5               lbnz copy_lp ; jump if not
  682 bcbd: d5          return: sep sret
  683 bcbe:             
  684 bcbe:             ; *******************************************
  685 bcbe:             ; *** Delete line from BASIC program area ***
  686 bcbe:             ; *******************************************
  687 bcbe: 2a          delete_ln: dec ra ; move back to line number
  688 bcbf: 2a                     dec ra
  689 bcc0: 4a                     lda ra ; get line
  690 bcc1: bd                     phi rd ; and setup for search
  691 bcc2: 0a                     ldn ra
  692 bcc3: ad                     plo rd
  693 bcc4: 2a                     dec ra ; ra back msb of line number
  694 bcc5: d7                     sep r7 ; find line
  695 bcc6: 19                     db find_ln.0
  696 bcc7: c3 bc d0               lbdf do_delete ; jump if line was found
  697 bcca: d4                     sep scall ; setup variable table
  698 bccb: bf 34                  dw rst_vars
  699 bccd: c0 bc 11               lbr mainlp ; nothing to delete
  700 bcd0: 9c          do_delete: ghi rc ; current line is copy destination
  701 bcd1: bd                     phi rd
  702 bcd2: 8c                     glo rc
  703 bcd3: ad                     plo rd
  704 bcd4: d7                     sep r7 ; next line is source
  705 bcd5: 48                     db next_ln.0
  706 bcd6: d4                     sep scall ; get size of basic block
  707 bcd7: d2 9b                  dw size_end
  708 bcd9: d4                     sep scall ; perform the copy
  709 bcda: be e9                  dw memcpy
  710 bcdc: d4                     sep scall ; setup variable table
  711 bcdd: bf 34                  dw rst_vars
  712 bcdf: c0 bc 11               lbr mainlp ; and back to main loop
  713 bce2:             
  714 bce2:             ; ****************************
  715 bce2:             ; *** Detokenize a string ***
  716 bce2:             ; *** RA - pointer to line ***
  717 bce2:             ; *** RF - where to put ***
  718 bce2:             ; ****************************
  719 bce2: 1a          detoken: inc ra ; move past line size
  720 bce3: 4a                     lda ra ; get line number
  721 bce4: bd                     phi rd
  722 bce5: 4a                     lda ra
  723 bce6: ad                     plo rd
  724 bce7: d4                     sep scall ; convert it to ascii
  725 bce8: ff 60                  dw f_uintout
  726 bcea: d7                     sep r7 ; add a space
  727 bceb: 53                     db add_char.0
  728 bcec: 20                     db 32
  729 bced: 0a          detkn_lp: ldn ra ; get next byte from token stream
  730 bcee: c2 bd 6b               lbz detkn_dn ; jump if end of line
  731 bcf1: fa 80                  ani 80h ; see if it is a token
  732 bcf3: ca bc fc               lbnz detkn_tk ; it is
  733 bcf6: 4a                     lda ra ; if not get get it
  734 bcf7: 5f                     str rf ; and place into output
  735 bcf8: 1f                     inc rf
  736 bcf9: c0 bc ed               lbr detkn_lp ; loop back for next
  737 bcfc: 4a          detkn_tk: lda ra ; retrieve token
  738 bcfd: ae                     plo re ; keep a copy
  739 bcfe: ff fd                  smi TKN_QSTR ; check for quoted string
  740 bd00: c2 bd 55               lbz detkn_qs ; jump if so
  741 bd03: ff 01                  smi 1 ; check for number
  742 bd05: c2 bd 4b               lbz detkn_nm ; jump if so
  743 bd08: 8e                     glo re ; recover token
  744 bd09: fa 7f                  ani 07fh ; strip off token bit
  745 bd0b: ae                     plo re ; re will be the counter
  746 bd0c: f8 d3                  ldi high functable ; point to function table
  747 bd0e: bd                     phi rd
  748 bd0f: f8 0b                  ldi low functable
  749 bd11: ad                     plo rd
  750 bd12: 8e          tkn_lp_1: glo re ; see if pointing at correct token
  751 bd13: c2 bd 20               lbz tkn_yes ; jump if so
  752 bd16: 2e                     dec re ; decrement count
  753 bd17: 4d          tkn_lp_2: lda rd ; get byte from token table
  754 bd18: fa 80                  ani 080h ; see if last char
  755 bd1a: c2 bd 17               lbz tkn_lp_2 ; keep looking if not
  756 bd1d: c0 bd 12               lbr tkn_lp_1 ; see if at correct token
  757 bd20: 2f          tkn_yes: dec rf ; point to previous character
  758 bd21: 4f                     lda rf ; retrieve it
  759 bd22: d4                     sep scall ; see if alphanumeric
  760 bd23: ff 78                  dw f_isalnum
  761 bd25: cb bd 34               lbnf tkn_yes_l ; jump if not
  762 bd28: 0d                     ldn rd ; see what first char of token is
  763 bd29: fa 7f                  ani 07fh
  764 bd2b: d4                     sep scall ; need to know if it is alpha
  765 bd2c: ff 72                  dw f_isalpha
  766 bd2e: cb bd 34               lbnf tkn_yes_l ; jump if not
  767 bd31: d7                     sep r7 ; otherwise add space
  768 bd32: 53                     db add_char.0
  769 bd33: 20                     db ' '
  770 bd34: 0d          tkn_yes_l: ldn rd ; get byte from token
  771 bd35: fa 7f                  ani 07fh ; strip token bit
  772 bd37: 5f                     str rf ; place character into buffer
  773 bd38: 1f                     inc rf
  774 bd39: 4d                     lda rd ; get byte back
  775 bd3a: fe                     shl ; shift high bit into DF
  776 bd3b: cb bd 34               lbnf tkn_yes_l ; jump if not at end
  777 bd3e: f6                     shr
  778 bd3f: d4                     sep scall ; see if alphs
  779 bd40: ff 72                  dw f_isalpha
  780 bd42: cb bc ed               lbnf detkn_lp ; jump if not
  781 bd45: d7                     sep r7 ; otherwise add trailing space
  782 bd46: 53                     db add_char.0
  783 bd47: 20                     db ' '
  784 bd48: c0 bc ed               lbr detkn_lp ; and continue processing
  785 bd4b: 4a          detkn_nm: lda ra ; get msb of number
  786 bd4c: bd                     phi rd ; and prepare for output
  787 bd4d: 4a                     lda ra
  788 bd4e: ad                     plo rd
  789 bd4f: d4                     sep scall ; convert number
  790 bd50: ff 63                  dw f_intout
  791 bd52: c0 bc ed               lbr detkn_lp ; and look for more tokens
  792 bd55: d7          detkn_qs: sep r7 ; need to add a quote
  793 bd56: 53                     db add_char.0
  794 bd57: 22                     db '"'
  795 bd58: 4a          qs_lp: lda ra ; get next byte
  796 bd59: fb ff                  xri 0ffh ; see if at end
  797 bd5b: c2 bd 65               lbz qs_done ; jump if so
  798 bd5e: fb ff                  xri 0ffh ; restore character
  799 bd60: 5f                     str rf ; place into output buffer
  800 bd61: 1f                     inc rf
  801 bd62: c0 bd 58               lbr qs_lp ; and keep looking
  802 bd65: d7          qs_done: sep r7 ; need terminating quote
  803 bd66: 53                     db add_char.0
  804 bd67: 22                     db '"'
  805 bd68: c0 bc ed               lbr detkn_lp ; and loop back for more tokens
  806 bd6b: f8 00       detkn_dn: ldi 0 ; need a terminator
  807 bd6d: 5f                     str rf ; place into buffer
  808 bd6e: d5                     sep sret ; and return
  809 bd6f:             
  810 bd6f: f8 d3       do_crlf: ldi high crlf ; point to input buffer
  811 bd71: bf                     phi rf
  812 bd72: f8 e4                  ldi low crlf
  813 bd74: af                     plo rf
  814 bd75: d4                     sep scall ; display it
  815 bd76: ff 09                  dw f_msg
  816 bd78: d5                     sep sret ; and return
  817 bd79:             
  818 bd79:             ; ********************************
  819 bd79:             ; *** Get random bit from LFSR ***
  820 bd79:             ; ********************************
  821 bd79: f8 01       fn_lfsr: ldi high lfsr ; point to lfsr
  822 bd7b: bd                     phi rd
  823 bd7c: f8 5d                  ldi low lfsr
  824 bd7e: ad                     plo rd
  825 bd7f: 1d                     inc rd ; point to lsb
  826 bd80: 1d                     inc rd
  827 bd81: 1d                     inc rd
  828 bd82: 0d                     ldn rd ; retrieve it
  829 bd83: ae                     plo re ; put into re ( have bit 0)
  830 bd84: f6                     shr ; shift bit 1 into first position
  831 bd85: 52                     str r2 ; xor with previous value
  832 bd86: 8e                     glo re
  833 bd87: f3                     xor
  834 bd88: ae                     plo re ; keep copy
  835 bd89: 02                     ldn r2 ; get value
  836 bd8a: f6                     shr ; shift bit 2 into first position
  837 bd8b: 52                     str r2 ; and combine
  838 bd8c: 8e                     glo re
  839 bd8d: f3                     xor
  840 bd8e: ae                     plo re
  841 bd8f: 02                     ldn r2 ; now shift to bit 4
  842 bd90: f6                     shr
  843 bd91: f6                     shr
  844 bd92: 52                     str r2 ; and combine
  845 bd93: 8e                     glo re
  846 bd94: f3                     xor
  847 bd95: ae                     plo re
  848 bd96: 02                     ldn r2 ; now shift to bit 6
  849 bd97: f6                     shr
  850 bd98: f6                     shr
  851 bd99: 52                     str r2 ; and combine
  852 bd9a: 8e                     glo re
  853 bd9b: f3                     xor
  854 bd9c: ae                     plo re
  855 bd9d: 2d                     dec rd ; point to lfsr msb
  856 bd9e: 2d                     dec rd
  857 bd9f: 2d                     dec rd
  858 bda0: 0d                     ldn rd ; retrieve it
  859 bda1: fe                     shl ; shift high bit to low
  860 bda2: 7e                     shlc
  861 bda3: 52                     str r2 ; combine with previous value
  862 bda4: 8e                     glo re
  863 bda5: f3                     xor
  864 bda6: f6                     shr ; shift new bit into DF
  865 bda7: 0d                     ldn rd ; now shift the register
  866 bda8: 76                     shrc
  867 bda9: 5d                     str rd
  868 bdaa: 1d                     inc rd ; now byte 1
  869 bdab: 0d                     ldn rd ; now shift the register
  870 bdac: 76                     shrc
  871 bdad: 5d                     str rd
  872 bdae: 1d                     inc rd ; now byte 2
  873 bdaf: 0d                     ldn rd ; now shift the register
  874 bdb0: 76                     shrc
  875 bdb1: 5d                     str rd
  876 bdb2: 1d                     inc rd ; now byte 3
  877 bdb3: 0d                     ldn rd ; now shift the register
  878 bdb4: 76                     shrc
  879 bdb5: 5d                     str rd
  880 bdb6: f6                     shr ; shift result bit into DF
  881 bdb7: d5                     sep sret ; and return
  882 bdb8:             
  883 bdb8:             
  884 bdb8: 8f          get_sinput: glo rf ; save consumed registers
  885 bdb9: 73                     stxd
  886 bdba: 9f                     ghi rf
  887 bdbb: 73                     stxd
  888 bdbc: 8c                     glo rc ; save consumed registers
  889 bdbd: 73                     stxd
  890 bdbe: 9c                     ghi rc
  891 bdbf: 73                     stxd
  892 bdc0: d4                     sep scall ; display ?
  893 bdc1: ff 66                  dw f_inmsg
  894 bdc3: 3f 20 00               db '? ',0
  895 bdc6: d7                     sep r7 ; setup input buffer
  896 bdc7: 09                     db set_buf.0
  897 bdc8: d4                     sep scall ; get input from user
  898 bdc9: ff 0f                  dw f_input
  899 bdcb: f8 ff       sinput_go: ldi 0ffh ; need different kind of terminator
  900 bdcd: 5f                     str rf
  901 bdce: d4                     sep scall ; setup CR/LF
  902 bdcf: bd 6f                  dw do_crlf
  903 bdd1: d7                     sep r7 ; setup input buffer
  904 bdd2: 09                     db set_buf.0
  905 bdd3: d4                     sep scall ; copy string into heap
  906 bdd4: c6 32                  dw str2heap
  907 bdd6: d7                     sep r7 ; retrieve address
  908 bdd7: 58                     db ex_pop.0
  909 bdd8: d7                     sep r7 ; transfer to rd
  910 bdd9: 72                     db rf_rd.0
  911 bdda: 60                     irx ; recover consumed register
  912 bddb: 72                     ldxa
  913 bddc: bc                     phi rc
  914 bddd: 72                     ldxa
  915 bdde: ac                     plo rc
  916 bddf: 72                     ldxa
  917 bde0: bf                     phi rf
  918 bde1: f0                     ldx
  919 bde2: af                     plo rf
  920 bde3: c3 d2 98               lbdf err_ret ; jump if error occurred
  921 bde6:             
  922 bde6: fc 00                  adi 0 ; signal success
  923 bde8: d5                     sep sret ; and return
  924 bde9:             
  925 bde9:             
  926 bde9:             ; ********************************
  927 bde9:             ; *** Get input from user ***
  928 bde9:             ; *** returns: RD - next value ***
  929 bde9:             ; ********************************
  930 bde9: 8f          get_input: glo rf ; save consumed registers
  931 bdea: 73                     stxd
  932 bdeb: 9f                     ghi rf
  933 bdec: 73                     stxd
  934 bded: 8a                     glo ra
  935 bdee: 73                     stxd
  936 bdef: 9a                     ghi ra
  937 bdf0: 73                     stxd
  938 bdf1: f8 01                  ldi high inp_pos ; need to get position
  939 bdf3: bf                     phi rf
  940 bdf4: f8 61                  ldi low inp_pos
  941 bdf6: af                     plo rf
  942 bdf7: 4f                     lda rf ; get buffer position
  943 bdf8: ba                     phi ra
  944 bdf9: 0f                     ldn rf
  945 bdfa: aa                     plo ra
  946 bdfb: 0a          input_go: ldn ra ; is there stil input in the buffer
  947 bdfc: ca be 05               lbnz input_gd ; jump if not
  948 bdff: d4                     sep scall ; get input from user
  949 be00: be 30                  dw need_inp
  950 be02: c0 bd fb               lbr input_go
  951 be05: d4          input_gd: sep scall ; evaluate input
  952 be06: c1 e7                  dw new_expr
  953 be08: c3 d2 93               lbdf syn_err ; jump if error occurred
  954 be0b: 0a                     ldn ra ; get next token
  955 be0c: c2 be 15               lbz input_go2 ; terminator is acceptable
  956 be0f: ff 8d                  smi 08dh ; otherwise must be a comma
  957 be11: ca be 6f               lbnz inp_err ; else syntax error
  958 be14: 1a                     inc ra ; move past the comma
  959 be15: f8 01       input_go2: ldi high inp_pos ; need to get position
  960 be17: bf                     phi rf
  961 be18: f8 61                  ldi low inp_pos
  962 be1a: af                     plo rf
  963 be1b: 9a                     ghi ra ; save new pointer
  964 be1c: 5f                     str rf
  965 be1d: 1f                     inc rf
  966 be1e: 8a                     glo ra
  967 be1f: 5f                     str rf
  968 be20: d7                     sep r7 ; get expression value
  969 be21: 58                     db ex_pop.0
  970 be22: d7                     sep r7 ; move it to RD
  971 be23: 72                     db rf_rd.0
  972 be24: 60                     irx ; recover consumed registers
  973 be25: 72                     ldxa
  974 be26: ba                     phi ra
  975 be27: 72                     ldxa
  976 be28: aa                     plo ra
  977 be29: 72                     ldxa
  978 be2a: bf                     phi rf
  979 be2b: f0                     ldx
  980 be2c: af                     plo rf
  981 be2d: fc 00                  adi 0 ; signal no errors
  982 be2f: d5                     sep sret ; and return
  983 be30:             
  984 be30: 8c          need_inp: glo rc
  985 be31: 73                     stxd
  986 be32: 9c                     ghi rc
  987 be33: 73                     stxd
  988 be34: 87                     glo r7
  989 be35: 73                     stxd
  990 be36: 97                     ghi r7
  991 be37: 73                     stxd
  992 be38: d4                     sep scall ; display ?
  993 be39: ff 66                  dw f_inmsg
  994 be3b: 3f 20 00               db '? ',0
  995 be3e: d7                     sep r7 ; setup input buffer
  996 be3f: 09                     db set_buf.0
  997 be40: d4                     sep scall ; get input from user
  998 be41: ff 0f                  dw f_input
  999 be43:             ; lbnf need_go
 1000 be43:             ; ldi 0
 1001 be43:             ; lbr inp_err
 1002 be43: d4          need_go: sep scall ; need a cr/lf
 1003 be44: ff 66                  dw f_inmsg
 1004 be46: 0a 0d 00               db 10,13,0
 1005 be49: d7                     sep r7 ; point to input buffer
 1006 be4a: 09                     db set_buf.0
 1007 be4b: f8 01                  ldi high ibuffer ; buffer for tokenized input
 1008 be4d: ba                     phi ra
 1009 be4e: f8 63                  ldi low ibuffer
 1010 be50: aa                     plo ra
 1011 be51: d4                     sep scall ; tokenize input
 1012 be52: bf 65                  dw tokenize
 1013 be54: 60                     irx ; recover consumed registers
 1014 be55: 72                     ldxa
 1015 be56: b7                     phi r7
 1016 be57: 72                     ldxa
 1017 be58: a7                     plo r7
 1018 be59: 72                     ldxa
 1019 be5a: bc                     phi rc
 1020 be5b: f0                     ldx
 1021 be5c: ac                     plo rc
 1022 be5d: f8 01                  ldi high inp_pos ; need to setup input pointer
 1023 be5f: bf                     phi rf
 1024 be60: f8 61                  ldi low inp_pos
 1025 be62: af                     plo rf
 1026 be63: f8 01                  ldi high ibuffer ; set to beginning of buffer
 1027 be65: ba                     phi ra
 1028 be66: 5f                     str rf
 1029 be67: 1f                     inc rf
 1030 be68: f8 63                  ldi low ibuffer
 1031 be6a: aa                     plo ra
 1032 be6b: 5f                     str rf
 1033 be6c: fc 00                  adi 0 ; signal no error
 1034 be6e: d5                     sep sret ; return to calelr
 1035 be6f: ae          inp_err: plo re
 1036 be70: 60                     irx ; recover consumed registers
 1037 be71: 72                     ldxa
 1038 be72: ba                     phi ra
 1039 be73: 72                     ldxa
 1040 be74: aa                     plo ra
 1041 be75: 72                     ldxa
 1042 be76: bf                     phi rf
 1043 be77: f0                     ldx
 1044 be78: af                     plo rf
 1045 be79: 8e                     glo re
 1046 be7a: c0 d2 93               lbr syn_err
 1047 be7d:             
 1048 be7d:             ; *****************************************************
 1049 be7d:             ; *** Insert tokenized line into basic program area ***
 1050 be7d:             ; *** RA - pointer to tokens ***
 1051 be7d:             ; *** RB - pointer to end of tokens ***
 1052 be7d:             ; *****************************************************
 1053 be7d: d4          insert_ln: sep scall ; setup variable table
 1054 be7e: bf 34                  dw rst_vars
 1055 be80: 1a                     inc ra ; move to next token
 1056 be81: 1a                     inc ra
 1057 be82: 1a                     inc ra
 1058 be83: 0a                     ldn ra ; retrieve it
 1059 be84: c2 bc be               lbz delete_ln ; need to delete instead of insert
 1060 be87: 2a                     dec ra ; move back to line number
 1061 be88: 2a                     dec ra
 1062 be89: 4a                     lda ra ; get line
 1063 be8a: bd                     phi rd ; and setup for search
 1064 be8b: 0a                     ldn ra
 1065 be8c: ad                     plo rd
 1066 be8d: 2a                     dec ra ; ra back msb of line number
 1067 be8e: 8a                     glo ra ; need to get size of tokens
 1068 be8f: 52                     str r2
 1069 be90: 8b                     glo rb
 1070 be91: f7                     sm
 1071 be92: fc 01                  adi 1 ; account for terminator
 1072 be94: 73                     stxd ; keep it stored on stack
 1073 be95: d7                     sep r7 ; find line
 1074 be96: 19                     db find_ln.0
 1075 be97: cb be b0               lbnf notexact ; jump if not an exact match
 1076 be9a: d7                     sep r7 ; get address of next line
 1077 be9b: 48                     db next_ln.0 ; rf now has source
 1078 be9c: 60                     irx ; point to line size
 1079 be9d: 8c                     glo rc ; need to compute dest
 1080 be9e: f4                     add ; add token size
 1081 be9f: ad                     plo rd ; and place into rd
 1082 bea0: 9c                     ghi rc ; high of address
 1083 bea1: 7c 00                  adci 0 ; propagate carry
 1084 bea3: bd                     phi rd ; rd now has dest
 1085 bea4: 1d                     inc rd
 1086 bea5: 22                     dec r2 ; protect size
 1087 bea6: 8c                     glo rc ; need to save RC
 1088 bea7: 73                     stxd
 1089 bea8: 9c                     ghi rc
 1090 bea9: 73                     stxd
 1091 beaa: d4                     sep scall ; find size of block
 1092 beab: d2 9b                  dw size_end
 1093 bead: c0 be c7               lbr insert_1 ; process the copy
 1094 beb0: 0c          notexact: ldn rc ; get line size
 1095 beb1: c2 be da               lbz end_line ; jump if at end of program
 1096 beb4: 60                     irx ; point to token size
 1097 beb5: 8c                     glo rc ; get source address
 1098 beb6: f4                     add
 1099 beb7: ad                     plo rd
 1100 beb8: 9c                     ghi rc
 1101 beb9: 7c 00                  adci 0 ; propagate carry
 1102 bebb: bd                     phi rd ; RD is copy destination
 1103 bebc: 1d                     inc rd
 1104 bebd: 22                     dec r2 ; keep token count safe
 1105 bebe: 8c                     glo rc ; need to save RC
 1106 bebf: 73                     stxd
 1107 bec0: af                     plo rf ; which is also source
 1108 bec1: 9c                     ghi rc
 1109 bec2: 73                     stxd
 1110 bec3: bf                     phi rf ; RF now has source
 1111 bec4: d4                     sep scall ; compute block size
 1112 bec5: d2 9b                  dw size_end
 1113 bec7: d4          insert_1: sep scall ; move memory
 1114 bec8: be e9                  dw memcpy
 1115 beca: 60                     irx ; recover basic pointer
 1116 becb: 72                     ldxa
 1117 becc: bc                     phi rc
 1118 becd: 72                     ldxa
 1119 bece: ac                     plo rc
 1120 becf: f0                     ldx ; and token count
 1121 bed0: af                     plo rf
 1122 bed1: d4                     sep scall ; copy tokenized line into memory
 1123 bed2: bc b0                  dw copy_ln
 1124 bed4: d4                     sep scall ; setup variable table
 1125 bed5: bf 34                  dw rst_vars
 1126 bed7: c0 bc 11               lbr mainlp ; and then back to main loop
 1127 beda: 60          end_line: irx ; recover count
 1128 bedb: f0                     ldx
 1129 bedc: af                     plo rf ; and setup for copy
 1130 bedd: d4                     sep scall ; copy the line to basic mmeory
 1131 bede: bc b0                  dw copy_ln
 1132 bee0: f8 00                  ldi 0 ; zero next line start
 1133 bee2: 5c                     str rc
 1134 bee3: d4                     sep scall ; setup variable table
 1135 bee4: bf 34                  dw rst_vars
 1136 bee6: c0 bc 11               lbr mainlp
 1137 bee9:             
 1138 bee9:             ; ************************************************
 1139 bee9:             ; *** copy memory, detects overlaps and copies ***
 1140 bee9:             ; *** in corrrect direction ***
 1141 bee9:             ; *** RF - Source memory ***
 1142 bee9:             ; *** RD - Destination memory ***
 1143 bee9:             ; *** RC - count ***
 1144 bee9:             ; ************************************************
 1145 bee9: 8d          memcpy: glo rd ; perform RF-RD
 1146 beea: 52                     str r2
 1147 beeb: 8f                     glo rf
 1148 beec: f7                     sm
 1149 beed: 9d                     ghi rd
 1150 beee: 52                     str r2
 1151 beef: 9f                     ghi rf
 1152 bef0: 77                     smb
 1153 bef1: cb bf 01               lbnf cpy_rev ; if RF is lower, need to copy in reverse
 1154 bef4: 4f          cpy_1: lda rf ; get source byte
 1155 bef5: 5d                     str rd ; store into destination
 1156 bef6: 1d                     inc rd
 1157 bef7: 2c                     dec rc ; decrement count
 1158 bef8: 8c                     glo rc ; see if done
 1159 bef9: ca be f4               lbnz cpy_1 ; jump if not done
 1160 befc: 9c                     ghi rc ; check high byte as well
 1161 befd: ca be f4               lbnz cpy_1
 1162 bf00: d5                     sep sret ; return to caller
 1163 bf01: 2c          cpy_rev: dec rc ; need to add count-1 to both pointers
 1164 bf02: 8c                     glo rc ; start with low byte
 1165 bf03: 52                     str r2
 1166 bf04: 8f                     glo rf ; add to source
 1167 bf05: f4                     add
 1168 bf06: af                     plo rf
 1169 bf07: 7e                     shlc ; get carry
 1170 bf08: ae                     plo re ; and save it
 1171 bf09: 8d                     glo rd ; now add count to destination
 1172 bf0a: f4                     add
 1173 bf0b: ad                     plo rd
 1174 bf0c: 9c                     ghi rc ; now high byte
 1175 bf0d: 52                     str r2
 1176 bf0e: 9d                     ghi rd ; do RD first since we have its carry
 1177 bf0f: 74                     adc
 1178 bf10: bd                     phi rd ; rd is now correct
 1179 bf11: 8e                     glo re ; get carry from rf
 1180 bf12: f6                     shr ; and put back into carry
 1181 bf13: 9f                     ghi rf ; now finish add on source
 1182 bf14: 74                     adc
 1183 bf15: bf                     phi rf
 1184 bf16: 1c                     inc rc ; put count back
 1185 bf17: 0f          cpy_2: ldn rf ; get byte from source
 1186 bf18: 5d                     str rd ; store into destination
 1187 bf19: 2f                     dec rf ; decrement pointers
 1188 bf1a: 2d                     dec rd
 1189 bf1b: 2c                     dec rc ; decrement count
 1190 bf1c: 8c                     glo rc ; see if done
 1191 bf1d: ca bf 17               lbnz cpy_2 ; jump if not
 1192 bf20: 9c                     ghi rc ; check high byte as well
 1193 bf21: ca bf 17               lbnz cpy_2
 1194 bf24: d5                     sep sret ; done with copy
 1195 bf25:             
 1196 bf25:             ; *****************************************************
 1197 bf25:             ; *** Shift top 2 expression stack entries upwards ***
 1198 bf25:             ; *** 0000-7FFF -> 8000-FFFF ***
 1199 bf25:             ; *** 8000-FFFF -> 0000-7FFF ***
 1200 bf25:             ; *****************************************************
 1201 bf25: 19          roll_up: inc r9 ; point to msb of first number
 1202 bf26: 09                     ldn r9 ; retrieive
 1203 bf27: fb 80                  xri 080h ; shift upwards
 1204 bf29: 59                     str r9 ; and put back
 1205 bf2a: 19                     inc r9 ; move to msb of next arg
 1206 bf2b: 19                     inc r9
 1207 bf2c: 09                     ldn r9 ; retrieive
 1208 bf2d: fb 80                  xri 080h ; shift upwards
 1209 bf2f: 59                     str r9 ; and put back
 1210 bf30: 29                     dec r9 ; move r9 back to where it belongs
 1211 bf31: 29                     dec r9
 1212 bf32: 29                     dec r9
 1213 bf33: d5                     sep sret ; return to caller
 1214 bf34:             
 1215 bf34:             ; ***********************
 1216 bf34:             ; *** Reset Variables ***
 1217 bf34:             ; ***********************
 1218 bf34:             
 1219 bf34:             
 1220 bf34:             
 1221 bf34: d4          rst_vars: sep scall ; find end of basic
 1222 bf35: bc 9b                  dw bas_end
 1223 bf37: 1f                     inc rf ; 1 past
 1224 bf38: f8 00                  ldi 0 ; make variable table empty
 1225 bf3a: 5f                     str rf
 1226 bf3b: f8 01                  ldi high var_pos ; pointer for variable table
 1227 bf3d: bd                     phi rd
 1228 bf3e: f8 06                  ldi low var_pos
 1229 bf40: ad                     plo rd
 1230 bf41: 9f                     ghi rf ; store address of variable table
 1231 bf42: 5d                     str rd
 1232 bf43: 1d                     inc rd
 1233 bf44: 8f                     glo rf
 1234 bf45: 5d                     str rd
 1235 bf46: f8 01                  ldi high memory ; need end of memory pointer
 1236 bf48: bd                     phi rd
 1237 bf49: f8 00                  ldi low memory
 1238 bf4b: ad                     plo rd
 1239 bf4c: 4d                     lda rd
 1240 bf4d: bf                     phi rf
 1241 bf4e: 0d                     ldn rd
 1242 bf4f: af                     plo rf
 1243 bf50: f8 ff                  ldi 0ffh ; zero terminator in heap memory
 1244 bf52: 5f                     str rf
 1245 bf53: f8 01                  ldi high heap ; point to heap storage
 1246 bf55: bd                     phi rd
 1247 bf56: f8 08                  ldi low heap
 1248 bf58: ad                     plo rd
 1249 bf59: 9f                     ghi rf ; store heap address
 1250 bf5a: 5d                     str rd
 1251 bf5b: 1d                     inc rd
 1252 bf5c: 8f                     glo rf
 1253 bf5d: 5d                     str rd
 1254 bf5e: 2f           dec rf
 1255 bf5f: f8 00        ldi 0
 1256 bf61: 5f           str rf
 1257 bf62: 2f           dec rf
 1258 bf63: 5f           str rf
 1259 bf64: d5                     sep sret ; return to caller
 1260 bf65:             
 1261 bf65:             
 1262 bf65:             
 1263 bf65:             ; *************************************
 1264 bf65:             ; *** Tokenize a string ***
 1265 bf65:             ; *** RA - Buffer for tokens ***
 1266 bf65:             ; *** RF - Ascii string to tokenize ***
 1267 bf65:             ; *** Returns: RC - token count ***
 1268 bf65:             ; *** DF=1 - error ***
 1269 bf65:             ; *************************************
 1270 bf65: f8 00       tokenize: ldi 0 ; set initial token count to zero
 1271 bf67: bc                     phi rc
 1272 bf68: ac                     plo rc
 1273 bf69: 87                     glo r7 ; save consumed register
 1274 bf6a: 73                     stxd
 1275 bf6b: 97                     ghi r7
 1276 bf6c: 73                     stxd
 1277 bf6d: d4          tokenlp: sep scall ; move past any whitespace
 1278 bf6e: ff 15                  dw f_ltrim
 1279 bf70: 0f                     ldn rf ; get pointed at character
 1280 bf71: c2 bf ee               lbz tokendn ; jump if terminator
 1281 bf74: ff 22                  smi 34 ; check for string
 1282 bf76: c2 bf a6               lbz charstr ; jump if so
 1283 bf79: d4                     sep scall ; see if numeric
 1284 bf7a: ff 7b                  dw f_idnum
 1285 bf7c: cb bf c0               lbnf tokennum ; jump if numeric
 1286 bf7f: f8 d3                  ldi high functable ; point to function table
 1287 bf81: b7                     phi r7
 1288 bf82: f8 0b                  ldi low functable
 1289 bf84: a7                     plo r7
 1290 bf85: d4                     sep scall ; check for token
 1291 bf86: ff 6f                  dw f_findtkn
 1292 bf88: c3 bf d9               lbdf tokenfunc ; jump if function
 1293 bf8b:             
 1294 bf8b: 0f                     ldn rf ; get next character
 1295 bf8c: d4                     sep scall ; see if alnum
 1296 bf8d: ff 78                  dw f_isalnum
 1297 bf8f: c3 bf 98               lbdf ustrlpa ; jump if it is
 1298 bf92: 4f                     lda rf ; otherwise it is a single character
 1299 bf93: 5a                     str ra
 1300 bf94: 1a                     inc ra
 1301 bf95: c0 bf 6d               lbr tokenlp ; and keep looking for tokens
 1302 bf98:             
 1303 bf98: 4f          ustrlpa: lda rf ; get first byte
 1304 bf99: 5a          ustrlp: str ra ; store into token stream
 1305 bf9a: 1a                     inc ra
 1306 bf9b: 4f                     lda rf ; get next byte
 1307 bf9c: d4                     sep scall ; see if alphanumeric
 1308 bf9d: ff 78                  dw f_isalnum
 1309 bf9f: c3 bf 99               lbdf ustrlp ; loop back if so, store, and keep going
 1310 bfa2: 2f                     dec rf ; move back to non-string char
 1311 bfa3: c0 bf 6d               lbr tokenlp ; loop back for more tokens
 1312 bfa6: 1f          charstr: inc rf ; move past opening quote
 1313 bfa7: f8 fd                  ldi TKN_QSTR ; token for quoted string
 1314 bfa9: 5a          charstrlp: str ra ; store it
 1315 bfaa: 1a                     inc ra
 1316 bfab: 4f                     lda rf ; get next byte of string
 1317 bfac: ae                     plo re ; save a copy
 1318 bfad: c2 bf b9               lbz tokenterm ; jump if end
 1319 bfb0: ff 22                  smi 34 ; check for ending quote
 1320 bfb2: c2 bf b9               lbz tokenterm ; also done
 1321 bfb5: 8e                     glo re ; recover byte
 1322 bfb6: c0 bf a9               lbr charstrlp ; and loop back til done
 1323 bfb9: f8 ff       tokenterm: ldi 0ffh ; quoted string termination
 1324 bfbb: 5a                     str ra
 1325 bfbc: 1a                     inc ra
 1326 bfbd: c0 bf 6d               lbr tokenlp
 1327 bfc0: c2 bf c9    tokennum: lbz numisdec ; jump if decimal number
 1328 bfc3: d4                     sep scall ; convert hex number
 1329 bfc4: ff 45                  dw f_hexin
 1330 bfc6: c0 bf cc               lbr numcont ; continue processing number
 1331 bfc9: d4          numisdec: sep scall ; convert number
 1332 bfca: ff 5d                  dw f_atoi
 1333 bfcc: f8 fe       numcont: ldi TKN_NUM ; get token for number
 1334 bfce: 5a                     str ra ; place into token stream
 1335 bfcf: 1a                     inc ra
 1336 bfd0: 9d                     ghi rd ; now write number
 1337 bfd1: 5a                     str ra
 1338 bfd2: 1a                     inc ra
 1339 bfd3: 8d                     glo rd ; and low byte
 1340 bfd4: 5a                     str ra
 1341 bfd5: 1a                     inc ra
 1342 bfd6: c0 bf 6d               lbr tokenlp ; loop back for more tokens
 1343 bfd9: 8d          tokenfunc: glo rd ; get token number
 1344 bfda: f9 80                  ori 080h ; set high bit
 1345 bfdc: 5a                     str ra ; store into token stream
 1346 bfdd: 1a                     inc ra ; point to next free space
 1347 bfde: ff 1a                  smi CMD_START ; remove command bias
 1348 bfe0: ff 89                  smi 89h ; check for REM
 1349 bfe2: ca bf 6d               lbnz tokenlp ; jump if not
 1350 bfe5: 4f          rem_lp: lda rf ; read from input
 1351 bfe6: c2 bf ee               lbz tokendn ; jump if end of line found
 1352 bfe9: 5a                     str ra ; store into token stream
 1353 bfea: 1a                     inc ra
 1354 bfeb: c0 bf e5               lbr rem_lp ; loop back until full line is copied
 1355 bfee: f8 00       tokendn: ldi 0 ; need to terminate token sequence
 1356 bff0: 5a                     str ra
 1357 bff1: fc 00                  adi 0 ; signal no error
 1358 bff3: 60                     irx ; recover R7
 1359 bff4: 72                     ldxa
 1360 bff5: b7                     phi r7
 1361 bff6: f0                     ldx
 1362 bff7: a7                     plo r7
 1363 bff8: d5                     sep sret ; and return to caller
 1364 bff9:             
 1365 bff9:             ; ******************************************************************************
 1366 bff9:             ; *** end of utility functions ***
 1367 bff9:             ; ******************************************************************************
 1368 bff9:             
 1369 bff9:             
 1370 bff9:             ; ******************************************************************************
 1371 bff9:             ; *** Start of L2 utility functions ***
 1372 bff9:             ; ******************************************************************************
 1373 bff9:             ; ***********************************************
 1374 bff9:             ; *** Find end of heap ***
 1375 bff9:             ; *** Returns: RF - last address used by heap ***
 1376 bff9:             ; ***********************************************
 1377 bff9: f8 01       end_heap: ldi high heap ; point to heap pointer
 1378 bffb: bf                     phi rf
 1379 bffc: f8 08                  ldi low heap
 1380 bffe: af                     plo rf
 1381 bfff: 4f                     lda rf ; retrieve it
 1382 c000: ae                     plo re
 1383 c001: 0f                     ldn rf
 1384 c002: af                     plo rf
 1385 c003: 8e                     glo re
 1386 c004: bf                     phi rf
 1387 c005: d5                     sep sret ; and return
 1388 c006:             
 1389 c006:             ; **********************************
 1390 c006:             ; *** Find end of variable table ***
 1391 c006:             ; *** Returns: RF - end of table ***
 1392 c006:             ; **********************************
 1393 c006: f8 01       end_vars: ldi high var_pos ; point to variable table
 1394 c008: bf                     phi rf
 1395 c009: f8 06                  ldi low var_pos
 1396 c00b: af                     plo rf
 1397 c00c: 4f                     lda rf ; retrieve it
 1398 c00d: ae                     plo re
 1399 c00e: 0f                     ldn rf
 1400 c00f: af                     plo rf
 1401 c010: 8e                     glo re
 1402 c011: bf                     phi rf
 1403 c012: 0f          endvarslp: ldn rf ; get size
 1404 c013: c2 c0 22               lbz endvarsdn ; jump if found ind
 1405 c016: ef                     sex rf ; set x to size address
 1406 c017: 8f                     glo rf ; and add into rf
 1407 c018: f4                     add
 1408 c019: af                     plo rf
 1409 c01a: e2                     sex r2 ; ponit x back to stack
 1410 c01b: 9f                     ghi rf ; propagate carry
 1411 c01c: 7c 00                  adci 0
 1412 c01e: bf                     phi rf
 1413 c01f: c0 c0 12               lbr endvarslp ; loop until end is found
 1414 c022: d5          endvarsdn: sep sret ; return to caller
 1415 c023:             
 1416 c023:             ; ************************************************
 1417 c023:             ; *** Get next data item from a DATA statement ***
 1418 c023:             ; ************************************************
 1419 c023: 8a          get_data: glo ra ; need to save RA
 1420 c024: 73                     stxd
 1421 c025: 9a                     ghi ra
 1422 c026: 73                     stxd
 1423 c027: f8 01                  ldi high data_pos ; need current data position
 1424 c029: bd                     phi rd
 1425 c02a: f8 04                  ldi low data_pos
 1426 c02c: ad                     plo rd
 1427 c02d: 4d                     lda rd ; get pointer
 1428 c02e: ba                     phi ra
 1429 c02f: 0d                     ldn rd
 1430 c030: aa                     plo ra
 1431 c031: 0a                     ldn ra ; see if valid data
 1432 c032: c2 c0 59               lbz data_err ; jump if not
 1433 c035: d4                     sep scall ; otherwise evaluate it
 1434 c036: c1 e7                  dw new_expr
 1435 c038: c3 c0 5c               lbdf bad_data ; jump if error in data
 1436 c03b: 0a                     ldn ra ; see if at terminator
 1437 c03c: c2 c0 68               lbz data_ne ; jump if end of data
 1438 c03f: ff 8d                  smi 8dh ; otherwise must be a comma
 1439 c041: ca c0 5c               lbnz bad_data ; jump if not
 1440 c044: 1a                     inc ra ; move to next item
 1441 c045: f8 01                  ldi high data_pos ; need current data position
 1442 c047: bd                     phi rd
 1443 c048: f8 04                  ldi low data_pos
 1444 c04a: ad                     plo rd
 1445 c04b: 9a                     ghi ra ; save new data pointer
 1446 c04c: 5d                     str rd
 1447 c04d: 1d                     inc rd
 1448 c04e: 8a                     glo ra
 1449 c04f: 5d                     str rd
 1450 c050: d7          data_cnt: sep r7 ; retrieve data value
 1451 c051: 58                     db ex_pop.0
 1452 c052: d7                     sep r7 ; transfer it to RD
 1453 c053: 72                     db rf_rd.0
 1454 c054: fc 00                  adi 0 ; signal no error
 1455 c056: c0 c0 60               lbr data_dn ; and clean up
 1456 c059: f8 09       data_err: ldi ERR_NODATA ; no more data, so error
 1457 c05b: c8                     lskp
 1458 c05c: f8 02       bad_data: ldi ERR_SYN ; signal syntax error
 1459 c05e: ff 00                  smi 0 ; signal an error
 1460 c060: ae          data_dn: plo re ; save possible error code
 1461 c061: 60                     irx ; recover ra
 1462 c062: 72                     ldxa
 1463 c063: ba                     phi ra
 1464 c064: f0                     ldx
 1465 c065: aa                     plo ra
 1466 c066: 8e                     glo re
 1467 c067: d5                     sep sret ; and return
 1468 c068: d4          data_ne: sep scall ; find next data line
 1469 c069: c0 70                  dw find_data
 1470 c06b: fc 00                  adi 0 ; signal no error
 1471 c06d: c0 c0 50               lbr data_cnt ; finish up
 1472 c070:             
 1473 c070:             ; *******************************************
 1474 c070:             ; *** Find next DATA statement in program ***
 1475 c070:             ; *******************************************
 1476 c070: 8c          find_data: glo rc ; save current line pointer
 1477 c071: 73                     stxd
 1478 c072: 9c                     ghi rc
 1479 c073: 73                     stxd
 1480 c074: f8 01                  ldi high data_lin ; need to get current data line
 1481 c076: bf                     phi rf
 1482 c077: f8 02                  ldi low data_lin
 1483 c079: af                     plo rf
 1484 c07a: 4f                     lda rf ; get it
 1485 c07b: bc                     phi rc
 1486 c07c: 0f                     ldn rf
 1487 c07d: ac                     plo rc
 1488 c07e: d7          fnd_datlp: sep r7 ; get next line
 1489 c07f: 48                     db next_ln.0
 1490 c080: 0f                     ldn rf ; are we at end of program
 1491 c081: c2 c0 ac               lbz fnd_daten ; jump if so
 1492 c084: 1f                     inc rf ; need to get first token
 1493 c085: 1f                     inc rf
 1494 c086: 1f                     inc rf
 1495 c087: 0f                     ldn rf ; get the token
 1496 c088: ff 1a                  smi CMD_START ; shift into command range
 1497 c08a: ff 96                  smi 96h ; check for DATA
 1498 c08c: c2 c0 99               lbz fnd_datys ; jump if it is
 1499 c08f: 2f                     dec rf ; back to line start
 1500 c090: 2f                     dec rf
 1501 c091: 2f                     dec rf
 1502 c092: 9f                     ghi rf ; transfer line number
 1503 c093: bc                     phi rc
 1504 c094: 8f                     glo rf
 1505 c095: ac                     plo rc
 1506 c096: c0 c0 7e               lbr fnd_datlp ; keep looking
 1507 c099: 1f          fnd_datys: inc rf ; move past data token
 1508 c09a: f8 01                  ldi high data_pos ; need to set data position
 1509 c09c: bc                     phi rc
 1510 c09d: f8 04                  ldi low data_pos
 1511 c09f: ac                     plo rc
 1512 c0a0: 9f                     ghi rf ; write new pointer
 1513 c0a1: 5c                     str rc
 1514 c0a2: 1c                     inc rc
 1515 c0a3: 8f                     glo rf
 1516 c0a4: 5c                     str rc
 1517 c0a5: 2f                     dec rf ; move back to beginning
 1518 c0a6: 2f                     dec rf
 1519 c0a7: 2f                     dec rf
 1520 c0a8: 2f                     dec rf
 1521 c0a9: c0 c0 b7               lbr fnd_datdn ; and finish
 1522 c0ac: f8 01       fnd_daten: ldi high data_pos ; need to set data position
 1523 c0ae: bc                     phi rc
 1524 c0af: f8 04                  ldi low data_pos
 1525 c0b1: ac                     plo rc
 1526 c0b2: 9f                     ghi rf ; write new pointer
 1527 c0b3: 5c                     str rc
 1528 c0b4: 1c                     inc rc
 1529 c0b5: 8f                     glo rf
 1530 c0b6: 5c                     str rc
 1531 c0b7: f8 01       fnd_datdn: ldi high data_lin ; need to write new opinter
 1532 c0b9: bc                     phi rc
 1533 c0ba: f8 02                  ldi low data_lin
 1534 c0bc: ac                     plo rc
 1535 c0bd: 9f                     ghi rf ; write new pointer
 1536 c0be: 5c                     str rc
 1537 c0bf: 1c                     inc rc
 1538 c0c0: 8f                     glo rf
 1539 c0c1: 5c                     str rc
 1540 c0c2: 60                     irx ; recover consumed registers
 1541 c0c3: 72                     ldxa
 1542 c0c4: bc                     phi rc
 1543 c0c5: f0                     ldx
 1544 c0c6: ac                     plo rc
 1545 c0c7: d5                     sep sret ; and return
 1546 c0c8:             
 1547 c0c8:             ; ******************************************************************************
 1548 c0c8:             ; *** End of L2 utility functions ***
 1549 c0c8:             ; ******************************************************************************
 1550 c0c8:             
 1551 c0c8:             
 1552 c0c8:             
 1553 c0c8:             ; ******************************************************************************
 1554 c0c8:             ; *** Integer expression functions ***
 1555 c0c8:             ; ******************************************************************************
 1556 c0c8:             ; ******************************
 1557 c0c8:             ; *** Add top 2 stack values ***
 1558 c0c8:             ; ******************************
 1559 c0c8: d7          ex_add: sep r7 ; get top of expression stack
 1560 c0c9: 58                     db ex_pop.0
 1561 c0ca: d7                     sep r7 ; copy rf to rd
 1562 c0cb: 72                     db rf_rd.0
 1563 c0cc: d7                     sep r7 ; get next stack value
 1564 c0cd: 58                     db ex_pop.0
 1565 c0ce: 8f                     glo rf ; add them together
 1566 c0cf: 52                     str r2
 1567 c0d0: 8d                     glo rd
 1568 c0d1: f4                     add
 1569 c0d2: af                     plo rf
 1570 c0d3: 9f                     ghi rf
 1571 c0d4: 52                     str r2
 1572 c0d5: 9d                     ghi rd
 1573 c0d6: 74                     adc
 1574 c0d7: bf                     phi rf
 1575 c0d8: d7                     sep r7 ; place back onto stack
 1576 c0d9: 6a                     db ex_push.0
 1577 c0da: d5                     sep sret ; and return
 1578 c0db:             
 1579 c0db:             ; ******************************
 1580 c0db:             ; *** And top 2 stack values ***
 1581 c0db:             ; ******************************
 1582 c0db: d7          ex_and: sep r7 ; get top of expression stack
 1583 c0dc: 58                     db ex_pop.0
 1584 c0dd: d7                     sep r7 ; copy rf to rd
 1585 c0de: 72                     db rf_rd.0
 1586 c0df: d7                     sep r7 ; get next stack value
 1587 c0e0: 58                     db ex_pop.0
 1588 c0e1: 8f                     glo rf ; and them together
 1589 c0e2: 52                     str r2
 1590 c0e3: 8d                     glo rd
 1591 c0e4: f2                     and
 1592 c0e5: af                     plo rf
 1593 c0e6: 9f                     ghi rf
 1594 c0e7: 52                     str r2
 1595 c0e8: 9d                     ghi rd
 1596 c0e9: f2                     and
 1597 c0ea: bf                     phi rf
 1598 c0eb: d7                     sep r7 ; place back onto stack
 1599 c0ec: 6a                     db ex_push.0
 1600 c0ed: d5                     sep sret ; and return
 1601 c0ee:             
 1602 c0ee:             ; *********************************
 1603 c0ee:             ; *** Divide top 2 stack values ***
 1604 c0ee:             ; *********************************
 1605 c0ee: d7          ex_div: sep r7 ; get top of expression stack
 1606 c0ef: 58                     db ex_pop.0
 1607 c0f0: d7                     sep r7 ; copy to rD
 1608 c0f1: 72                     db rf_rd.0
 1609 c0f2: d7                     sep r7 ; get next value
 1610 c0f3: 58                     db ex_pop.0
 1611 c0f4: 89                     glo r9 ; save consumed register
 1612 c0f5: 73                     stxd
 1613 c0f6: 99                     ghi r9
 1614 c0f7: 73                     stxd
 1615 c0f8: 88                     glo r8 ; save consumed register
 1616 c0f9: 73                     stxd
 1617 c0fa: 98                     ghi r8
 1618 c0fb: 73                     stxd
 1619 c0fc: d4                     sep scall ; call bios to divide
 1620 c0fd: ff 33                  dw f_div16
 1621 c0ff: 8b                     glo rb ; transfer answer
 1622 c100: af                     plo rf
 1623 c101: 9b                     ghi rb
 1624 c102: bf                     phi rf
 1625 c103: 60                     irx ; recover consumed register
 1626 c104: 72                     ldxa
 1627 c105: b8                     phi r8
 1628 c106: 72                     ldxa
 1629 c107: a8                     plo r8
 1630 c108: 72                     ldxa
 1631 c109: b9                     phi r9
 1632 c10a: f0                     ldx
 1633 c10b: a9                     plo r9
 1634 c10c: d7                     sep r7 ; write back to stack
 1635 c10d: 6a                     db ex_push.0
 1636 c10e: d5                     sep sret ; and return
 1637 c10f:             
 1638 c10f:             ; *************************************
 1639 c10f:             ; *** see if top 2 values are equal ***
 1640 c10f:             ; *************************************
 1641 c10f: d4          ex_eq: sep scall ; subtract top 2 values
 1642 c110: c1 d4                  dw ex_sub
 1643 c112: d7                     sep r7 ; get result
 1644 c113: 58                     db ex_pop.0
 1645 c114: 8f                     glo rf ; check for equality
 1646 c115: ca c1 1c               lbnz false ; jump if not equal
 1647 c118: 9f                     ghi rf ; check high byte
 1648 c119: c2 c1 1f               lbz true ; jump if true
 1649 c11c: f8 00       false: ldi 0 ; need zero on stack
 1650 c11e: c8                     lskp
 1651 c11f: f8 ff       true: ldi 0ffh ; place -1 on stack
 1652 c121: bf                     phi rf
 1653 c122: af                     plo rf
 1654 c123: d7                     sep r7
 1655 c124: 6a                     db ex_push.0
 1656 c125: d5                     sep sret ; and return to caller
 1657 c126:             
 1658 c126:             ; **************************
 1659 c126:             ; *** see if tos-1 > tos ***
 1660 c126:             ; **************************
 1661 c126: d4          ex_gt: sep scall ; bias numbers upwards
 1662 c127: bf 25                  dw roll_up
 1663 c129: d4                     sep scall ; subtract top 2 values
 1664 c12a: c1 d4                  dw ex_sub
 1665 c12c: d7                     sep r7 ; get result
 1666 c12d: 58                     db ex_pop.0
 1667 c12e: 8f                     glo rf ; check for equal
 1668 c12f: ca c1 36               lbnz ex_gt_go ; jump if not
 1669 c132: 9f                     ghi rf ; check high byte
 1670 c133: c2 c1 1c               lbz false ; they are equal, so fasle
 1671 c136: c3 c1 1f    ex_gt_go: lbdf true ; true if subtraction was positive
 1672 c139: c0 c1 1c               lbr false ; otherwise false
 1673 c13c:             
 1674 c13c:             ; ***************************
 1675 c13c:             ; *** see if tos-1 >= tos ***
 1676 c13c:             ; ***************************
 1677 c13c: d4          ex_gte: sep scall ; bias numbers upwards
 1678 c13d: bf 25                  dw roll_up
 1679 c13f: d4                     sep scall ; subtract top 2 values
 1680 c140: c1 d4                  dw ex_sub
 1681 c142: d7                     sep r7 ; get result
 1682 c143: 58                     db ex_pop.0
 1683 c144: c3 c1 1f               lbdf true ; true if subtraction was positive
 1684 c147: c0 c1 1c               lbr false ; otherwise false
 1685 c14a:             
 1686 c14a:             ; **************************
 1687 c14a:             ; *** see if tos-1 < tos ***
 1688 c14a:             ; **************************
 1689 c14a: d4          ex_lt: sep scall ; bias numbers upwards
 1690 c14b: bf 25                  dw roll_up
 1691 c14d: d4                     sep scall ; subtract top 2 values
 1692 c14e: c1 d4                  dw ex_sub
 1693 c150: d7                     sep r7 ; get result
 1694 c151: 58                     db ex_pop.0
 1695 c152: cb c1 1f               lbnf true ; true if subtraction was negative
 1696 c155: c0 c1 1c               lbr false ; otherwise false
 1697 c158:             
 1698 c158:             ; ***************************
 1699 c158:             ; *** see if tos-1 <= tos ***
 1700 c158:             ; ***************************
 1701 c158: d4          ex_lte: sep scall ; bias numbers upwards
 1702 c159: bf 25                  dw roll_up
 1703 c15b: d4                     sep scall ; subtract top 2 values
 1704 c15c: c1 d4                  dw ex_sub
 1705 c15e: d7                     sep r7 ; get result
 1706 c15f: 58                     db ex_pop.0
 1707 c160: 8f                     glo rf ; check for equal
 1708 c161: ca c1 68               lbnz ex_lte_go ; jump if not
 1709 c164: 9f                     ghi rf ; check high byte
 1710 c165: c2 c1 1f               lbz true ; they are equal, so true
 1711 c168: cb c1 1f    ex_lte_go: lbnf true ; true if subtraction was negative
 1712 c16b: c0 c1 1c               lbr false ; otherwise false
 1713 c16e:             
 1714 c16e:             ; *********************************
 1715 c16e:             ; *** Modulo top 2 stack values ***
 1716 c16e:             ; *********************************
 1717 c16e: d7          ex_mod: sep r7 ; get top of expression stack
 1718 c16f: 58                     db ex_pop.0
 1719 c170: d7                     sep r7 ; copy to rD
 1720 c171: 72                     db rf_rd.0
 1721 c172: d7                     sep r7 ; get next value
 1722 c173: 58                     db ex_pop.0
 1723 c174: 89                     glo r9 ; save consumed register
 1724 c175: 73                     stxd
 1725 c176: 99                     ghi r9
 1726 c177: 73                     stxd
 1727 c178: 88                     glo r8 ; save consumed register
 1728 c179: 73                     stxd
 1729 c17a: 98                     ghi r8
 1730 c17b: 73                     stxd
 1731 c17c: d4                     sep scall ; call bios to divide
 1732 c17d: ff 33                  dw f_div16
 1733 c17f: 60                     irx ; recover consumed register
 1734 c180: 72                     ldxa
 1735 c181: b8                     phi r8
 1736 c182: 72                     ldxa
 1737 c183: a8                     plo r8
 1738 c184: 72                     ldxa
 1739 c185: b9                     phi r9
 1740 c186: f0                     ldx
 1741 c187: a9                     plo r9
 1742 c188: d7                     sep r7 ; write back to stack
 1743 c189: 6a                     db ex_push.0
 1744 c18a: d5                     sep sret ; and return
 1745 c18b:             
 1746 c18b:             ; ***********************************
 1747 c18b:             ; *** Multiply top 2 stack values ***
 1748 c18b:             ; ***********************************
 1749 c18b: d7          ex_mul: sep r7 ; get top of expression stack
 1750 c18c: 58                     db ex_pop.0
 1751 c18d: d7                     sep r7 ; copy rf to rd
 1752 c18e: 72                     db rf_rd.0
 1753 c18f: d7                     sep r7 ; get next stack value
 1754 c190: 58                     db ex_pop.0
 1755 c191: 8c                     glo rc ; preserver consumed register
 1756 c192: 73                     stxd
 1757 c193: 9c                     ghi rc
 1758 c194: 73                     stxd
 1759 c195: d4                     sep scall ; call bios to multiply numbers
 1760 c196: ff 30                  dw f_mul16
 1761 c198: 9b                     ghi rb ; move answer to rf
 1762 c199: bf                     phi rf
 1763 c19a: 8b                     glo rb
 1764 c19b: af                     plo rf
 1765 c19c: 60                     irx ; and recover RC
 1766 c19d: 72                     ldxa
 1767 c19e: bc                     phi rc
 1768 c19f: f0                     ldx
 1769 c1a0: ac                     plo rc
 1770 c1a1: d7                     sep r7 ; place back onto stack
 1771 c1a2: 6a                     db ex_push.0
 1772 c1a3: d5                     sep sret ; and return
 1773 c1a4:             
 1774 c1a4:             ; **************************************
 1775 c1a4:             ; *** Negate top of expression stack ***
 1776 c1a4:             ; **************************************
 1777 c1a4: d7          ex_neg: sep r7 ; get top of expression stack
 1778 c1a5: 58                     db ex_pop.0
 1779 c1a6: 8f                     glo rf ; subtract it from 0
 1780 c1a7: fd 00                  sdi 0
 1781 c1a9: af                     plo rf
 1782 c1aa: 9f                     ghi rf ; carry through upper byte
 1783 c1ab: 7d 00                  sdbi 0
 1784 c1ad: bf                     phi rf
 1785 c1ae: d7                     sep r7 ; put back onto stack
 1786 c1af: 6a                     db ex_push.0
 1787 c1b0: d5                     sep sret ; and return
 1788 c1b1:             
 1789 c1b1:             ; ***************************************
 1790 c1b1:             ; *** see if top 2 values are unequal ***
 1791 c1b1:             ; ***************************************
 1792 c1b1: d4          ex_neq: sep scall ; subtract top 2 values
 1793 c1b2: c1 d4                  dw ex_sub
 1794 c1b4: d7                     sep r7 ; get result
 1795 c1b5: 58                     db ex_pop.0
 1796 c1b6: 8f                     glo rf ; check for equality
 1797 c1b7: ca c1 1f               lbnz true ; jump if not equal
 1798 c1ba: 9f                     ghi rf ; check high byte
 1799 c1bb: c2 c1 1c               lbz false ; jump if true
 1800 c1be: c0 c1 1f               lbr true
 1801 c1c1:             
 1802 c1c1:             ; *****************************
 1803 c1c1:             ; *** Or top 2 stack values ***
 1804 c1c1:             ; *****************************
 1805 c1c1: d7          ex_or: sep r7 ; get top of expression stack
 1806 c1c2: 58                     db ex_pop.0
 1807 c1c3: d7                     sep r7 ; copy rf to rd
 1808 c1c4: 72                     db rf_rd.0
 1809 c1c5: d7                     sep r7 ; get next stack value
 1810 c1c6: 58                     db ex_pop.0
 1811 c1c7: 8f                     glo rf ; and them together
 1812 c1c8: 52                     str r2
 1813 c1c9: 8d                     glo rd
 1814 c1ca: f1                     or
 1815 c1cb: af                     plo rf
 1816 c1cc: 9f                     ghi rf
 1817 c1cd: 52                     str r2
 1818 c1ce: 9d                     ghi rd
 1819 c1cf: f1                     or
 1820 c1d0: bf                     phi rf
 1821 c1d1: d7                     sep r7 ; place back onto stack
 1822 c1d2: 6a                     db ex_push.0
 1823 c1d3: d5                     sep sret ; and return
 1824 c1d4:             
 1825 c1d4:             ; ***********************************
 1826 c1d4:             ; *** Subtract top 2 stack values ***
 1827 c1d4:             ; ***********************************
 1828 c1d4: d7          ex_sub: sep r7 ; get top of expression stack
 1829 c1d5: 58                     db ex_pop.0
 1830 c1d6: d7                     sep r7 ; copy rf to rd
 1831 c1d7: 72                     db rf_rd.0
 1832 c1d8: d7                     sep r7 ; get next stack value
 1833 c1d9: 58                     db ex_pop.0
 1834 c1da: 8f                     glo rf ; subtract them
 1835 c1db: 52                     str r2
 1836 c1dc: 8d                     glo rd
 1837 c1dd: f5                     sd
 1838 c1de: af                     plo rf
 1839 c1df: 9f                     ghi rf
 1840 c1e0: 52                     str r2
 1841 c1e1: 9d                     ghi rd
 1842 c1e2: 75                     sdb
 1843 c1e3: bf                     phi rf
 1844 c1e4: d7                     sep r7 ; place back onto stack
 1845 c1e5: 6a                     db ex_push.0
 1846 c1e6: d5                     sep sret ; and return
 1847 c1e7:             
 1848 c1e7:             ; ******************************************************************************
 1849 c1e7:             ; *** End of Integer expression functions ***
 1850 c1e7:             ; ******************************************************************************
 1851 c1e7:             
 1852 c1e7:             
 1853 c1e7:             
 1854 c1e7:             ; ******************************************************************************
 1855 c1e7:             ; *** Start of expression evaluator ***
 1856 c1e7:             ; ******************************************************************************
 1857 c1e7:             ; ****************************
 1858 c1e7:             ; *** Expression Evaluator ***
 1859 c1e7:             ; *** RA points to tokens ***
 1860 c1e7:             ; ****************************
 1861 c1e7: f8 05       new_expr: ldi high expstack ; setup expression stack
 1862 c1e9: b9                     phi r9
 1863 c1ea: f8 b6                  ldi low expstack
 1864 c1ec: a9                     plo r9
 1865 c1ed: 0a          expr: ldn ra ; get first token
 1866 c1ee: ff 81                  smi 081h ; see if negative sign
 1867 c1f0: ca c2 00               lbnz expr_pos ; jump if not
 1868 c1f3: 1a                     inc ra ; move past minus sign
 1869 c1f4: d4                     sep scall ; call level 2
 1870 c1f5: c2 7f                  dw level_1
 1871 c1f7: c3 d2 98               lbdf err_ret ; jump on syntax error
 1872 c1fa: d4                     sep scall ; then call negate
 1873 c1fb: c1 a4                  dw ex_neg
 1874 c1fd: c0 c2 0d               lbr expr_1 ; continue
 1875 c200: 0a          expr_pos: ldn ra ; check for plus sign
 1876 c201: ff 80                  smi 080h
 1877 c203: ca c2 07               lbnz expr_0 ; jump if not
 1878 c206: 1a                     inc ra ; ignore it
 1879 c207: d4          expr_0: sep scall ; call level 2 to get value
 1880 c208: c2 7f                  dw level_1
 1881 c20a: c3 d2 98               lbdf err_ret ; jump on syntax error
 1882 c20d: 0a          expr_1: ldn ra ; get token
 1883 c20e: ff 86                  smi 086h ; check for =
 1884 c210: ca c2 20               lbnz expr_1a ; jump if not
 1885 c213: 1a                     inc ra ; move past =
 1886 c214: d4                     sep scall ; call level 1 to get value
 1887 c215: c2 7f                  dw level_1
 1888 c217: c3 d2 98               lbdf err_ret ; jump on syntax error
 1889 c21a: d4                     sep scall ; now check for equality
 1890 c21b: c1 0f                  dw ex_eq
 1891 c21d: c0 c2 0d               lbr expr_1 ; look for more
 1892 c220: ff 01       expr_1a: smi 1 ; check for <=
 1893 c222: ca c2 32               lbnz expr_1b ; jump if not
 1894 c225: 1a                     inc ra ; move past symbol
 1895 c226: d4                     sep scall ; call level 1 to get value
 1896 c227: c2 7f                  dw level_1
 1897 c229: c3 d2 98               lbdf err_ret ; jump on syntax error
 1898 c22c: d4                     sep scall ; now check
 1899 c22d: c1 58                  dw ex_lte
 1900 c22f: c0 c2 0d               lbr expr_1 ; look for more
 1901 c232: ff 01       expr_1b: smi 1 ; check for >=
 1902 c234: ca c2 44               lbnz expr_1c ; jump if not
 1903 c237: 1a                     inc ra ; move past symbol
 1904 c238: d4                     sep scall ; call level 1 to get value
 1905 c239: c2 7f                  dw level_1
 1906 c23b: c3 d2 98               lbdf err_ret ; jump on syntax error
 1907 c23e: d4                     sep scall ; now check
 1908 c23f: c1 3c                  dw ex_gte
 1909 c241: c0 c2 0d               lbr expr_1 ; look for more
 1910 c244: ff 01       expr_1c: smi 1 ; check for <>
 1911 c246: ca c2 56               lbnz expr_1d ; jump if not
 1912 c249: 1a                     inc ra ; move past symbol
 1913 c24a: d4                     sep scall ; call level 1 to get value
 1914 c24b: c2 7f                  dw level_1
 1915 c24d: c3 d2 98               lbdf err_ret ; jump on syntax error
 1916 c250: d4                     sep scall ; now check
 1917 c251: c1 b1                  dw ex_neq
 1918 c253: c0 c2 0d               lbr expr_1 ; look for more
 1919 c256: ff 01       expr_1d: smi 1 ; check for <
 1920 c258: ca c2 68               lbnz expr_1e ; jump if not
 1921 c25b: 1a                     inc ra ; move past symbol
 1922 c25c: d4                     sep scall ; call level 1 to get value
 1923 c25d: c2 7f                  dw level_1
 1924 c25f: c3 d2 98               lbdf err_ret ; jump on syntax error
 1925 c262: d4                     sep scall ; now check
 1926 c263: c1 4a                  dw ex_lt
 1927 c265: c0 c2 0d               lbr expr_1 ; look for more
 1928 c268: ff 01       expr_1e: smi 1 ; check for >
 1929 c26a: ca c2 7a               lbnz expr_1f ; jump if not
 1930 c26d: 1a                     inc ra ; move past symbol
 1931 c26e: d4                     sep scall ; call level 1 to get value
 1932 c26f: c2 7f                  dw level_1
 1933 c271: c3 d2 98               lbdf err_ret ; jump on syntax error
 1934 c274: d4                     sep scall ; now check
 1935 c275: c1 26                  dw ex_gt
 1936 c277: c0 c2 0d               lbr expr_1 ; look for more
 1937 c27a: fc 00       expr_1f: adi 0 ; signal no errors
 1938 c27c: f8 02                  ldi 2 ; signal integer result
 1939 c27e: d5                     sep sret ; and return to caller
 1940 c27f:             
 1941 c27f:             ; ***********************************
 1942 c27f:             ; *** Level 1, find AND, OR, &, | ***
 1943 c27f:             ; ***********************************
 1944 c27f: d4          level_1: sep scall ; call level 2 to get value
 1945 c280: c2 b7                  dw level_2
 1946 c282: c3 d2 98               lbdf err_ret ; jump on syntax error
 1947 c285: 0a          level_1c: ldn ra ; get next byte
 1948 c286: ff 8e                  smi 08eh ; see if AND
 1949 c288: ca c2 98               lbnz level_1a ; jump if not
 1950 c28b: 1a          level_and: inc ra ; move past plus
 1951 c28c: d4                     sep scall ; call level 2 to get value
 1952 c28d: c2 b7                  dw level_2
 1953 c28f: c3 d2 98               lbdf err_ret ; jump on syntax error
 1954 c292: d4                     sep scall ; and top 2 stack values
 1955 c293: c0 db                  dw ex_and
 1956 c295: c0 c2 85               lbr level_1c ; keep looking
 1957 c298: ff 01       level_1a: smi 1 ; check for &
 1958 c29a: c2 c2 8b               lbz level_and ; compute and
 1959 c29d: ff 01                  smi 1 ; check for OR
 1960 c29f: ca c2 af               lbnz level_1b ; jump if not
 1961 c2a2: 1a          level_or: inc ra ; move past minus sign
 1962 c2a3: d4                     sep scall ; call level 2 to get value
 1963 c2a4: c2 b7                  dw level_2
 1964 c2a6: c3 d2 98               lbdf err_ret ; jump on syntax error
 1965 c2a9: d4                     sep scall ; or top 2 stack values
 1966 c2aa: c1 c1                  dw ex_or
 1967 c2ac: c0 c2 85               lbr level_1c ; keep looking
 1968 c2af: ff 01       level_1b: smi 1 ; check for |
 1969 c2b1: c2 c2 a2               lbz level_or ; jump if so
 1970 c2b4: fc 00       level_1n: adi 0 ; signal no error in level
 1971 c2b6: d5                     sep sret ; return from level 2
 1972 c2b7:             
 1973 c2b7:             ; **************************
 1974 c2b7:             ; *** Level 2, find +, - ***
 1975 c2b7:             ; **************************
 1976 c2b7: d4          level_2: sep scall ; call level 3 to get value
 1977 c2b8: c2 e5                  dw level_3
 1978 c2ba: c3 d2 98               lbdf err_ret ; jump on syntax error
 1979 c2bd: 0a          level_2c: ldn ra ; get next byte
 1980 c2be: ff 80                  smi 080h ; see if plus
 1981 c2c0: ca c2 d0               lbnz level_2a ; jump if not
 1982 c2c3: 1a                     inc ra ; move past plus
 1983 c2c4: d4                     sep scall ; call level 3 to get value
 1984 c2c5: c2 e5                  dw level_3
 1985 c2c7: c3 d2 98               lbdf err_ret ; jump on syntax error
 1986 c2ca: d4                     sep scall ; add top 2 stack values
 1987 c2cb: c0 c8                  dw ex_add
 1988 c2cd: c0 c2 bd               lbr level_2c ; keep looking
 1989 c2d0: ff 01       level_2a: smi 1 ; check for minus
 1990 c2d2: ca c2 e2               lbnz level_2n ; jump if not
 1991 c2d5: 1a                     inc ra ; move past minus sign
 1992 c2d6: d4                     sep scall ; call level 3 to get value
 1993 c2d7: c2 e5                  dw level_3
 1994 c2d9: c3 d2 98               lbdf err_ret ; jump on syntax error
 1995 c2dc: d4                     sep scall ; subtract top 2 stack values
 1996 c2dd: c1 d4                  dw ex_sub
 1997 c2df: c0 c2 bd               lbr level_2c ; keep looking
 1998 c2e2: fc 00       level_2n: adi 0 ; signal no error in level
 1999 c2e4: d5                     sep sret ; return from level 2
 2000 c2e5:             
 2001 c2e5:             ; **************************
 2002 c2e5:             ; *** Level 2, find *, / ***
 2003 c2e5:             ; **************************
 2004 c2e5: d4          level_3: sep scall ; call level 4 to get value
 2005 c2e6: c3 13                  dw level_4
 2006 c2e8: c3 d2 98               lbdf err_ret ; jump on syntax error
 2007 c2eb: 0a          level_3c: ldn ra ; get next token
 2008 c2ec: ff 82                  smi 082h ; check for *
 2009 c2ee: ca c2 fe               lbnz level_3a ; jump if not
 2010 c2f1: 1a                     inc ra ; move past multiply symbol
 2011 c2f2: d4                     sep scall ; call level 4 to get value
 2012 c2f3: c3 13                  dw level_4
 2013 c2f5: c3 d2 98               lbdf err_ret ; jump on syntax error
 2014 c2f8: d4                     sep scall ; multiply values
 2015 c2f9: c1 8b                  dw ex_mul
 2016 c2fb: c0 c2 eb               lbr level_3c ; then continue
 2017 c2fe: ff 01       level_3a: smi 1 ; check for division
 2018 c300: ca c3 10               lbnz level_3n ; jump if not
 2019 c303: 1a                     inc ra ; move past /
 2020 c304: d4                     sep scall ; call level 4 to get value
 2021 c305: c3 13                  dw level_4
 2022 c307: c3 d2 98               lbdf err_ret ; jump on syntax error
 2023 c30a: d4                     sep scall ; perform division
 2024 c30b: c0 ee                  dw ex_div
 2025 c30d: c0 c2 eb               lbr level_3c ; then keep processing
 2026 c310: fc 00       level_3n: adi 0 ; signal no error
 2027 c312: d5                     sep sret ; and return
 2028 c313:             
 2029 c313:             ; ***********************************************
 2030 c313:             ; *** Check for numbers, variables, functions ***
 2031 c313:             ; ***********************************************
 2032 c313: 0a          level_4: ldn ra ; get token
 2033 c314: ff fe                  smi TKN_NUM ; check for number
 2034 c316: ca c3 23               lbnz level_4a ; jump if not
 2035 c319: 1a                     inc ra ; move past token
 2036 c31a: 4a                     lda ra ; retrieve actual number
 2037 c31b: bf                     phi rf
 2038 c31c: 4a                     lda ra
 2039 c31d: af                     plo rf
 2040 c31e: d7          push_it: sep r7 ; place onto stack
 2041 c31f: 6a                     db ex_push.0
 2042 c320: fc 00                  adi 0 ; signal no error
 2043 c322: d5                     sep sret ; and return
 2044 c323: 0a          level_4a: ldn ra ; get token
 2045 c324: ff 84                  smi 84h ; check for open parens
 2046 c326: ca c3 39               lbnz level_4b ; jump if not
 2047 c329: 1a                     inc ra ; move past parens
 2048 c32a: d4                     sep scall ; evaluate inside parens
 2049 c32b: c1 ed                  dw expr
 2050 c32d: c3 d2 98               lbdf err_ret
 2051 c330: 4a          closed: lda ra ; check for closing parens
 2052 c331: ff 85                  smi 085h
 2053 c333: ca d2 93               lbnz syn_err ; no closing parens is a syntax error
 2054 c336: fc 00                  adi 0 ; otherwise good value computed
 2055 c338: d5                     sep sret ; return
 2056 c339: 0a          level_4b: ldn ra ; get token
 2057 c33a: d4                     sep scall ; see if variable name
 2058 c33b: ff 78                  dw f_isalnum
 2059 c33d: cb c3 4f               lbnf level_4c ; jump if not
 2060 c340: d4                     sep scall ; get variable address
 2061 c341: c7 92                  dw get_var
 2062 c343: c3 d2 98               lbdf err_ret
 2063 c346: 4f                     lda rf ; retrieve value from variable
 2064 c347: ae                     plo re
 2065 c348: 4f                     lda rf
 2066 c349: af                     plo rf
 2067 c34a: 8e                     glo re
 2068 c34b: bf                     phi rf
 2069 c34c: c0 c3 1e               lbr push_it ; put onto stack and return
 2070 c34f: 4a          level_4c: lda ra ; last try, functions
 2071 c350: fe                     shl ; is high bit set
 2072 c351: cb d2 93               lbnf syn_err ; syntax error if not
 2073 c354: f6                     shr
 2074 c355: ff 14                  smi 020 ; check for PEEK
 2075 c357: c2 c4 09               lbz fn_peek ; jump if so
 2076 c35a: ff 01                  smi 1 ; check for FRE
 2077 c35c: c2 c3 cc               lbz fn_fre ; jump if so
 2078 c35f: ff 01                  smi 1 ; check for RND
 2079 c361: c2 c4 1b               lbz fn_rnd ; jump if so
 2080 c364: ff 01                  smi 1 ; check for INP
 2081 c366: c2 c3 e3               lbz fn_inp ; jump if so
 2082 c369: ff 01                  smi 1 ; check for FLG
 2083 c36b: c2 c3 c1               lbz fn_flg ; jump if so
 2084 c36e: ff 01                  smi 1 ; check for USR
 2085 c370: c2 c3 8a               lbz fn_usr ; jump if so
 2086 c373:             
 2087 c373: ff 1c                  smi 28 ; check for VARPTR
 2088 c375: c2 c4 39               lbz fn_varptr ; jump if so
 2089 c378: ff 02                  smi 2 ; check for LEN
 2090 c37a: c2 c4 a3               lbz fn_len ; jump if so
 2091 c37d: ff 01                  smi 1 ; check for ASC
 2092 c37f: c2 c4 4b               lbz fn_asc ; jump if so
 2093 c382: ff 01                  smi 1 ; check for VAL
 2094 c384: c2 c5 9d               lbz fn_val ; jump if so
 2095 c387:             
 2096 c387: ff 00                  smi 0 ; signal an error
 2097 c389: d5                     sep sret ; and return
 2098 c38a:             
 2099 c38a:             ; ******************************************************************************
 2100 c38a:             ; *** End of expression evaluator ***
 2101 c38a:             ; ******************************************************************************
 2102 c38a:             
 2103 c38a:             
 2104 c38a:             ; ******************************************************************************
 2105 c38a:             ; *** Start of L1 functions ***
 2106 c38a:             ; ******************************************************************************
 2107 c38a:             ; *****************************************************
 2108 c38a:             ; *** Process USR ***
 2109 c38a:             ; *** User routine is called with R3 active ***
 2110 c38a:             ; *** RF will hold passed value from 2nd arg of USR ***
 2111 c38a:             ; *** routine must return with a SEP RD ***
 2112 c38a:             ; *** it is up to the USR to preserve any registers ***
 2113 c38a:             ; *** that it uses ***
 2114 c38a:             ; *****************************************************
 2115 c38a: d4          fn_usr: sep scall ; get argument
 2116 c38b: c1 ed                  dw expr
 2117 c38d: c3 d2 98               lbdf err_ret
 2118 c390: 4a                     lda ra ; get next token
 2119 c391: ff 85                  smi 085h ; check for single argument version
 2120 c393: c2 c3 a6               lbz fn_usr_1 ; jump if single argument version
 2121 c396: ff 08                  smi 8 ; check for comma
 2122 c398: ca d2 93               lbnz syn_err ; else syntax error
 2123 c39b: d4                     sep scall ; get first 2nd argument
 2124 c39c: c1 ed                  dw expr
 2125 c39e: 4a                     lda ra ; get next token
 2126 c39f: ff 85                  smi 085h ; need to be closing parens
 2127 c3a1: ca d2 93               lbnz syn_err ; jump if not
 2128 c3a4: d7                     sep r7 ; retrieve argument to pass
 2129 c3a5: 58                     db ex_pop.0
 2130 c3a6: f8 c3       fn_usr_1: ldi high fn_usr_go ; setup jump
 2131 c3a8: bd                     phi rd
 2132 c3a9: f8 ad                  ldi low fn_usr_go
 2133 c3ab: ad                     plo rd
 2134 c3ac: dd                     sep rd ; transfer to usr call routine
 2135 c3ad: e9          fn_usr_go: sex r9 ; retrieve call address
 2136 c3ae: 60                     irx ; from expression stack
 2137 c3af: 72                     ldxa
 2138 c3b0: b3                     phi r3
 2139 c3b1: f0                     ldx
 2140 c3b2: a3                     plo r3
 2141 c3b3: e2                     sex r2 ; x back to stack
 2142 c3b4: d3                     sep r3 ; transfer to usr routine
 2143 c3b5: f8 c3                  ldi high fn_usr_dn ; need to get back on R3
 2144 c3b7: b3                     phi r3
 2145 c3b8: f8 bc                  ldi low fn_usr_dn
 2146 c3ba: a3                     plo r3
 2147 c3bb: d3                     sep r3
 2148 c3bc: d7          fn_usr_dn: sep r7 ; place return value onto stack
 2149 c3bd: 6a                     db ex_push.0
 2150 c3be: fc 00                  adi 0 ; signal no error
 2151 c3c0: d5                     sep sret ; and return
 2152 c3c1:             
 2153 c3c1:             ; *******************
 2154 c3c1:             ; *** Process FLG ***
 2155 c3c1:             ; *******************
 2156 c3c1: d7          fn_flg: sep r7 ; get flags
 2157 c3c2: 78                     db get_flags.0
 2158 c3c3: af                     plo rf ; place into rf
 2159 c3c4: f8 00                  ldi 0 ; high byte is zero
 2160 c3c6: bf                     phi rf
 2161 c3c7: d7                     sep r7 ; place onto stack
 2162 c3c8: 6a                     db ex_push.0
 2163 c3c9: c0 c3 30               lbr closed ; be sure function is closed
 2164 c3cc:             
 2165 c3cc:             ; *******************
 2166 c3cc:             ; *** Process FRE ***
 2167 c3cc:             ; *******************
            # 2120 "rcbasic.asm"
 2169 c3cc: d4          fn_fre: sep scall ; get end of basic
 2170 c3cd: c0 06                  dw end_vars
 2171 c3cf: d7                     sep r7 ; move to rd
 2172 c3d0: 72                     db rf_rd.0
 2173 c3d1: d4                     sep scall ; get end of heap
 2174 c3d2: bf f9                  dw end_heap
 2175 c3d4:             
 2176 c3d4: 8d                     glo rd ; subtract end of variables
 2177 c3d5: 52                     str r2
 2178 c3d6: 8f                     glo rf
 2179 c3d7: f7                     sm
 2180 c3d8: af                     plo rf
 2181 c3d9: 9d                     ghi rd
 2182 c3da: 52                     str r2
 2183 c3db: 9f                     ghi rf
 2184 c3dc: 77                     smb
 2185 c3dd: bf                     phi rf
 2186 c3de: d7                     sep r7 ; put value onto stack
 2187 c3df: 6a                     db ex_push.0
 2188 c3e0: c0 c3 30               lbr closed ; check to be sure function is closed
 2189 c3e3:             
 2190 c3e3:             ; *******************
 2191 c3e3:             ; *** Process INP ***
 2192 c3e3:             ; *******************
 2193 c3e3: d4          fn_inp: sep scall ; get argument
 2194 c3e4: c1 ed                  dw expr
 2195 c3e6: c3 d2 98               lbdf err_ret
 2196 c3e9: d7                     sep r7 ; retrieve port
 2197 c3ea: 58                     db ex_pop.0
 2198 c3eb: f8 01                  ldi high buffer ; need somewhere for command
 2199 c3ed: bd                     phi rd
 2200 c3ee: f8 b3                  ldi low buffer
 2201 c3f0: ad                     plo rd
 2202 c3f1: 8f                     glo rf
 2203 c3f2: fa 07                  ani 7 ; mask for range
 2204 c3f4: c2 d2 96               lbz val_err ; jump if error
 2205 c3f7: fc 68                  adi 68h ; convert to INP instructino
 2206 c3f9: 5d                     str rd ; store into memory
 2207 c3fa: 1d                     inc rd
 2208 c3fb: f8 d3                  ldi 0d3h ; function to reset P=3
 2209 c3fd: 5d                     str rd
 2210 c3fe: 2d                     dec rd ; point rd back to inp instruction
 2211 c3ff: dd                     sep rd ; and execute it
 2212 c400: af                     plo rf ; put read value into rf
 2213 c401: f8 00                  ldi 0 ; zero high byte
 2214 c403: bf                     phi rf
 2215 c404: d7                     sep r7 ; put read value on expr stack
 2216 c405: 6a                     db ex_push.0
 2217 c406: c0 c3 30               lbr closed ; and be sure function is closed
 2218 c409:             
 2219 c409:             ; ********************
 2220 c409:             ; *** Process PEEK ***
 2221 c409:             ; ********************
 2222 c409: d4          fn_peek: sep scall ; get argument
 2223 c40a: c1 ed                  dw expr
 2224 c40c: c3 d2 98               lbdf err_ret ; jump if error occured
 2225 c40f: d7                     sep r7 ; get address
 2226 c410: 58                     db ex_pop.0
 2227 c411: 0f                     ldn rf ; read value from memory
 2228 c412: af                     plo rf ; put back into rf
 2229 c413: f8 00                  ldi 0 ; zero high byte
 2230 c415: bf                     phi rf
 2231 c416: d7                     sep r7 ; put value onto stack
 2232 c417: 6a                     db ex_push.0
 2233 c418: c0 c3 30               lbr closed ; check to be sure function is closed
 2234 c41b:             
 2235 c41b:             ; *******************
 2236 c41b:             ; *** Process RND ***
 2237 c41b:             ; *******************
 2238 c41b: f8 10       fn_rnd: ldi 16 ; need to get 16 bits
 2239 c41d: 73          rnd_lp: stxd ; save count
 2240 c41e: d4                     sep scall ; get random bit
 2241 c41f: bd 79                  dw fn_lfsr
 2242 c421: 8f                     glo rf ; shift into result
 2243 c422: 7e                     shlc
 2244 c423: af                     plo rf
 2245 c424: 9f                     ghi rf
 2246 c425: 7e                     shlc
 2247 c426: bf                     phi rf
 2248 c427: 60                     irx ; recover count
 2249 c428: f0                     ldx
 2250 c429: ff 01                  smi 1 ; minus 1
 2251 c42b: ca c4 1d               lbnz rnd_lp ; keep looping until all bits read
 2252 c42e: d7                     sep r7 ; put result onto stack
 2253 c42f: 6a                     db ex_push.0
 2254 c430: d4                     sep scall ; evaluate argument
 2255 c431: c1 ed                  dw expr
 2256 c433: d4                     sep scall ; get modulo
 2257 c434: c1 6e                  dw ex_mod
 2258 c436: c0 c3 30               lbr closed ; then be sure function is closed
 2259 c439:             
 2260 c439:             ; ******************************************************************************
 2261 c439:             ; *** End of L1 functions ***
 2262 c439:             ; ******************************************************************************
 2263 c439:             
 2264 c439:             
 2265 c439:             
 2266 c439:             
 2267 c439:             ; ******************************************************************************
 2268 c439:             ; *** Start of L2 functions ***
 2269 c439:             ; ******************************************************************************
 2270 c439:             ; **********************
 2271 c439:             ; *** Process VARPTR ***
 2272 c439:             ; **********************
 2273 c439: 0a          fn_varptr: ldn ra ; get next token
 2274 c43a: d4                     sep scall ; must be alpha, indicating a variable
 2275 c43b: ff 72                  dw f_isalpha
 2276 c43d: cb d2 93               lbnf syn_err ; otherwise syntax error
 2277 c440: d4                     sep scall ; get variables location
 2278 c441: c7 92                  dw get_var
 2279 c443: c3 d2 98               lbdf err_ret ; jump if error occurred
 2280 c446: d7                     sep r7 ; place onto expression stack
 2281 c447: 6a                     db ex_push.0
 2282 c448: c0 c3 30               lbr closed ; check to be sure function is closed
 2283 c44b:             
 2284 c44b:             ; ******************************************************************************
 2285 c44b:             ; *** Start of String functions ***
 2286 c44b:             ; ******************************************************************************
 2287 c44b:             
 2288 c44b:             ; *******************
 2289 c44b:             ; *** Process ASC ***
 2290 c44b:             ; *******************
 2291 c44b: d4          fn_asc: sep scall ; get argument
 2292 c44c: c6 6c                  dw sexpr
 2293 c44e: c3 d2 98               lbdf err_ret ; jump if error occurred
 2294 c451: d7                     sep r7 ; retrieve string address
 2295 c452: 58                     db ex_pop.0
 2296 c453: d4                     sep scall ; deallocate temporary storage
 2297 c454: d0 2b                  dw dealloc
 2298 c456: 0f                     ldn rf ; get first byte for string
 2299 c457: af                     plo rf ; set RF to value
 2300 c458: f8 00                  ldi 0
 2301 c45a: bf                     phi rf
 2302 c45b: c0 c4 be               lbr len_dn ; put answer on stack and finish
 2303 c45e:             
 2304 c45e:             ; *******************
 2305 c45e:             ; *** Process CHR ***
 2306 c45e:             ; *******************
 2307 c45e: d4          fn_chr: sep scall ; evaluate argument
 2308 c45f: c1 ed                  dw expr
 2309 c461: c3 d2 98               lbdf err_ret ; jump if error occurred
 2310 c464: d7                     sep r7 ; get buffer
 2311 c465: 09                     db set_buf.0
 2312 c466: d7                     sep r7 ; put into rd
 2313 c467: 72                     db rf_rd.0
 2314 c468: d7                     sep r7 ; get argument
 2315 c469: 58                     db ex_pop.0
 2316 c46a: 8f                     glo rf ; put answer into buffer
 2317 c46b: 5d                     str rd
 2318 c46c: 1d                     inc rd
 2319 c46d: f8 ff       str_term: ldi 0ffh ; terminate it
 2320 c46f: 5d                     str rd
 2321 c470: 1d                     inc rd
 2322 c471: c0 c5 8d               lbr copy_str ; copy string into heap
 2323 c474:             
 2324 c474:             ; *********************
 2325 c474:             ; *** Process LEFT$ ***
 2326 c474:             ; *********************
 2327 c474: d4          fn_left: sep scall ; get first argument
 2328 c475: c6 6c                  dw sexpr
 2329 c477: c3 d2 98               lbdf err_ret ; jump if error occurred
 2330 c47a: 4a                     lda ra ; get next token
 2331 c47b: ff 8d                  smi 08dh ; must be a comma
 2332 c47d: ca d2 93               lbnz syn_err ; else syntax error
 2333 c480: d4                     sep scall ; get length argument
 2334 c481: c1 ed                  dw expr
 2335 c483: c3 d2 98               lbdf err_ret ; jump if error occurred
 2336 c486: d7          left_go2: sep r7 ; get number of characters
 2337 c487: 58                     db ex_pop.0
 2338 c488: 8f                     glo rf ; save number of characters
 2339 c489: 73                     stxd
 2340 c48a: d7                     sep r7 ; get source address
 2341 c48b: 58                     db ex_pop.0
 2342 c48c: d4                     sep scall ; deallocate temporary storage
 2343 c48d: d0 2b                  dw dealloc
 2344 c48f: 60                     irx ; recover character count
 2345 c490: f0                     ldx
 2346 c491: ae                     plo re ; into re
 2347 c492: f8 01       left_go: ldi high buffer ; setup destination buffer
 2348 c494: bd                     phi rd
 2349 c495: f8 b3                  ldi low buffer
 2350 c497: ad                     plo rd
 2351 c498: 8e          left_lp: glo re ; see if done
 2352 c499: c2 c4 6d               lbz str_term ; jump if so
 2353 c49c: 2e                     dec re ; decrement re
 2354 c49d: 4f                     lda rf ; get byte from source
 2355 c49e: 5d                     str rd ; place into destination
 2356 c49f: 1d                     inc rd
 2357 c4a0: c0 c4 98               lbr left_lp ; loop until done
 2358 c4a3:             
 2359 c4a3:             ; *******************
 2360 c4a3:             ; *** Process LEN ***
 2361 c4a3:             ; *******************
 2362 c4a3: d4          fn_len: sep scall ; get argument
 2363 c4a4: c6 6c                  dw sexpr
 2364 c4a6: c3 d2 98               lbdf err_ret ; jump if error occurred
 2365 c4a9: d7                     sep r7 ; retrieve string address
 2366 c4aa: 58                     db ex_pop.0
 2367 c4ab: d4                     sep scall ; deallocate temporary storage
 2368 c4ac: d0 2b                  dw dealloc
 2369 c4ae: d7                     sep r7 ; put it in RD
 2370 c4af: 72                     db rf_rd.0
 2371 c4b0: f8 00                  ldi 0 ; set count to 0
 2372 c4b2: bf                     phi rf
 2373 c4b3: af                     plo rf
 2374 c4b4: 4d          len_lp: lda rd ; get byte from string
 2375 c4b5: fb ff                  xri 0ffh ; see if last byte was read
 2376 c4b7: c2 c4 be               lbz len_dn ; jump if so
 2377 c4ba: 1f                     inc rf ; increment count
 2378 c4bb: c0 c4 b4               lbr len_lp
 2379 c4be: d7          len_dn: sep r7 ; push answer onto stack
 2380 c4bf: 6a                     db ex_push.0
 2381 c4c0: c0 c3 30               lbr closed ; finish up
 2382 c4c3:             
 2383 c4c3:             ; ********************
 2384 c4c3:             ; *** Process MID$ ***
 2385 c4c3:             ; ********************
 2386 c4c3: d4          fn_mid: sep scall ; get first argument
 2387 c4c4: c6 6c                  dw sexpr
 2388 c4c6: c3 d2 98               lbdf err_ret ; jump if error occurred
 2389 c4c9: 4a                     lda ra ; get next token
 2390 c4ca: ff 8d                  smi 08dh ; must be a comma
 2391 c4cc: ca d2 93               lbnz syn_err ; else syntax error
 2392 c4cf: d4                     sep scall ; get start argument
 2393 c4d0: c1 ed                  dw expr
 2394 c4d2: c3 d2 98               lbdf err_ret ; jump if error occurred
 2395 c4d5: d7                     sep r7 ; get start
 2396 c4d6: 58                     db ex_pop.0
 2397 c4d7: 29                     dec r9 ; keep on stack as well
 2398 c4d8: 29                     dec r9
 2399 c4d9: 8f                     glo rf ; zero is not allowed
 2400 c4da: c2 d2 96               lbz val_err
 2401 c4dd: 4a                     lda ra ; get next token
 2402 c4de: ff 8d                  smi 08dh ; must be a comma
 2403 c4e0: ca d2 93               lbnz syn_err ; else syntax error
 2404 c4e3: d4                     sep scall ; get count argument
 2405 c4e4: c1 ed                  dw expr
 2406 c4e6: c3 d2 98               lbdf err_ret ; jump if error occurred
 2407 c4e9: d7                     sep r7 ; retrieve count
 2408 c4ea: 58                     db ex_pop.0
 2409 c4eb: 8f                     glo rf ; save it
 2410 c4ec: 73                     stxd
 2411 c4ed: d7                     sep r7 ; get position
 2412 c4ee: 58                     db ex_pop.0
 2413 c4ef: 8f                     glo rf ; save position on stack
 2414 c4f0: 73                     stxd
 2415 c4f1: d7                     sep r7 ; get source string address
 2416 c4f2: 58                     db ex_pop.0
 2417 c4f3: 29                     dec r9 ; keep address on stack
 2418 c4f4: 29                     dec r9
 2419 c4f5: d4                     sep scall ; clear temporary storage
 2420 c4f6: d0 2b                  dw dealloc
 2421 c4f8: d7                     sep r7 ; get source string address
 2422 c4f9: 58                     db ex_pop.0
 2423 c4fa: 60                     irx ; recover star position
 2424 c4fb: f0                     ldx ; into low re
 2425 c4fc: ae                     plo re
 2426 c4fd: 2e          mid_lp1: dec re
 2427 c4fe: 8e                     glo re ; see if done
 2428 c4ff: c2 c5 0c               lbz mid_dn ; jump if so
 2429 c502: 0f                     ldn rf ; get character
 2430 c503: fb ff                  xri 0ffh ; check for terminator
 2431 c505: c2 c5 0c               lbz mid_dn ; jump if found
 2432 c508: 1f                     inc rf ; move source forward
 2433 c509: c0 c4 fd               lbr mid_lp1 ; loop until start found
 2434 c50c: f8 01       mid_dn: ldi high buffer ; setup destination buffer
 2435 c50e: bd                     phi rd
 2436 c50f: f8 b3                  ldi low buffer
 2437 c511: ad                     plo rd
 2438 c512: 60                     irx ; recover count
 2439 c513: f0                     ldx
 2440 c514: ae                     plo re
 2441 c515: 8e          mid_lp2: glo re ; see if done
 2442 c516: c2 c5 27               lbz mid_dn2 ; jump if so
 2443 c519: 2e                     dec re ; decrement count
 2444 c51a: 4f                     lda rf ; get byte from string
 2445 c51b: fb ff                  xri 0ffh ; see if end of string
 2446 c51d: c2 c5 27               lbz mid_dn2 ; jump if so
 2447 c520: fb ff                  xri 0ffh ; recover character
 2448 c522: 5d                     str rd ; store into result
 2449 c523: 1d                     inc rd
 2450 c524: c0 c5 15               lbr mid_lp2 ; loop back until done
 2451 c527: f8 ff       mid_dn2: ldi 0ffh ; terminate string
 2452 c529: 5d                     str rd
 2453 c52a: f8 01                  ldi high buffer ; setup destination buffer
 2454 c52c: bf                     phi rf
 2455 c52d: f8 b3                  ldi low buffer
 2456 c52f: af                     plo rf
 2457 c530: d4                     sep scall ; copy string to heap
 2458 c531: c6 32                  dw str2heap
 2459 c533: c0 c3 30               lbr closed ; finish up
 2460 c536:             
 2461 c536:             
 2462 c536:             
 2463 c536:             ; **********************
 2464 c536:             ; *** Process RIGHT$ ***
 2465 c536:             ; **********************
 2466 c536: d4          fn_right: sep scall ; get first argument
 2467 c537: c6 6c                  dw sexpr
 2468 c539: c3 d2 98               lbdf err_ret ; jump if error occurred
 2469 c53c: 4a                     lda ra ; get next token
 2470 c53d: ff 8d                  smi 08dh ; must be a comma
 2471 c53f: ca d2 93               lbnz syn_err ; else syntax error
 2472 c542: d4                     sep scall ; get length argument
 2473 c543: c1 ed                  dw expr
 2474 c545: c3 d2 98               lbdf err_ret ; jump if error occurred
 2475 c548: d7                     sep r7 ; get number of characters
 2476 c549: 58                     db ex_pop.0
 2477 c54a: 8f                     glo rf ; move to re
 2478 c54b: 73                     stxd ; place on stack
 2479 c54c: d7                     sep r7 ; point to buffer
 2480 c54d: 09                     db set_buf.0
 2481 c54e: d7                     sep r7 ; get source address
 2482 c54f: 58                     db ex_pop.0
 2483 c550: d4                     sep scall ; deallocate temporary storage
 2484 c551: d0 2b                  dw dealloc
 2485 c553: f8 00                  ldi 0 ; setup character count
 2486 c555: ae                     plo re
 2487 c556: 4f          right_lp1: lda rf ; get byte from source
 2488 c557: fb ff                  xri 0ffh ; see if terminator
 2489 c559: c2 c5 60               lbz right_1 ; jump if so
 2490 c55c: 1e                     inc re ; increment count
 2491 c55d: c0 c5 56               lbr right_lp1 ; keep looking for end
 2492 c560: 60          right_1: irx ; point to requested count
 2493 c561: f0                     ldx ; read it
 2494 c562: ab                     plo rb ; copy it here
 2495 c563: bb                     phi rb
 2496 c564: 2f                     dec rf ; point to terminator
 2497 c565: 8b          right_lp2: glo rb ; done yet
 2498 c566: c2 c5 73               lbz right_f ; jump if so
 2499 c569: 8e                     glo re ; also check against length
 2500 c56a: c2 c5 73               lbz right_f
 2501 c56d: 2f                     dec rf ; move back one char
 2502 c56e: 2b                     dec rb ; decrement request count
 2503 c56f: 2e                     dec re ; and size
 2504 c570: c0 c5 65               lbr right_lp2 ; and loop until 1 is zero
 2505 c573: 9b          right_f: ghi rb ; get request count
 2506 c574: ae                     plo re ; place into re
 2507 c575: c0 c4 92               lbr left_go ; copy the string to the buffer
 2508 c578:             
 2509 c578:             
 2510 c578:             ; ********************
 2511 c578:             ; *** Process STR$ ***
 2512 c578:             ; ********************
 2513 c578: d4          fn_str: sep scall ; get argument
 2514 c579: c1 ed                  dw expr
 2515 c57b: c3 d2 98               lbdf err_ret ; jump if error resulted
 2516 c57e: d7                     sep r7 ; retrieve value
 2517 c57f: 58                     db ex_pop.0
 2518 c580: d7                     sep r7 ; transfer to RD
 2519 c581: 72                     db rf_rd.0
 2520 c582: d7                     sep r7 ; need a buffer
 2521 c583: 09                     db set_buf.0
 2522 c584: d4                     sep scall ; convert number to ascii
 2523 c585: ff 63                  dw f_intout
 2524 c587: f8 ff                  ldi 0ffh ; terminate it
 2525 c589: 5f                     str rf
 2526 c58a: 1f                     inc rf
 2527 c58b: d7                     sep r7 ; move address to rd
 2528 c58c: 72                     db rf_rd.0
 2529 c58d: d7          copy_str: sep r7 ; point to beginning of buffer
 2530 c58e: 09                     db set_buf.0
 2531 c58f: d4                     sep scall ; copy string to heap
 2532 c590: c6 32                  dw str2heap
 2533 c592: c3 d2 98               lbdf err_ret ; jump on error
 2534 c595: c0 c3 30               lbr closed ; finish up
 2535 c598:             
 2536 c598: f8 0a       om_err: ldi ERR_NOMEM ; indicate out of memory
 2537 c59a: ff 00                  smi 0
 2538 c59c: d5                     sep sret ; adn return
 2539 c59d:             ; *******************
 2540 c59d:             ; *** Process VAL ***
 2541 c59d:             ; *******************
 2542 c59d: d4          fn_val: sep scall ; get argument
 2543 c59e: c6 6c                  dw sexpr
 2544 c5a0: c3 d2 98               lbdf err_ret ; jump if error occurred
 2545 c5a3: d7                     sep r7 ; retrieve string address
 2546 c5a4: 58                     db ex_pop.0
 2547 c5a5: d4                     sep scall ; deallocate temporary storage
 2548 c5a6: d0 2b                  dw dealloc
 2549 c5a8: d4                     sep scall ; convert to integer
 2550 c5a9: ff 5d                  dw f_atoi
 2551 c5ab: 9d                     ghi rd ; put back into rf
 2552 c5ac: bf                     phi rf
 2553 c5ad: 8d                     glo rd
 2554 c5ae: af                     plo rf
 2555 c5af: c0 c4 be               lbr len_dn ; finish
 2556 c5b2:             
 2557 c5b2: f8 05       new_mexpr: ldi high expstack ; setup expression stack
 2558 c5b4: b9                     phi r9
 2559 c5b5: f8 b6                  ldi low expstack
 2560 c5b7: a9                     plo r9
 2561 c5b8: 0a          mexpr: ldn ra ; get first char from expression
 2562 c5b9: ff fd                  smi TKN_QSTR ; see if a string
 2563 c5bb: c2 c5 f3               lbz mexpr_s ; jump if so
 2564 c5be: ff 01                  smi 1 ; see if numeric
 2565 c5c0: c2 c5 f9               lbz mexpr_n ; jump if so
 2566 c5c3: 0a                     ldn ra ; see if starts with a variable
 2567 c5c4: d4                     sep scall
 2568 c5c5: ff 72                  dw f_isalpha
 2569 c5c7: cb c5 e0               lbnf mexpr_nv ; jump if not a variable
 2570 c5ca: 8a                     glo ra ; save variable address
 2571 c5cb: 73                     stxd
 2572 c5cc: 9a                     ghi ra
 2573 c5cd: 73                     stxd
 2574 c5ce: d4                     sep scall ; and retrieve variable
 2575 c5cf: c7 92                  dw get_var
 2576 c5d1: ae                     plo re
 2577 c5d2: 60                     irx ; recover original ra
 2578 c5d3: 72                     ldxa
 2579 c5d4: ba                     phi ra
 2580 c5d5: f0                     ldx
 2581 c5d6: aa                     plo ra
 2582 c5d7: 8e                     glo re
 2583 c5d8: ff 03                  smi 3 ; is it a string variable
 2584 c5da: c2 c5 f3               lbz mexpr_s ; jump if so
 2585 c5dd: c0 c5 f9               lbr mexpr_n ; otherwise numeric
 2586 c5e0: 0a          mexpr_nv: ldn ra ; recover character
 2587 c5e1: ff 1a                  smi CMD_START ; check if string function
 2588 c5e3: cb c5 f9               lbnf mexpr_n ; jump if numeric function
 2589 c5e6: ff a0                  smi 0a0h
 2590 c5e8: cb c5 f9               lbnf mexpr_n ; jump if numeric function
 2591 c5eb: ff 05                  smi 5 ; check high range of string functions
 2592 c5ed: cb c5 f3               lbnf mexpr_s
 2593 c5f0: c0 c5 f9               lbr mexpr_n
 2594 c5f3: d4          mexpr_s: sep scall ; call string evaluator
 2595 c5f4: c6 6c                  dw sexpr
 2596 c5f6: f8 03                  ldi 3 ; signal string result
 2597 c5f8: d5                     sep sret ; and return
 2598 c5f9: d4          mexpr_n: sep scall ; call numeric evaluator
 2599 c5fa: c1 ed                  dw expr
 2600 c5fc: f8 02       mexpr_r: ldi 2 ; signal string result
 2601 c5fe: d5                     sep sret ; and return
 2602 c5ff:             
 2603 c5ff:             ; *****************************************************************
 2604 c5ff:             ; **** Strcmp compares the strings pointing to by R(D) and R(F) ***
 2605 c5ff:             ; **** Returns: ***
 2606 c5ff:             ; **** R(F) = R(D) 0 ***
 2607 c5ff:             ; **** R(F) < R(D) -1 (255) ***
 2608 c5ff:             ; **** R(F) > R(D) 1 ***
 2609 c5ff:             ; *****************************************************************
 2610 c5ff: 4d          strcmp: lda rd ; get next byte in string
 2611 c600: fb ff                xri 0ffh ; check for end
 2612 c602: 32 14                bz strcmpe ; found end of first string
 2613 c604: fb ff                xri 0ffh ; restore character
 2614 c606: 52                   str r2 ; store into memory
 2615 c607: 4f                   lda rf ; get byte from first string
 2616 c608: f7                   sm ; subtract 2nd byte from it
 2617 c609: c2 c5 ff             lbz strcmp ; so far a match, keep looking
 2618 c60c: 3b 11                bnf strcmp1 ; jump if first string is smaller
 2619 c60e: f8 01                ldi 1 ; indicate first string is larger
 2620 c610: c8                   lskp ; and return to caller
 2621 c611: f8 ff       strcmp1: ldi 255 ; return -1, first string is smaller
 2622 c613: d5                   sep sret ; return to calelr
 2623 c614: 4f          strcmpe: lda rf ; get byte from second string
 2624 c615: fb ff                xri 0ffh ; check for end of 2nd string
 2625 c617: 32 1c                bz strcmpm ; jump if also zero
 2626 c619: f8 01                ldi 1 ; first string is smaller (returns -1)
 2627 c61b: d5                   sep sret ; return to caller
 2628 c61c: f8 00       strcmpm: ldi 0 ; strings are a match
 2629 c61e: d5                   sep sret ; return to caller
 2630 c61f:             
 2631 c61f: 1a          docmp: inc ra ; move past =
 2632 c620: d4                     sep scall ; get next argument
 2633 c621: c7 3c                  dw sexpr_l1
 2634 c623: c3 d2 98               lbdf err_ret ; jump in case of error
 2635 c626: d7                     sep r7 ; retrieve second argument
 2636 c627: 58                     db ex_pop.0
 2637 c628: d7                     sep r7 ; move it to rd
 2638 c629: 72                     db rf_rd.0
 2639 c62a: d7                     sep r7 ; retrieve first argument
 2640 c62b: 58                     db ex_pop.0
 2641 c62c: d4                     sep scall ; compare teh strings
 2642 c62d: c5 ff                  dw strcmp
 2643 c62f: fc 00                  adi 0 ; signal no error
 2644 c631: d5                     sep sret ; return
 2645 c632:             
 2646 c632:             ; *****************************
 2647 c632:             ; *** Copy string into heap ***
 2648 c632:             ; *** RF - String to copy ***
 2649 c632:             ; *** Returns: RF - address ***
 2650 c632:             ; *****************************
 2651 c632: f8 00       str2heap: ldi 0 ; setup count
 2652 c634: bd                     phi rd
 2653 c635: ad                     plo rd
 2654 c636: 8f                     glo rf ; save string address
 2655 c637: 73                     stxd
 2656 c638: 9f                     ghi rf
 2657 c639: 73                     stxd
 2658 c63a: 1d          str_hp_l1: inc rd ; increment count
 2659 c63b: 4f                     lda rf ; get byte from string
 2660 c63c: fb ff                  xri 0ffh ; check for terminator
 2661 c63e: ca c6 3a               lbnz str_hp_l1 ; jump if not yet found
 2662 c641: 8d                     glo rd ; save count
 2663 c642: 73                     stxd
 2664 c643: af                     plo rf ; and put into rf
 2665 c644: 9d                     ghi rd
 2666 c645: 73                     stxd
 2667 c646: bf                     phi rf
 2668 c647: d4                     sep scall ; allocate the memory
 2669 c648: d0 87                  dw alloc
 2670 c64a: 60                     irx ; recover count
 2671 c64b: 72                     ldxa
 2672 c64c: bb                     phi rb
 2673 c64d: 72                     ldxa
 2674 c64e: ab                     plo rb
 2675 c64f: 72                     ldxa ; and source address
 2676 c650: bd                     phi rd
 2677 c651: f0                     ldx
 2678 c652: ad                     plo rd
 2679 c653: c3 d2 98               lbdf err_ret ; jump if error occurred
 2680 c656: d7                     sep r7 ; put address onto expression stack
 2681 c657: 6a                     db ex_push.0
 2682 c658: 4d          str_hp_l2: lda rd ; read byte from source
 2683 c659: 5f                     str rf ; store into destination
 2684 c65a: 1f                     inc rf
 2685 c65b: 2b                     dec rb ; decrement count
 2686 c65c: 8b                     glo rb ; see if done
 2687 c65d: 52                     str r2
 2688 c65e: 9b                     ghi rb
 2689 c65f: f1                     or
 2690 c660: ca c6 58               lbnz str_hp_l2
 2691 c663: fc 00                  adi 0 ; signal no error
 2692 c665: d5                     sep sret ; and return
 2693 c666:             
 2694 c666:             ; **************************************************
 2695 c666:             ; *** Process string expression pointed to by RA ***
 2696 c666:             ; **************************************************
 2697 c666: f8 05       new_sexpr: ldi high expstack ; setup expression stack
 2698 c668: b9                     phi r9
 2699 c669: f8 b6                  ldi low expstack
 2700 c66b: a9                     plo r9
 2701 c66c: d4          sexpr: sep scall ; get argument
 2702 c66d: c7 3c                  dw sexpr_l1
 2703 c66f: c3 d2 98               lbdf err_ret ; jump on error
 2704 c672: 0a                     ldn ra ; check for relational symbols
 2705 c673: ff 86                  smi 86h ; check for =
 2706 c675: ca c6 95               lbnz sexpr_a ; jump if not
 2707 c678: d4                     sep scall ; call string comparison
 2708 c679: c6 1f                  dw docmp
 2709 c67b: c3 d2 98               lbdf err_ret ; jump on error
 2710 c67e: ca c6 90               lbnz sfalse ; jump if falst
 2711 c681: f8 ff       strue: ldi 0ffh ; put -1 on stack
 2712 c683: e9          s_stack: sex r9 ; point to expression stack
 2713 c684: 73                     stxd
 2714 c685: 73                     stxd
 2715 c686: e2                     sex r2 ; point x back to correct stack
 2716 c687: f8 c5       sfix: ldi high mexpr_r ; change to numeric return
 2717 c689: b6                     phi r6
 2718 c68a: f8 fc                  ldi low mexpr_r
 2719 c68c: a6                     plo r6
 2720 c68d: fc 00                  adi 0 ; signal success
 2721 c68f: d5                     sep sret ; and return
 2722 c690: f8 00       sfalse: ldi 0 ; need a zero on the stack
 2723 c692: c0 c6 83               lbr s_stack ; finish up
 2724 c695: ff 01       sexpr_a: smi 1 ; check for <=
 2725 c697: ca c6 ab               lbnz sexpr_b ; jump if not
 2726 c69a: d4                     sep scall ; call string comparison
 2727 c69b: c6 1f                  dw docmp
 2728 c69d: c3 d2 98               lbdf err_ret ; jump on error
 2729 c6a0: c2 c6 81               lbz strue ; jump if equal
 2730 c6a3: fb ff                  xri 0ffh
 2731 c6a5: c2 c6 81               lbz strue
 2732 c6a8: c0 c6 90               lbr sfalse
 2733 c6ab: ff 01       sexpr_b: smi 1 ; check for >=
 2734 c6ad: ca c6 c1               lbnz sexpr_c ; jump if not
 2735 c6b0: d4                     sep scall ; call string comparison
 2736 c6b1: c6 1f                  dw docmp
 2737 c6b3: c3 d2 98               lbdf err_ret ; jump on error
 2738 c6b6: c2 c6 81               lbz strue ; jump if equal
 2739 c6b9: fb ff                  xri 0ffh
 2740 c6bb: ca c6 81               lbnz strue
 2741 c6be: c0 c6 90               lbr sfalse
 2742 c6c1: ff 01       sexpr_c: smi 1 ; check for >=
 2743 c6c3: ca c6 d2               lbnz sexpr_d ; jump if not
 2744 c6c6: d4                     sep scall ; call string comparison
 2745 c6c7: c6 1f                  dw docmp
 2746 c6c9: c3 d2 98               lbdf err_ret ; jump on error
 2747 c6cc: ca c6 81               lbnz strue ; jump if equal
 2748 c6cf: c0 c6 90               lbr sfalse
 2749 c6d2: ff 01       sexpr_d: smi 1 ; check for <
 2750 c6d4: ca c6 e8               lbnz sexpr_e ; jump if not
 2751 c6d7: d4                     sep scall ; call string comparison
 2752 c6d8: c6 1f                  dw docmp
 2753 c6da: c3 d2 98               lbdf err_ret ; jump on error
 2754 c6dd: c2 c6 90               lbz sfalse ; false if they were equal
 2755 c6e0: fb ff                  xri 0ffh
 2756 c6e2: c2 c6 81               lbz strue
 2757 c6e5: c0 c6 90               lbr sfalse
 2758 c6e8: ff 01       sexpr_e: smi 1 ; check for >
 2759 c6ea: ca c6 fe               lbnz sexpr_f ; jump if not
 2760 c6ed: d4                     sep scall ; call string comparison
 2761 c6ee: c6 1f                  dw docmp
 2762 c6f0: c3 d2 98               lbdf err_ret ; jump on error
 2763 c6f3: c2 c6 90               lbz sfalse ; false if they were equal
 2764 c6f6: fb ff                  xri 0ffh
 2765 c6f8: ca c6 81               lbnz strue
 2766 c6fb: c0 c6 90               lbr sfalse
 2767 c6fe:             
 2768 c6fe: 0a          sexpr_f: ldn ra ; recover symbol
 2769 c6ff: ff 80                  smi 80h
 2770 c701: ca c7 39               lbnz sexpr_g ; jump if not +
 2771 c704: 1a                     inc ra ; move past plus
 2772 c705: d4                     sep scall ; get next argument
 2773 c706: c7 3c                  dw sexpr_l1
 2774 c708: c3 d2 98               lbdf err_ret ; jump in case of error
 2775 c70b: d7                     sep r7 ; recover 2nd string
 2776 c70c: 58                     db ex_pop.0
 2777 c70d: d4                     sep scall ; deallocate temporary storage
 2778 c70e: d0 2b                  dw dealloc
 2779 c710: d7                     sep r7 ; move to rd
 2780 c711: 72                     db rf_rd.0
 2781 c712: d7                     sep r7 ; recover 1st string
 2782 c713: 58                     db ex_pop.0
 2783 c714: d4                     sep scall ; deallocate temporary storage
 2784 c715: d0 2b                  dw dealloc
 2785 c717: f8 01                  ldi high buffer ; setup buffer
 2786 c719: bb                     phi rb
 2787 c71a: f8 b3                  ldi low buffer
 2788 c71c: ab                     plo rb
 2789 c71d: 4f          cat_lp1: lda rf ; read byte from 1st string
 2790 c71e: 5b                     str rb ; store into buffer
 2791 c71f: 1b                     inc rb
 2792 c720: fb ff                  xri 0ffh ; was terminator written
 2793 c722: ca c7 1d               lbnz cat_lp1 ; loop back if not
 2794 c725: 2b                     dec rb ; need to overwrite terminator
 2795 c726: 4d          cat_lp2: lda rd ; read byte from 2nd string
 2796 c727: 5b                     str rb ; store into buffer
 2797 c728: 1b                     inc rb
 2798 c729: fb ff                  xri 0ffh ; was terminator written
 2799 c72b: ca c7 26               lbnz cat_lp2 ; loop back if not
 2800 c72e: d7                     sep r7 ; get beginning of buffer
 2801 c72f: 09                     db set_buf.0
 2802 c730: d4                     sep scall ; and copy string to heap
 2803 c731: c6 32                  dw str2heap
 2804 c733: c3 d2 98               lbdf err_ret ; jump if error
 2805 c736: c0 c6 fe               lbr sexpr_f ; loop back for possibly more plusses
 2806 c739:             
 2807 c739: fc 00       sexpr_g: adi 0 ; signal no error
 2808 c73b: d5                     sep sret ; and return
 2809 c73c:             
 2810 c73c: 0a          sexpr_l1: ldn ra ; get next byte
 2811 c73d: ff fd                  smi TKN_QSTR ; is it a quoted string
 2812 c73f: ca c7 52               lbnz sexpr_l1a ; jump if not
 2813 c742: 1a                     inc ra ; point to string
 2814 c743: e9                     sex r9 ; place address on expression stack
 2815 c744: 8a                     glo ra
 2816 c745: 73                     stxd
 2817 c746: 9a                     ghi ra
 2818 c747: 73                     stxd
 2819 c748: e2                     sex r2 ; point X back to real stack
 2820 c749: 4a          sexpr_lp1: lda ra ; need to find end
 2821 c74a: fb ff                  xri 0ffh ; check for terminator
 2822 c74c: ca c7 49               lbnz sexpr_lp1 ; loop until found
 2823 c74f: fc 00                  adi 0 ; signal no error
 2824 c751: d5                     sep sret ; return with value
 2825 c752: 4a          sexpr_l1a: lda ra ; get token again
 2826 c753: ff 1a                  smi CMD_START ; remove bias
 2827 c755: ff a0                  smi 0a0h ; check for str$
 2828 c757: c2 c5 78               lbz fn_str ; jump if so
 2829 c75a: ff 01                  smi 1 ; check for chr$
 2830 c75c: c2 c4 5e               lbz fn_chr ; jump if so
 2831 c75f: ff 01                  smi 1 ; check for left$
 2832 c761: c2 c4 74               lbz fn_left ; jump if so
 2833 c764: ff 01                  smi 1 ; check for right$
 2834 c766: c2 c5 36               lbz fn_right ; jump if so
 2835 c769: ff 01                  smi 1 ; check for mid$
 2836 c76b: c2 c4 c3               lbz fn_mid ; jump if so
 2837 c76e:             
 2838 c76e: 2a                     dec ra ; move back
 2839 c76f: 0a                     ldn ra ; see if possible variable
 2840 c770: d4                     sep scall
 2841 c771: ff 72                  dw f_isalpha
 2842 c773: cb d2 93               lbnf syn_err ; jump if not a possible variable
 2843 c776: d4                     sep scall ; get variable address
 2844 c777: c7 92                  dw get_var
 2845 c779: ff 03                  smi 3 ; must be a string variable
 2846 c77b: ca d2 93               lbnz syn_err ; else error
 2847 c77e: 4f                     lda rf ; get pointed to data
 2848 c77f: ae                     plo re
 2849 c780: 0f                     ldn rf
 2850 c781: af                     plo rf ; and set rf to it
 2851 c782: 8e                     glo re
 2852 c783: bf                     phi rf
 2853 c784: d7                     sep r7 ; place onto expression stack
 2854 c785: 6a                     db ex_push.0
 2855 c786: fc 00                  adi 0 ; no errors
 2856 c788: d5                     sep sret ; return
 2857 c789:             
 2858 c789: 4a          sclosed: lda ra ; next token must be a )
 2859 c78a: ff 85                  smi 085h
 2860 c78c: ca d2 93               lbnz syn_err ; else syntax error
 2861 c78f: fc 00                  adi 0 ; signal no error
 2862 c791: d5                     sep sret ; and return
 2863 c792:             
 2864 c792:             ; ******************************************************************************
 2865 c792:             ; *** End of L2 functions ***
 2866 c792:             ; ******************************************************************************
 2867 c792:             
 2868 c792:             
 2869 c792:             ; **********************************************
 2870 c792:             ; *** Find variable address pointed to by RA ***
 2871 c792:             ; *** Returns: RF - address of value ***
 2872 c792:             ; **********************************************
            # 2849 "rcbasic.asm"
 2874 c792: f8 01       get_var: ldi high var_pos ; need variable table
 2875 c794: bf                     phi rf
 2876 c795: f8 06                  ldi low var_pos
 2877 c797: af                     plo rf
 2878 c798: 4f                     lda rf ; read variable table address
 2879 c799: ae                     plo re ; save high byte for a moment
 2880 c79a: 0f                     ldn rf ; get low byte
 2881 c79b: af                     plo rf ; make RF variable table pointer
 2882 c79c: 8e                     glo re
 2883 c79d: bf                     phi rf
 2884 c79e: 0f          var_lp: ldn rf ; see if at end of table
 2885 c79f: c2 c7 f5               lbz var_new ; yep, so new variable
 2886 c7a2: d7                     sep r7 ; make a copy of this position
 2887 c7a3: 72                     db rf_rd.0
 2888 c7a4: 1f                     inc rf ; move past size
 2889 c7a5: 8a                     glo ra ; also keep RA
 2890 c7a6: ab                     plo rb
 2891 c7a7: 9a                     ghi ra
 2892 c7a8: bb                     phi rb
 2893 c7a9: ea                     sex ra ; make X point to data stream
 2894 c7aa: 4f          var_slp: lda rf ; get next byte from variable table
 2895 c7ab: ae                     plo re
 2896 c7ac: fe                     shl ; shift high bit to DF
 2897 c7ad: 8e                     glo re ; and then value back
 2898 c7ae: c3 c7 c6               lbdf var_lst ; jump if on last character
 2899 c7b1: f7                     sm ; compare entries
 2900 c7b2: 1a                     inc ra ; move ra to next character before testing
 2901 c7b3: c2 c7 aa               lbz var_slp ; jump on match
 2902 c7b6: 9b          no_mtch: ghi rb ; no match, so reset ra
 2903 c7b7: ba                     phi ra
 2904 c7b8: 8b                     glo rb
 2905 c7b9: aa                     plo ra
 2906 c7ba: ed                     sex rd ; point X to next variable offset
 2907 c7bb: 8d                     glo rd ; add into position
 2908 c7bc: f4                     add
 2909 c7bd: af                     plo rf ; and place into RF
 2910 c7be: 9d                     ghi rd
 2911 c7bf: 7c 00                  adci 0
 2912 c7c1: bf                     phi rf ; rf now pointing at next variable entry
 2913 c7c2: e2                     sex r2 ; point X back to stack
 2914 c7c3: c0 c7 9e               lbr var_lp ; and check next entry
 2915 c7c6: fa 7f       var_lst: ani 07fh ; clear high bit
 2916 c7c8: ae                     plo re ; keep a copy
 2917 c7c9: ff 04                  smi 4 ; is variable an arry
 2918 c7cb: c2 c7 ec               lbz is_array ; jump if so
 2919 c7ce: 8e                     glo re ; recover re
 2920 c7cf: f7                     sm ; check for match
 2921 c7d0: ca c7 b6               lbnz no_mtch ; jump if not
 2922 c7d3: 1a                     inc ra ; move ra past variable name
 2923 c7d4: 0a                     ldn ra ; need to make sure variable is ended
 2924 c7d5: d4                     sep scall
 2925 c7d6: ff 78                  dw f_isalnum
 2926 c7d8: c3 c7 b6               lbdf no_mtch ; no match if still variable name
 2927 c7db: ae                     plo re
 2928 c7dc: ff 24                  smi '$' ; make sure not a string
 2929 c7de: c2 c7 b6               lbz no_mtch
 2930 c7e1: 8e                     glo re
 2931 c7e2: ff 84                  smi 084h ; make sure not an array
 2932 c7e4: c2 c7 b6               lbz no_mtch ; else no match
 2933 c7e7: 4f                     lda rf ; get type
 2934 c7e8: e2                     sex r2 ; point X back to stack
 2935 c7e9: fc 00                  adi 0 ; signal no error
 2936 c7eb: d5                     sep sret ; so return
 2937 c7ec: 4a          is_array: lda ra ; next token must also be a (
 2938 c7ed: ff 84                  smi 84h
 2939 c7ef: ca c7 b6               lbnz no_mtch ; else no match
 2940 c7f2: c0 c8 4a               lbr array ; item found was an array, proccess it
 2941 c7f5:             
 2942 c7f5: 8f          var_new: glo rf ; save this position
 2943 c7f6: ad                     plo rd
 2944 c7f7: 9f                     ghi rf
 2945 c7f8: bd                     phi rd
 2946 c7f9: 1f                     inc rf ; move past size
 2947 c7fa: 4a          var_nmlp: lda ra ; read byte from token stream
 2948 c7fb: d4                     sep scall ; see if valid for variable name
 2949 c7fc: ff 78                  dw f_isalnum
 2950 c7fe: cb c8 06               lbnf var_nmdn ; jump if done with name
 2951 c801: 5f                     str rf ; store into variable entry
 2952 c802: 1f                     inc rf
 2953 c803: c0 c7 fa               lbr var_nmlp ; loop back until full name is copied
 2954 c806: ff 24       var_nmdn: smi '$' ; check for string variables
 2955 c808: ca c8 2a               lbnz var_notst ; jump if not a string
 2956 c80b: f8 a4                  ldi ('$')+80h ; append to variable name
 2957 c80d: 5f                     str rf
 2958 c80e: 1f                     inc rf
 2959 c80f: f8 03                  ldi 3 ; signify a string
 2960 c811: 5f                     str rf
 2961 c812: 1f                     inc rf
 2962 c813: f8 d3                  ldi high term ; point to a null string
 2963 c815: 5f                     str rf
 2964 c816: 1f                     inc rf
 2965 c817: f8 e3                  ldi low term
 2966 c819: 5f                     str rf
 2967 c81a: 1f                     inc rf
 2968 c81b: 8f                     glo rf ; need to find offset
 2969 c81c: 52                     str r2
 2970 c81d: 8d                     glo rd
 2971 c81e: f5                     sd
 2972 c81f: 5d                     str rd ; store offset at beginning of entry
 2973 c820: f8 00                  ldi 0 ; write end of variable table entry
 2974 c822: 5f                     str rf
 2975 c823: 2f                     dec rf ; move back to address field
 2976 c824: 2f                     dec rf
 2977 c825: fc 00                  adi 0 ; signal no error
 2978 c827: f8 03                  ldi 3 ; signal string variable
 2979 c829: d5                     sep sret ; and return to caller
 2980 c82a:             
 2981 c82a: 2a          var_notst: dec ra ; move RA back
 2982 c82b: 2f                     dec rf ; point to last char of varname
 2983 c82c: 0f                     ldn rf ; and retrieve it
 2984 c82d: f9 80                  ori 80h ; set high bit
 2985 c82f: 5f                     str rf ; and write it back
 2986 c830: 1f                     inc rf ; move to type field
 2987 c831: f8 02                  ldi 2 ; only integers for now
 2988 c833: 5f                     str rf
 2989 c834: 1f                     inc rf
 2990 c835: f8 00                  ldi 0 ; new vars have zero for their value
 2991 c837: 5f                     str rf
 2992 c838: 1f                     inc rf ; move past value field
 2993 c839: 5f                     str rf
 2994 c83a: 1f                     inc rf
 2995 c83b: 8f                     glo rf ; need to find offset
 2996 c83c: 52                     str r2
 2997 c83d: 8d                     glo rd
 2998 c83e: f5                     sd
 2999 c83f: 5d                     str rd ; store offset at beginning of entry
 3000 c840: f8 00                  ldi 0 ; write end of variable table entry
 3001 c842: 5f                     str rf
 3002 c843: 2f                     dec rf ; move rf to value field
 3003 c844: 2f                     dec rf
 3004 c845: fc 00                  adi 0 ; signal no error
 3005 c847: f8 02                  ldi 2 ; signal integer variable
 3006 c849: d5                     sep sret ; and return to caller
 3007 c84a:             ; ******************************************
 3008 c84a:             ; *** process an array variable location ***
 3009 c84a:             ; ******************************************
 3010 c84a: e2          array: sex r2 ; point X back to stack
 3011 c84b: 1f                     inc rf ; should now be pointing to array address
 3012 c84c: 4f                     lda rf ; retreive it
 3013 c84d: ae                     plo re
 3014 c84e: 0f                     ldn rf
 3015 c84f: af                     plo rf
 3016 c850: 8e                     glo re
 3017 c851: bf                     phi rf ; rf now points to array descriptor
 3018 c852: 99                     ghi r9 ; see if expression stack is defined
 3019 c853: ca c8 60               lbnz array_1 ; jump if it is
 3020 c856: 89                     glo r9
 3021 c857: ca c8 60               lbnz array_1
 3022 c85a: f8 05                  ldi high expstack ; setup expression stack
 3023 c85c: b9                     phi r9
 3024 c85d: f8 b6                  ldi low expstack
 3025 c85f: a9                     plo r9
 3026 c860: d7          array_1: sep r7 ; move address to RD
 3027 c861: 72                     db rf_rd.0
 3028 c862: f8 00                  ldi 0 ; set initial accumulation to 0
 3029 c864: bf                     phi rf
 3030 c865: af                     plo rf
 3031 c866: d7                     sep r7
 3032 c867: 6a                     db ex_push.0 ; tos now has accumultaion
 3033 c868: 4d                     lda rd ; get number of dimensions
 3034 c869: 73                     stxd ; save it
 3035 c86a: d7                     sep r7 ; save this position
 3036 c86b: b8                     db push_rd.0
 3037 c86c:             ; Number of dimensions is on stack, RD->dimension size, on top of stack
 3038 c86c: d4          ar_mullp2: sep scall ; get next dimension
 3039 c86d: c1 ed                  dw expr
 3040 c86f: c3 c8 eb               lbdf err3_ret ; exit if error
 3041 c872: d7                     sep r7 ; recvoer array descriptor address
 3042 c873: be                     db pop_rd.0
 3043 c874: 4d                     lda rd ; get dimension size
 3044 c875: 73                     stxd ; place onto stack
 3045 c876: 0d                     ldn rd ; lsb of size
 3046 c877: 52                     str r2 ; also on stack
 3047 c878: 2d                     dec rd
 3048 c879: d7                     sep r7 ; recover first dimension
 3049 c87a: 58                     db ex_pop.0
 3050 c87b: 29                     dec r9 ; and keep on expression stack
 3051 c87c: 29                     dec r9
 3052 c87d: 8f                     glo rf ; check range
 3053 c87e: f7                     sm
 3054 c87f: 60                     irx ; point x to msb
 3055 c880: 9f                     ghi rf ; continue subtraction
 3056 c881: 77                     smb
 3057 c882: c3 c8 e4               lbdf dim_err ; jump on dimension error
 3058 c885: 60                     irx ; recover dimension count
 3059 c886: f0                     ldx
 3060 c887: ff 01                  smi 1 ; and subtract 1
 3061 c889: c2 c8 bf               lbz array_dn ; jump if done processing arguments
 3062 c88c: ae                     plo re ; save this
 3063 c88d: d7                     sep r7 ; put dimension pointer on stack
 3064 c88e: b8                     db push_rd.0
 3065 c88f: 8e                     glo re ; get it back
 3066 c890: 73                     stxd ; put dim count back on stack
 3067 c891: 1d                     inc rd
 3068 c892: 1d                     inc rd
 3069 c893: 73          ar_mullp: stxd ; save dimension count
 3070 c894: 4d                     lda rd ; get next dimension size
 3071 c895: bf                     phi rf ; into rf
 3072 c896: 4d                     lda rd
 3073 c897: af                     plo rf
 3074 c898: d7                     sep r7 ; place onto expression stack
 3075 c899: 6a                     db ex_push.0
 3076 c89a: d7                     sep r7 ; save pointer
 3077 c89b: b8                     db push_rd.0
 3078 c89c: d4                     sep scall ; multiply numbers
 3079 c89d: c1 8b                  dw ex_mul
 3080 c89f: d7                     sep r7 ; recover rd
 3081 c8a0: be                     db pop_rd.0
 3082 c8a1: 60                     irx ; and dimension count
 3083 c8a2: f0                     ldx
 3084 c8a3: ff 01                  smi 1 ; minus 1
 3085 c8a5: ca c8 93               lbnz ar_mullp ; morre multiplications to go
 3086 c8a8: d4                     sep scall ; add total to accumulation
 3087 c8a9: c0 c8                  dw ex_add
 3088 c8ab: 60                     irx ; recover dimentsion count
 3089 c8ac: f0                     ldx
 3090 c8ad: ae                     plo re ; set aside
 3091 c8ae: d7                     sep r7 ; get dimension pointer
 3092 c8af: be                     db pop_rd.0
 3093 c8b0: 1d                     inc rd ; move to next dimension
 3094 c8b1: 1d                     inc rd
 3095 c8b2: 8e                     glo re ; get dimension count
 3096 c8b3: 73                     stxd ; and save
 3097 c8b4: d7                     sep r7 ; and put back on stack
 3098 c8b5: b8                     db push_rd.0
 3099 c8b6: 4a                     lda ra ; get next token
 3100 c8b7: ff 8d                  smi 08dh ; must be a comma
 3101 c8b9: ca c8 eb               lbnz err3_ret ; error if not
 3102 c8bc: c0 c8 6c               lbr ar_mullp2 ; loop back
 3103 c8bf: 1d          array_dn: inc rd ; move past final dimension
 3104 c8c0: 1d                     inc rd
 3105 c8c1: d7                     sep r7 ; save location
 3106 c8c2: b8                     db push_rd.0
 3107 c8c3: d4                     sep scall ; add last dimension to toal
 3108 c8c4: c0 c8                  dw ex_add
 3109 c8c6: d7                     sep r7 ; get cell number
 3110 c8c7: 58                     db ex_pop.0
 3111 c8c8: 8f                     glo rf ; multiply by 2
 3112 c8c9: fe                     shl
 3113 c8ca: af                     plo rf
 3114 c8cb: 9f                     ghi rf
 3115 c8cc: 7e                     shlc
 3116 c8cd: bf                     phi rf
 3117 c8ce: d7                     sep r7 ; and put back onto stack
 3118 c8cf: 6a                     db ex_push.0
 3119 c8d0: d7                     sep r7 ; recover location
 3120 c8d1: a4                     db pop_rf.0
 3121 c8d2: d7                     sep r7 ; add to base addres
 3122 c8d3: 6a                     db ex_push.0
 3123 c8d4: d4                     sep scall
 3124 c8d5: c0 c8                  dw ex_add
 3125 c8d7: d7                     sep r7 ; get final cell number
 3126 c8d8: 58                     db ex_pop.0
 3127 c8d9: 4a                     lda ra ; last token must be a )
 3128 c8da: ff 85                  smi 85h
 3129 c8dc: ca d2 93               lbnz syn_err ; else error
 3130 c8df: f8 02                  ldi 2 ; array is integer
 3131 c8e1: fc 00                  adi 0 ; signal success
 3132 c8e3: d5                     sep sret ; return to caller
 3133 c8e4:             
 3134 c8e4:             
 3135 c8e4: f8 0b       dim_err: ldi ERR_BADDIM ; signal bad dimensions
 3136 c8e6: ff 00                  smi 0
 3137 c8e8: c0 c8 ed               lbr err1_ret ; and return
 3138 c8eb: 60          err3_ret: irx ; dump 3 bytes off the stack
 3139 c8ec: 60          err2_ret: irx
 3140 c8ed: 60          err1_ret: irx
 3141 c8ee: d5                     sep sret ; and return
 3142 c8ef:             
 3143 c8ef:             
 3144 c8ef:             
 3145 c8ef:             
 3146 c8ef:             ; ******************************************************************************
 3147 c8ef:             ; *** Start of L1 statements ***
 3148 c8ef:             ; ******************************************************************************
 3149 c8ef:             ; *******************
 3150 c8ef:             ; *** Process END ***
 3151 c8ef:             ; *******************
 3152 c8ef: f8 00       ex_end: ldi 0 ; terminate program execution
 3153 c8f1: bc                     phi rc
 3154 c8f2: ac                     plo rc
 3155 c8f3: c0 d2 77               lbr exec_dn ; finish up
 3156 c8f6:             
 3157 c8f6:             ; *********************
 3158 c8f6:             ; *** Process GOSUB ***
 3159 c8f6:             ; *********************
 3160 c8f6: d4          ex_gosub: sep scall ; evaluate expression for line number
 3161 c8f7: c1 e7                  dw new_expr
 3162 c8f9: c3 d2 93               lbdf syn_err ; jump on error
 3163 c8fc: d7                     sep r7 ; retrieve line number
 3164 c8fd: 58                     db ex_pop.0
 3165 c8fe: d7                     sep r7 ; move it to rd
 3166 c8ff: 72                     db rf_rd.0
 3167 c900: 8c                     glo rc ; save line in case of error
 3168 c901: 73                     stxd
 3169 c902: 9c                     ghi rc
 3170 c903: 73                     stxd
 3171 c904: 9c                     ghi rc ; save current line to gosub stack
 3172 c905: 58                     str r8
 3173 c906: 18                     inc r8
 3174 c907: 8c                     glo rc
 3175 c908: 58                     str r8
 3176 c909: 18                     inc r8
 3177 c90a: d7                     sep r7 ; find line
 3178 c90b: 19                     db find_ln.0
 3179 c90c: cb c9 3a               lbnf no_line ; jump if line was not found
 3180 c90f: 60                     irx ; remove old line. Mark Albene
 3181 c910: 60                     irx
 3182 c911: 9a                     ghi ra ; save current pointer to gosub stack
 3183 c912: 58                     str r8
 3184 c913: 18                     inc r8
 3185 c914: 8a                     glo ra
 3186 c915: 58                     str r8
 3187 c916: 18                     inc r8
 3188 c917: c0 c9 33               lbr goto_go ; then treat like goto
 3189 c91a:             
 3190 c91a:             ; ********************
 3191 c91a:             ; *** Process GOTO ***
 3192 c91a:             ; ********************
 3193 c91a: d4          ex_goto: sep scall ; evaluate expression for line number
 3194 c91b: c1 e7                  dw new_expr
 3195 c91d: c3 d2 98               lbdf err_ret ; jump on error
 3196 c920: 0a                     ldn ra ; must be terminator
 3197 c921: ca d2 93               lbnz syn_err
 3198 c924: d7          goto_go2: sep r7 ; retrieve line number
 3199 c925: 58                     db ex_pop.0
 3200 c926: d7                     sep r7 ; move it to rd
 3201 c927: 72                     db rf_rd.0
 3202 c928: 8c                     glo rc ; save line in case of error
 3203 c929: 73                     stxd
 3204 c92a: 9c                     ghi rc
 3205 c92b: 73                     stxd
 3206 c92c: d7                     sep r7 ; find line
 3207 c92d: 19                     db find_ln.0
 3208 c92e: cb c9 3a               lbnf no_line ; jump if line was not found
 3209 c931: 60                     irx ; get rid of old line
 3210 c932: 60                     irx
 3211 c933: 9c          goto_go: ghi rc ; copy line address to RA
 3212 c934: ba                     phi ra
 3213 c935: 8c                     glo rc
 3214 c936: aa                     plo ra
 3215 c937: c0 d2 86               lbr exec_tst ; execute from new line
 3216 c93a: 60          no_line: irx ; recover current line
 3217 c93b: 72                     ldxa
 3218 c93c: bc                     phi rc
 3219 c93d: f0                     ldx
 3220 c93e: ac                     plo rc
 3221 c93f: f8 03       err_noln: ldi ERR_NOLIN ; signal line not found
 3222 c941: ff 00                  smi 0 ; signal error
 3223 c943: d5                     sep sret ; and return
 3224 c944:             
 3225 c944:             ; ******************
 3226 c944:             ; *** Process IF ***
 3227 c944:             ; ******************
 3228 c944: d4          ex_if: sep scall ; evaluate expression
 3229 c945:             
 3230 c945:             
 3231 c945:             
 3232 c945: c5 b2                  dw new_mexpr
 3233 c947:             
 3234 c947: c3 d2 98               lbdf err_ret ; jump on error
 3235 c94a: d7                     sep r7 ; retrieve result
 3236 c94b: 58                     db ex_pop.0
 3237 c94c: 8f                     glo rf ; see if success
 3238 c94d: 52                     str r2
 3239 c94e: 9f                     ghi rf
 3240 c94f: f1                     or
 3241 c950: c2 d2 77               lbz exec_dn ; jump if IF failed test
 3242 c953: 0a          if_chk: ldn ra ; check for optional THEN
 3243 c954: ff 9f                  smi 09fh
 3244 c956: ca d2 48               lbnz execute ; not there, so just continue
 3245 c959: 1a                     inc ra ; move past it
 3246 c95a: c0 d2 48               lbr execute ; and continue
 3247 c95d:             
 3248 c95d:             ; *********************
 3249 c95d:             ; *** Process f_input ***
 3250 c95d:             ; *********************
 3251 c95d: 0a          ex_input: ldn ra ; get next token
 3252 c95e: ff fd                  smi TKN_QSTR ; is it a quoted string
 3253 c960: c2 c9 a8               lbz input_pr ; jump if so
 3254 c963: 0a          input_lp: ldn ra ; see if done
 3255 c964: c2 ca b1               lbz chk_term ; jump if so
 3256 c967: 0a                     ldn ra ; get character
 3257 c968: d4                     sep scall ; must be a variable name
 3258 c969: ff 72                  dw f_isalpha
 3259 c96b: cb d2 93               lbnf syn_err ; otherwise error
 3260 c96e: d4                     sep scall ; get variable address
 3261 c96f: c7 92                  dw get_var
 3262 c971: c3 d2 98               lbdf err_ret
 3263 c974:             
 3264 c974: ff 02                  smi 2 ; is variable an integer
 3265 c976: c2 c9 8b               lbz inp_num ; jump if so
 3266 c979: d4                     sep scall ; deallocate previous value
 3267 c97a: cf ab                  dw de_str
 3268 c97c: f8 05                  ldi high expstack ; setup expression stack
 3269 c97e: b9                     phi r9
 3270 c97f: f8 b6                  ldi low expstack
 3271 c981: a9                     plo r9
 3272 c982: d4                     sep scall ; get string input
 3273 c983: bd b8                  dw get_sinput
 3274 c985: c0 c9 91               lbr inp_cnt ; store value
 3275 c988: c0 d2 93       lbr syn_err
 3276 c98b:             
 3277 c98b: d4          inp_num: sep scall ; get input
 3278 c98c: bd e9                  dw get_input
 3279 c98e: c3 d2 98               lbdf err_ret ; jump on error
 3280 c991: 9d          inp_cnt: ghi rd ; store into variable
 3281 c992: 5f                     str rf
 3282 c993: 1f                     inc rf
 3283 c994: 8d                     glo rd
 3284 c995: 5f                     str rf
 3285 c996: 0a                     ldn ra ; get next token
 3286 c997: c2 ca b1               lbz chk_term ; jump if terminator
 3287 c99a: ff 93                  smi 093h ; colon also ends input
 3288 c99c: c2 ca b1               lbz chk_term
 3289 c99f: 4a                     lda ra ; get next token
 3290 c9a0: ff 8d                  smi 08dh ; must be a comma
 3291 c9a2: c2 c9 63               lbz input_lp ; process next variable
 3292 c9a5: c0 d2 93               lbr syn_err ; otherwise error
 3293 c9a8: 1a          input_pr: inc ra ; move past quote token
 3294 c9a9: 4a          prompt_lp: lda ra ; get byte from token stream
 3295 c9aa: fb ff                  xri 0ffh ; see if last character
 3296 c9ac: c2 c9 b7               lbz prompt_dn ; jump if so
 3297 c9af: fb ff                  xri 0ffh ; otherwise restore character
 3298 c9b1: d4                     sep scall ; and output it
 3299 c9b2: ff 03                  dw f_type
 3300 c9b4: c0 c9 a9               lbr prompt_lp ; loop back until done
 3301 c9b7: 4a          prompt_dn: lda ra ; get next token
 3302 c9b8: ff 8c                  smi 08ch ; must be a semicolon
 3303 c9ba: ca d2 93               lbnz syn_err ; otherwise error
 3304 c9bd: c0 c9 63               lbr input_lp ; loop back to get input
 3305 c9c0:             
 3306 c9c0:             ; *******************
 3307 c9c0:             ; *** Process LET ***
 3308 c9c0:             ; *******************
 3309 c9c0: 0a          ex_let: ldn ra ; get next char
 3310 c9c1: d4                     sep scall ; it must be alph
 3311 c9c2: ff 72                  dw f_isalpha
 3312 c9c4: cb d2 93               lbnf syn_err ; otherwise syntax error
 3313 c9c7: f8 00                  ldi 0 ; mark expression stack as undefined
 3314 c9c9: b9                     phi r9
 3315 c9ca: a9                     plo r9
 3316 c9cb: d4                     sep scall ; get variable address
 3317 c9cc: c7 92                  dw get_var
 3318 c9ce: c3 d2 98               lbdf err_ret
 3319 c9d1: ae                     plo re ; save variable type
 3320 c9d2: 4a                     lda ra ; next token must be an =
 3321 c9d3: ff 86                  smi 86h
 3322 c9d5: ca d2 93               lbnz syn_err ; jump on error
 3323 c9d8: 8f                     glo rf ; save variable address
 3324 c9d9: 73                     stxd
 3325 c9da: 9f                     ghi rf
 3326 c9db: 73                     stxd
 3327 c9dc: 8e                     glo re ; save variable type
 3328 c9dd: 73                     stxd
 3329 c9de:             
 3330 c9de: d4                     sep scall ; dealloate possible string variable
 3331 c9df: cf ab                  dw de_str
 3332 c9e1:             
 3333 c9e1: d4                     sep scall ; evaluate expression
 3334 c9e2:             
 3335 c9e2:             
 3336 c9e2:             
 3337 c9e2: c5 b2                  dw new_mexpr
 3338 c9e4:             
 3339 c9e4: c3 d2 98               lbdf err_ret ; jump if error occurred
 3340 c9e7: 60                     irx ; need to check types
 3341 c9e8: f3                     xor
 3342 c9e9: ae                     plo re
 3343 c9ea: 60                     irx ; get variable address
 3344 c9eb: 72                     ldxa
 3345 c9ec: bd                     phi rd
 3346 c9ed: f0                     ldx
 3347 c9ee: ad                     plo rd
 3348 c9ef: 8e                     glo re
 3349 c9f0: ca d2 93               lbnz syn_err ; syntax error if types do not match
 3350 c9f3: d7                     sep r7 ; recover result
 3351 c9f4: 58                     db ex_pop.0
 3352 c9f5: 9f                     ghi rf ; write value to variable
 3353 c9f6: 5d                     str rd
 3354 c9f7: 1d                     inc rd
 3355 c9f8: 8f                     glo rf
 3356 c9f9: 5d                     str rd
 3357 c9fa: c0 ca b1               lbr chk_term ; done
 3358 c9fd:             
 3359 c9fd:             ; ****************************
 3360 c9fd:             ; *** Process LIST command ***
 3361 c9fd:             ; ****************************
 3362 c9fd: f8 00       ex_list: ldi 0 ; setup list boundaries
 3363 c9ff: b8                     phi r8
 3364 ca00: a8                     plo r8
 3365 ca01: f8 ff                  ldi 0ffh
 3366 ca03: b9                     phi r9
 3367 ca04: a9                     plo r9
 3368 ca05: 29                     dec r9
 3369 ca06: 0a                     ldn ra ; get next token
 3370 ca07: c2 ca 35               lbz ex_flist ; jump if full list requested
 3371 ca0a: ff 81                  smi 81h ; is it the minus
 3372 ca0c: c2 ca 1d               lbz to_end ; jump if so
 3373 ca0f: 4a                     lda ra ; get token again
 3374 ca10: ff fe                  smi TKN_NUM ; must be a number
 3375 ca12: ca d2 93               lbnz syn_err ; otherwise error
 3376 ca15: 4a                     lda ra ; retrieve number into r8
 3377 ca16: b8                     phi r8
 3378 ca17: 4a                     lda ra
 3379 ca18: a8                     plo r8
 3380 ca19: 0a                     ldn ra ; see if single line
 3381 ca1a: c2 ca 8c               lbz list_1 ; jump if so
 3382 ca1d: 4a          to_end: lda ra
 3383 ca1e: ff 81                  smi 81h ; must now be a minus sign
 3384 ca20: ca d2 93               lbnz syn_err ; else error
 3385 ca23: 0a                     ldn ra ; see if open end
 3386 ca24: c2 ca 35               lbz ex_flist ; jump if so
 3387 ca27: 4a                     lda ra ; and retrieve it
 3388 ca28: ff fe                  smi TKN_NUM ; must be a number
 3389 ca2a: ca d2 93               lbnz syn_err ; otherwise error
 3390 ca2d: 4a                     lda ra ; retrieve number into R9
 3391 ca2e: b9                     phi r9
 3392 ca2f: 4a                     lda ra
 3393 ca30: a9                     plo r9
 3394 ca31: 0a                     ldn ra ; must be followd by terminator
 3395 ca32: ca d2 93               lbnz syn_err
 3396 ca35: 8a          ex_flist: glo ra ; save token address
 3397 ca36: 73                     stxd
 3398 ca37: 9a                     ghi ra
 3399 ca38: 73                     stxd
 3400 ca39: 8c                     glo rc ; save line address
 3401 ca3a: 73                     stxd
 3402 ca3b: 9c                     ghi rc
 3403 ca3c: 73                     stxd
 3404 ca3d: f8 05                  ldi high pgmtext ; point to basic storage
 3405 ca3f: ba                     phi ra ; put into ra and rc
 3406 ca40: bc                     phi rc
 3407 ca41: f8 b7                  ldi low pgmtext
 3408 ca43: aa                     plo ra
 3409 ca44: ac                     plo rc
 3410 ca45: 0a          flist_lp: ldn ra ; get line size
 3411 ca46: c2 ca 80               lbz flist_dn ; jump if done
 3412 ca49: 1a                     inc ra ; retrieve line number
 3413 ca4a: 4a                     lda ra
 3414 ca4b: bd                     phi rd
 3415 ca4c: 0a                     ldn ra
 3416 ca4d: ad                     plo rd
 3417 ca4e: 2a                     dec ra ; put pointer back
 3418 ca4f: 2a                     dec ra
 3419 ca50: 88                     glo r8 ; perform line-R8
 3420 ca51: 52                     str r2
 3421 ca52: 8d                     glo rd
 3422 ca53: f7                     sm
 3423 ca54: 98                     ghi r8
 3424 ca55: 52                     str r2
 3425 ca56: 9d                     ghi rd
 3426 ca57: 77                     smb
 3427 ca58: cb ca 75               lbnf no_show ; jump if line number was too small
 3428 ca5b: 19                     inc r9
 3429 ca5c: 89                     glo r9 ; now line-R9
 3430 ca5d: 52                     str r2
 3431 ca5e: 8d                     glo rd
 3432 ca5f: f7                     sm
 3433 ca60: 99                     ghi r9
 3434 ca61: 52                     str r2
 3435 ca62: 9d                     ghi rd
 3436 ca63: 77                     smb
 3437 ca64: 29                     dec r9
 3438 ca65: c3 ca 75               lbdf no_show ; jump if line number was too large
 3439 ca68: d7          show: sep r7 ; setup output buffer
 3440 ca69: 09                     db set_buf.0
 3441 ca6a: d4                     sep scall ; detokenize the line
 3442 ca6b: bc e2                  dw detoken
 3443 ca6d: d7                     sep r7 ; point to output buffer
 3444 ca6e: 09                     db set_buf.0
 3445 ca6f: d4                     sep scall ; display it
 3446 ca70: ff 09                  dw f_msg
 3447 ca72: d4                     sep scall ; need a cr/lf
 3448 ca73: bd 6f                  dw do_crlf
 3449 ca75: d7          no_show: sep r7 ; find next line
 3450 ca76: 48                     db next_ln.0
 3451 ca77: 9f                     ghi rf ; transfer address
 3452 ca78: ba                     phi ra
 3453 ca79: bc                     phi rc
 3454 ca7a: 8f                     glo rf
 3455 ca7b: aa                     plo ra
 3456 ca7c: ac                     plo rc
 3457 ca7d: c0 ca 45               lbr flist_lp ; display next line
 3458 ca80: 60          flist_dn: irx ; recover consumed registers
 3459 ca81: 72                     ldxa
 3460 ca82: bc                     phi rc
 3461 ca83: 72                     ldxa
 3462 ca84: ac                     plo rc
 3463 ca85: 72                     ldxa
 3464 ca86: ba                     phi ra
 3465 ca87: f0                     ldx
 3466 ca88: aa                     plo ra
 3467 ca89: c0 ca b1               lbr chk_term ; goot at this opint
 3468 ca8c: 98          list_1: ghi r8 ; transfer number
 3469 ca8d: bd                     phi rd
 3470 ca8e: 88                     glo r8
 3471 ca8f: ad                     plo rd
 3472 ca90: d7                     sep r7 ; find the line
 3473 ca91: 19                     db find_ln.0
 3474 ca92: 9c                     ghi rc ; transfer address
 3475 ca93: ba                     phi ra
 3476 ca94: 8c                     glo rc
 3477 ca95: aa                     plo ra
 3478 ca96: f8 00                  ldi 0 ; zero RC
 3479 ca98: bc                     phi rc
 3480 ca99: ac                     plo rc
 3481 ca9a: cb c9 3f               lbnf err_noln ; jump if line was not found
 3482 ca9d: d7                     sep r7
 3483 ca9e: 09                     db set_buf.0
 3484 ca9f: d4                     sep scall ; detokenize the line
 3485 caa0: bc e2                  dw detoken
 3486 caa2: d7                     sep r7 ; point to output buffer
 3487 caa3: 09                     db set_buf.0
 3488 caa4: d4                     sep scall ; display it
 3489 caa5: ff 09                  dw f_msg
 3490 caa7: d4                     sep scall ; need a cr/lf
 3491 caa8: bd 6f                  dw do_crlf
 3492 caaa: f8 00                  ldi 0 ; make sure no program continues
 3493 caac: bc                     phi rc
 3494 caad: ac                     plo rc
 3495 caae: c0 ca b1               lbr chk_term ; done
 3496 cab1:             
 3497 cab1:             
 3498 cab1:             
 3499 cab1: 0a          chk_term: ldn ra ; get next token
 3500 cab2: c2 d2 48               lbz execute
 3501 cab5: ff 93                  smi 093h ; colon is also valid
 3502 cab7: ca d2 93               lbnz syn_err ; should have been zero
 3503 caba: c0 ca c0               lbr exec_coln
 3504 cabd: fc 00       exec_good: adi 0 ; signal no error
 3505 cabf: d5                     sep sret ; return to caller
 3506 cac0: 1a          exec_coln: inc ra ; move past colon
 3507 cac1: c0 d2 48               lbr execute ; continue processing line
 3508 cac4:             
 3509 cac4:             ; *******************
 3510 cac4:             ; *** Process NEW ***
 3511 cac4:             ; *******************
 3512 cac4: f8 00       ex_new: ldi 0 ; terminate program execution
 3513 cac6: bc                     phi rc
 3514 cac7: ac                     plo rc
 3515 cac8: d7                     sep r7 ; set first byte of basic area to 0
 3516 cac9: c5                     db set_byte.0
 3517 caca: 05 b7                  dw pgmtext
 3518 cacc: 00                     db 0
 3519 cacd: d4                     sep scall ; setup variable table
 3520 cace: bf 34                  dw rst_vars
 3521 cad0: c0 d2 77               lbr exec_dn ; finish up
 3522 cad3:             
 3523 cad3:             ; *******************
 3524 cad3:             ; *** Process OUT ***
 3525 cad3:             ; *******************
 3526 cad3: d4          ex_out: sep scall ; get first argument
 3527 cad4: c1 e7                  dw new_expr
 3528 cad6: c3 d2 98               lbdf err_ret ; jump on error
 3529 cad9: 4a                     lda ra ; get next token
 3530 cada: ff 8d                  smi 08dh ; must be a comma
 3531 cadc: ca d2 93               lbnz syn_err ; otherwise syntax error
 3532 cadf: d7                     sep r7 ; retrieve value from stack
 3533 cae0: 58                     db ex_pop.0
 3534 cae1: 8f                     glo rf ; save address
 3535 cae2: fa 07                  ani 7 ; mask for correct range
 3536 cae4: c2 d2 96               lbz val_err ; jump if invalid value
 3537 cae7: fc 60                  adi 60h ; convert to out instruction
 3538 cae9: 73                     stxd
 3539 caea: d4                     sep scall ; now get value
 3540 caeb: c1 e7                  dw new_expr
 3541 caed: c3 d2 98               lbdf err_ret ; jump on error
 3542 caf0: d7                     sep r7 ; retrieve value
 3543 caf1: 58                     db ex_pop.0
 3544 caf2: 60                     irx ; recover address
 3545 caf3: f0                     ldx
 3546 caf4: bf                     phi rf
 3547 caf5: f8 d3                  ldi 0d3h ; instruction to put reset P=3
 3548 caf7: 73                     stxd
 3549 caf8: 8f                     glo rf ; put value onto stack
 3550 caf9: 73                     stxd
 3551 cafa: 9f                     ghi rf ; get out instruction
 3552 cafb: 52                     str r2
 3553 cafc: d2                     sep r2 ; execute instructions on stack
 3554 cafd: 22                     dec r2 ; move stack back to correct address
 3555 cafe: c0 ca b1               lbr chk_term ; check termination
 3556 cb01:             
 3557 cb01:             ; ********************
 3558 cb01:             ; *** Process PLOT ***
 3559 cb01:             ; ********************
 3560 cb01: d4          ex_plot: sep scall ; evaluate argument
 3561 cb02: c1 e7                  dw new_expr
 3562 cb04: c3 d2 98               lbdf err_ret ; jump if error occurred
 3563 cb07: 0a                     ldn ra ; see if comma is specified
 3564 cb08: ff 8d                  smi 08dh
 3565 cb0a: ca cb 41               lbnz ex_plotdn ; jump if not
 3566 cb0d: 1a                     inc ra ; move past comma
 3567 cb0e: d4                     sep scall ; evaluate second argument
 3568 cb0f: c1 ed                  dw expr
 3569 cb11: c3 d2 98               lbdf err_ret
 3570 cb14: d7                     sep r7 ; point to buffer
 3571 cb15: 09                     db set_buf.0
 3572 cb16: d7                     sep r7 ; add escape character
 3573 cb17: 53                     db add_char.0
 3574 cb18: 1b                     db 01bh
 3575 cb19: d7                     sep r7 ; add escape character
 3576 cb1a: 53                     db add_char.0
 3577 cb1b: 5b                     db '['
 3578 cb1c: d7                     sep r7 ; get top of expr stack in RD
 3579 cb1d: 61                     db ex_pop_rd.0
 3580 cb1e: d4                     sep scall ; convert output
 3581 cb1f: ff 63                  dw f_intout
 3582 cb21: d7                     sep r7 ; now need a semicolon
 3583 cb22: 53                     db add_char.0
 3584 cb23: 3b                     db ';'
 3585 cb24: d7                     sep r7 ; get top of expr stack in RD
 3586 cb25: 61                     db ex_pop_rd.0
 3587 cb26: d4                     sep scall ; convert output
 3588 cb27: ff 63                  dw f_intout
 3589 cb29: d7                     sep r7 ; now need a semicolon
 3590 cb2a: 53                     db add_char.0
 3591 cb2b: 48                     db 'H'
 3592 cb2c: d7                     sep r7 ; now need a semicolon
 3593 cb2d: 53                     db add_char.0
 3594 cb2e: 00                     db 0
 3595 cb2f: d7                     sep r7 ; point to buffer
 3596 cb30: 09                     db set_buf.0
 3597 cb31: d4                     sep scall ; send escape sequence
 3598 cb32: ff 09                  dw f_msg
 3599 cb34: 0a                     ldn ra ; get next character
 3600 cb35: ff 8d                  smi 08dh ; is it a comma
 3601 cb37: ca ca b1               lbnz chk_term ; jump if not
 3602 cb3a: 1a                     inc ra ; move past comma
 3603 cb3b: d4                     sep scall ; get final argument
 3604 cb3c: c1 e7                  dw new_expr
 3605 cb3e: c3 d2 98               lbdf err_ret
 3606 cb41: d7          ex_plotdn: sep r7 ; retreive value
 3607 cb42: 58                     db ex_pop.0
 3608 cb43: 8f                     glo rf ; get low value
 3609 cb44: d4                     sep scall ; and display it
 3610 cb45: ff 03                  dw f_type
 3611 cb47: c0 ca b1               lbr chk_term ; done
 3612 cb4a:             
 3613 cb4a:             ; ********************
 3614 cb4a:             ; *** Process POKE ***
 3615 cb4a:             ; ********************
 3616 cb4a: d4          ex_poke: sep scall ; get first argument
 3617 cb4b: c1 e7                  dw new_expr
 3618 cb4d: c3 d2 98               lbdf err_ret ; jump on error
 3619 cb50: 4a                     lda ra ; get next token
 3620 cb51: ff 8d                  smi 08dh ; must be a comma
 3621 cb53: ca d2 93               lbnz syn_err ; otherwise syntax error
 3622 cb56: d7                     sep r7 ; retrieve value from stack
 3623 cb57: 58                     db ex_pop.0
 3624 cb58: 8f                     glo rf ; save address
 3625 cb59: 73                     stxd
 3626 cb5a: 9f                     ghi rf
 3627 cb5b: 73                     stxd
 3628 cb5c: d4                     sep scall ; now get value
 3629 cb5d: c1 e7                  dw new_expr
 3630 cb5f: c3 d2 98               lbdf err_ret ; jump on error
 3631 cb62: d7                     sep r7 ; retrieve value
 3632 cb63: 58                     db ex_pop.0
 3633 cb64: 60                     irx ; recover address
 3634 cb65: 72                     ldxa
 3635 cb66: bd                     phi rd
 3636 cb67: f0                     ldx
 3637 cb68: ad                     plo rd
 3638 cb69: 8f                     glo rf ; get byte from value
 3639 cb6a: 5d                     str rd ; and poke into memory
 3640 cb6b: c0 ca b1               lbr chk_term ; check termination
 3641 cb6e:             
 3642 cb6e:             ; *********************
 3643 cb6e:             ; *** process PRINT ***
 3644 cb6e:             ; *********************
 3645 cb6e: 0a          ex_print: ldn ra ; get next symbol
 3646 cb6f: c2 cb cc               lbz print_dn ; jump if hit end
 3647 cb72: ff 93                  smi 093h ; colon is also valid terminator
 3648 cb74: c2 cb cc               lbz print_dn
 3649 cb77: 4a                     lda ra
 3650 cb78: ae                     plo re ; keep a copy
 3651 cb79: ff 8c                  smi 08ch ; check for semicolon
 3652 cb7b: c2 cb b8               lbz print_sc ; jump if so
 3653 cb7e: 8e                     glo re ; recover symbol
 3654 cb7f: ff 8d                  smi 08dh ; check for comma
 3655 cb81: c2 cb c4               lbz print_cm ; jump if so
 3656 cb84: 8e                     glo re ; recover symbol
            # 3640 "rcbasic.asm"
 3658 cb85: 2a                     dec ra ; point to beginning of expression
 3659 cb86: d4                     sep scall ; evaluate it
 3660 cb87: c5 b2                  dw new_mexpr
 3661 cb89: c3 d2 98               lbdf err_ret ; jump if error occurred
 3662 cb8c: ff 02                  smi 2 ; was result an integer
 3663 cb8e: c2 cb a4               lbz prt_int ; jump if so
 3664 cb91: d7                     sep r7 ; retrieve string address
 3665 cb92: 58                     db ex_pop.0
 3666 cb93: d4                     sep scall ; deallocate temporary storage
 3667 cb94: d0 2b                  dw dealloc
 3668 cb96: 4f          print_qs: lda rf ; get next symbol
 3669 cb97: fb ff                  xri 0ffh ; see if terminator found
 3670 cb99: c2 cb 6e               lbz ex_print ; jump if so
 3671 cb9c: fb ff                  xri 0ffh ; restore character
 3672 cb9e: d4                     sep scall ; display the character
 3673 cb9f: ff 03                  dw f_type
 3674 cba1: c0 cb 96               lbr print_qs ; loop back until done
 3675 cba4:             
 3676 cba4: d7          prt_int: sep r7 ; retrieve final value
 3677 cba5: 58                     db ex_pop.0
 3678 cba6: d7                     sep r7 ; move to rd
 3679 cba7: 72                     db rf_rd.0
 3680 cba8: d7                     sep r7 ; setup a buffer
 3681 cba9: 09                     db set_buf.0
 3682 cbaa: d4                     sep scall ; and convert number
 3683 cbab: ff 63                  dw f_intout
 3684 cbad: f8 00                  ldi 0 ; place terminator
 3685 cbaf: 5f                     str rf
 3686 cbb0: d7                     sep r7 ; setup a buffer
 3687 cbb1: 09                     db set_buf.0
 3688 cbb2: d4                     sep scall ; print value
 3689 cbb3: ff 09                  dw f_msg
 3690 cbb5: c0 cb 6e               lbr ex_print ; and look for other things to print
            # 3682 "rcbasic.asm"
 3692 cbb8: 0a          print_sc: ldn ra ; get next symbol
 3693 cbb9: c2 cb c1               lbz print_ncr ; jump if no cr needed
 3694 cbbc: ff 93                  smi 093h ; colon is also valid for end
 3695 cbbe: ca cb 6e               lbnz ex_print ; continue printing
 3696 cbc1: c0 ca b1    print_ncr: lbr chk_term
 3697 cbc4: f8 09       print_cm: ldi 9 ; need to output a tab
 3698 cbc6: d4                     sep scall ; send to terminal
 3699 cbc7: ff 03                  dw f_type
 3700 cbc9: c0 cb b8               lbr print_sc ; then process like semicolon
 3701 cbcc: d4          print_dn: sep scall ; print a cr/lf
 3702 cbcd: ff 66                  dw f_inmsg
 3703 cbcf: 0a 0d 00               db 10,13,0
 3704 cbd2: c0 ca b1               lbr chk_term ; and continue processing line
 3705 cbd5:             
 3706 cbd5:             ; **********************
 3707 cbd5:             ; *** Process RETURN ***
 3708 cbd5:             ; **********************
 3709 cbd5: 0a          ex_return: ldn ra ; next token must be zero
 3710 cbd6: ca d2 93               lbnz syn_err ; else syntax error
 3711 cbd9: 88                     glo r8 ; make sure gosub stack is not empty
 3712 cbda: ff b5                  smi gosub_st.0
 3713 cbdc: ca cb ea               lbnz ret_good ; jump if good
 3714 cbdf: 98                     ghi r8 ; check high byte as well
 3715 cbe0: ff 02                  smi gosub_st.1
 3716 cbe2: ca cb ea               lbnz ret_good
 3717 cbe5: ff 00                  smi 0 ; signal an error
 3718 cbe7: f8 04                  ldi ERR_INVRET
 3719 cbe9: d5                     sep sret ; and return to caller
 3720 cbea: 28          ret_good: dec r8 ; retrieve current token pointer
 3721 cbeb: 08                     ldn r8
 3722 cbec: aa                     plo ra
 3723 cbed: 28                     dec r8
 3724 cbee: 08                     ldn r8
 3725 cbef: ba                     phi ra
 3726 cbf0: 28                     dec r8 ; retrieve current line pointer
 3727 cbf1: 08                     ldn r8
 3728 cbf2: ac                     plo rc
 3729 cbf3: 28                     dec r8
 3730 cbf4: 08                     ldn r8
 3731 cbf5: bc                     phi rc
 3732 cbf6: c0 ca b1               lbr chk_term ; and continue
 3733 cbf9:             
 3734 cbf9:             ; *******************
 3735 cbf9:             ; *** Process RUN ***
 3736 cbf9:             ; *******************
 3737 cbf9: f8 05       ex_run: ldi high pgmtext ; point to first program line
 3738 cbfb: bc                     phi rc ; placei into rc and ra
 3739 cbfc: ba                     phi ra
 3740 cbfd: f8 b7                  ldi low pgmtext
 3741 cbff: ac                     plo rc
 3742 cc00: aa                     plo ra
 3743 cc01: f8 02                  ldi high gosub_st ; setup gosub stack
 3744 cc03: b8                     phi r8
 3745 cc04: f8 b5                  ldi low gosub_st
 3746 cc06: a8                     plo r8
 3747 cc07: d7                     sep r7 ; zero the input buffer
 3748 cc08: c5                     db set_byte.0
 3749 cc09: 01 63                  dw ibuffer
 3750 cc0b: 00                     db 0
 3751 cc0c: d7                     sep r7 ; setup input buffer pointer
 3752 cc0d: cd                     db set_word.0
 3753 cc0e: 01 61                  dw inp_pos
 3754 cc10: 01 63                  dw ibuffer
 3755 cc12:             
 3756 cc12: d4                     sep scall ; setup variable table
 3757 cc13: bf 34                  dw rst_vars
 3758 cc15: d7                     sep r7 ; need to setup FOR stack
 3759 cc16: cd                     db set_word.0
 3760 cc17: 01 0a                  dw for_pos
 3761 cc19: 01 5c                  dw for_st
 3762 cc1b: d7                     sep r7 ; need to setup DATA pointers
 3763 cc1c: cd                     db set_word.0
 3764 cc1d: 01 02                  dw data_lin
 3765 cc1f: 05 b7                  dw pgmtext
 3766 cc21: d7                     sep r7 ; point rf to beginning of basic
 3767 cc22: d6                     db set_rf.0
 3768 cc23: 05 b7                  dw pgmtext
 3769 cc25: 1f                     inc rf ; move to first token
 3770 cc26: 1f                     inc rf
 3771 cc27: 1f                     inc rf
 3772 cc28: 0f                     ldn rf ; and retrieve it
 3773 cc29: ff 1a                  smi CMD_START ; subtract command offset
 3774 cc2b: ff 96                  smi 96h ; check for DATA
 3775 cc2d: ca cc 3f               lbnz nodata
 3776 cc30: 1f                     inc rf ; otherwise point to first data item
 3777 cc31: f8 01                  ldi high data_pos ; setup data position
 3778 cc33: bd                     phi rd
 3779 cc34: f8 04                  ldi low data_pos
 3780 cc36: ad                     plo rd
 3781 cc37: 9f                     ghi rf ; and write pointer
 3782 cc38: 5d                     str rd
 3783 cc39: 1d                     inc rd
 3784 cc3a: 8f                     glo rf
 3785 cc3b: 5d                     str rd
 3786 cc3c: c0 cc 42               lbr yesdata ; and skip looking for DATA
 3787 cc3f: d4          nodata: sep scall ; find next data statement
 3788 cc40: c0 70                  dw find_data
 3789 cc42:             
 3790 cc42: c0 d2 86    yesdata: lbr exec_tst ; start program execution
 3791 cc45:             
 3792 cc45:             ; ******************************************************************************
 3793 cc45:             ; *** End of L1 statements ***
 3794 cc45:             ; ******************************************************************************
 3795 cc45:             
 3796 cc45:             ; ************************
 3797 cc45:             ; *** Exit from basic ***
 3798 cc45:             ; ************************
 3799 cc45:             
 3800 cc45: c0 80 03    ex_bye: lbr 8003h
            # 3802 "rcbasic.asm"
 3802 cc48:             ; **********************************************************
 3803 cc48:             ; *** Pico/Elf ROM ***
 3804 cc48:             ; **********************************************************
 3805 cc48:             ; ********************
 3806 cc48:             ; *** Process SAVE ***
 3807 cc48:             ; ********************
 3808 cc48: d4          ex_save: sep scall ; open XMODEM channel
 3809 cc49: d4 00                  dw xopenw
 3810 cc4b: f8 b7 af f8 
            05 bf                  mov rf,pgmtext ; point to basic space
 3811 cc51: d4                     sep scall ; get size of block
 3812 cc52: d2 9b                  dw size_end
 3813 cc54: 8c 73 9c 73            push rc ; save count
 3814 cc58: f8 63 af f8 
            01 bf                  mov rf,ibuffer ; where to store it
 3815 cc5e: 9c                     ghi rc ; write count
 3816 cc5f: 5f                     str rf
 3817 cc60: 1f                     inc rf ; point to low byte
 3818 cc61: 8c                     glo rc ; get low byte of count
 3819 cc62: 5f                     str rf ; and store it
 3820 cc63: 2f                     dec rf ; point back to high byte
 3821 cc64: f8 02 ac f8 
            00 bc                  mov rc,2 ; 2 bytes to write
 3822 cc6a: d4                     sep scall ; write them to XMODEM channel
 3823 cc6b: d4 09                  dw xwrite
 3824 cc6d: f8 b7 af f8 
            05 bf                  mov rf,pgmtext ; point back to basic space
 3825 cc73: 60 72 bc f0 
            ac                     pop rc ; recover count
 3826 cc78: d4                     sep scall ; write block to XMODEM channel
 3827 cc79: d4 09                  dw xwrite
 3828 cc7b: d4                     sep scall ; close the XMODEM channel
 3829 cc7c: d4 0c                  dw xclosew
 3830 cc7e: f8 00                  ldi 0 ; signal end
 3831 cc80: ac                     plo rc
 3832 cc81: bc                     phi rc
 3833 cc82: c0 d2 77               lbr exec_dn ; finish up
 3834 cc85:             
 3835 cc85:             ; ********************
 3836 cc85:             ; *** Process LOAD ***
 3837 cc85:             ; ********************
 3838 cc85: d4          ex_load: sep scall ; attempt to open XMODEM channel
 3839 cc86: d4 03                  dw xopenr
 3840 cc88: f8 63 af f8 
            01 bf                  mov rf,ibuffer ; point to temporary buffer
 3841 cc8e: f8 02 ac f8 
            00 bc                  mov rc,2 ; need to read 2 bytes
 3842 cc94: d4                     sep scall ; get save size from XMODEM channel
 3843 cc95: d4 06                  dw xread
 3844 cc97: f8 63 af f8 
            01 bf                  mov rf,ibuffer ; point to bytes read
 3845 cc9d: 4f                     lda rf ; get high byte of count
 3846 cc9e: bc                     phi rc ; put into count
 3847 cc9f: 0f                     ldn rf ; get low byte of count
 3848 cca0: ac                     plo rc ; put into count
 3849 cca1: f8 b7 af f8 
            05 bf                  mov rf,pgmtext ; point to basic space
 3850 cca7: d4                     sep scall ; Read from XMODEM channel
 3851 cca8: d4 06                  dw xread
 3852 ccaa: d4                     sep scall ; close the XMODEM channel
 3853 ccab: d4 0f                  dw xcloser
 3854 ccad: d4                     sep scall ; setup variable table
 3855 ccae: bf 34                  dw rst_vars
 3856 ccb0: f8 00                  ldi 0 ; signal end
 3857 ccb2: ac                     plo rc
 3858 ccb3: bc                     phi rc
 3859 ccb4: c0 d2 77               lbr exec_dn ; finish up
            # 3990 "rcbasic.asm"
 3861 ccb7:             ; ******************************************************************************
 3862 ccb7:             ; *** Start of L2 statements ***
 3863 ccb7:             ; ******************************************************************************
 3864 ccb7:             ; *********************
 3865 ccb7:             ; *** Process CLEAR ***
 3866 ccb7:             ; *********************
 3867 ccb7: d4          ex_clear: sep scall ; reset variables nad heap
 3868 ccb8: bf 34                  dw rst_vars
 3869 ccba: c0 ca b1               lbr chk_term ; finished
 3870 ccbd:             
 3871 ccbd:             ; *******************
 3872 ccbd:             ; *** Process FOR ***
 3873 ccbd:             ; *******************
 3874 ccbd: 0a          ex_for: ldn ra ; get next token
 3875 ccbe: d4                     sep scall ; it must be alpha (variable)
 3876 ccbf: ff 72                  dw f_isalpha
 3877 ccc1: cb d2 93               lbnf syn_err ; otherwise syntax error
 3878 ccc4: d4                     sep scall ; get variable address
 3879 ccc5: c7 92                  dw get_var
 3880 ccc7: c3 d2 98               lbdf err_ret
 3881 ccca: f8 01                  ldi high for_pos ; get current pointer
 3882 cccc: bd                     phi rd
 3883 cccd: f8 0a                  ldi low for_pos
 3884 cccf: ad                     plo rd
 3885 ccd0: 4d                     lda rd
 3886 ccd1: bb                     phi rb
 3887 ccd2: 4d                     lda rd
 3888 ccd3: ab                     plo rb
 3889 ccd4: 8b          for_lp: glo rb ; make sure it is not empty
 3890 ccd5: fb 5c                  xri for_st.0
 3891 ccd7: ae                     plo re ; save first result
 3892 ccd8: 9b                     ghi rb
 3893 ccd9: fb 01                  xri for_st.1
 3894 ccdb: 52                     str r2 ; or with first result
 3895 ccdc: 8e                     glo re
 3896 ccdd: f1                     or
 3897 ccde: c2 cd 08               lbz for_new ; jump if end of for stack
 3898 cce1:             
 3899 cce1: 1b                     inc rb ; point to var address msb
 3900 cce2: eb                     sex rb ; use this as data pointer
 3901 cce3: 9f                     ghi rf ; compare against IF variable address
 3902 cce4: f3                     xor
 3903 cce5: ae                     plo re ; keep temporary value
 3904 cce6: 1b                     inc rb ; move to lsb
 3905 cce7: 8f                     glo rf
 3906 cce8: f3                     xor ; and compare
 3907 cce9: e2                     sex r2 ; point x back to stack
 3908 ccea: 52                     str r2 ; put temp value here
 3909 cceb: 8e                     glo re ; get high temp value
 3910 ccec: f1                     or ; and combine with first value
 3911 cced: 2b                     dec rb ; move to beginning of entry
 3912 ccee: 2b                     dec rb ; back to free spot
 3913 ccef: ca cc fd               lbnz for_nxt ; jump if entry was not a match
 3914 ccf2: 8b                     glo rb ; clear entry and reuse
 3915 ccf3: fc 0a                  adi 10
 3916 ccf5: ab                     plo rb
 3917 ccf6: 9b                     ghi rb
 3918 ccf7: 7c 00                  adci 0
 3919 ccf9: bb                     phi rb
 3920 ccfa: c0 cd 12               lbr for_go
 3921 ccfd: 8b          for_nxt: glo rb ; move to next entry
 3922 ccfe: fc 0a                  adi 10
 3923 cd00: ab                     plo rb
 3924 cd01: 9b                     ghi rb
 3925 cd02: 7c 00                  adci 0
 3926 cd04: bb                     phi rb
 3927 cd05: c0 cc d4               lbr for_lp
 3928 cd08:             
 3929 cd08:             
 3930 cd08: f8 01       for_new: ldi high for_pos ; get current pointer
 3931 cd0a: bd                     phi rd
 3932 cd0b: f8 0a                  ldi low for_pos
 3933 cd0d: ad                     plo rd
 3934 cd0e: 4d                     lda rd
 3935 cd0f: bb                     phi rb
 3936 cd10: 4d                     lda rd
 3937 cd11: ab                     plo rb
 3938 cd12: eb          for_go: sex rb ; point X to for stack
 3939 cd13: 8c                     glo rc ; put RC onto stack
 3940 cd14: 73                     stxd
 3941 cd15: 9c                     ghi rc
 3942 cd16: 73                     stxd
 3943 cd17: e2                     sex r2 ; point X back to stack
 3944 cd18: 4a                     lda ra ; get next token
 3945 cd19: ff 86                  smi 086h ; must be =
 3946 cd1b: ca d2 93               lbnz syn_err ; otherwise error
 3947 cd1e: 8f                     glo rf ; save variable address for now
 3948 cd1f: 73                     stxd
 3949 cd20: 9f                     ghi rf
 3950 cd21: 73                     stxd
 3951 cd22: 8b                     glo rb ; save rb
 3952 cd23: 73                     stxd
 3953 cd24: 9b                     ghi rb
 3954 cd25: 73                     stxd
 3955 cd26: d4                     sep scall ; get start value
 3956 cd27: c1 e7                  dw new_expr
 3957 cd29: 60                     irx ; recover rb
 3958 cd2a: 72                     ldxa
 3959 cd2b: bb                     phi rb
 3960 cd2c: f0                     ldx
 3961 cd2d: ab                     plo rb
 3962 cd2e: c3 d2 98               lbdf err_ret ; jump if error
 3963 cd31: d7                     sep r7 ; get value
 3964 cd32: 58                     db ex_pop.0
 3965 cd33: 60                     irx ; recover variable address
 3966 cd34: 72                     ldxa
 3967 cd35: bd                     phi rd
 3968 cd36: f0                     ldx
 3969 cd37: ad                     plo rd
 3970 cd38: 22                     dec r2 ; keep variable address on stack
 3971 cd39: 22                     dec r2
 3972 cd3a: 9f                     ghi rf ; write start into variable
 3973 cd3b: 5d                     str rd
 3974 cd3c: 1d                     inc rd
 3975 cd3d: 8f                     glo rf
 3976 cd3e: 5d                     str rd
 3977 cd3f: 4a                     lda ra ; get next token
 3978 cd40: ff 1a                  smi CMD_START ; offset for commands
 3979 cd42: ff 92                  smi 092h ; must be TO
 3980 cd44: ca d2 93               lbnz syn_err ; else syntax error
 3981 cd47: 8b                     glo rb ; save rb
 3982 cd48: 73                     stxd
 3983 cd49: 9b                     ghi rb
 3984 cd4a: 73                     stxd
 3985 cd4b: d4                     sep scall ; evaluate ending value
 3986 cd4c: c1 e7                  dw new_expr
 3987 cd4e: ae                     plo re
 3988 cd4f: 60                     irx ; recover rb
 3989 cd50: 72                     ldxa
 3990 cd51: bb                     phi rb
 3991 cd52: f0                     ldx
 3992 cd53: ab                     plo rb
 3993 cd54: 8e                     glo re
 3994 cd55: c3 d2 98               lbdf err_ret ; jump on error
 3995 cd58: f8 01                  ldi 1 ; default step is 1
 3996 cd5a: af                     plo rf
 3997 cd5b: f8 00                  ldi 0
 3998 cd5d: bf                     phi rf
 3999 cd5e: d7                     sep r7 ; put step onto stack
 4000 cd5f: 6a                     db ex_push.0
 4001 cd60: 0a                     ldn ra ; need to check for STEP
 4002 cd61: ff 1a                  smi CMD_START ; offset for commands
 4003 cd63: ff 94                  smi 094h ; check for STEP
 4004 cd65: ca cd 7c               lbnz no_step ; jump if not
 4005 cd68: d7                     sep r7 ; drop default step from stack
 4006 cd69: 58                     db ex_pop.0
 4007 cd6a: 8b                     glo rb ; save rb
 4008 cd6b: 73                     stxd
 4009 cd6c: 9b                     ghi rb
 4010 cd6d: 73                     stxd
 4011 cd6e: 1a                     inc ra ; move past STEP token
 4012 cd6f: d4                     sep scall ; evaluate step
 4013 cd70: c1 ed                  dw expr
 4014 cd72: ae                     plo re
 4015 cd73: 60                     irx ; recover rb
 4016 cd74: 72                     ldxa
 4017 cd75: bb                     phi rb
 4018 cd76: f0                     ldx
 4019 cd77: ab                     plo rb
 4020 cd78: 8e                     glo re
 4021 cd79: c3 d2 98               lbdf err_ret ; jump on error
 4022 cd7c:             
 4023 cd7c: d7          no_step: sep r7 ; retrieve end value
 4024 cd7d: 58                     db ex_pop.0
 4025 cd7e: d7                     sep r7 ; transfer to rd
 4026 cd7f: 72                     db rf_rd.0
 4027 cd80: d7                     sep r7 ; retrieve end value
 4028 cd81: 58                     db ex_pop.0
 4029 cd82: eb                     sex rb ; write RA onto stack
 4030 cd83: 8a                     glo ra
 4031 cd84: 73                     stxd
 4032 cd85: 9a                     ghi ra
 4033 cd86: 73                     stxd
 4034 cd87: 8f                     glo rf ; now end value
 4035 cd88: 73                     stxd
 4036 cd89: 9f                     ghi rf
 4037 cd8a: 73                     stxd
 4038 cd8b: 8d                     glo rd ; now step
 4039 cd8c: 73                     stxd
 4040 cd8d: 9d                     ghi rd
 4041 cd8e: 73                     stxd
 4042 cd8f: e2                     sex r2 ; need to retrieve variable address
 4043 cd90: 60                     irx
 4044 cd91: 72                     ldxa
 4045 cd92: bf                     phi rf
 4046 cd93: f0                     ldx
 4047 cd94: af                     plo rf
 4048 cd95: eb                     sex rb ; need to write to for stack
 4049 cd96: 8f                     glo rf
 4050 cd97: 73                     stxd
 4051 cd98: 9f                     ghi rf
 4052 cd99: 73                     stxd
 4053 cd9a: e2                     sex r2 ; point X back to proper stack
 4054 cd9b: f8 01                  ldi high for_pos ; need to write new forstack value
 4055 cd9d: bf                     phi rf
 4056 cd9e: f8 0a                  ldi low for_pos
 4057 cda0: af                     plo rf
 4058 cda1: 9b                     ghi rb
 4059 cda2: 5f                     str rf
 4060 cda3: 1f                     inc rf
 4061 cda4: 8b                     glo rb
 4062 cda5: 5f                     str rf
 4063 cda6: c0 ca b1               lbr chk_term ; done processing
 4064 cda9:             
 4065 cda9:             ; ********************
 4066 cda9:             ; *** Process NEXT ***
 4067 cda9:             ; ********************
 4068 cda9: 0a          ex_next: ldn ra ; need to see if a variable is specified
 4069 cdaa: c2 ce 02               lbz next_nv ; jump for no variable version
 4070 cdad: ff 93                  smi 093h ; colon is also valid
 4071 cdaf: c2 ce 02               lbz next_nv
 4072 cdb2: 0a                     ldn ra ; recover token
 4073 cdb3: d4                     sep scall ; must now be a variable
 4074 cdb4: ff 72                  dw f_isalpha
 4075 cdb6: cb d2 93               lbnf syn_err ; else syntax error
 4076 cdb9: d4                     sep scall ; get address for specified variable
 4077 cdba: c7 92                  dw get_var
 4078 cdbc: c3 d2 98               lbdf err_ret
 4079 cdbf: d7                     sep r7 ; get FOR stack into RB
 4080 cdc0: dc                     db get_rb.0
 4081 cdc1: 01 0a                  dw for_pos
 4082 cdc3:             
 4083 cdc3: 8b          next_lp: glo rb ; make sure it is not empty
 4084 cdc4: fb 5c                  xri for_st.0
 4085 cdc6: ae                     plo re ; save first result
 4086 cdc7: 9b                     ghi rb
 4087 cdc8: fb 01                  xri for_st.1
 4088 cdca: 52                     str r2 ; or with first result
 4089 cdcb: 8e                     glo re
 4090 cdcc: f1                     or
 4091 cdcd: c2 ce 63               lbz next_nf ; jump if next without for
 4092 cdd0: eb                     sex rb ; get inner loop variable
 4093 cdd1: 60                     irx
 4094 cdd2: 72                     ldxa
 4095 cdd3: bd                     phi rd
 4096 cdd4: f0                     ldx
 4097 cdd5: ad                     plo rd
 4098 cdd6: 2b                     dec rb ; move pointer back
 4099 cdd7: 2b                     dec rb
 4100 cdd8: e2                     sex r2 ; X back to stack
 4101 cdd9: 8f                     glo rf ; compare addresses
 4102 cdda: 52                     str r2
 4103 cddb: 8d                     glo rd
 4104 cddc: f3                     xor
 4105 cddd: ae                     plo re ; keep result
 4106 cdde: 9f                     ghi rf
 4107 cddf: 52                     str r2
 4108 cde0: 9d                     ghi rd
 4109 cde1: f3                     xor
 4110 cde2: 52                     str r2 ; or with first result
 4111 cde3: 8e                     glo re
 4112 cde4: f1                     or
 4113 cde5: c2 ce 02               lbz next_nv ; match, so continue
 4114 cde8: 8b                     glo rb ; need to drop loop
 4115 cde9: fc 0a                  adi 10
 4116 cdeb: ab                     plo rb
 4117 cdec: 9b                     ghi rb
 4118 cded: 7c 00                  adci 0
 4119 cdef: bb                     phi rb
 4120 cdf0: 9e                     ghi re ; save baud constant
 4121 cdf1: 52                     str r2
 4122 cdf2: f8 01                  ldi high for_pos ; need to write new pointer
 4123 cdf4: be                     phi re
 4124 cdf5: f8 0a                  ldi low for_pos
 4125 cdf7: ae                     plo re
 4126 cdf8: 9b                     ghi rb
 4127 cdf9: 5e                     str re
 4128 cdfa: 1e                     inc re
 4129 cdfb: 8b                     glo rb
 4130 cdfc: 5e                     str re
 4131 cdfd: f0                     ldx ; recover baud constant
 4132 cdfe: be                     phi re
 4133 cdff: c0 cd c3               lbr next_lp ; see if next loop is correct
 4134 ce02: d7          next_nv: sep r7 ; get FOR stack into RB
 4135 ce03: dc                     db get_rb.0
 4136 ce04: 01 0a                  dw for_pos
 4137 ce06: 8b                     glo rb ; make sure it is not empty
 4138 ce07: fb 5c                  xri for_st.0
 4139 ce09: ae                     plo re ; save first result
 4140 ce0a: 9b                     ghi rb
 4141 ce0b: fb 01                  xri for_st.1
 4142 ce0d: 52                     str r2 ; or with first result
 4143 ce0e: 8e                     glo re
 4144 ce0f: f1                     or
 4145 ce10: c2 ce 63               lbz next_nf ; jump if next without for
 4146 ce13: eb                     sex rb ; use RB for the stack
 4147 ce14: 60                     irx ; recover variable address
 4148 ce15: 72                     ldxa
 4149 ce16: bf                     phi rf
 4150 ce17: 72                     ldxa
 4151 ce18: af                     plo rf
 4152 ce19: 72                     ldxa ; retrieve step
 4153 ce1a: bd                     phi rd
 4154 ce1b: ae                     plo re ; keep copy of high byte of step
 4155 ce1c: 72                     ldxa
 4156 ce1d: ad                     plo rd
 4157 ce1e: ef                     sex rf ; now poiht X to variable
 4158 ce1f: 60                     irx ; sb
 4159 ce20: 8d                     glo rd ; add in step to variable value
 4160 ce21: f4                     add
 4161 ce22: 73                     stxd ; store back into variable
 4162 ce23: ad                     plo rd ; and keep in rd
 4163 ce24: 9d                     ghi rd ; now high byte
 4164 ce25: 74                     adc
 4165 ce26: 5f                     str rf ; place back into variable
 4166 ce27: bd                     phi rd
 4167 ce28: eb                     sex rb ; now point at end value
 4168 ce29: 60                     irx ; lsb
 4169 ce2a: 8e                     glo re ; get sign of step
 4170 ce2b: fe                     shl ; shift into df
 4171 ce2c: cb ce 3a               lbnf next_p ; jump if positive
 4172 ce2f: 8d                     glo rd ; do RD-end
 4173 ce30: f7                     sm
 4174 ce31: 2b                     dec rb
 4175 ce32: 9d                     ghi rd
 4176 ce33: 75                     sdb
 4177 ce34: c3 ce 56               lbdf next_ne ; jump if not at end
 4178 ce37: c0 ce 42               lbr next_ok
 4179 ce3a: 8d          next_p: glo rd ; do end-RD
 4180 ce3b: f5                     sd
 4181 ce3c: 2b                     dec rb ; point to msb
 4182 ce3d: 9d                     ghi rd
 4183 ce3e: 75                     sdb
 4184 ce3f: c3 ce 56               lbdf next_ne ; jump if not at end
 4185 ce42: 60          next_ok: irx ; lsb of end
 4186 ce43: 60                     irx ; msb or ra
 4187 ce44: 60                     irx ; lsb of ra
 4188 ce45: 60                     irx ; msb of rc
 4189 ce46: 60                     irx ; lsb of rc, item is now off the stack
 4190 ce47: e2                     sex r2 ; put X back on proper stack
 4191 ce48: f8 01                  ldi high for_pos ; need to write new forstack value
 4192 ce4a: bf                     phi rf
 4193 ce4b: f8 0a                  ldi low for_pos
 4194 ce4d: af                     plo rf
 4195 ce4e: 9b                     ghi rb
 4196 ce4f: 5f                     str rf
 4197 ce50: 1f                     inc rf
 4198 ce51: 8b                     glo rb
 4199 ce52: 5f                     str rf
 4200 ce53: c0 ca b1               lbr chk_term ; done processing
 4201 ce56: 60          next_ne: irx ; lsb of end
 4202 ce57: 60                     irx ; msb of ra
 4203 ce58: 72                     ldxa ; retrieve token pointer
 4204 ce59: ba                     phi ra
 4205 ce5a: 72                     ldxa
 4206 ce5b: aa                     plo ra
 4207 ce5c: 72                     ldxa ; retrieve current line
 4208 ce5d: bc                     phi rc
 4209 ce5e: f0                     ldx
 4210 ce5f: ac                     plo rc
 4211 ce60: c0 ca b1               lbr chk_term ; continue
 4212 ce63: f8 08       next_nf: ldi ERR_NOFOR
 4213 ce65: ff 00                  smi 0 ; signal an error
 4214 ce67: d5                     sep sret ; and return
 4215 ce68:             
 4216 ce68:             ; ***********************
 4217 ce68:             ; *** Process ON GOTO ***
 4218 ce68:             ; ***********************
 4219 ce68: d4          ex_on: sep scall ; get first argument
 4220 ce69: c1 e7                  dw new_expr
 4221 ce6b: c3 d2 98               lbdf err_ret ; jump if error occurred
 4222 ce6e: 4a                     lda ra ; get next token
 4223 ce6f: ff 1a                  smi CMD_START ; offset for commands
 4224 ce71: ff 83                  smi 83h ; look for GOTO
 4225 ce73: c2 ce 79               lbz on_goto ; jump if so
 4226 ce76: c0 d2 93               lbr syn_err ; otherwise syntax error
 4227 ce79: d7          on_goto: sep r7 ; retrieve value
 4228 ce7a: 58                     db ex_pop.0
 4229 ce7b: 8f                     glo rf ; get low byte
 4230 ce7c: 73          on_gotolp: stxd ; and preserve
 4231 ce7d: 0a                     ldn ra ; see if hit terminator
 4232 ce7e: c2 ca b1               lbz chk_term ; jump if so
 4233 ce81: ff 93                  smi 093h ; colon is also valid
 4234 ce83: c2 ca b1               lbz chk_term
 4235 ce86: d4                     sep scall ; evaluate line number
 4236 ce87: c1 e7                  dw new_expr
 4237 ce89: c3 d2 98               lbdf err_ret ; jump if error occurred
 4238 ce8c: 60                     irx ; recover ON expression
 4239 ce8d: f0                     ldx
 4240 ce8e: ff 01                  smi 1 ; subtract 1
 4241 ce90: c2 c9 24               lbz goto_go2 ; jump if correct entry is found
 4242 ce93: ae                     plo re ; save count
 4243 ce94: 0a                     ldn ra ; check next token
 4244 ce95: c2 ca b1               lbz chk_term ; jump if terminator
 4245 ce98: ff 93                  smi 093h ; or colon
 4246 ce9a: c2 ca b1               lbz chk_term
 4247 ce9d: 4a                     lda ra ; now must be a comma
 4248 ce9e: ff 8d                  smi 8dh
 4249 cea0: ca d2 93               lbnz syn_err ; jump if not
 4250 cea3: 8e                     glo re ; recover count
 4251 cea4: c0 ce 7c               lbr on_gotolp ; and keep lookin
 4252 cea7:             
 4253 cea7:             ; **********************
 4254 cea7:             ; *** Process RANDOM ***
 4255 cea7:             ; **********************
 4256 cea7: d4          ex_random: sep scall ; get input from user
 4257 cea8: bd e9                  dw get_input
 4258 ceaa: c3 d2 98               lbdf err_ret
 4259 cead: f8 01                  ldi high lfsr ; point to lfsr register
 4260 ceaf: bf                     phi rf
 4261 ceb0: f8 5d                  ldi low lfsr
 4262 ceb2: af                     plo rf
 4263 ceb3: f8 00                  ldi 0
 4264 ceb5: 5f                     str rf
 4265 ceb6: 1f                     inc rf
 4266 ceb7: f8 01                  ldi 1
 4267 ceb9: 5f                     str rf
 4268 ceba: 1f                     inc rf
 4269 cebb: 9d                     ghi rd ; write new seed to it
 4270 cebc: 5f                     str rf
 4271 cebd: 1f                     inc rf
 4272 cebe: 8d                     glo rd
 4273 cebf: 5f                     str rf
 4274 cec0: c0 ca b1               lbr chk_term ; done
 4275 cec3:             
 4276 cec3:             
 4277 cec3:             ; ********************
 4278 cec3:             ; *** Process READ ***
 4279 cec3:             ; ********************
 4280 cec3: 0a          ex_read: ldn ra ; get next token
 4281 cec4: 0a          read_lp: ldn ra ; see if done
 4282 cec5: c2 ca b1               lbz chk_term ; jump if so
 4283 cec8: 0a                     ldn ra ; get character
 4284 cec9: d4                     sep scall ; must be a variable name
 4285 ceca: ff 72                  dw f_isalpha
 4286 cecc: cb d2 93               lbnf syn_err ; otherwise error
 4287 cecf: d4                     sep scall ; get variable address
 4288 ced0: c7 92                  dw get_var
 4289 ced2: c3 d2 98               lbdf err_ret
 4290 ced5: 8f                     glo rf ; save variable position
 4291 ced6: 73                     stxd
 4292 ced7: 9f                     ghi rf
 4293 ced8: 73                     stxd
 4294 ced9: d4                     sep scall ; get input
 4295 ceda: c0 23                  dw get_data
 4296 cedc: c3 d2 98               lbdf err_ret ; jump on error
 4297 cedf: 60                     irx ; recover variable address
 4298 cee0: 72                     ldxa
 4299 cee1: bf                     phi rf
 4300 cee2: f0                     ldx
 4301 cee3: af                     plo rf
 4302 cee4: 9d                     ghi rd ; store into variable
 4303 cee5: 5f                     str rf
 4304 cee6: 1f                     inc rf
 4305 cee7: 8d                     glo rd
 4306 cee8: 5f                     str rf
 4307 cee9: 0a                     ldn ra ; get next token
 4308 ceea: c2 ca b1               lbz chk_term ; jump if terminator
 4309 ceed: ff 93                  smi 093h ; colon also ends input
 4310 ceef: c2 ca b1               lbz chk_term
 4311 cef2: 4a                     lda ra ; get next token
 4312 cef3: ff 8d                  smi 08dh ; must be a comma
 4313 cef5: c2 ce c4               lbz read_lp ; process next variable
 4314 cef8: c0 d2 93               lbr syn_err ; otherwise error
 4315 cefb:             
 4316 cefb:             ; ***********************
 4317 cefb:             ; *** Process RESTORE ***
 4318 cefb:             ; ***********************
 4319 cefb: 0a          ex_restore: ldn ra ; see if there is an argument
 4320 cefc: c2 cf 2e               lbz rst_strt ; jump if not
 4321 ceff: ff 93                  smi 093h ; colon is also valid
 4322 cf01: c2 cf 2e               lbz rst_strt
 4323 cf04: d4                     sep scall ; otherwise evaluate argument
 4324 cf05: c1 e7                  dw new_expr
 4325 cf07: c3 d2 98               lbdf err_ret ; jump if error occurrecd
 4326 cf0a: 8c                     glo rc ; save rc
 4327 cf0b: 73                     stxd
 4328 cf0c: 9c                     ghi rc
 4329 cf0d: 73                     stxd
 4330 cf0e: d7                     sep r7 ; retrieve line number
 4331 cf0f: 58                     db ex_pop.0
 4332 cf10: d7                     sep r7 ; transfer to rd
 4333 cf11: 72                     db rf_rd.0
 4334 cf12: d7                     sep r7 ; then find line number
 4335 cf13: 19                     db find_ln.0
 4336 cf14: 9c                     ghi rc ; move to rd
 4337 cf15: bd                     phi rd
 4338 cf16: 8c                     glo rc
 4339 cf17: ad                     plo rd
 4340 cf18: 60                     irx ; retrieve original rc
 4341 cf19: 72                     ldxa
 4342 cf1a: bc                     phi rc
 4343 cf1b: f0                     ldx
 4344 cf1c: ac                     plo rc
 4345 cf1d: cb c9 3f               lbnf err_noln ; no line error
 4346 cf20: f8 01                  ldi high data_lin ; point to pointer location
 4347 cf22: bf                     phi rf
 4348 cf23: f8 02                  ldi low data_lin
 4349 cf25: af                     plo rf
 4350 cf26: 9d                     ghi rd ; save pointer
 4351 cf27: 5f                     str rf
 4352 cf28: 1f                     inc rf
 4353 cf29: 8d                     glo rd
 4354 cf2a: 5f                     str rf
 4355 cf2b: c0 cf 3b               lbr rest_cnt ; ok, continue
 4356 cf2e: f8 01       rst_strt: ldi high data_lin ; point to pointer location
 4357 cf30: bf                     phi rf
 4358 cf31: f8 02                  ldi low data_lin
 4359 cf33: af                     plo rf
 4360 cf34: f8 05                  ldi high pgmtext ; restore to beginning of basic
 4361 cf36: 5f                     str rf
 4362 cf37: 1f                     inc rf
 4363 cf38: f8 b7                  ldi low pgmtext
 4364 cf3a: 5f                     str rf
 4365 cf3b: 2f          rest_cnt: dec rf ; retrieve pointer
 4366 cf3c: 4f                     lda rf ; into rd
 4367 cf3d: bd                     phi rd
 4368 cf3e: 4f                     lda rf
 4369 cf3f: ad                     plo rd
 4370 cf40: 1d                     inc rd ; move to first token
 4371 cf41: 1d                     inc rd
 4372 cf42: 1d                     inc rd
 4373 cf43: 0d                     ldn rd ; and get it
 4374 cf44: ff 1a                  smi CMD_START ; subtract command offset
 4375 cf46: ff 96                  smi 96h ; check for DATA
 4376 cf48: ca cf 5a               lbnz nodata2
 4377 cf4b: 1d                     inc rd ; otherwise point to first data item
 4378 cf4c: f8 01                  ldi high data_pos ; setup data position
 4379 cf4e: bf                     phi rf
 4380 cf4f: f8 04                  ldi low data_pos
 4381 cf51: af                     plo rf
 4382 cf52: 9d                     ghi rd ; and write pointer
 4383 cf53: 5f                     str rf
 4384 cf54: 1f                     inc rf
 4385 cf55: 8d                     glo rd
 4386 cf56: 5f                     str rf
 4387 cf57: c0 ca b1               lbr chk_term ; done
 4388 cf5a: d4          nodata2: sep scall ; find next data statement
 4389 cf5b: c0 70                  dw find_data
 4390 cf5d: c0 ca b1               lbr chk_term ; done
 4391 cf60:             
 4392 cf60:             ; **************************************************
 4393 cf60:             ; *** See if an address is bound to a string var ***
 4394 cf60:             ; *** RF - Address to check ***
 4395 cf60:             ; *** Returns: DF=1 - address in use ***
 4396 cf60:             ; **************************************************
 4397 cf60: 8f          chk_var: glo rf ; put address to check on the stack
 4398 cf61: 73                     stxd
 4399 cf62: 9f                     ghi rf
 4400 cf63: 73                     stxd
 4401 cf64: f8 01                  ldi high var_pos ; need to get variable pointer
 4402 cf66: bf                     phi rf
 4403 cf67: f8 06                  ldi low var_pos
 4404 cf69: af                     plo rf
 4405 cf6a: 4f                     lda rf ; retrieve the pointer into RF
 4406 cf6b: ae                     plo re
 4407 cf6c: 0f                     ldn rf
 4408 cf6d: af                     plo rf
 4409 cf6e: 8e                     glo re
 4410 cf6f: bf                     phi rf
 4411 cf70: 0f          chk_varlp: ldn rf ; get byte
 4412 cf71: c2 cf a3               lbz chk_no ; jump if at end of table
 4413 cf74: 52                     str r2 ; add to address
 4414 cf75: 8f                     glo rf
 4415 cf76: f4                     add
 4416 cf77: af                     plo rf
 4417 cf78: 9f                     ghi rf
 4418 cf79: 7c 00                  adci 0
 4419 cf7b: bf                     phi rf
 4420 cf7c: 2f                     dec rf ; move to type
 4421 cf7d: 2f                     dec rf
 4422 cf7e: 2f                     dec rf
 4423 cf7f: 4f                     lda rf ; get type
 4424 cf80: ff 03                  smi 3 ; is it a string var
 4425 cf82: ca cf 9e               lbnz chk_nst ; jump if not a string
 4426 cf85: 60                     irx ; move to low value of address
 4427 cf86: 4f                     lda rf ; get byte from variable address
 4428 cf87: f7                     sm ; compare the values
 4429 cf88: 60                     irx ; point to high byte of value
 4430 cf89: ca cf 98               lbnz chk_n1 ; jump if no match
 4431 cf8c: 0f                     ldn rf ; get low byte
 4432 cf8d: f7                     sm ; and compare it
 4433 cf8e: ca cf 98               lbnz chk_n1 ; jump if no match
 4434 cf91: 22                     dec r2 ; move stack pointer back
 4435 cf92: 22                     dec r2
 4436 cf93: ff 00                  smi 0 ; signal variable in use
 4437 cf95: c0 cf a5               lbr chk_dn ; finished
 4438 cf98: 22          chk_n1: dec r2 ; move stack pointer back
 4439 cf99: 22                     dec r2
 4440 cf9a: 1f                     inc rf ; move to next variable
 4441 cf9b: c0 cf 70               lbr chk_varlp ; and check it
 4442 cf9e: 1f          chk_nst: inc rf ; move to next variable
 4443 cf9f: 1f                     inc rf
 4444 cfa0: c0 cf 70               lbr chk_varlp
 4445 cfa3: fc 00       chk_no: adi 0 ; signal not in use
 4446 cfa5: 60          chk_dn: irx ; recover address
 4447 cfa6: 72                     ldxa
 4448 cfa7: bf                     phi rf
 4449 cfa8: f0                     ldx
 4450 cfa9: af                     plo rf
 4451 cfaa: d5                     sep sret ; and return
 4452 cfab:             
 4453 cfab:             ; ******************************************************
 4454 cfab:             ; *** Deallocate a string variables prior assignment ***
 4455 cfab:             ; *** RD - pointer to string variable address field ***
 4456 cfab:             ; ******************************************************
 4457 cfab: 2f          de_str: dec rf ; get variable type
 4458 cfac: 4f                     lda rf ; and get it
 4459 cfad: ff 03                  smi 3 ; is it a string
 4460 cfaf: ca bc bd               lbnz return ; jump if not
 4461 cfb2: 8f                     glo rf ; save address
 4462 cfb3: 73                     stxd
 4463 cfb4: 9f                     ghi rf
 4464 cfb5: 73                     stxd
 4465 cfb6: 0f                     ldn rf ; get variable binding
 4466 cfb7: ae                     plo re
 4467 cfb8: f8 00                  ldi 0 ; delete binding
 4468 cfba: 5f                     str rf
 4469 cfbb: 1f                     inc rf
 4470 cfbc: 0f                     ldn rf
 4471 cfbd: af                     plo rf ; into rf
 4472 cfbe: 8e                     glo re
 4473 cfbf: bf                     phi rf
 4474 cfc0: d4                     sep scall ; dealloate current binding
 4475 cfc1: d0 2b                  dw dealloc
 4476 cfc3: 60                     irx ; recover address
 4477 cfc4: 72                     ldxa
 4478 cfc5: bf                     phi rf
 4479 cfc6: f0                     ldx
 4480 cfc7: af                     plo rf
 4481 cfc8: d5                     sep sret ; and return
 4482 cfc9:             
 4483 cfc9:             ; **************************************
 4484 cfc9:             ; *** Consolidate heap memory blocks ***
 4485 cfc9:             ; **************************************
 4486 cfc9: 8f          consol: glo rf ; save consumed registers
 4487 cfca: 73                     stxd
 4488 cfcb: 9f                     ghi rf
 4489 cfcc: 73                     stxd
 4490 cfcd: 8d                     glo rd ; save consumed registers
 4491 cfce: 73                     stxd
 4492 cfcf: 9d                     ghi rd
 4493 cfd0: 73                     stxd
 4494 cfd1: f8 01                  ldi high heap ; need to see if below heap
 4495 cfd3: bf                     phi rf
 4496 cfd4: f8 08                  ldi low heap
 4497 cfd6: af                     plo rf
 4498 cfd7: 4f                     lda rf ; retrieve the pointer
 4499 cfd8: ae                     plo re
 4500 cfd9: 0f                     ldn rf
 4501 cfda: af                     plo rf
 4502 cfdb: 8e                     glo re
 4503 cfdc: bf                     phi rf
 4504 cfdd: 0f          cons_lp: ldn rf ; get flag byte
 4505 cfde: c2 d0 00               lbz cons_z ; jump if free block
 4506 cfe1: fb ff                  xri 0ffh ; see if end of heap
 4507 cfe3: c2 cf f6               lbz cons_dn ; jump if so
 4508 cfe6: d7          cons_nxt: sep r7 ; copy rf to rd
 4509 cfe7: 72                     db rf_rd.0
 4510 cfe8: 1d                     inc rd ; point to lsb of size
 4511 cfe9: 1d                     inc rd
 4512 cfea: ed                     sex rd ; use this as data pointer
 4513 cfeb: 8f                     glo rf ; and add to rf
 4514 cfec: f4                     add
 4515 cfed: af                     plo rf
 4516 cfee: 2d                     dec rd
 4517 cfef: 9f                     ghi rf
 4518 cff0: 74                     adc
 4519 cff1: bf                     phi rf
 4520 cff2: e2                     sex r2 ; put stack back
 4521 cff3: c0 cf dd               lbr cons_lp ; loop until done
 4522 cff6: 60          cons_dn: irx ; recover consumed registers
 4523 cff7: 72                     ldxa
 4524 cff8: bd                     phi rd
 4525 cff9: 72                     ldxa
 4526 cffa: ad                     plo rd
 4527 cffb: 72                     ldxa
 4528 cffc: bf                     phi rf
 4529 cffd: f0                     ldx
 4530 cffe: af                     plo rf
 4531 cfff: d5                     sep sret ; and return
 4532 d000: d7          cons_z: sep r7 ; copy rf to rd
 4533 d001: 72                     db rf_rd.0
 4534 d002: 1f                     inc rf ; point to lsb of block size
 4535 d003: 1f                     inc rf
 4536 d004: ef                     sex rf ; use this as data pointer
 4537 d005: 8d                     glo rd ; add block size to address
 4538 d006: f4                     add
 4539 d007: ad                     plo rd
 4540 d008: 2f                     dec rf
 4541 d009: 9d                     ghi rd
 4542 d00a: 74                     adc
 4543 d00b: bd                     phi rd
 4544 d00c: 2f                     dec rf ; rf back to flag byte
 4545 d00d: e2                     sex r2 ; X back to stack
 4546 d00e: 0d                     ldn rd ; get flag byte of next entry
 4547 d00f: fb ff                  xri 0ffh ; check for end
 4548 d011: c2 cf f6               lbz cons_dn ; jump of at end
 4549 d014: fb ff                  xri 0ffh
 4550 d016: ca cf e6               lbnz cons_nxt ; jump if not an empty block
 4551 d019: 1d                     inc rd ; move next entry pointer to lsb of size
 4552 d01a: 1d                     inc rd
 4553 d01b: 1f                     inc rf ; move curernt pointer to lsb
 4554 d01c: 1f                     inc rf
 4555 d01d: ed                     sex rd ; use 2nd entry as data
 4556 d01e: 0f                     ldn rf ; add sizes together
 4557 d01f: f4                     add
 4558 d020: 5f                     str rf
 4559 d021: 2f                     dec rf ; move poitners to msb
 4560 d022: 2d                     dec rd
 4561 d023: 0f                     ldn rf
 4562 d024: 74                     adc
 4563 d025: 5f                     str rf
 4564 d026: e2                     sex r2 ; set x back to stack
 4565 d027: 2f                     dec rf ; move back to flag byte
 4566 d028: c0 cf dd               lbr cons_lp ; and keep looking
 4567 d02b:             
 4568 d02b:             ; *******************************
 4569 d02b:             ; *** Deallocate heap memory ***
 4570 d02b:             ; *** RF - address to dealloc ***
 4571 d02b:             ; *******************************
 4572 d02b: d4          dealloc: sep scall ; see if variable uses address
 4573 d02c: cf 60                  dw chk_var
 4574 d02e: c3 bc bd               lbdf return ; do not deallocate if variable is using
 4575 d031: 8d                     glo rd ; preserve RD
 4576 d032: 73                     stxd
 4577 d033: 9d                     ghi rd
 4578 d034: 73                     stxd
 4579 d035: f8 01                  ldi high heap ; need to see if below heap
 4580 d037: bd                     phi rd
 4581 d038: f8 08                  ldi low heap
 4582 d03a: ad                     plo rd
 4583 d03b: 1d                     inc rd ; point to low byte
 4584 d03c: ed                     sex rd ; use rd as data pointer
 4585 d03d: 8f                     glo rf ; subtract request address
 4586 d03e: f7                     sm
 4587 d03f: 2d                     dec rd ; point to msb
 4588 d040: 9f                     ghi rf
 4589 d041: 77                     smb
 4590 d042: e2                     sex r2 ; point X back to stack
 4591 d043: 60                     irx ; recover RD
 4592 d044: 72                     ldxa
 4593 d045: bd                     phi rd
 4594 d046: f0                     ldx
 4595 d047: ad                     plo rd
 4596 d048: cb bc bd               lbnf return ; jump if address is not in heap
 4597 d04b: 2f                     dec rf ; move to flag byte
 4598 d04c: 2f                     dec rf
 4599 d04d: 2f                     dec rf
 4600 d04e: f8 00                  ldi 0 ; mark as unused block
 4601 d050: 5f                     str rf
 4602 d051: 1f                     inc rf ; restore rf
 4603 d052: 1f                     inc rf
 4604 d053: 1f                     inc rf
 4605 d054: d4                     sep scall ; consolidate free blocks
 4606 d055: cf c9                  dw consol
 4607 d057: d5                     sep sret ; and return to caller
 4608 d058:             
 4609 d058:             ; ******************************************
 4610 d058:             ; *** Check for heap/var table collision ***
 4611 d058:             ; *** Returns: DF=1 out of memory ***
 4612 d058:             ; ******************************************
 4613 d058: 8f          chk_om: glo rf ; save consumed registers
 4614 d059: 73                     stxd
 4615 d05a: 9f                     ghi rf
 4616 d05b: 73                     stxd
 4617 d05c: 8d                     glo rd ; save consumed registers
 4618 d05d: 73                     stxd
 4619 d05e: 9d                     ghi rd
 4620 d05f: 73                     stxd
 4621 d060: d4                     sep scall ; get end of variables
 4622 d061: c0 06                  dw end_vars
 4623 d063: f8 01                  ldi high heap ; point to heap pointer
 4624 d065: bd                     phi rd
 4625 d066: f8 08                  ldi low heap
 4626 d068: ad                     plo rd
 4627 d069: 1d                     inc rd ; point to lsb
 4628 d06a: ed                     sex rd ; point x to heap pointer
 4629 d06b: 8f                     glo rf ; perform vars-heap
 4630 d06c: f7                     sm
 4631 d06d: 2d                     dec rd
 4632 d06e: 9f                     ghi rf
 4633 d06f: 77                     smb
 4634 d070: e2                     sex r2 ; point X back to stack
 4635 d071: cb d0 79               lbnf not_om ; jump if no overlap
 4636 d074: ff 00                  smi 0 ; signal memory error
 4637 d076: f8 0a                  ldi ERR_NOMEM
 4638 d078: c8                     lskp
 4639 d079: fc 00       not_om: adi 0 ; signal good
 4640 d07b: ae                     plo re ; save return value
 4641 d07c: 60                     irx ; recover consumed registers
 4642 d07d: 72                     ldxa
 4643 d07e: bd                     phi rd
 4644 d07f: 72                     ldxa
 4645 d080: ad                     plo rd
 4646 d081: 72                     ldxa
 4647 d082: bf                     phi rf
 4648 d083: f0                     ldx
 4649 d084: af                     plo rf
 4650 d085: 8e                     glo re ; recover result code
 4651 d086: d5                     sep sret ; and return
 4652 d087:             
 4653 d087:             ; **********************************
 4654 d087:             ; *** Allocate space on the heap ***
 4655 d087:             ; *** RF - size to allocate ***
 4656 d087:             ; *** Returns: RF - address ***
 4657 d087:             ; *** DF=1 - no memory ***
 4658 d087:             ; **********************************
 4659 d087: f8 01       alloc: ldi high heap ; get heap pointer
 4660 d089: bd                     phi rd
 4661 d08a: f8 08                  ldi low heap
 4662 d08c: ad                     plo rd
 4663 d08d: 4d                     lda rd ; and retrieve it
 4664 d08e: ae                     plo re
 4665 d08f: 0d                     ldn rd
 4666 d090: ad                     plo rd
 4667 d091: 8e                     glo re
 4668 d092: bd                     phi rd ; rd now has heap pointer
 4669 d093: 1f                     inc rf ; include header size in comparisons
 4670 d094: 1f                     inc rf
 4671 d095: 1f                     inc rf
 4672 d096: 0d          alloc_lp1: ldn rd ; get flag byte
 4673 d097: c2 d0 b0               lbz alloc_z ; check empty block
 4674 d09a: fb ff                  xri 0ffh ; see if at end of memory
 4675 d09c: c2 d1 10               lbz alloc_e ; jump if so
 4676 d09f:             
 4677 d09f: 1d          alloc_no: inc rd ; point to msb of size
 4678 d0a0: 4d                     lda rd ; retrieve it
 4679 d0a1: 73                     stxd ; place onto stack
 4680 d0a2: 0d                     ldn rd ; get lsb
 4681 d0a3: 52                     str r2 ; and place in memory
 4682 d0a4: 2d                     dec rd ; move rd back to flag byte
 4683 d0a5: 2d                     dec rd
 4684 d0a6: 8d                     glo rd ; and add offset
 4685 d0a7: f4                     add
 4686 d0a8: ad                     plo rd
 4687 d0a9: 60                     irx ; point to next location
 4688 d0aa: 9d                     ghi rd
 4689 d0ab: 74                     adc
 4690 d0ac: bd                     phi rd ; rd now has new offset
 4691 d0ad: c0 d0 96               lbr alloc_lp1 ; check this entry
 4692 d0b0: 1d          alloc_z: inc rd ; move to lsb of block size
 4693 d0b1: 1d                     inc rd
 4694 d0b2: ed                     sex rd ; use size as data pointer
 4695 d0b3: 8f                     glo rf ; perform SIZEb - SIZEr
 4696 d0b4: f5                     sd
 4697 d0b5: 52                     str r2 ; save result
 4698 d0b6: 2d                     dec rd ; move to msb
 4699 d0b7: 9f                     ghi rf ; and continue subtraction
 4700 d0b8: 75                     sdb
 4701 d0b9: ae                     plo re ; RE:[R2] has difference
 4702 d0ba: 2d                     dec rd ; rd now back at flag
 4703 d0bb: e2                     sex r2 ; X back to stack
 4704 d0bc: cb d0 9f               lbnf alloc_no ; jump if not enough space
 4705 d0bf: f8 01                  ldi 1 ; allocate this block
 4706 d0c1: 5d                     str rd
 4707 d0c2: 02                     ldn r2 ; see if difference is greater than 5 bytes
 4708 d0c3: ff 05                  smi 5
 4709 d0c5: 8e                     glo re
 4710 d0c6: 7f 00                  smbi 0
 4711 d0c8: cb d1 06               lbnf no_split ; jump if block too small to split
 4712 d0cb: 9e                     ghi re ; save baud constant
 4713 d0cc: 73                     stxd
 4714 d0cd: 1d                     inc rd ; retrieve current block size
 4715 d0ce: 4d                     lda rd ; retreive current size
 4716 d0cf: be                     phi re
 4717 d0d0: 0d                     ldn rd
 4718 d0d1: ae                     plo re ; re now has original block size
 4719 d0d2: 8f                     glo rf ; write new block size
 4720 d0d3: 5d                     str rd
 4721 d0d4: 2d                     dec rd
 4722 d0d5: 9f                     ghi rf
 4723 d0d6: 5d                     str rd ; rd is at msb of block size
 4724 d0d7: 8e                     glo re ; find size for next block
 4725 d0d8: 52                     str r2
 4726 d0d9: 8f                     glo rf
 4727 d0da: f5                     sd
 4728 d0db: ae                     plo re
 4729 d0dc: 9e                     ghi re
 4730 d0dd: 52                     str r2
 4731 d0de: 9f                     ghi rf
 4732 d0df: 75                     sdb
 4733 d0e0: be                     phi re ; re now has size of next block
 4734 d0e1: 2d                     dec rd ; move rd back to flags byte
 4735 d0e2: 8d                     glo rd ; save this address
 4736 d0e3: 73                     stxd
 4737 d0e4: 9d                     ghi rd
 4738 d0e5: 73                     stxd
 4739 d0e6: 8f                     glo rf ; add in block size
 4740 d0e7: 52                     str r2
 4741 d0e8: 8d                     glo rd
 4742 d0e9: f4                     add
 4743 d0ea: ad                     plo rd
 4744 d0eb: 9f                     ghi rf
 4745 d0ec: 52                     str r2
 4746 d0ed: 9d                     ghi rd
 4747 d0ee: 74                     adc
 4748 d0ef: bd                     phi rd
 4749 d0f0: f8 00                  ldi 0 ; signal an empty block
 4750 d0f2: 5d                     str rd
 4751 d0f3: 1d                     inc rd
 4752 d0f4: 9e                     ghi re ; write block size
 4753 d0f5: 5d                     str rd
 4754 d0f6: 1d                     inc rd
 4755 d0f7: 8e                     glo re
 4756 d0f8: 5d                     str rd
 4757 d0f9: 60                     irx ; recover entry address
 4758 d0fa: 72                     ldxa
 4759 d0fb: bf                     phi rf ; into rf
 4760 d0fc: 72                     ldxa
 4761 d0fd: af                     plo rf
 4762 d0fe: f0                     ldx ; also recover baud constant
 4763 d0ff: be                     phi re
 4764 d100: 1f                     inc rf ; move to first free memory address
 4765 d101: 1f                     inc rf
 4766 d102: 1f                     inc rf
 4767 d103: fc 00                  adi 0 ; signal no error
 4768 d105: d5                     sep sret ; and return
 4769 d106:             
 4770 d106: 1d          no_split: inc rd ; move to first spot in memory
 4771 d107: 1d                     inc rd
 4772 d108: 1d                     inc rd
 4773 d109: 9d                     ghi rd ; and transfer to RF
 4774 d10a: bf                     phi rf
 4775 d10b: 8d                     glo rd
 4776 d10c: af                     plo rf
 4777 d10d: fc 00                  adi 0 ; signal success
 4778 d10f: d5                     sep sret ; and return
 4779 d110:             
 4780 d110: 2f          alloc_e: dec rf ; rf back to its original value
 4781 d111: 2f                     dec rf
 4782 d112: 2f                     dec rf
 4783 d113: f8 01                  ldi high heap ; get heap pointer
 4784 d115: bd                     phi rd
 4785 d116: f8 08                  ldi low heap
 4786 d118: ad                     plo rd
 4787 d119: 4d                     lda rd ; and retrieve it
 4788 d11a: ae                     plo re
 4789 d11b: 8f                     glo rf ; subtract size from pointer
 4790 d11c: 52                     str r2
 4791 d11d: 0d                     ldn rd
 4792 d11e: f7                     sm
 4793 d11f: ad                     plo rd
 4794 d120: 9f                     ghi rf ; now high byte
 4795 d121: 52                     str r2
 4796 d122: 8e                     glo re
 4797 d123: 77                     smb
 4798 d124: bd                     phi rd
 4799 d125: 2d                     dec rd ; decrement 3 for flag and offset
 4800 d126: 2d                     dec rd
 4801 d127: 2d                     dec rd ; now pointing at new block
 4802 d128: 9e                     ghi re ; save baud constant
 4803 d129: 52                     str r2
 4804 d12a: f8 01                  ldi high heap ; need to save new heap pointer
 4805 d12c: be                     phi re
 4806 d12d: f8 08                  ldi low heap
 4807 d12f: ae                     plo re
 4808 d130: 9d                     ghi rd ; write pointer
 4809 d131: 5e                     str re
 4810 d132: 1e                     inc re
 4811 d133: 8d                     glo rd
 4812 d134: 5e                     str re
 4813 d135: 02                     ldn r2 ; recover re
 4814 d136: be                     phi re
 4815 d137:             
 4816 d137: d4                     sep scall ; check if memory error
 4817 d138: d0 58                  dw chk_om
 4818 d13a: c3 d2 98               lbdf err_ret ; jump if error
 4819 d13d: 1f                     inc rf ; change request size to add header
 4820 d13e: 1f                     inc rf
 4821 d13f: 1f                     inc rf
 4822 d140: f8 01                  ldi 1 ; set block as used
 4823 d142: 5d                     str rd
 4824 d143: 1d                     inc rd
 4825 d144: 9f                     ghi rf ; store size
 4826 d145: 5d                     str rd
 4827 d146: 1d                     inc rd
 4828 d147: 8f                     glo rf
 4829 d148: 5d                     str rd
 4830 d149: 1d                     inc rd ; move pointer to fisrt of memory block
 4831 d14a: 8d                     glo rd ; and transfer to rf
 4832 d14b: af                     plo rf
 4833 d14c: 9d                     ghi rd
 4834 d14d: bf                     phi rf
 4835 d14e: fc 00                  adi 0 ; signal success
 4836 d150: d5                     sep sret ; and return
 4837 d151:             
 4838 d151:             
 4839 d151:             ; *******************
 4840 d151:             ; *** Process DIM ***
 4841 d151:             ; *******************
 4842 d151: 0a          ex_dim: ldn ra ; see if terminator
 4843 d152: c2 ca b1               lbz chk_term ; jump if so
 4844 d155: ff 93                  smi 093h ; colon is also valid
 4845 d157: c2 ca b1               lbz chk_term ; end on colon as well
 4846 d15a: 0a                     ldn ra ; check for valid variable name
 4847 d15b: d4                     sep scall
 4848 d15c: ff 72                  dw f_isalpha
 4849 d15e: cb d2 93               lbnf syn_err ; jump if not possible variable
 4850 d161: d4                     sep scall ; get end of variable table
 4851 d162: c0 06                  dw end_vars
 4852 d164: d7                     sep r7 ; copy rf to rd
 4853 d165: 72                     db rf_rd.0
 4854 d166: 1f                     inc rf ; point to name field
 4855 d167: 4a          dim_lp1: lda ra ; get byte from input stream
 4856 d168: d4                     sep scall ; see if valid for variable names
 4857 d169: ff 78                  dw f_isalnum
 4858 d16b: cb d1 73               lbnf dim_2 ; jump if not
 4859 d16e: 5f                     str rf ; store into variable entry
 4860 d16f: 1f                     inc rf
 4861 d170: c0 d1 67               lbr dim_lp1 ; loop until end of name found
 4862 d173: 2a          dim_2: dec ra ; need to reget last char
 4863 d174: 4a                     lda ra
 4864 d175: fb 84                  xri 84h ; must be a (
 4865 d177: ca d2 93               lbnz syn_err ; else syntax error
 4866 d17a: fb 84                  xri 84h ; put it back
 4867 d17c: 5f                     str rf ; and store into output buffer
 4868 d17d: 1f                     inc rf
 4869 d17e: f8 12                  ldi 12h ; indicator for integer array
 4870 d180: 5f                     str rf
 4871 d181: 1f                     inc rf
 4872 d182:             
 4873 d182: 1f            inc rf
 4874 d183: 1f            inc rf
 4875 d184: f8 00         ldi 0
 4876 d186: 5f            str rf
 4877 d187: 2f            dec rf
 4878 d188: 2f            dec rf
 4879 d189:             
 4880 d189: 8d                     glo rd ; can now compute size
 4881 d18a: 52                     str r2
 4882 d18b: 8f                     glo rf
 4883 d18c: f7                     sm
 4884 d18d: fc 02                  adi 2 ; add in 3 bytes for address and size
 4885 d18f: 5d                     str rd ; store into size
 4886 d190: 8f                     glo rf ; save address for later
 4887 d191: 73                     stxd
 4888 d192: 9f                     ghi rf
 4889 d193: 73                     stxd
 4890 d194: d4                     sep scall ; process first argument
 4891 d195: c1 e7                  dw new_expr
 4892 d197: c3 d2 45               lbdf ret_2 ; jump if error occurred
 4893 d19a: d7                     sep r7 ; need to add 1
 4894 d19b: 58                     db ex_pop.0
 4895 d19c: 1f                     inc rf
 4896 d19d: d7                     sep r7
 4897 d19e: 6a                     db ex_push
 4898 d19f: f8 01                  ldi 1 ; indicate 1 dimension
 4899 d1a1: 73                     stxd
 4900 d1a2: 0a          dim_args: ldn ra ; need to check next token
 4901 d1a3: ff 8d                  smi 08dh ; is it a comma
 4902 d1a5: ca d1 bc               lbnz single
 4903 d1a8: 1a                     inc ra ; move past comma
 4904 d1a9: d4                     sep scall ; evaluate second argument
 4905 d1aa: c1 ed                  dw expr
 4906 d1ac: c3 d2 45               lbdf ret_2 ; jump if error occurred
 4907 d1af: d7                     sep r7 ; need to add 1
 4908 d1b0: 58                     db ex_pop.0
 4909 d1b1: 1f                     inc rf
 4910 d1b2: d7                     sep r7
 4911 d1b3: 6a                     db ex_push
 4912 d1b4: 60                     irx ; get argument count
 4913 d1b5: f0                     ldx
 4914 d1b6: fc 01                  adi 1
 4915 d1b8: 73                     stxd ; and keep on stack
 4916 d1b9: c0 d1 a2               lbr dim_args ; loop for possible other dimensions
 4917 d1bc: 99          single: ghi r9 ; set rb=r9
 4918 d1bd: bb                     phi rb
 4919 d1be: 89                     glo r9
 4920 d1bf: ab                     plo rb
 4921 d1c0: 60                     irx ; recover dimension count
 4922 d1c1: f0                     ldx
 4923 d1c2: 22                     dec r2 ; and keep on stack
 4924 d1c3: 1b                     inc rb ; point rb to first argument
 4925 d1c4: ae                     plo re ; put count into re
 4926 d1c5: 4b          copylp1: lda rb ; get argument
 4927 d1c6: bf                     phi rf
 4928 d1c7: 4b                     lda rb
 4929 d1c8: af                     plo rf
 4930 d1c9: d7                     sep r7 ; make copy on top of expression stack
 4931 d1ca: 6a                     db ex_push.0
 4932 d1cb: 2e                     dec re ; see if done
 4933 d1cc: 8e                     glo re ; get count
 4934 d1cd: ca d1 c5               lbnz copylp1 ; jump if not doen
 4935 d1d0: 60                     irx ; get dimension count
 4936 d1d1: f0                     ldx
 4937 d1d2: 73                     stxd ; keep on stack twice
 4938 d1d3: 73                     stxd
 4939 d1d4: 60          mullp: irx ; get count
 4940 d1d5: f0                     ldx
 4941 d1d6: ff 01                  smi 1 ; minus 1
 4942 d1d8: c2 d1 e2               lbz muldn ; jump if no more multiplies needed
 4943 d1db: 73                     stxd ; put count back on stack
 4944 d1dc: d4                     sep scall ; and multiply top 2 elements
 4945 d1dd: c1 8b                  dw ex_mul
 4946 d1df: c0 d1 d4               lbr mullp ; jump back and see if done
 4947 d1e2: 4a          muldn: lda ra ; get next token
 4948 d1e3: ff 85                  smi 085h ; must be a )
 4949 d1e5: ca d2 45               lbnz ret_2 ; else syntax error
 4950 d1e8: d7                     sep r7 ; get dimension
 4951 d1e9: 58                     db ex_pop.0
 4952 d1ea: 8f                     glo rf ; 2 bytes per entry
 4953 d1eb: fe                     shl
 4954 d1ec: af                     plo rf
 4955 d1ed: 9f                     ghi rf
 4956 d1ee: 7e                     shlc
 4957 d1ef: bf                     phi rf
 4958 d1f0: 1f                     inc rf ; also space for size and dimensions
 4959 d1f1: 60                     irx ; get number of dimensions
 4960 d1f2: f0                     ldx
 4961 d1f3: 22                     dec r2 ; and keep on stack
 4962 d1f4: 1f          mullp2: inc rf
 4963 d1f5: 1f                     inc rf
 4964 d1f6: ff 01                  smi 1 ; subtract 1 from count
 4965 d1f8: ca d1 f4               lbnz mullp2 ; loop back if need more space
 4966 d1fb: d4                     sep scall ; allocate the memory
 4967 d1fc: d0 87                  dw alloc
 4968 d1fe: c3 d2 41               lbdf om_error ; jump if could not allocate the memory
 4969 d201: 60                     irx ; retrieve address
 4970 d202: 72                     ldxa ; first is the dimension count
 4971 d203: ab                     plo rb ; set it aside for now
 4972 d204: 72                     ldxa
 4973 d205: bd                     phi rd
 4974 d206: f0                     ldx
 4975 d207: ad                     plo rd
 4976 d208: 9f                     ghi rf ; write address into variable record
 4977 d209: 5d                     str rd
 4978 d20a: 1d                     inc rd
 4979 d20b: 8f                     glo rf
 4980 d20c: 5d                     str rd
 4981 d20d: 1d                     inc rd
 4982 d20e: f8 00                  ldi 0 ; werite terminating zero
 4983 d210: 5d                     str rd
 4984 d211: 8b                     glo rb ; get dimension count
 4985 d212: 5f                     str rf
 4986 d213: 1f                     inc rf
 4987 d214: ae                     plo re ; and place into re
 4988 d215: d7                     sep r7 ; move rf to rd
 4989 d216: 72                     db rf_rd.0
 4990 d217: 99                     ghi r9 ; set rb=r9
 4991 d218: bb                     phi rb
 4992 d219: 89                     glo r9
 4993 d21a: ab                     plo rb
 4994 d21b: 1b                     inc rb
 4995 d21c: 8e                     glo re ; get dimenstion count
 4996 d21d: 1d          dim_lp4: inc rd ; move pointer
 4997 d21e: 1d                     inc rd
 4998 d21f: ff 01                  smi 1 ; subtract from count
 4999 d221: ca d2 1d               lbnz dim_lp4 ; loop until done
 5000 d224: 4b          dim_lp3: lda rb
 5001 d225: 5d                     str rd
 5002 d226: 2d                     dec rd
 5003 d227: 4b                     lda rb
 5004 d228: 5d                     str rd
 5005 d229: 2d                     dec rd
 5006 d22a: 2e                     dec re ; see if done with dimensions
 5007 d22b: 8e                     glo re
 5008 d22c: ca d2 24               lbnz dim_lp3 ; loop back if not
 5009 d22f:             
 5010 d22f: 0a                     ldn ra ; check ending
 5011 d230: c2 ca b1               lbz chk_term ; done if terminator found
 5012 d233: ff 93                  smi 093h ; colon is also valid
 5013 d235: c2 ca b1               lbz chk_term ; end on colon as well
 5014 d238: 4a                     lda ra ; otherwise must be a comma
 5015 d239: ff 8d                  smi 8dh
 5016 d23b: ca d2 93               lbnz syn_err
 5017 d23e: c0 d1 51               lbr ex_dim ; loop for more
 5018 d241:             
 5019 d241:             
 5020 d241: f8 0a       om_error: ldi ERR_NOMEM ; indicate out of memory
 5021 d243: ff 00                  smi 0
 5022 d245: 60          ret_2: irx ; remove rf from stack
 5023 d246: 60                     irx
 5024 d247: d5                     sep sret ; and return
 5025 d248:             
 5026 d248:             ; ******************************************************************************
 5027 d248:             ; *** End of L2 statements ***
 5028 d248:             ; ******************************************************************************
 5029 d248:             
 5030 d248:             
 5031 d248:             ; ******************************************
 5032 d248:             ; *** Now for the BASIC execution engine ***
 5033 d248:             ; *** RA - address of tokens to execute ***
 5034 d248:             ; *** RC - current line number ***
 5035 d248:             ; *** Returns: DF=0 - success ***
 5036 d248:             ; *** DF=1 - Error ***
 5037 d248:             ; *** D - Error code ***
 5038 d248:             ; ******************************************
 5039 d248: 3f 4f       execute: bn4 exec_1 ; jump if EF4 not asserted
 5040 d24a: f8 00                  ldi ERR_BREAK ; otherwise breat
 5041 d24c: ff 00                  smi 0
 5042 d24e: d5                     sep sret
 5043 d24f: 0a          exec_1: ldn ra ; get token
 5044 d250: c2 d2 77               lbz exec_dn ; jump if at end of statement
 5045 d253: ff fd                  smi TKN_QSTR ; quoted strings cannot be first command
 5046 d255: c2 d2 93               lbz syn_err ; syntax error
 5047 d258: ff 01                  smi 1 ; neither can numbers
 5048 d25a: c2 d2 93               lbz syn_err
 5049 d25d: 0a                     ldn ra ; get token again
 5050 d25e: d4                     sep scall ; see if possible variable
 5051 d25f: ff 72                  dw f_isalpha
 5052 d261: c3 c9 c0               lbdf ex_let ; if so, treat as LET
 5053 d264: fa 80                  ani 080h ; see if token or unquoted string
 5054 d266: c2 d2 93               lbz syn_err ; for now, unqoted strings are erros
 5055 d269: 4a                     lda ra ; get token
 5056 d26a: fa 7f                  ani 07fh ; strip token bit
 5057 d26c: ff 1a                  smi CMD_START ; check for PRINT
 5058 d26e: cb d2 93               lbnf syn_err ; jump if function instead of statement
 5059 d271: af                     plo rf
 5060 d272: d7                     sep r7 ; execute command
 5061 d273: 8c                     db do_cmd.0
 5062 d274:             
 5063 d274: c0 d2 93               lbr syn_err ; failed to find command
 5064 d277:             
 5065 d277: 8c          exec_dn: glo rc ; see if we were in run mode
 5066 d278: 52                     str r2
 5067 d279: 9c                     ghi rc
 5068 d27a: f1                     or
 5069 d27b: c2 d2 8a               lbz good_ret ; if not, then good return
 5070 d27e: d7          exec_run: sep r7 ; need to get next line
 5071 d27f: 48                     db next_ln.0
 5072 d280: 9f                     ghi rf ; setup addresses
 5073 d281: bc                     phi rc
 5074 d282: ba                     phi ra
 5075 d283: 8f                     glo rf
 5076 d284: ac                     plo rc
 5077 d285: aa                     plo ra
 5078 d286: 0a          exec_tst: ldn ra ; see if at end of program
 5079 d287: ca d2 8d               lbnz exec_go ; execute new line if not
 5080 d28a: fc 00       good_ret: adi 0 ; signal no errors
 5081 d28c: d5                     sep sret ; and return
 5082 d28d: 1a          exec_go: inc ra ; move past size and line number
 5083 d28e: 1a                     inc ra
 5084 d28f: 1a                     inc ra
 5085 d290: c0 d2 48               lbr execute ; and execute new line
 5086 d293:             
 5087 d293: f8 02       syn_err: ldi ERR_SYN ; signal syntax error
 5088 d295: c8                     lskp
 5089 d296: f8 05       val_err: ldi ERR_VAL ; signal syntax error
 5090 d298: ff 00       err_ret: smi 0 ; be sure error flag is set
 5091 d29a: d5                     sep sret ; and return
 5092 d29b:             
 5093 d29b:             ; *****************************************
 5094 d29b:             ; *** Find size from RF to end of basic ***
 5095 d29b:             ; *** RF - start of line ***
 5096 d29b:             ; *** Returns: RC - count of bytes ***
 5097 d29b:             ; *****************************************
 5098 d29b: 8f          size_end: glo rf ; save RF
 5099 d29c: 73                     stxd
 5100 d29d: 9f                     ghi rf
 5101 d29e: 73                     stxd
 5102 d29f: f8 00                  ldi 0 ; setup count
 5103 d2a1: ac                     plo rc
 5104 d2a2: bc                     phi rc
 5105 d2a3: 0f          size_lp: ldn rf ; see if at end
 5106 d2a4: c2 d2 ba               lbz size_dn ; jump if end found
 5107 d2a7: ef                     sex rf
 5108 d2a8: 8c                     glo rc ; add count to total
 5109 d2a9: f4                     add
 5110 d2aa: ac                     plo rc
 5111 d2ab: 9c                     ghi rc ; propagate carry
 5112 d2ac: 7c 00                  adci 0
 5113 d2ae: bc                     phi rc
 5114 d2af: 8f                     glo rf ; add count into line position
 5115 d2b0: f4                     add
 5116 d2b1: af                     plo rf ; and set as new line position
 5117 d2b2: 9f                     ghi rf ; propagate carry
 5118 d2b3: 7c 00                  adci 0
 5119 d2b5: bf                     phi rf
 5120 d2b6: e2                     sex r2
 5121 d2b7: c0 d2 a3               lbr size_lp ; keep looping until end
 5122 d2ba: 60          size_dn: irx ; recover RF
 5123 d2bb: 72                     ldxa
 5124 d2bc: bf                     phi rf
 5125 d2bd: f0                     ldx
 5126 d2be: af                     plo rf
 5127 d2bf: 1c                     inc rc ; add in program terminator
 5128 d2c0: d5                     sep sret ; and return to caller
            # 5268 "rcbasic.asm"
 5130 d2c1: f8 05       begin2: ldi high stack ; restart address here
 5131 d2c3: b2                     phi r2
 5132 d2c4: f8 35                  ldi low stack
 5133 d2c6: a2                     plo r2
 5134 d2c7: f8 bb                  ldi high restart ; setup for start
 5135 d2c9: b6                     phi r6
 5136 d2ca: f8 50                  ldi low restart
 5137 d2cc: a6                     plo r6
 5138 d2cd: e2                     sex r2 ; point X to stack
 5139 d2ce: c0 ff 3f               lbr f_initcall ; setup SCALL and SRET
 5140 d2d1: f8 05       begin: ldi high stack ; setup stack
 5141 d2d3: b2                     phi r2
 5142 d2d4: f8 35                  ldi low stack
 5143 d2d6: a2                     plo r2
 5144 d2d7: f8 bb                  ldi high start ; setup for start
 5145 d2d9: b6                     phi r6
 5146 d2da: f8 ad                  ldi low start
 5147 d2dc: a6                     plo r6
 5148 d2dd: e2                     sex r2 ; point X to stack
 5149 d2de: c0 ff 3f               lbr f_initcall ; setup SCALL and SRET
 5150 d2e1:             
 5151 d2e1:             
 5152 d2e1:             ; **********************************************************
 5153 d2e1:             ; ***** Convert string to uppercase, honor quoted text *****
 5154 d2e1:             ; **********************************************************
 5155 d2e1: 0f          touc: ldn rf ; check for quote
 5156 d2e2: ff 22                  smi 022h
 5157 d2e4: c2 d2 fe               lbz touc_qt ; jump if quote
 5158 d2e7: 0f                     ldn rf ; get byte from string
 5159 d2e8: c2 d2 fd               lbz touc_dn ; jump if done
 5160 d2eb: ff 61                  smi 'a' ; check if below lc
 5161 d2ed: cb d2 f9               lbnf touc_nxt ; jump if so
 5162 d2f0: ff 1b                  smi 27 ; check upper rage
 5163 d2f2: c3 d2 f9               lbdf touc_nxt ; jump if above lc
 5164 d2f5: 0f                     ldn rf ; otherwise convert character to lc
 5165 d2f6: ff 20                  smi 32
 5166 d2f8: 5f                     str rf
 5167 d2f9: 1f          touc_nxt: inc rf ; point to next character
 5168 d2fa: c0 d2 e1               lbr touc ; loop to check rest of string
 5169 d2fd: d5          touc_dn: sep sret ; return to caller
 5170 d2fe: 1f          touc_qt: inc rf ; move past quote
 5171 d2ff: 4f          touc_qlp: lda rf ; get next character
 5172 d300: c2 d2 fd               lbz touc_dn ; exit if terminator found
 5173 d303: ff 22                  smi 022h ; check for quote charater
 5174 d305: c2 d2 e1               lbz touc ; back to main loop if quote
 5175 d308: c0 d2 ff               lbr touc_qlp ; otherwise keep looking
 5176 d30b:             
 5177 d30b:             
 5178 d30b: ab          functable: db ('+'+80h) ; 0
 5179 d30c: ad                     db ('-'+80h) ; 1
 5180 d30d: aa                     db ('*'+80h) ; 2
 5181 d30e: af                     db ('/'+80h) ; 3
 5182 d30f: a8                     db ('('+80h) ; 4
 5183 d310: a9                     db (')'+80h) ; 5
 5184 d311: bd                     db ('='+80h) ; 6
 5185 d312: 3c bd                  db '<',('='+80h) ; 7
 5186 d314: 3e bd                  db '>',('='+80h) ; 8
 5187 d316: 3c be                  db '<',('>'+80h) ; 9
 5188 d318: bc                     db ('<'+80h) ; 10
 5189 d319: be                     db ('>'+80h) ; 11
 5190 d31a: bb                     db (';'+80h) ; 12
 5191 d31b: ac                     db (','+80h) ; 13
 5192 d31c: 41 4e c4               db 'AN',('D'+80h) ; 14
 5193 d31f: a6                     db ('&'+80h) ; 15
 5194 d320: 4f d2                  db 'O',('R'+80h) ; 16
 5195 d322: fc                     db ('|'+80h) ; 17
 5196 d323: de                     db ('^'+80h) ; 18
 5197 d324: ba                     db (':'+80h) ; 19
 5198 d325: 50 45 45 4b 
            a8                     db 'PEEK',('('+80h) ; 20
 5199 d32a: 46 52 45 a8            db 'FRE',('('+80h) ; 21
 5200 d32e: 52 4e 44 a8            db 'RND',('('+80h) ; 22
 5201 d332: 49 4e 50 a8            db 'INP',('('+80h) ; 23
 5202 d336: 46 4c 47 a8            db 'FLG',('('+80h) ; 24
 5203 d33a:             
 5204 d33a: 55 53 52 a8            db 'USR',('('+80h) ; 25
 5205 d33e:             
 5206 d33e: 50 52 49 4e 
            d4                     db 'PRIN',('T'+80h) ; 0
 5207 d343: bf                     db ('?'+80h) ; 1
 5208 d344: 4c 45 d4               db 'LE',('T'+80h) ; 2
 5209 d347: 47 4f 54 cf            db 'GOT',('O'+80h) ; 3
 5210 d34b: 49 c6                  db 'I',('F'+80h) ; 4
 5211 d34d: 54 48 45 ce            db 'THE',('N'+80h) ; 5
 5212 d351: 45 4e c4               db 'EN',('D'+80h) ; 6
 5213 d354: 47 4f 53 55 
            c2                     db 'GOSU',('B'+80h) ; 7
 5214 d359: 52 45 54 55 
            52 ce                  db 'RETUR',('N'+80h) ; 8
 5215 d35f: 52 45 cd               db 'RE',('M'+80h) ; 9
 5216 d362: 49 4e 50 55 
            d4                     db 'INPU',('T'+80h) ; 10
 5217 d367: 50 4f 4b c5            db 'POK',('E'+80h) ; 11
 5218 d36b: 4f 55 d4               db 'OU',('T'+80h) ; 12
 5219 d36e: 50 4c 4f d4            db 'PLO',('T'+80h) ; 13
 5220 d372: 52 55 ce               db 'RU',('N'+80h) ; 14
 5221 d375: 4c 49 53 d4            db 'LIS',('T'+80h) ; 15
 5222 d379: 4e 45 d7               db 'NE',('W'+80h) ; 16
 5223 d37c:             
 5224 d37c: 46 4f d2               db 'FO',('R'+80h) ; 17
 5225 d37f: 54 cf                  db 'T',('O'+80h) ; 18
 5226 d381: 4e 45 58 d4            db 'NEX',('T'+80h) ; 19
 5227 d385: 53 54 45 d0            db 'STE',('P'+80h) ; 20
 5228 d389: 4f ce                  db 'O',('N'+80h) ; 21
 5229 d38b: 44 41 54 c1            db 'DAT',('A'+80h) ; 22
 5230 d38f: 52 45 41 c4            db 'REA',('D'+80h) ; 23
 5231 d393: 52 45 53 54 
            4f 52 c5               db 'RESTOR',('E'+80h) ; 24
 5232 d39a: 44 49 cd               db 'DI',('M'+80h) ; 25
 5233 d39d: 52 41 4e 44 
            4f cd                  db 'RANDO',('M'+80h) ; 26
 5234 d3a3: 56 41 52 50 
            54 52 a8               db 'VARPTR',('('+80h) ; 27
 5235 d3aa: 43 4c 45 41 
            d2                     db 'CLEA',('R'+80h) ; 28
 5236 d3af: 4c 45 4e a8            db 'LEN',('('+80h) ; 29
 5237 d3b3: 41 53 43 a8            db 'ASC',('('+80h) ; 30
 5238 d3b7: 56 41 4c a8            db 'VAL',('('+80h) ; 31
 5239 d3bb: 53 54 52 24 
            a8                     db 'STR$',('('+80h) ; 32
 5240 d3c0: 43 48 52 24 
            a8                     db 'CHR$',('('+80h) ; 33
 5241 d3c5: 4c 45 46 54 
            24 a8                  db 'LEFT$',('('+80h) ; 34
 5242 d3cb: 52 49 47 48 
            54 24 a8               db 'RIGHT$',('('+80h) ; 35
 5243 d3d2: 4d 49 44 24 
            a8                     db 'MID$',('('+80h) ; 36
 5244 d3d7:             
 5245 d3d7: 42 59 c5               db 'BY',('E'+80h) ; 43
 5246 d3da:             
 5247 d3da: 53 41 56 c5            db 'SAV',('E'+80h) ; 44
 5248 d3de: 4c 4f 41 c4            db 'LOA',('D'+80h) ; 45
            # 5399 "rcbasic.asm"
 5250 d3e2: 00                     db 0
 5251 d3e3: ff          term: db 0ffh
 5252 d3e4: 0a 0d 00    crlf: db 10,13,0
 5253 d3e7:             
 5254 d3e7:             endrom: equ $
 5255 d3e7:             
 5256 d3e7:             
 5257 d3e7:                        org 100h
 5258 0100:             
 5259 0100:             
 5260 0100:             
 5261 0100:             
 5262 0100:             
 5263 0100:             
 5264 0100:             memory: ds 2
 5265 0102:             data_lin: ds 2
 5266 0104:             data_pos: ds 2
 5267 0106:             var_pos: ds 2
 5268 0108:             heap: ds 2
 5269 010a:             for_pos: ds 2
 5270 010c:                        ds 80
 5271 015c:             for_st: ds 1
 5272 015d:             
 5273 015d:             lfsr: ds 4
 5274 0161:             inp_pos: ds 2 ; pointer into f_input buffer
 5275 0163:             ibuffer: ds 80 ; holds input for f_input
 5276 01b3:             buffer: ds 256 ; input buffer
 5277 02b3:             gosub_pos: ds 2
 5278 02b5:             gosub_st: ds 256
 5279 03b5:             tokens: ds 256 ; buffer for tokenization
 5280 04b5:                        ds 128 ; space for stack
 5281 0535:             stack: ds 1
 5282 0536:                        ds 128
 5283 05b6:             expstack: ds 1
 5284 05b7:             
 5285 05b7:             
 5286 05b7:             
 5287 05b7:             
 5288 05b7:             pgmtext: ds 1

ba53h: ADD_CHAR         - <   268>    727    768    782    793    803   3573 
         3576   3583   3590   3593 
d087h: ALLOC            - <  4659>   2669   4967 
d110h: ALLOC_E          - <  4780>   4675 
d096h: ALLOC_LP1        - <  4672>   4691 
d09fh: ALLOC_NO         - <  4677>   4704 
d0b0h: ALLOC_Z          - <  4692>   4673 
c84ah: ARRAY            - <  3010>   2940 
c860h: ARRAY_1          - <  3026>   3019   3021 
c8bfh: ARRAY_DN         - <  3103>   3061 
c893h: AR_MULLP         - <  3069>   3085 
c86ch: AR_MULLP2        - <  3038>   3102 
c05ch: BAD_DATA         - <  1458>   1435   1439 
bc9bh: BAS_END          - <   650>   1222 
bca4h: BAS_END2         - <   656>    654 
bc9fh: BAS_ENDLP        - <   653>    664 
d2d1h: BEGIN            - <  5140>    188 
d2c1h: BEGIN2           - <  5130>    189 
01b3h: BUFFER           - <  5276>    195    197   2198   2200   2347   2349 
         2434   2436   2453   2455   2785   2787 
bac9h: BYTE_GO          - <   378>    389 
ffe0h: CALL             - <    67> 
c71dh: CAT_LP1          - <  2789>   2793 
c726h: CAT_LP2          - <  2795>   2799 
bfa6h: CHARSTR          - <  1312>   1282 
bfa9h: CHARSTRLP        - <  1314>   1322 
cfa5h: CHK_DN           - <  4446>   4437 
cf98h: CHK_N1           - <  4438>   4430   4433 
cfa3h: CHK_NO           - <  4445>   4412 
cf9eh: CHK_NST          - <  4442>   4425 
d058h: CHK_OM           - <  4613>   4817 
cab1h: CHK_TERM         - <  3499>   3255   3286   3288   3357   3467   3495 
         3555   3601   3611   3640   3696   3704   3732   3869   4063   4200 
         4211   4232   4234   4244   4246   4274   4282   4308   4310   4387 
         4390   4843   4845   5011   5013 
cf60h: CHK_VAR          - <  4397>   4573 
cf70h: CHK_VARLP        - <  4411>   4441   4444 
c330h: CLOSED           - <  2051>   2163   2188   2217   2233   2258   2282 
         2381   2459   2534 
001ah: CMD_START        - <   179>   1347   1496   2587   2826   3773   3978 
         4002   4223   4374   5057 
bb00h: CMD_TABLE        - <   428>    322    325 
cfc9h: CONSOL           - <  4486>   4606 
cff6h: CONS_DN          - <  4522>   4507   4548 
cfddh: CONS_LP          - <  4504>   4521   4566 
cfe6h: CONS_NXT         - <  4508>   4550 
d000h: CONS_Z           - <  4532>   4505 
d1c5h: COPYLP1          - <  4926>   4934 
bcb0h: COPY_LN          - <   672>   1123   1131 
bcb5h: COPY_LP          - <   676>    681 
c58dh: COPY_STR         - <  2529>   2322 
bef4h: CPY_1            - <  1154>   1159   1161 
bf17h: CPY_2            - <  1185>   1191   1193 
bf01h: CPY_REV          - <  1163>   1153 
d3e4h: CRLF             - <  5252>    810    812 
c050h: DATA_CNT         - <  1450>   1471 
c060h: DATA_DN          - <  1460>   1455 
c059h: DATA_ERR         - <  1456>   1432 
0102h: DATA_LIN         - <  5265>   1480   1482   1531   1533   3764   4346 
         4348   4356   4358 
c068h: DATA_NE          - <  1468>   1437 
0104h: DATA_POS         - <  5266>   1423   1425   1441   1443   1508   1510 
         1522   1524   3777   3779   4378   4380 
d02bh: DEALLOC          - <  4572>   2297   2343   2368   2420   2484   2548 
         2778   2784   3667   4475 
bcbeh: DELETE_LN        - <   687>   1059 
bd6bh: DETKN_DN         - <   806>    730 
bcedh: DETKN_LP         - <   729>    736    780    784    791    805 
bd4bh: DETKN_NM         - <   785>    742 
bd55h: DETKN_QS         - <   792>    740 
bcfch: DETKN_TK         - <   737>    732 
bce2h: DETOKEN          - <   719>   3442   3485 
cfabh: DE_STR           - <  4457>   3267   3331 
d173h: DIM_2            - <  4862>   4858 
d1a2h: DIM_ARGS         - <  4900>   4916 
c8e4h: DIM_ERR          - <  3135>   3057 
d167h: DIM_LP1          - <  4855>   4861 
d224h: DIM_LP3          - <  5000>   5008 
d21dh: DIM_LP4          - <  4996>   4999 
c61fh: DOCMP            - <  2631>   2708   2727   2736   2745   2752   2761 
ba8ch: DO_CMD           - <   319>   5061 
bd6fh: DO_CRLF          - <   810>    564    902   3448   3491 
bcd0h: DO_DELETE        - <   700>    696 
d3e7h: ENDROM           - <  5254> 
c022h: ENDVARSDN        - <  1414>   1404 
c012h: ENDVARSLP        - <  1403>   1413 
bff9h: END_HEAP         - <  1377>   2174 
bedah: END_LINE         - <  1127>   1095 
c006h: END_VARS         - <  1393>   2170   4622   4851 
c8edh: ERR1_RET         - <  3140>   3137 
c8ech: ERR2_RET         - <  3139> 
c8ebh: ERR3_RET         - <  3138>   3040   3101 
bc4bh: ERROR            - <   596>    591 
bc70h: ERROR_CNT        - <   616>    638 
000bh: ERR_BADDIM       - <   176>   3135 
0000h: ERR_BREAK        - <   165>   5040 
0001h: ERR_DIRECT       - <   166> 
0006h: ERR_FILE         - <   171> 
0007h: ERR_INVLP        - <   172> 
0004h: ERR_INVRET       - <   169>   3718 
0009h: ERR_NODATA       - <   174>   1456 
0008h: ERR_NOFOR        - <   173>   4212 
0003h: ERR_NOLIN        - <   168>   3221 
c93fh: ERR_NOLN         - <  3221>   3481   4345 
000ah: ERR_NOMEM        - <   175>   2536   4637   5020 
d298h: ERR_RET          - <  5090>    920   1871   1881   1888   1897   1906 
         1915   1924   1933   1946   1953   1964   1978   1985   1994   2006 
         2013   2022   2050   2062   2117   2195   2224   2279   2293   2309 
         2329   2335   2364   2388   2394   2406   2468   2474   2515   2533 
         2544   2634   2679   2703   2709   2728   2737   2746   2753   2762 
         2774   2804   3195   3234   3262   3279   3318   3339   3528   3541 
         3562   3569   3605   3618   3630   3661   3880   3962   3994   4021 
         4078   4221   4237   4258   4289   4296   4325   4818 
0002h: ERR_SYN          - <   167>   1458   5087 
000ch: ERR_UNSUP        - <   177> 
0005h: ERR_VAL          - <   170>   5089 
d248h: EXECUTE          - <  5039>    590   3244   3246   3500   3507   5085 
d24fh: EXEC_1           - <  5043>   5039 
cac0h: EXEC_COLN        - <  3506>   3503 
d277h: EXEC_DN          - <  5065>    437    451   3155   3241   3521   3833 
         3859   5044 
d28dh: EXEC_GO          - <  5082>   5079 
cabdh: EXEC_GOOD        - <  3504> 
d27eh: EXEC_RUN         - <  5070> 
d286h: EXEC_TST         - <  5078>   3215   3790 
c1edh: EXPR             - <  1865>   2049   2116   2124   2194   2223   2255 
         2308   2334   2393   2405   2473   2514   2599   3039   3568   4013 
         4905 
c207h: EXPR_0           - <  1879>   1877 
c20dh: EXPR_1           - <  1882>   1874   1891   1900   1909   1918   1927 
         1936 
c220h: EXPR_1A          - <  1892>   1884 
c232h: EXPR_1B          - <  1901>   1893 
c244h: EXPR_1C          - <  1910>   1902 
c256h: EXPR_1D          - <  1919>   1911 
c268h: EXPR_1E          - <  1928>   1920 
c27ah: EXPR_1F          - <  1937>   1929 
c200h: EXPR_POS         - <  1875>   1867 
05b6h: EXPSTACK         - <  5283>   1861   1863   2557   2559   2697   2699 
         3022   3024   3268   3270 
c0c8h: EX_ADD           - <  1559>   1987   3087   3108   3124 
c0dbh: EX_AND           - <  1582>   1955 
cc45h: EX_BYE           - <  3800>    467 
ccb7h: EX_CLEAR         - <  3867>    457 
d151h: EX_DIM           - <  4842>    454   5017 
c0eeh: EX_DIV           - <  1605>   2024 
c8efh: EX_END           - <  3152>    434 
c10fh: EX_EQ            - <  1641>   1890 
ca35h: EX_FLIST         - <  3396>   3370   3386 
ccbdh: EX_FOR           - <  3874>    446 
c8f6h: EX_GOSUB         - <  3160>    435 
c91ah: EX_GOTO          - <  3193>    431 
c126h: EX_GT            - <  1661>   1935 
c13ch: EX_GTE           - <  1677>   1908 
c136h: EX_GT_GO         - <  1671>   1668 
c944h: EX_IF            - <  3228>    432 
c95dh: EX_INPUT         - <  3251>    438 
c9c0h: EX_LET           - <  3309>    430   5052 
c9fdh: EX_LIST          - <  3362>    443 
cc85h: EX_LOAD          - <  3838>    474 
c14ah: EX_LT            - <  1689>   1926 
c158h: EX_LTE           - <  1701>   1899 
c168h: EX_LTE_GO        - <  1711>   1708 
c16eh: EX_MOD           - <  1717>   2257 
c18bh: EX_MUL           - <  1749>   2015   3079   4945 
c1a4h: EX_NEG           - <  1777>   1873 
c1b1h: EX_NEQ           - <  1792>   1917 
cac4h: EX_NEW           - <  3512>    444 
cda9h: EX_NEXT          - <  4068>    448 
ce68h: EX_ON            - <  4219>    450 
c1c1h: EX_OR            - <  1805>   1966 
cad3h: EX_OUT           - <  3526>    440 
cb01h: EX_PLOT          - <  3560>    441 
cb41h: EX_PLOTDN        - <  3606>   3565 
cb4ah: EX_POKE          - <  3616>    439 
ba58h: EX_POP           - <   273>    908    969   1451   1560   1564   1583 
         1587   1606   1610   1644   1666   1682   1694   1706   1718   1722 
         1750   1754   1778   1795   1806   1810   1829   1833   2129   2197 
         2226   2295   2315   2337   2341   2366   2396   2408   2412   2416 
         2422   2476   2482   2517   2546   2636   2640   2776   2782   3049 
         3110   3126   3164   3199   3236   3351   3533   3543   3607   3623 
         3632   3665   3677   3964   4006   4024   4028   4228   4331   4894 
         4908   4951 
ba61h: EX_POP_RD        - <   282>   3579   3586 
cb6eh: EX_PRINT         - <  3645>    428    429   3670   3690   3695 
ba6ah: EX_PUSH          - <   291>   1576   1599   1635   1655   1743   1771 
         1786   1822   1845   2041   2149   2162   2187   2216   2232   2253 
         2281   2380   2681   2854   3032   3075   3118   3122   4000   4897 
         4911   4931 
cea7h: EX_RANDOM        - <  4256>    455 
cec3h: EX_READ          - <  4280>    452 
cefbh: EX_RESTORE       - <  4319>    453 
cbd5h: EX_RETURN        - <  3709>    436 
cbf9h: EX_RUN           - <  3737>    442 
cc48h: EX_SAVE          - <  3808>    473 
c1d4h: EX_SUB           - <  1828>   1642   1664   1680   1692   1704   1793 
         1996 
c11ch: FALSE            - <  1649>   1646   1670   1672   1684   1696   1712 
         1799 
c070h: FIND_DATA        - <  1476>   1469   3788   4389 
ba43h: FIND_EOF         - <   246>    218    232 
ba3eh: FIND_EX          - <   243>    231 
ba19h: FIND_LN          - <   213>    695   1074   3178   3207   3473   4335 
ba1fh: FIND_LP          - <   217>    242 
ca80h: FLIST_DN         - <  3458>   3411 
ca45h: FLIST_LP         - <  3410>   3457 
c0b7h: FND_DATDN        - <  1531>   1521 
c0ach: FND_DATEN        - <  1522>   1491 
c07eh: FND_DATLP        - <  1488>   1506 
c099h: FND_DATYS        - <  1507>   1498 
c44bh: FN_ASC           - <  2291>   2092 
c45eh: FN_CHR           - <  2307>   2830 
c3c1h: FN_FLG           - <  2156>   2083 
c3cch: FN_FRE           - <  2169>   2077 
c3e3h: FN_INP           - <  2193>   2081 
c474h: FN_LEFT          - <  2327>   2832 
c4a3h: FN_LEN           - <  2362>   2090 
bd79h: FN_LFSR          - <   821>   2241 
c4c3h: FN_MID           - <  2386>   2836 
c409h: FN_PEEK          - <  2222>   2075 
c536h: FN_RIGHT         - <  2466>   2834 
c41bh: FN_RND           - <  2238>   2079 
c578h: FN_STR           - <  2513>   2828 
c38ah: FN_USR           - <  2115>   2085 
c3a6h: FN_USR_1         - <  2130>   2120 
c3bch: FN_USR_DN        - <  2148>   2143   2145 
c3adh: FN_USR_GO        - <  2135>   2130   2132 
c59dh: FN_VAL           - <  2542>   2094 
c439h: FN_VARPTR        - <  2273>   2088 
cd12h: FOR_GO           - <  3938>   3920 
ccd4h: FOR_LP           - <  3889>   3927 
cd08h: FOR_NEW          - <  3930>   3897 
ccfdh: FOR_NXT          - <  3921>   3913 
010ah: FOR_POS          - <  5269>   3760   3881   3883   3930   3932   4054 
         4056   4081   4122   4124   4136   4191   4193 
015ch: FOR_ST           - <  5271>   3761   3890   3893   4084   4087   4138 
         4141 
d30bh: FUNCTABLE        - <  5178>    746    748   1286   1288 
bae8h: FUNC_CALL        - <   409> 
f830h: F_ASTODT         - <   136> 
f833h: F_ASTOTM         - <   137> 
ff5dh: F_ATOI           - <   102>   1332   2550 
ff00h: F_BOOT           - <    71> 
ff42h: F_BOOTIDE        - <    93> 
f800h: F_BREAD          - <   120> 
ff6ch: F_BRKTEST        - <   107> 
f806h: F_BTEST          - <   122> 
f803h: F_BTYPE          - <   121> 
ff33h: F_DIV16          - <    88>   1620   1732 
ff2ah: F_DRIVE          - <    85> 
f827h: F_DTTOAS         - <   134> 
ff6fh: F_FINDTKN        - <   108>   1291 
ff57h: F_FREEMEM        - <   100>    497    527 
ff81h: F_GETDEV         - <   114> 
f815h: F_GETTOD         - <   127> 
ff45h: F_HEXIN          - <    94>   1329 
ff48h: F_HEXOUT2        - <    95> 
ff4bh: F_HEXOUT4        - <    96> 
f824h: F_IDEID          - <   132> 
ff3ch: F_IDEREAD        - <    91> 
ff36h: F_IDERESET       - <    89> 
f821h: F_IDESIZE        - <   131> 
ff39h: F_IDEWRITE       - <    90> 
ff7bh: F_IDNUM          - <   112>   1284 
ff3fh: F_INITCALL       - <    92>   5139   5149 
ff66h: F_INMSG          - <   105>    481    518    557    593    600    617 
          621    893    993   1003   3702 
ff0fh: F_INPUT          - <    76>    562    898    998 
ff69h: F_INPUTL         - <   106> 
ff63h: F_INTOUT         - <   104>    790   2523   3581   3588   3683 
ff78h: F_ISALNUM        - <   111>    760   1296   1308   2058   2925   2949 
         4857 
ff72h: F_ISALPHA        - <   109>    765    779   2275   2568   2841   3258 
         3311   3876   4074   4285   4848   5051 
ff75h: F_ISHEX          - <   110> 
ff5ah: F_ISNUM          - <   101> 
ff7eh: F_ISTERM         - <   113> 
ff15h: F_LTRIM          - <    78>   1278 
ff1bh: F_MEMCPY         - <    80> 
ff54h: F_MINIMON        - <    99> 
ff51h: F_MOVER          - <    98> 
ff09h: F_MSG            - <    74>    611    637    815   3446   3489   3598 
         3689 
ff30h: F_MUL16          - <    87>   1760 
f836h: F_NVRCCHK        - <   138> 
f81bh: F_RDNVR          - <   129> 
ff21h: F_RDSEC          - <    82> 
ff06h: F_READ           - <    73> 
f82dh: F_RTCTEST        - <   135> 
ff27h: F_SEEK           - <    84> 
ff24h: F_SEEK0          - <    83> 
ff2dh: F_SETBD          - <    86> 
f818h: F_SETTOD         - <   128> 
ff12h: F_STRCMP         - <    77> 
ff18h: F_STRCPY         - <    79> 
f82ah: F_TMTOAS         - <   133> 
ff4eh: F_TTY            - <    97> 
ff03h: F_TYPE           - <    72>    479   3299   3610   3673   3699 
ff0ch: F_TYPEX          - <    75> 
ff60h: F_UINTOUT        - <   103>    605    631    725 
f80ch: F_UREAD          - <   124> 
f812h: F_USETBD         - <   126> 
f80fh: F_UTEST          - <   125> 
f809h: F_UTYPE          - <   123> 
fff9h: F_VERSION        - <   116> 
f81eh: F_WRNVR          - <   130> 
ff1eh: F_WRTSEC         - <    81> 
c023h: GET_DATA         - <  1419>   4295 
ba78h: GET_FLAGS        - <   305>   2157 
bde9h: GET_INPUT        - <   930>   3278   4257 
badch: GET_RB           - <   397>   4080   4135 
bdb8h: GET_SINPUT       - <   884>   3273 
c792h: GET_VAR          - <  2874>   2061   2278   2575   2844   3261   3317 
         3879   4077   4288 
d28ah: GOOD_RET         - <  5080>   5069 
02b3h: GOSUB_POS        - <  5277> 
02b5h: GOSUB_ST         - <  5278>   3712   3715   3743   3745 
c933h: GOTO_GO          - <  3211>   3188 
c924h: GOTO_GO2         - <  3198>   4241 
ba07h: GROUP_7          - <   193>    199    204    245    248    262    271 
          280    289    297    303    312    314    333    339    346    352 
          359    365    372    380    395    407    421    492    494    537 
          539 
0108h: HEAP             - <  5268>   1245   1247   1377   1379   4494   4496 
         4579   4581   4623   4625   4659   4661   4783   4785   4804   4806 
0163h: IBUFFER          - <  5275>   1007   1009   1026   1030   3749   3754 
         3814   3840   3844 
c953h: IF_CHK           - <  3242> 
be05h: INPUT_GD         - <   951>    947 
bdfbh: INPUT_GO         - <   946>    950 
be15h: INPUT_GO2        - <   959>    955 
c963h: INPUT_LP         - <  3254>   3291   3304 
c9a8h: INPUT_PR         - <  3293>   3253 
c991h: INP_CNT          - <  3280>   3274 
be6fh: INP_ERR          - <  1035>    957 
c98bh: INP_NUM          - <  3277>   3265 
0161h: INP_POS          - <  5274>    938    940    959    961   1022   1024 
         3753 
bec7h: INSERT_1         - <  1113>   1093 
be7dh: INSERT_LN        - <  1053>    583 
c7ech: IS_ARRAY         - <  2937>   2918 
c492h: LEFT_GO          - <  2347>   2507 
c486h: LEFT_GO2         - <  2336> 
c498h: LEFT_LP          - <  2351>   2357 
c4beh: LEN_DN           - <  2379>   2302   2376   2555 
c4b4h: LEN_LP           - <  2374>   2378 
c27fh: LEVEL_1          - <  1944>   1870   1880   1887   1896   1905   1914 
         1923   1932 
c298h: LEVEL_1A         - <  1957>   1949 
c2afh: LEVEL_1B         - <  1968>   1960 
c285h: LEVEL_1C         - <  1947>   1956   1967 
c2b4h: LEVEL_1N         - <  1970> 
c2b7h: LEVEL_2          - <  1976>   1945   1952   1963 
c2d0h: LEVEL_2A         - <  1989>   1981 
c2bdh: LEVEL_2C         - <  1979>   1988   1997 
c2e2h: LEVEL_2N         - <  1998>   1990 
c2e5h: LEVEL_3          - <  2004>   1977   1984   1993 
c2feh: LEVEL_3A         - <  2017>   2009 
c2ebh: LEVEL_3C         - <  2007>   2016   2025 
c310h: LEVEL_3N         - <  2026>   2018 
c313h: LEVEL_4          - <  2032>   2005   2012   2021 
c323h: LEVEL_4A         - <  2044>   2034 
c339h: LEVEL_4B         - <  2056>   2046 
c34fh: LEVEL_4C         - <  2070>   2059 
c28bh: LEVEL_AND        - <  1950>   1958 
c2a2h: LEVEL_OR         - <  1961>   1969 
015dh: LFSR             - <  5273>    547    551    821    823   4259   4261 
ca8ch: LIST_1           - <  3468>   3381 
bc11h: MAINLP           - <   556>    511    595    619    699    712   1126 
         1136 
bee9h: MEMCPY           - <  1145>    709   1114 
0100h: MEMORY           - <  5264>    500    502    528    530   1235   1237 
c5b8h: MEXPR            - <  2561> 
c5f9h: MEXPR_N          - <  2598>   2565   2585   2588   2590   2593 
c5e0h: MEXPR_NV         - <  2586>   2569 
c5fch: MEXPR_R          - <  2600>   2716   2718 
c5f3h: MEXPR_S          - <  2594>   2563   2584   2592 
c50ch: MID_DN           - <  2434>   2428   2431 
c527h: MID_DN2          - <  2451>   2442   2446 
c4fdh: MID_LP1          - <  2426>   2433 
c515h: MID_LP2          - <  2441>   2450 
d1e2h: MULDN            - <  4947>   4942 
d1d4h: MULLP            - <  4939>   4946 
d1f4h: MULLP2           - <  4962>   4965 
be43h: NEED_GO          - <  1002> 
be30h: NEED_INP         - <   984>    949 
c1e7h: NEW_EXPR         - <  1861>    952   1434   3161   3194   3527   3540 
         3561   3604   3617   3629   3956   3986   4220   4236   4324   4891 
c5b2h: NEW_MEXPR        - <  2557>   3232   3337   3660 
c666h: NEW_SEXPR        - <  2697> 
ba48h: NEXT_LN          - <   254>    705   1077   1489   3450   5071 
cdc3h: NEXT_LP          - <  4083>   4133 
ce56h: NEXT_NE          - <  4201>   4177   4184 
ce63h: NEXT_NF          - <  4212>   4091   4145 
ce02h: NEXT_NV          - <  4134>   4069   4071   4113 
ce42h: NEXT_OK          - <  4185>   4178 
ce3ah: NEXT_P           - <  4179>   4171 
cc3fh: NODATA           - <  3787>   3775 
cf5ah: NODATA2          - <  4388>   4376 
beb0h: NOTEXACT         - <  1094>   1075 
d079h: NOT_OM           - <  4639>   4635 
ba7eh: NO_EF1           - <   308>    306 
ba82h: NO_EF2           - <   310>    308 
ba86h: NO_EF3           - <   312>    310 
c93ah: NO_LINE          - <  3216>   3179   3208 
c7b6h: NO_MTCH          - <  2902>   2921   2926   2929   2932   2939 
ca75h: NO_SHOW          - <  3449>   3427   3438 
d106h: NO_SPLIT         - <  4770>   4711 
cd7ch: NO_STEP          - <  4023>   4004 
bfcch: NUMCONT          - <  1333>   1330 
bfc9h: NUMISDEC         - <  1331>   1327 
c598h: OM_ERR           - <  2536> 
d241h: OM_ERROR         - <  5020>   4968 
ce79h: ON_GOTO          - <  4227>   4225 
ce7ch: ON_GOTOLP        - <  4230>   4251 
05b7h: PGMTEXT          - <  5288>    213    215    543    652   3404   3407 
         3517   3737   3740   3765   3768   3810   3824   3849   4360   4363 
bbe8h: PICOSTRT         - <   526> 
bab1h: POP_RB           - <   354> 
babeh: POP_RD           - <   367>   3042   3081   3092 
baa4h: POP_RF           - <   341>   3120 
cbc4h: PRINT_CM         - <  3697>   3655 
cbcch: PRINT_DN         - <  3701>   3646   3648 
cbc1h: PRINT_NCR        - <  3696>   3693 
cb96h: PRINT_QS         - <  3668>   3674 
cbb8h: PRINT_SC         - <  3692>   3652   3700 
c9b7h: PROMPT_DN        - <  3301>   3296 
c9a9h: PROMPT_LP        - <  3294>   3300 
cba4h: PRT_INT          - <  3676>   3663 
c31eh: PUSH_IT          - <  2040>   2069 
baabh: PUSH_RB          - <   348> 
bab8h: PUSH_RD          - <   361>   3036   3064   3077   3098   3106 
ba9eh: PUSH_RF          - <   335> 
bd65h: QS_DONE          - <   802>    797 
bd58h: QS_LP            - <   795>    801 
cec4h: READ_LP          - <  4281>   4313 
bfe5h: REM_LP           - <  1350>   1354 
bb50h: RESTART          - <   477>   5134   5136 
cf3bh: REST_CNT         - <  4365>   4355 
fff1h: RET              - <    68> 
bcbdh: RETURN           - <   682>   4460   4574   4596 
d245h: RET_2            - <  5022>   4892   4906   4949 
cbeah: RET_GOOD         - <  3720>   3713   3716 
ba72h: RF_RD            - <   299>    910    971   1453   1562   1585   1608 
         1720   1752   1808   1831   2172   2313   2370   2519   2528   2638 
         2780   2887   3027   3166   3201   3679   4026   4333   4509   4533 
         4853   4989 
c560h: RIGHT_1          - <  2492>   2489 
c573h: RIGHT_F          - <  2505>   2498   2500 
c556h: RIGHT_LP1        - <  2487>   2491 
c565h: RIGHT_LP2        - <  2497>   2504 
c41dh: RND_LP           - <  2239>   2251 
bf25h: ROLL_UP          - <  1201>   1662   1678   1690   1702 
cf2eh: RST_STRT         - <  4356>   4320   4322 
bf34h: RST_VARS         - <  1221>    510    554    698    711   1054   1125 
         1135   3520   3757   3855   3868 
0004h: SCALL            - <    64>    478    480    496    509    513    526 
          553    556    561    563    567    573    589    592    599    604 
          610    616    620    630    636    697    706    708    710    724 
          759    764    778    789    814    892    897    901    905    948 
          951    992    997   1002   1011   1053   1091   1111   1113   1122 
         1124   1130   1134   1221   1277   1283   1290   1295   1307   1328 
         1331   1433   1468   1619   1641   1661   1663   1677   1679   1689 
         1691   1701   1703   1731   1759   1792   1869   1872   1879   1886 
         1889   1895   1898   1904   1907   1913   1916   1922   1925   1931 
         1934   1944   1951   1954   1962   1965   1976   1983   1986   1992 
         1995   2004   2011   2014   2020   2023   2048   2057   2060   2115 
         2123   2169   2173   2193   2222   2240   2254   2256   2274   2277 
         2291   2296   2307   2327   2333   2342   2362   2367   2386   2392 
         2404   2419   2457   2466   2472   2483   2513   2522   2531   2542 
         2547   2549   2567   2574   2594   2598   2632   2641   2668   2701 
         2707   2726   2735   2744   2751   2760   2772   2777   2783   2802 
         2840   2843   2924   2948   3038   3078   3086   3107   3123   3160 
         3193   3228   3257   3260   3266   3272   3277   3298   3310   3316 
         3330   3333   3441   3445   3447   3484   3488   3490   3519   3526 
         3539   3560   3567   3580   3587   3597   3603   3609   3616   3628 
         3659   3666   3672   3682   3688   3698   3701   3756   3787   3808 
         3811   3822   3826   3828   3838   3842   3850   3852   3854   3867 
         3875   3878   3955   3985   4012   4073   4076   4219   4235   4256 
         4284   4287   4294   4323   4388   4474   4572   4605   4621   4816 
         4847   4850   4856   4890   4904   4944   4966   5050 
c789h: SCLOSED          - <  2858> 
ba09h: SET_BUF          - <   195>    560    566    570    603    609    629 
          635    896    904    996   1006   2311   2480   2521   2530   2801 
         3440   3444   3483   3487   3571   3596   3681   3687 
bac5h: SET_BYTE         - <   374>   3516   3748 
bad6h: SET_RF           - <   391>    651   3767 
ba11h: SET_TKN          - <   200>    572    580    588 
bacdh: SET_WORD         - <   382>    542    546    550   3752   3759   3763 
c66ch: SEXPR            - <  2701>   2292   2328   2363   2387   2467   2543 
         2595 
c695h: SEXPR_A          - <  2724>   2706 
c6abh: SEXPR_B          - <  2733>   2725 
c6c1h: SEXPR_C          - <  2742>   2734 
c6d2h: SEXPR_D          - <  2749>   2743 
c6e8h: SEXPR_E          - <  2758>   2750 
c6feh: SEXPR_F          - <  2768>   2759   2805 
c739h: SEXPR_G          - <  2807>   2770 
c73ch: SEXPR_L1         - <  2810>   2633   2702   2773 
c752h: SEXPR_L1A        - <  2825>   2812 
c749h: SEXPR_LP1        - <  2820>   2822 
c690h: SFALSE           - <  2722>   2710   2732   2741   2748   2754   2757 
         2763   2766 
c687h: SFIX             - <  2716> 
ca68h: SHOW             - <  3439> 
d1bch: SINGLE           - <  4917>   4902 
bdcbh: SINPUT_GO        - <   899> 
d2bah: SIZE_DN          - <  5122>   5106 
d29bh: SIZE_END         - <  5098>    707   1092   1112   3812 
d2a3h: SIZE_LP          - <  5105>   5121 
0005h: SRET             - <    65>    655    682    808    816    881    923 
          982   1034   1162   1194   1213   1259   1363   1387   1414   1467 
         1545   1577   1600   1636   1656   1744   1772   1787   1823   1846 
         1939   1971   1999   2027   2043   2055   2097   2151   2538   2597 
         2601   2622   2627   2629   2644   2692   2721   2808   2824   2856 
         2862   2936   2979   3006   3132   3141   3223   3505   3719   4214 
         4451   4481   4531   4607   4651   4768   4778   4836   5024   5042 
         5081   5091   5128   5169 
0535h: STACK            - <  5281>   5130   5132   5140   5142 
bbadh: START            - <   513>   5144   5146 
c632h: STR2HEAP         - <  2651>    906   2458   2532   2803 
c5ffh: STRCMP           - <  2610>   2617   2642 
c611h: STRCMP1          - <  2621>   2618 
c614h: STRCMPE          - <  2623>   2612 
c61ch: STRCMPM          - <  2628>   2625 
c681h: STRUE            - <  2711>   2729   2731   2738   2740   2747   2756 
         2765 
c63ah: STR_HP_L1        - <  2658>   2661 
c658h: STR_HP_L2        - <  2682>   2690 
c46dh: STR_TERM         - <  2319>   2352 
d293h: SYN_ERR          - <  5087>    433    447    449    456    458    459 
          460    461    462    463    464    465    953   1046   2053   2072 
         2122   2127   2276   2332   2391   2403   2471   2842   2846   2860 
         3129   3162   3197   3259   3275   3292   3303   3312   3322   3349 
         3375   3384   3389   3395   3502   3531   3621   3710   3877   3946 
         3980   4075   4226   4249   4286   4314   4849   4865   5016   5046 
         5048   5054   5058   5063 
c683h: S_STACK          - <  2712>   2723 
d3e3h: TERM             - <  5251>   2962   2965 
bd12h: TKN_LP_1         - <   750>    756 
bd17h: TKN_LP_2         - <   753>    755 
00feh: TKN_NUM          - <   162>    582   1333   2033   3374   3388 
00fdh: TKN_QSTR         - <   161>    739   1313   2562   2811   3252   5045 
00ffh: TKN_TERM         - <   163> 
00fch: TKN_USTR         - <   160> 
bd20h: TKN_YES          - <   757>    751 
bd34h: TKN_YES_L        - <   770>    761    766    776 
bfeeh: TOKENDN          - <  1355>   1280   1351 
bfd9h: TOKENFUNC        - <  1343>   1292 
bf65h: TOKENIZE         - <  1270>    574   1012 
bf6dh: TOKENLP          - <  1277>   1301   1311   1326   1342   1349 
bfc0h: TOKENNUM         - <  1327>   1285 
03b5h: TOKENS           - <  5279>    200    202 
bfb9h: TOKENTERM        - <  1323>   1318   1320 
d2e1h: TOUC             - <  5155>    568   5168   5174 
d2fdh: TOUC_DN          - <  5169>   5159   5172 
d2f9h: TOUC_NXT         - <  5167>   5161   5163 
d2ffh: TOUC_QLP         - <  5171>   5175   5175 
d2feh: TOUC_QT          - <  5170>   5157 
ca1dh: TO_END           - <  3382>   3372 
c11fh: TRUE             - <  1651>   1648   1671   1683   1695   1710   1711 
         1797   1800 
bf99h: USTRLP           - <  1304>   1309 
bf98h: USTRLPA          - <  1303>   1297 
d296h: VAL_ERR          - <  5089>   2204   2400   3536 
c79eh: VAR_LP           - <  2884>   2914 
c7c6h: VAR_LST          - <  2915>   2898 
c7f5h: VAR_NEW          - <  2942>   2885 
c806h: VAR_NMDN         - <  2954>   2950 
c7fah: VAR_NMLP         - <  2947>   2953 
c82ah: VAR_NOTST        - <  2981>   2955 
0106h: VAR_POS          - <  5267>   1226   1228   1393   1395   2874   2876 
         4401   4403 
c7aah: VAR_SLP          - <  2894>   2901 
bc79h: WAS_RUN          - <   620>    613    615 
d40fh: XCLOSER          - <   157>   3853 
d40ch: XCLOSEW          - <   156>   3829 
d403h: XOPENR           - <   153>   3839 
d400h: XOPENW           - <   152>   3809 
d406h: XREAD            - <   154>   3843   3851 
d409h: XWRITE           - <   155>   3823   3827 
cc42h: YESDATA          - <  3790>   3786 

5288 Lines assembled
0 Errors
483 Labels
Object Code:6621 bytes

